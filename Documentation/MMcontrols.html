<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MMcontrols API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MMcontrols</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PyQt5.QtWidgets import QLayout, QLineEdit, QFrame, QGridLayout, QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QComboBox, QSpacerItem, QSizePolicy
from PyQt5.QtCore import Qt, pyqtSignal, QObject, QThread
from PyQt5.QtGui import QResizeEvent, QIcon, QPixmap, QFont
from PyQt5 import uic
import sys
import os
# import PyQt5.QtWidgets
import json
from pycromanager import Core
import numpy as np
import time
import asyncio
import pyqtgraph as pg
import matplotlib.pyplot as plt
from matplotlib import colormaps # type: ignore
#For drawing
import matplotlib
matplotlib.use(&#39;Qt5Agg&#39;)
# from PyQt5 import QtCore, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure
import tifffile
import time
from PyQt5.QtCore import QTimer,QDateTime
import logging



class ConfigInfo:
    def __init__(self,core,config_group_id):
        self.core = core
        self.config_group_id = config_group_id
        pass
    
    #Returns the config group name
    def configGroupName(self):
        return self.core.get_available_config_groups().get(self.config_group_id)
    
    #Returns the number of config options for this config group
    def nrConfigs(self):
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).size()
    
    #Returns the name of the config within the config group
    def configName(self,config_id):
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).get(config_id)
    
    #Returns the first device name and property from Verbose
    def deviceNameProperty_fromVerbose(self):
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        start_index = verboseInfoCurrentConfigGroup.find(&#34;&lt;html&gt;&#34;) + len(&#34;&lt;html&gt;&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;:&#34;)
        deviceName = verboseInfoCurrentConfigGroup[start_index:end_index]
        start_index = end_index + len(&#34;:&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;=&#34;)
        deviceProperty  = verboseInfoCurrentConfigGroup[start_index:end_index]
        return deviceName,deviceProperty
    
    #Returns whether the config group has property limits
    def hasPropertyLimits(self):
        #Get the verbose info from the config group state
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        #Determine the number of devices in the verbose info
        nrDevicesFromVerbose = verboseInfoCurrentConfigGroup.count(&#39;&lt;br&gt;&#39;)
        if nrDevicesFromVerbose == 1 and self.nrConfigs() == 1:
            [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
            #Determines whether the device name/property has limits:
            if self.core.has_property_limits(deviceName,deviceProperty):
                return True
            else:
                return False
        else:
            return False
    
    #Finds lower limit of the device property
    def lowerLimit(self):
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            lowerLimit = self.core.get_property_lower_limit(deviceName,deviceProperty)
        else:
            lowerLimit = 0
        return lowerLimit
            
    #Finds upper limit of the device property
    def upperLimit(self):
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            upperLimit = self.core.get_property_upper_limit(deviceName,deviceProperty)
        else:
            upperLimit = 0
        return upperLimit
            
    #Returns Boolean whether the config group should be represented as a drop-down menu
    def isDropDown(self):
        if self.nrConfigs()&gt;1:
            return True
        else:
            return False
        
    #Returns Boolean whether the config group should be represented as a slider
    def isSlider(self):
        if self.nrConfigs()&gt;1:
            return False
        else:
            if self.hasPropertyLimits():
                return True
            else:
                return False
        
    #Returns Boolean whether the config group should be represented as an input field
    def isInputField(self):
        if self.nrConfigs()&gt;1:
            return False
        else:
            if self.hasPropertyLimits():
                return False
            else:
                return True

    def helpStringInfo(self):
        infostring=&#39;No option for this config&#39;
        if self.isDropDown():
            infostring = &#34;Device {} should be an dropdown with {} options&#34;.format(self.configGroupName(),self.nrConfigs())
        if self.isSlider():
            infostring = &#34;Device {} should be an Slider with limits {}-{}&#34;.format(self.configGroupName(),self.lowerLimit(),self.upperLimit())
        if self.isInputField():
            infostring = &#34;Device {} should be an input field&#34;.format(self.configGroupName())
        return infostring
    
    #Get the current MM value of this config group:
    def getCurrentMMValue(self):
        return self.core.get_current_config(self.configGroupName())

#Create a big MM config ui and add all config groups with options
class MMConfigUI:
    def __init__(self, config_groups,showStages=True,showROIoptions=True,showLiveMode=True,number_config_columns=5):
        self.config_groups = config_groups
        self.number_columns = number_config_columns
        self.core = self.config_groups[0].core
        self.dropDownBoxes = {}
        #Create a Vertical+horizontal layout:
        self.mainLayout = QGridLayout()
        #Create a layout for the configs:
        self.configLayout = QGridLayout()
        #Add this to the mainLayout:
        self.mainLayout.addLayout(self.configLayout,0,0)
        #Fill the configLayout
        for config_id in range(len(config_groups)):
            self.addRow(config_id)
        pass
    
        #Add a button to refresh from MM:
        self.refreshButton = QPushButton(&#34;Refresh configs from MM&#34;)
        totalRowsAdded = int(np.ceil(len(config_groups)/self.number_columns))
        #Add a button spanning the total columns at the bottom
        self.configLayout.addWidget(self.refreshButton,totalRowsAdded+1,0,1,self.number_columns)
        #Connect the button:
        self.refreshButton.clicked.connect(lambda index: self.updateConfigsFromMM())
        
        #Add the stages widget to the right of this if wanted
        if showStages:
            self.mainLayout.addWidget(self.Vseparator_line(), 0, 1)
            #Now add the stages widget
            # self.stagesWidget()
            self.mainLayout.addLayout(self.stagesLayout(), 0, 2)
        
        if showROIoptions:
            self.mainLayout.addWidget(self.Vseparator_line(),0,3)
            #Now add the ROI options widget
            self.mainLayout.addLayout(self.ROIoptionsLayout(),0,4)
        
        if showLiveMode:
            self.mainLayout.addWidget(self.Vseparator_line(),0,5)
            #Now add the live mode widget
            self.mainLayout.addLayout(self.liveModeLayout(),0,6)
        
        #Update everything for good measure at the end of init
        self.updateAllMMinfo()
        
        #Change the font of everything in the layout
        self.set_font_and_margins_recursive(self.mainLayout, font=QFont(&#34;Arial&#34;, 7))
    
    
    #Live mode UI
    def liveModeLayout(self):
        #Create a Grid layout:
        liveModeLayout = QGridLayout()
        self.LiveModeButton = QPushButton(&#34;Start/Stop Live Mode&#34;)
        #add a connection to the button:
        self.LiveModeButton.clicked.connect(lambda index: self.changeLiveMode())
        #Add the button to the layout:
        liveModeLayout.addWidget(self.LiveModeButton,0,0)
        #Return the layout
        return liveModeLayout
    
    #Changes live mode
    def changeLiveMode(self):
        if shared_data.liveMode == False:
            shared_data.liveMode = True
        else:
            shared_data.liveMode = False
                
    #Set the font of all buttons/labels in the layout recursively
    def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
        if widget is None:
            return
        
        if isinstance(widget, (QLabel, QPushButton, QComboBox)):
            widget.setFont(font)
            widget.setContentsMargins(0, 0, 0, 0)
            widget.setMinimumSize(0, 0)
            # widget.setSizePolicy(
            #     QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
            # )

        if hasattr(widget, &#39;layout&#39;):
            layout = widget.layout()
            if layout:
                layout.setContentsMargins(0, 0, 0, 0)
                # layout.setSpacing(0)  # Optionally, remove spacing between widgets
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if hasattr(item, &#39;widget&#39;):
                        self.set_font_and_margins_recursive(item.widget(), font=font)
                    if hasattr(item, &#39;layout&#39;):
                        self.set_font_and_margins_recursive(item.layout(), font=font)
    
    #Unused, but helpfull piece of code
    def get_device_properties(self):
        core = self.core
        devices = core.get_loaded_devices()
        devices = [devices.get(i) for i in range(devices.size())]
        device_items = []
        for device in devices:
            logging.debug(&#39;Device: &#39;+device)
            names = core.get_device_property_names(device)
            props = [names.get(i) for i in range(names.size())]
            property_items = []
            for prop in props:
                logging.debug(&#39;Property&#39;,prop)
                value = core.get_property(device, prop)
                is_read_only = core.is_property_read_only(device, prop)
                if core.has_property_limits(device, prop):
                    lower = core.get_property_lower_limit(device, prop)
                    upper = core.get_property_upper_limit(device, prop)
                    allowed = {
                    &#34;type&#34;: &#34;range&#34;,
                    &#34;min&#34;: lower,
                    &#34;max&#34;: upper,
                    &#34;readOnly&#34;: is_read_only,
                    }
                else:
                    allowed = core.get_allowed_property_values(device, prop)
                    allowed = {
                    &#34;type&#34;: &#34;enum&#34;,
                    &#34;options&#34;: [allowed.get(i) for i in range(allowed.size())],&#34;readOnly&#34;: is_read_only,
                    }
                    property_items.append(
                    {&#34;device&#34;: device, &#34;name&#34;: prop, &#34;value&#34;: value, &#34;allowed&#34;: allowed}
                    )
                    logging.debug(&#39;===&gt;&#39;, device, prop, value, allowed)
            if len(property_items) &gt; 0:
                device_items.append(
                {
                &#34;name&#34;: device,
                &#34;value&#34;: &#34;{} properties&#34;.format(len(props)),
                &#34;items&#34;: property_items,
                }
                )
        return device_items

    def Vseparator_line(self):
        separator_line = QFrame()
        separator_line.setFrameShape(QFrame.VLine)
        separator_line.setFrameShadow(QFrame.Sunken)
        separator_line.setStyleSheet(&#34;background-color: #FFFFFF; min-width: 1px;&#34;)
        return separator_line
    
    def ROIoptionsLayout(self):
        #Create a Grid layout:
        ROIoptionsLayout = QGridLayout()
        self.ROIoptionsButtons = {}
        #Following options should be added:
        #Reset ROI to max size
        self.ROIoptionsButtons[&#39;Reset&#39;] = QPushButton(&#34;Reset ROI&#34;)
        self.ROIoptionsButtons[&#39;Reset&#39;].clicked.connect(lambda index: self.resetROI())
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
        #Zoom in once to center
        self.ROIoptionsButtons[&#39;ZoomIn&#39;] = QPushButton(&#34;Zoom In&#34;)
        self.ROIoptionsButtons[&#39;ZoomIn&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomIn&#39;))
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],1,0)
        #Zoom out once from center
        self.ROIoptionsButtons[&#39;ZoomOut&#39;] = QPushButton(&#34;Zoom Out&#34;)
        self.ROIoptionsButtons[&#39;ZoomOut&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomOut&#39;))
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],2,0)
        return ROIoptionsLayout
    
    #Reset the ROI to full frame
    def resetROI(self):
        self.core.clear_roi()
    
    def zoomROI(self,option):
        #Get the current ROI info
        #[x,y,width,height]
        roiv = [self.core.get_roi().x,self.core.get_roi().y,self.core.get_roi().width,self.core.get_roi().height]
        logging.debug(&#39;ROI zoom requested, current size: &#39;+str(roiv))
        if option == &#39;ZoomIn&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth/2)
                newTotHeight = int(curTotHeight/2)
                newX = int(roiv[0]+(curTotWidth-newTotWidth)/2)
                newY = int(roiv[1]+(curTotHeight-newTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
        elif option == &#39;ZoomOut&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth*2)
                newTotHeight = int(curTotHeight*2)
                newX = int(roiv[0]-(newTotWidth-curTotWidth)/2)
                newY = int(roiv[1]-(newTotHeight-curTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
    
    def setROI(self,ROIpos):
        #ROIpos should be a list of [x,y,width,height]
        logging.debug(&#39;Zooming ROI to &#39; + str(ROIpos))
        try:
            if shared_data.liveMode == False:
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3])
                self.core.wait_for_system()
            else:
                shared_data.liveMode = False
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3])
                time.sleep(0.5)
                shared_data.liveMode = True
        except:
            logging.error(&#39;ZOOMING DIDN\&#39;T WORK!&#39;)
    
    def stagesLayout(self):
        stageLayout = QHBoxLayout()
        stageLayout.addLayout(self.XYstageLayout())
        stageLayout.addLayout(self.oneDstageLayout())
        return stageLayout
    
    def XYstageLayout(self):
        #Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device()
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName)
        
        #Get current pixel size via self.core.get_pixel_size_um()
        #Then move 0.1, 0.5, or 1 field with the arrows
        field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]
        field_move_fraction = [1,.5,.1]
        
        #Widget itself is a grid layout with 7x7 entries
        XYStageLayout = QGridLayout()
        XYStageLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        #XY move buttons
        self.XYmoveButtons = {}
        for m in range(1,4):
            #Initialize buttons
            self.XYmoveButtons[f&#39;Up_{m}&#39;] = QPushButton(&#34;⮝&#34;*(4-m))
            self.XYmoveButtons[f&#39;Up_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,field_size_um[1]*field_move_fraction[m-1]))
            self.XYmoveButtons[f&#39;Down_{m}&#39;] = QPushButton(&#34;⮟&#34;*(4-m))
            self.XYmoveButtons[f&#39;Down_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,-field_size_um[1]*field_move_fraction[m-1]))
            self.XYmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;⮜&#34;*(4-m))
            self.XYmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(-field_size_um[0]*field_move_fraction[m-1],0))
            self.XYmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;⮞&#34;*(4-m))
            self.XYmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(field_size_um[0]*field_move_fraction[m-1],0))
            
            #Add buttons to layout
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Up_{m}&#39;],m-1,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Down_{m}&#39;],8-m,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Left_{m}&#39;],4,m-1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Right_{m}&#39;],4,8-m,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
                        
        #Add a central label for info
        #this label contains the XY stage name, then an enter, then the current position:
        self.XYStageInfoWidget = QLabel()
        XYStageLayout.addWidget(self.XYStageInfoWidget,4,4)
        #Update the text of it
        self.updateXYStageInfoWidget()
        
        return XYStageLayout
    
    def getDevicesOfDeviceType(self,devicetype):
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        #Get devices
        devices = self.core.get_loaded_devices()
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.core.get_device_type(device).to_string() == devicetype:
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType
    
    def oneDstageLayout(self):
        #Create a layout
        self.oneDStageLayout = QGridLayout()
        
        #Creates a UI layout to move all found 1D stages
        #Find all 1D stages
        allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        
        #Create a drop-down menu that has these stages as options
        self.oneDstageDropdown = QComboBox()
        for stage in allStages:
            self.oneDstageDropdown.addItem(stage)
        #If it changes, call the update routine
        self.oneDstageDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageLayout())
        #Add the dropdown to the layout:
        self.oneDStageLayout.addWidget(self.oneDstageDropdown,0,0)
        
        #Add left/right buttons and a label for the position
        self.oneDmoveButtons = {}
        for m in range(1,3):
            #Initialize buttons
            self.oneDmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;⮝&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(-m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;⮟&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(m))
            
            #Add buttons to layout
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Left_{m}&#39;],m-1+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Right_{m}&#39;],5-m+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        
        #Get current info of the widget
        self.oneDinfoWidget = QLabel()
        self.oneDStageLayout.addWidget(self.oneDinfoWidget,1,0)
        #update the text
        self.updateOneDstageLayout()
        
        return self.oneDStageLayout
    
    def updateOneDstageLayout(self):
        self.oneDinfoWidget.setText(f&#34;{self.oneDstageDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageDropdown.currentText()):.1f}&#34;)
    
    def moveOneDStage(self,amount):
        #Get the currently selected one-D stage:
        selectedStage = self.oneDstageDropdown.currentText()
        
        self.moveoneDstagesmallAmount = 10
        self.moveoneDstagelargeAmount = 100
        
        logging.debug(&#34;moving &#34; + selectedStage + &#34; by &#34; + str(amount))
        
        #Move the stage relatively
        if abs(amount) == 2:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagesmallAmount).astype(float))
        elif abs(amount) == 1:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagelargeAmount).astype(float))
        self.updateOneDstageLayout()
        
    def updateXYStageInfoWidget(self):#Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device()
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName)
        self.XYStageInfoWidget.setText(f&#34;{XYStageName}\r\n {XYStagePos.x:.0f}/{XYStagePos.y:.0f}&#34;)
        
    def moveXYStage(self,relX,relY):
        #Move XY stage with um positions in relx, rely:
        self.core.set_relative_xy_position(relX,relY)
        #Update the XYStageInfoWidget (if it exists)
        self.updateXYStageInfoWidget()
    
    def addRow(self,config_id):
        #Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination
        rowLayout = QHBoxLayout()
        #Add the label to it
        self.addLabel(rowLayout,config_id)
        #Add the widget to the QVBoxlayout
        self.configLayout.addLayout(rowLayout,divmod(config_id,self.number_columns)[1],divmod(config_id,self.number_columns)[0])
    
    def addLabel(self,rowLayout,config_id):
        #add a label to the row:
        label = QLabel()
        label.setText(self.config_groups[config_id].configGroupName())
        rowLayout.addWidget(label)
        #Add the dropdown/slider/inputfield:
        if self.config_groups[config_id].isDropDown():
            self.addDropDown(rowLayout,config_id)
        if self.config_groups[config_id].isSlider():
            self.addSlider(rowLayout,config_id)
        if self.config_groups[config_id].isInputField():
            self.addInputField(rowLayout,config_id)
        return rowLayout
        # pass
    
    def addDropDown(self,rowLayout,config_id):
        #Create a drop-down menu:
        self.dropDownBoxes[config_id] = QComboBox()
        #Add an empty option:
        self.dropDownBoxes[config_id].addItem(&#39;&#39;)
        #Populate with the options:
        for i in range(self.config_groups[config_id].nrConfigs()):
            self.dropDownBoxes[config_id].addItem(self.config_groups[config_id].configName(i))
        #Update the value to the current MM value:
        self.updateValuefromMM(config_id)
        #Add a callback when it is changed:
        self.dropDownBoxes[config_id].currentIndexChanged.connect(lambda index, config_id = config_id: self.on_dropDownChanged(config_id))
        
        #Add dropdown to rowLayout:
        rowLayout.addWidget(self.dropDownBoxes[config_id])
    
    def on_dropDownChanged(self,config_id):
        &#34;&#34;&#34;
        Changes a micromanager config when a dropdown has changed

        Args:
            config_id (int): The ID of the dropdown box that triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        #Get the new value from the dropdown:
        newValue = self.dropDownBoxes[config_id].currentText()
        #Change the value if it&#39;s a true value
        if newValue != &#34;&#34; and newValue != &#34; &#34;:
            #Get the config group name:
            configGroupName = self.config_groups[config_id].configGroupName()
            #Set in MM:
            self.config_groups[config_id].core.set_config(configGroupName,newValue)
    
    def addSlider(self,rowLayout,config_id):
        #TODO: Add a slider in pyqt
        pass
    
    def addInputField(self,rowLayout,config_id):
        pass
    
    #Update a single config based on current value in MM
    def updateValuefromMM(self,config_id):
        logging.debug(&#34;Updating value from &#34; + self.config_groups[config_id].configGroupName())
        #Get the value of the config_id from micromanager:
        currentValue = self.config_groups[config_id].getCurrentMMValue()
        #Set the value of the dropdown to the current MM value
        if self.config_groups[config_id].isDropDown():
            self.dropDownBoxes[config_id].setCurrentText(currentValue)
        pass
    
    #Update all configs based on current value in MM
    def updateConfigsFromMM(self):
        #Update all values from MM:
        for config_id in range(len(self.config_groups)):
            self.updateValuefromMM(config_id)
        pass
    
    #Update everything there is update-able
    def updateAllMMinfo(self):
        logging.debug(&#39;Updating all MM info&#39;)
        self.updateConfigsFromMM()
        self.updateXYStageInfoWidget()
        self.updateOneDstageLayout()

def microManagerControlsUI(core,MM_JSON,main_layout,sshared_data):
    global shared_data
    shared_data = sshared_data
    # Get all config groups
    allConfigGroups={}
    nrconfiggroups = core.get_available_config_groups().size()
    for config_group_id in range(nrconfiggroups):
        allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
    
    #Create the MM config via all config groups
    MMconfig = MMConfigUI(allConfigGroups)
    main_layout.addLayout(MMconfig.mainLayout)
    
    return MMconfig
    
    #Test line:
    # breakpoint
    
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MMcontrols.microManagerControlsUI"><code class="name flex">
<span>def <span class="ident">microManagerControlsUI</span></span>(<span>core, MM_JSON, main_layout, sshared_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def microManagerControlsUI(core,MM_JSON,main_layout,sshared_data):
    global shared_data
    shared_data = sshared_data
    # Get all config groups
    allConfigGroups={}
    nrconfiggroups = core.get_available_config_groups().size()
    for config_group_id in range(nrconfiggroups):
        allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
    
    #Create the MM config via all config groups
    MMconfig = MMConfigUI(allConfigGroups)
    main_layout.addLayout(MMconfig.mainLayout)
    
    return MMconfig
    
    #Test line:
    # breakpoint</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MMcontrols.ConfigInfo"><code class="flex name class">
<span>class <span class="ident">ConfigInfo</span></span>
<span>(</span><span>core, config_group_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigInfo:
    def __init__(self,core,config_group_id):
        self.core = core
        self.config_group_id = config_group_id
        pass
    
    #Returns the config group name
    def configGroupName(self):
        return self.core.get_available_config_groups().get(self.config_group_id)
    
    #Returns the number of config options for this config group
    def nrConfigs(self):
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).size()
    
    #Returns the name of the config within the config group
    def configName(self,config_id):
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).get(config_id)
    
    #Returns the first device name and property from Verbose
    def deviceNameProperty_fromVerbose(self):
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        start_index = verboseInfoCurrentConfigGroup.find(&#34;&lt;html&gt;&#34;) + len(&#34;&lt;html&gt;&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;:&#34;)
        deviceName = verboseInfoCurrentConfigGroup[start_index:end_index]
        start_index = end_index + len(&#34;:&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;=&#34;)
        deviceProperty  = verboseInfoCurrentConfigGroup[start_index:end_index]
        return deviceName,deviceProperty
    
    #Returns whether the config group has property limits
    def hasPropertyLimits(self):
        #Get the verbose info from the config group state
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        #Determine the number of devices in the verbose info
        nrDevicesFromVerbose = verboseInfoCurrentConfigGroup.count(&#39;&lt;br&gt;&#39;)
        if nrDevicesFromVerbose == 1 and self.nrConfigs() == 1:
            [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
            #Determines whether the device name/property has limits:
            if self.core.has_property_limits(deviceName,deviceProperty):
                return True
            else:
                return False
        else:
            return False
    
    #Finds lower limit of the device property
    def lowerLimit(self):
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            lowerLimit = self.core.get_property_lower_limit(deviceName,deviceProperty)
        else:
            lowerLimit = 0
        return lowerLimit
            
    #Finds upper limit of the device property
    def upperLimit(self):
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            upperLimit = self.core.get_property_upper_limit(deviceName,deviceProperty)
        else:
            upperLimit = 0
        return upperLimit
            
    #Returns Boolean whether the config group should be represented as a drop-down menu
    def isDropDown(self):
        if self.nrConfigs()&gt;1:
            return True
        else:
            return False
        
    #Returns Boolean whether the config group should be represented as a slider
    def isSlider(self):
        if self.nrConfigs()&gt;1:
            return False
        else:
            if self.hasPropertyLimits():
                return True
            else:
                return False
        
    #Returns Boolean whether the config group should be represented as an input field
    def isInputField(self):
        if self.nrConfigs()&gt;1:
            return False
        else:
            if self.hasPropertyLimits():
                return False
            else:
                return True

    def helpStringInfo(self):
        infostring=&#39;No option for this config&#39;
        if self.isDropDown():
            infostring = &#34;Device {} should be an dropdown with {} options&#34;.format(self.configGroupName(),self.nrConfigs())
        if self.isSlider():
            infostring = &#34;Device {} should be an Slider with limits {}-{}&#34;.format(self.configGroupName(),self.lowerLimit(),self.upperLimit())
        if self.isInputField():
            infostring = &#34;Device {} should be an input field&#34;.format(self.configGroupName())
        return infostring
    
    #Get the current MM value of this config group:
    def getCurrentMMValue(self):
        return self.core.get_current_config(self.configGroupName())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MMcontrols.ConfigInfo.configGroupName"><code class="name flex">
<span>def <span class="ident">configGroupName</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configGroupName(self):
    return self.core.get_available_config_groups().get(self.config_group_id)</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.configName"><code class="name flex">
<span>def <span class="ident">configName</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configName(self,config_id):
    return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).get(config_id)</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.deviceNameProperty_fromVerbose"><code class="name flex">
<span>def <span class="ident">deviceNameProperty_fromVerbose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deviceNameProperty_fromVerbose(self):
    verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
    start_index = verboseInfoCurrentConfigGroup.find(&#34;&lt;html&gt;&#34;) + len(&#34;&lt;html&gt;&#34;)
    end_index = verboseInfoCurrentConfigGroup.find(&#34;:&#34;)
    deviceName = verboseInfoCurrentConfigGroup[start_index:end_index]
    start_index = end_index + len(&#34;:&#34;)
    end_index = verboseInfoCurrentConfigGroup.find(&#34;=&#34;)
    deviceProperty  = verboseInfoCurrentConfigGroup[start_index:end_index]
    return deviceName,deviceProperty</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.getCurrentMMValue"><code class="name flex">
<span>def <span class="ident">getCurrentMMValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCurrentMMValue(self):
    return self.core.get_current_config(self.configGroupName())</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.hasPropertyLimits"><code class="name flex">
<span>def <span class="ident">hasPropertyLimits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasPropertyLimits(self):
    #Get the verbose info from the config group state
    verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
    #Determine the number of devices in the verbose info
    nrDevicesFromVerbose = verboseInfoCurrentConfigGroup.count(&#39;&lt;br&gt;&#39;)
    if nrDevicesFromVerbose == 1 and self.nrConfigs() == 1:
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        #Determines whether the device name/property has limits:
        if self.core.has_property_limits(deviceName,deviceProperty):
            return True
        else:
            return False
    else:
        return False</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.helpStringInfo"><code class="name flex">
<span>def <span class="ident">helpStringInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def helpStringInfo(self):
    infostring=&#39;No option for this config&#39;
    if self.isDropDown():
        infostring = &#34;Device {} should be an dropdown with {} options&#34;.format(self.configGroupName(),self.nrConfigs())
    if self.isSlider():
        infostring = &#34;Device {} should be an Slider with limits {}-{}&#34;.format(self.configGroupName(),self.lowerLimit(),self.upperLimit())
    if self.isInputField():
        infostring = &#34;Device {} should be an input field&#34;.format(self.configGroupName())
    return infostring</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.isDropDown"><code class="name flex">
<span>def <span class="ident">isDropDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isDropDown(self):
    if self.nrConfigs()&gt;1:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.isInputField"><code class="name flex">
<span>def <span class="ident">isInputField</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isInputField(self):
    if self.nrConfigs()&gt;1:
        return False
    else:
        if self.hasPropertyLimits():
            return False
        else:
            return True</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.isSlider"><code class="name flex">
<span>def <span class="ident">isSlider</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isSlider(self):
    if self.nrConfigs()&gt;1:
        return False
    else:
        if self.hasPropertyLimits():
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.lowerLimit"><code class="name flex">
<span>def <span class="ident">lowerLimit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lowerLimit(self):
    [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
    if self.core.has_property_limits(deviceName,deviceProperty):
        lowerLimit = self.core.get_property_lower_limit(deviceName,deviceProperty)
    else:
        lowerLimit = 0
    return lowerLimit</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.nrConfigs"><code class="name flex">
<span>def <span class="ident">nrConfigs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nrConfigs(self):
    return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).size()</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.upperLimit"><code class="name flex">
<span>def <span class="ident">upperLimit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upperLimit(self):
    [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
    if self.core.has_property_limits(deviceName,deviceProperty):
        upperLimit = self.core.get_property_upper_limit(deviceName,deviceProperty)
    else:
        upperLimit = 0
    return upperLimit</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MMcontrols.MMConfigUI"><code class="flex name class">
<span>class <span class="ident">MMConfigUI</span></span>
<span>(</span><span>config_groups, showStages=True, showROIoptions=True, showLiveMode=True, number_config_columns=5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MMConfigUI:
    def __init__(self, config_groups,showStages=True,showROIoptions=True,showLiveMode=True,number_config_columns=5):
        self.config_groups = config_groups
        self.number_columns = number_config_columns
        self.core = self.config_groups[0].core
        self.dropDownBoxes = {}
        #Create a Vertical+horizontal layout:
        self.mainLayout = QGridLayout()
        #Create a layout for the configs:
        self.configLayout = QGridLayout()
        #Add this to the mainLayout:
        self.mainLayout.addLayout(self.configLayout,0,0)
        #Fill the configLayout
        for config_id in range(len(config_groups)):
            self.addRow(config_id)
        pass
    
        #Add a button to refresh from MM:
        self.refreshButton = QPushButton(&#34;Refresh configs from MM&#34;)
        totalRowsAdded = int(np.ceil(len(config_groups)/self.number_columns))
        #Add a button spanning the total columns at the bottom
        self.configLayout.addWidget(self.refreshButton,totalRowsAdded+1,0,1,self.number_columns)
        #Connect the button:
        self.refreshButton.clicked.connect(lambda index: self.updateConfigsFromMM())
        
        #Add the stages widget to the right of this if wanted
        if showStages:
            self.mainLayout.addWidget(self.Vseparator_line(), 0, 1)
            #Now add the stages widget
            # self.stagesWidget()
            self.mainLayout.addLayout(self.stagesLayout(), 0, 2)
        
        if showROIoptions:
            self.mainLayout.addWidget(self.Vseparator_line(),0,3)
            #Now add the ROI options widget
            self.mainLayout.addLayout(self.ROIoptionsLayout(),0,4)
        
        if showLiveMode:
            self.mainLayout.addWidget(self.Vseparator_line(),0,5)
            #Now add the live mode widget
            self.mainLayout.addLayout(self.liveModeLayout(),0,6)
        
        #Update everything for good measure at the end of init
        self.updateAllMMinfo()
        
        #Change the font of everything in the layout
        self.set_font_and_margins_recursive(self.mainLayout, font=QFont(&#34;Arial&#34;, 7))
    
    
    #Live mode UI
    def liveModeLayout(self):
        #Create a Grid layout:
        liveModeLayout = QGridLayout()
        self.LiveModeButton = QPushButton(&#34;Start/Stop Live Mode&#34;)
        #add a connection to the button:
        self.LiveModeButton.clicked.connect(lambda index: self.changeLiveMode())
        #Add the button to the layout:
        liveModeLayout.addWidget(self.LiveModeButton,0,0)
        #Return the layout
        return liveModeLayout
    
    #Changes live mode
    def changeLiveMode(self):
        if shared_data.liveMode == False:
            shared_data.liveMode = True
        else:
            shared_data.liveMode = False
                
    #Set the font of all buttons/labels in the layout recursively
    def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
        if widget is None:
            return
        
        if isinstance(widget, (QLabel, QPushButton, QComboBox)):
            widget.setFont(font)
            widget.setContentsMargins(0, 0, 0, 0)
            widget.setMinimumSize(0, 0)
            # widget.setSizePolicy(
            #     QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
            # )

        if hasattr(widget, &#39;layout&#39;):
            layout = widget.layout()
            if layout:
                layout.setContentsMargins(0, 0, 0, 0)
                # layout.setSpacing(0)  # Optionally, remove spacing between widgets
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if hasattr(item, &#39;widget&#39;):
                        self.set_font_and_margins_recursive(item.widget(), font=font)
                    if hasattr(item, &#39;layout&#39;):
                        self.set_font_and_margins_recursive(item.layout(), font=font)
    
    #Unused, but helpfull piece of code
    def get_device_properties(self):
        core = self.core
        devices = core.get_loaded_devices()
        devices = [devices.get(i) for i in range(devices.size())]
        device_items = []
        for device in devices:
            logging.debug(&#39;Device: &#39;+device)
            names = core.get_device_property_names(device)
            props = [names.get(i) for i in range(names.size())]
            property_items = []
            for prop in props:
                logging.debug(&#39;Property&#39;,prop)
                value = core.get_property(device, prop)
                is_read_only = core.is_property_read_only(device, prop)
                if core.has_property_limits(device, prop):
                    lower = core.get_property_lower_limit(device, prop)
                    upper = core.get_property_upper_limit(device, prop)
                    allowed = {
                    &#34;type&#34;: &#34;range&#34;,
                    &#34;min&#34;: lower,
                    &#34;max&#34;: upper,
                    &#34;readOnly&#34;: is_read_only,
                    }
                else:
                    allowed = core.get_allowed_property_values(device, prop)
                    allowed = {
                    &#34;type&#34;: &#34;enum&#34;,
                    &#34;options&#34;: [allowed.get(i) for i in range(allowed.size())],&#34;readOnly&#34;: is_read_only,
                    }
                    property_items.append(
                    {&#34;device&#34;: device, &#34;name&#34;: prop, &#34;value&#34;: value, &#34;allowed&#34;: allowed}
                    )
                    logging.debug(&#39;===&gt;&#39;, device, prop, value, allowed)
            if len(property_items) &gt; 0:
                device_items.append(
                {
                &#34;name&#34;: device,
                &#34;value&#34;: &#34;{} properties&#34;.format(len(props)),
                &#34;items&#34;: property_items,
                }
                )
        return device_items

    def Vseparator_line(self):
        separator_line = QFrame()
        separator_line.setFrameShape(QFrame.VLine)
        separator_line.setFrameShadow(QFrame.Sunken)
        separator_line.setStyleSheet(&#34;background-color: #FFFFFF; min-width: 1px;&#34;)
        return separator_line
    
    def ROIoptionsLayout(self):
        #Create a Grid layout:
        ROIoptionsLayout = QGridLayout()
        self.ROIoptionsButtons = {}
        #Following options should be added:
        #Reset ROI to max size
        self.ROIoptionsButtons[&#39;Reset&#39;] = QPushButton(&#34;Reset ROI&#34;)
        self.ROIoptionsButtons[&#39;Reset&#39;].clicked.connect(lambda index: self.resetROI())
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
        #Zoom in once to center
        self.ROIoptionsButtons[&#39;ZoomIn&#39;] = QPushButton(&#34;Zoom In&#34;)
        self.ROIoptionsButtons[&#39;ZoomIn&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomIn&#39;))
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],1,0)
        #Zoom out once from center
        self.ROIoptionsButtons[&#39;ZoomOut&#39;] = QPushButton(&#34;Zoom Out&#34;)
        self.ROIoptionsButtons[&#39;ZoomOut&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomOut&#39;))
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],2,0)
        return ROIoptionsLayout
    
    #Reset the ROI to full frame
    def resetROI(self):
        self.core.clear_roi()
    
    def zoomROI(self,option):
        #Get the current ROI info
        #[x,y,width,height]
        roiv = [self.core.get_roi().x,self.core.get_roi().y,self.core.get_roi().width,self.core.get_roi().height]
        logging.debug(&#39;ROI zoom requested, current size: &#39;+str(roiv))
        if option == &#39;ZoomIn&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth/2)
                newTotHeight = int(curTotHeight/2)
                newX = int(roiv[0]+(curTotWidth-newTotWidth)/2)
                newY = int(roiv[1]+(curTotHeight-newTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
        elif option == &#39;ZoomOut&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth*2)
                newTotHeight = int(curTotHeight*2)
                newX = int(roiv[0]-(newTotWidth-curTotWidth)/2)
                newY = int(roiv[1]-(newTotHeight-curTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
    
    def setROI(self,ROIpos):
        #ROIpos should be a list of [x,y,width,height]
        logging.debug(&#39;Zooming ROI to &#39; + str(ROIpos))
        try:
            if shared_data.liveMode == False:
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3])
                self.core.wait_for_system()
            else:
                shared_data.liveMode = False
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3])
                time.sleep(0.5)
                shared_data.liveMode = True
        except:
            logging.error(&#39;ZOOMING DIDN\&#39;T WORK!&#39;)
    
    def stagesLayout(self):
        stageLayout = QHBoxLayout()
        stageLayout.addLayout(self.XYstageLayout())
        stageLayout.addLayout(self.oneDstageLayout())
        return stageLayout
    
    def XYstageLayout(self):
        #Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device()
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName)
        
        #Get current pixel size via self.core.get_pixel_size_um()
        #Then move 0.1, 0.5, or 1 field with the arrows
        field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]
        field_move_fraction = [1,.5,.1]
        
        #Widget itself is a grid layout with 7x7 entries
        XYStageLayout = QGridLayout()
        XYStageLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        #XY move buttons
        self.XYmoveButtons = {}
        for m in range(1,4):
            #Initialize buttons
            self.XYmoveButtons[f&#39;Up_{m}&#39;] = QPushButton(&#34;⮝&#34;*(4-m))
            self.XYmoveButtons[f&#39;Up_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,field_size_um[1]*field_move_fraction[m-1]))
            self.XYmoveButtons[f&#39;Down_{m}&#39;] = QPushButton(&#34;⮟&#34;*(4-m))
            self.XYmoveButtons[f&#39;Down_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,-field_size_um[1]*field_move_fraction[m-1]))
            self.XYmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;⮜&#34;*(4-m))
            self.XYmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(-field_size_um[0]*field_move_fraction[m-1],0))
            self.XYmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;⮞&#34;*(4-m))
            self.XYmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(field_size_um[0]*field_move_fraction[m-1],0))
            
            #Add buttons to layout
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Up_{m}&#39;],m-1,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Down_{m}&#39;],8-m,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Left_{m}&#39;],4,m-1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Right_{m}&#39;],4,8-m,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
                        
        #Add a central label for info
        #this label contains the XY stage name, then an enter, then the current position:
        self.XYStageInfoWidget = QLabel()
        XYStageLayout.addWidget(self.XYStageInfoWidget,4,4)
        #Update the text of it
        self.updateXYStageInfoWidget()
        
        return XYStageLayout
    
    def getDevicesOfDeviceType(self,devicetype):
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        #Get devices
        devices = self.core.get_loaded_devices()
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.core.get_device_type(device).to_string() == devicetype:
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType
    
    def oneDstageLayout(self):
        #Create a layout
        self.oneDStageLayout = QGridLayout()
        
        #Creates a UI layout to move all found 1D stages
        #Find all 1D stages
        allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        
        #Create a drop-down menu that has these stages as options
        self.oneDstageDropdown = QComboBox()
        for stage in allStages:
            self.oneDstageDropdown.addItem(stage)
        #If it changes, call the update routine
        self.oneDstageDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageLayout())
        #Add the dropdown to the layout:
        self.oneDStageLayout.addWidget(self.oneDstageDropdown,0,0)
        
        #Add left/right buttons and a label for the position
        self.oneDmoveButtons = {}
        for m in range(1,3):
            #Initialize buttons
            self.oneDmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;⮝&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(-m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;⮟&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(m))
            
            #Add buttons to layout
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Left_{m}&#39;],m-1+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Right_{m}&#39;],5-m+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        
        #Get current info of the widget
        self.oneDinfoWidget = QLabel()
        self.oneDStageLayout.addWidget(self.oneDinfoWidget,1,0)
        #update the text
        self.updateOneDstageLayout()
        
        return self.oneDStageLayout
    
    def updateOneDstageLayout(self):
        self.oneDinfoWidget.setText(f&#34;{self.oneDstageDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageDropdown.currentText()):.1f}&#34;)
    
    def moveOneDStage(self,amount):
        #Get the currently selected one-D stage:
        selectedStage = self.oneDstageDropdown.currentText()
        
        self.moveoneDstagesmallAmount = 10
        self.moveoneDstagelargeAmount = 100
        
        logging.debug(&#34;moving &#34; + selectedStage + &#34; by &#34; + str(amount))
        
        #Move the stage relatively
        if abs(amount) == 2:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagesmallAmount).astype(float))
        elif abs(amount) == 1:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagelargeAmount).astype(float))
        self.updateOneDstageLayout()
        
    def updateXYStageInfoWidget(self):#Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device()
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName)
        self.XYStageInfoWidget.setText(f&#34;{XYStageName}\r\n {XYStagePos.x:.0f}/{XYStagePos.y:.0f}&#34;)
        
    def moveXYStage(self,relX,relY):
        #Move XY stage with um positions in relx, rely:
        self.core.set_relative_xy_position(relX,relY)
        #Update the XYStageInfoWidget (if it exists)
        self.updateXYStageInfoWidget()
    
    def addRow(self,config_id):
        #Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination
        rowLayout = QHBoxLayout()
        #Add the label to it
        self.addLabel(rowLayout,config_id)
        #Add the widget to the QVBoxlayout
        self.configLayout.addLayout(rowLayout,divmod(config_id,self.number_columns)[1],divmod(config_id,self.number_columns)[0])
    
    def addLabel(self,rowLayout,config_id):
        #add a label to the row:
        label = QLabel()
        label.setText(self.config_groups[config_id].configGroupName())
        rowLayout.addWidget(label)
        #Add the dropdown/slider/inputfield:
        if self.config_groups[config_id].isDropDown():
            self.addDropDown(rowLayout,config_id)
        if self.config_groups[config_id].isSlider():
            self.addSlider(rowLayout,config_id)
        if self.config_groups[config_id].isInputField():
            self.addInputField(rowLayout,config_id)
        return rowLayout
        # pass
    
    def addDropDown(self,rowLayout,config_id):
        #Create a drop-down menu:
        self.dropDownBoxes[config_id] = QComboBox()
        #Add an empty option:
        self.dropDownBoxes[config_id].addItem(&#39;&#39;)
        #Populate with the options:
        for i in range(self.config_groups[config_id].nrConfigs()):
            self.dropDownBoxes[config_id].addItem(self.config_groups[config_id].configName(i))
        #Update the value to the current MM value:
        self.updateValuefromMM(config_id)
        #Add a callback when it is changed:
        self.dropDownBoxes[config_id].currentIndexChanged.connect(lambda index, config_id = config_id: self.on_dropDownChanged(config_id))
        
        #Add dropdown to rowLayout:
        rowLayout.addWidget(self.dropDownBoxes[config_id])
    
    def on_dropDownChanged(self,config_id):
        &#34;&#34;&#34;
        Changes a micromanager config when a dropdown has changed

        Args:
            config_id (int): The ID of the dropdown box that triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        #Get the new value from the dropdown:
        newValue = self.dropDownBoxes[config_id].currentText()
        #Change the value if it&#39;s a true value
        if newValue != &#34;&#34; and newValue != &#34; &#34;:
            #Get the config group name:
            configGroupName = self.config_groups[config_id].configGroupName()
            #Set in MM:
            self.config_groups[config_id].core.set_config(configGroupName,newValue)
    
    def addSlider(self,rowLayout,config_id):
        #TODO: Add a slider in pyqt
        pass
    
    def addInputField(self,rowLayout,config_id):
        pass
    
    #Update a single config based on current value in MM
    def updateValuefromMM(self,config_id):
        logging.debug(&#34;Updating value from &#34; + self.config_groups[config_id].configGroupName())
        #Get the value of the config_id from micromanager:
        currentValue = self.config_groups[config_id].getCurrentMMValue()
        #Set the value of the dropdown to the current MM value
        if self.config_groups[config_id].isDropDown():
            self.dropDownBoxes[config_id].setCurrentText(currentValue)
        pass
    
    #Update all configs based on current value in MM
    def updateConfigsFromMM(self):
        #Update all values from MM:
        for config_id in range(len(self.config_groups)):
            self.updateValuefromMM(config_id)
        pass
    
    #Update everything there is update-able
    def updateAllMMinfo(self):
        logging.debug(&#39;Updating all MM info&#39;)
        self.updateConfigsFromMM()
        self.updateXYStageInfoWidget()
        self.updateOneDstageLayout()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MMcontrols.MMConfigUI.ROIoptionsLayout"><code class="name flex">
<span>def <span class="ident">ROIoptionsLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ROIoptionsLayout(self):
    #Create a Grid layout:
    ROIoptionsLayout = QGridLayout()
    self.ROIoptionsButtons = {}
    #Following options should be added:
    #Reset ROI to max size
    self.ROIoptionsButtons[&#39;Reset&#39;] = QPushButton(&#34;Reset ROI&#34;)
    self.ROIoptionsButtons[&#39;Reset&#39;].clicked.connect(lambda index: self.resetROI())
    ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
    #Zoom in once to center
    self.ROIoptionsButtons[&#39;ZoomIn&#39;] = QPushButton(&#34;Zoom In&#34;)
    self.ROIoptionsButtons[&#39;ZoomIn&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomIn&#39;))
    ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],1,0)
    #Zoom out once from center
    self.ROIoptionsButtons[&#39;ZoomOut&#39;] = QPushButton(&#34;Zoom Out&#34;)
    self.ROIoptionsButtons[&#39;ZoomOut&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomOut&#39;))
    ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],2,0)
    return ROIoptionsLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.Vseparator_line"><code class="name flex">
<span>def <span class="ident">Vseparator_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Vseparator_line(self):
    separator_line = QFrame()
    separator_line.setFrameShape(QFrame.VLine)
    separator_line.setFrameShadow(QFrame.Sunken)
    separator_line.setStyleSheet(&#34;background-color: #FFFFFF; min-width: 1px;&#34;)
    return separator_line</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.XYstageLayout"><code class="name flex">
<span>def <span class="ident">XYstageLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def XYstageLayout(self):
    #Obtain the stage info from MM:
    XYStageName = self.core.get_xy_stage_device()
    #Get the stage position
    XYStagePos = self.core.get_xy_stage_position(XYStageName)
    
    #Get current pixel size via self.core.get_pixel_size_um()
    #Then move 0.1, 0.5, or 1 field with the arrows
    field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]
    field_move_fraction = [1,.5,.1]
    
    #Widget itself is a grid layout with 7x7 entries
    XYStageLayout = QGridLayout()
    XYStageLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)
    
    #XY move buttons
    self.XYmoveButtons = {}
    for m in range(1,4):
        #Initialize buttons
        self.XYmoveButtons[f&#39;Up_{m}&#39;] = QPushButton(&#34;⮝&#34;*(4-m))
        self.XYmoveButtons[f&#39;Up_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,field_size_um[1]*field_move_fraction[m-1]))
        self.XYmoveButtons[f&#39;Down_{m}&#39;] = QPushButton(&#34;⮟&#34;*(4-m))
        self.XYmoveButtons[f&#39;Down_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,-field_size_um[1]*field_move_fraction[m-1]))
        self.XYmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;⮜&#34;*(4-m))
        self.XYmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(-field_size_um[0]*field_move_fraction[m-1],0))
        self.XYmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;⮞&#34;*(4-m))
        self.XYmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(field_size_um[0]*field_move_fraction[m-1],0))
        
        #Add buttons to layout
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Up_{m}&#39;],m-1,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Down_{m}&#39;],8-m,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Left_{m}&#39;],4,m-1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Right_{m}&#39;],4,8-m,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
                    
    #Add a central label for info
    #this label contains the XY stage name, then an enter, then the current position:
    self.XYStageInfoWidget = QLabel()
    XYStageLayout.addWidget(self.XYStageInfoWidget,4,4)
    #Update the text of it
    self.updateXYStageInfoWidget()
    
    return XYStageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addDropDown"><code class="name flex">
<span>def <span class="ident">addDropDown</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addDropDown(self,rowLayout,config_id):
    #Create a drop-down menu:
    self.dropDownBoxes[config_id] = QComboBox()
    #Add an empty option:
    self.dropDownBoxes[config_id].addItem(&#39;&#39;)
    #Populate with the options:
    for i in range(self.config_groups[config_id].nrConfigs()):
        self.dropDownBoxes[config_id].addItem(self.config_groups[config_id].configName(i))
    #Update the value to the current MM value:
    self.updateValuefromMM(config_id)
    #Add a callback when it is changed:
    self.dropDownBoxes[config_id].currentIndexChanged.connect(lambda index, config_id = config_id: self.on_dropDownChanged(config_id))
    
    #Add dropdown to rowLayout:
    rowLayout.addWidget(self.dropDownBoxes[config_id])</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addInputField"><code class="name flex">
<span>def <span class="ident">addInputField</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addInputField(self,rowLayout,config_id):
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addLabel"><code class="name flex">
<span>def <span class="ident">addLabel</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addLabel(self,rowLayout,config_id):
    #add a label to the row:
    label = QLabel()
    label.setText(self.config_groups[config_id].configGroupName())
    rowLayout.addWidget(label)
    #Add the dropdown/slider/inputfield:
    if self.config_groups[config_id].isDropDown():
        self.addDropDown(rowLayout,config_id)
    if self.config_groups[config_id].isSlider():
        self.addSlider(rowLayout,config_id)
    if self.config_groups[config_id].isInputField():
        self.addInputField(rowLayout,config_id)
    return rowLayout
    # pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addRow"><code class="name flex">
<span>def <span class="ident">addRow</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addRow(self,config_id):
    #Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination
    rowLayout = QHBoxLayout()
    #Add the label to it
    self.addLabel(rowLayout,config_id)
    #Add the widget to the QVBoxlayout
    self.configLayout.addLayout(rowLayout,divmod(config_id,self.number_columns)[1],divmod(config_id,self.number_columns)[0])</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addSlider"><code class="name flex">
<span>def <span class="ident">addSlider</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSlider(self,rowLayout,config_id):
    #TODO: Add a slider in pyqt
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.changeLiveMode"><code class="name flex">
<span>def <span class="ident">changeLiveMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeLiveMode(self):
    if shared_data.liveMode == False:
        shared_data.liveMode = True
    else:
        shared_data.liveMode = False</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.getDevicesOfDeviceType"><code class="name flex">
<span>def <span class="ident">getDevicesOfDeviceType</span></span>(<span>self, devicetype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDevicesOfDeviceType(self,devicetype):
    #Find all devices that have a specific devicetype
    #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
    #for all devicetypes
    #Get devices
    devices = self.core.get_loaded_devices()
    devices = [devices.get(i) for i in range(devices.size())]
    devicesOfType = []
    #Loop over devices
    for device in devices:
        if self.core.get_device_type(device).to_string() == devicetype:
            logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
            devicesOfType.append(device)
    return devicesOfType</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.get_device_properties"><code class="name flex">
<span>def <span class="ident">get_device_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_properties(self):
    core = self.core
    devices = core.get_loaded_devices()
    devices = [devices.get(i) for i in range(devices.size())]
    device_items = []
    for device in devices:
        logging.debug(&#39;Device: &#39;+device)
        names = core.get_device_property_names(device)
        props = [names.get(i) for i in range(names.size())]
        property_items = []
        for prop in props:
            logging.debug(&#39;Property&#39;,prop)
            value = core.get_property(device, prop)
            is_read_only = core.is_property_read_only(device, prop)
            if core.has_property_limits(device, prop):
                lower = core.get_property_lower_limit(device, prop)
                upper = core.get_property_upper_limit(device, prop)
                allowed = {
                &#34;type&#34;: &#34;range&#34;,
                &#34;min&#34;: lower,
                &#34;max&#34;: upper,
                &#34;readOnly&#34;: is_read_only,
                }
            else:
                allowed = core.get_allowed_property_values(device, prop)
                allowed = {
                &#34;type&#34;: &#34;enum&#34;,
                &#34;options&#34;: [allowed.get(i) for i in range(allowed.size())],&#34;readOnly&#34;: is_read_only,
                }
                property_items.append(
                {&#34;device&#34;: device, &#34;name&#34;: prop, &#34;value&#34;: value, &#34;allowed&#34;: allowed}
                )
                logging.debug(&#39;===&gt;&#39;, device, prop, value, allowed)
        if len(property_items) &gt; 0:
            device_items.append(
            {
            &#34;name&#34;: device,
            &#34;value&#34;: &#34;{} properties&#34;.format(len(props)),
            &#34;items&#34;: property_items,
            }
            )
    return device_items</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.liveModeLayout"><code class="name flex">
<span>def <span class="ident">liveModeLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def liveModeLayout(self):
    #Create a Grid layout:
    liveModeLayout = QGridLayout()
    self.LiveModeButton = QPushButton(&#34;Start/Stop Live Mode&#34;)
    #add a connection to the button:
    self.LiveModeButton.clicked.connect(lambda index: self.changeLiveMode())
    #Add the button to the layout:
    liveModeLayout.addWidget(self.LiveModeButton,0,0)
    #Return the layout
    return liveModeLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.moveOneDStage"><code class="name flex">
<span>def <span class="ident">moveOneDStage</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveOneDStage(self,amount):
    #Get the currently selected one-D stage:
    selectedStage = self.oneDstageDropdown.currentText()
    
    self.moveoneDstagesmallAmount = 10
    self.moveoneDstagelargeAmount = 100
    
    logging.debug(&#34;moving &#34; + selectedStage + &#34; by &#34; + str(amount))
    
    #Move the stage relatively
    if abs(amount) == 2:
        self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagesmallAmount).astype(float))
    elif abs(amount) == 1:
        self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagelargeAmount).astype(float))
    self.updateOneDstageLayout()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.moveXYStage"><code class="name flex">
<span>def <span class="ident">moveXYStage</span></span>(<span>self, relX, relY)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveXYStage(self,relX,relY):
    #Move XY stage with um positions in relx, rely:
    self.core.set_relative_xy_position(relX,relY)
    #Update the XYStageInfoWidget (if it exists)
    self.updateXYStageInfoWidget()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.on_dropDownChanged"><code class="name flex">
<span>def <span class="ident">on_dropDownChanged</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes a micromanager config when a dropdown has changed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the dropdown box that triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_dropDownChanged(self,config_id):
    &#34;&#34;&#34;
    Changes a micromanager config when a dropdown has changed

    Args:
        config_id (int): The ID of the dropdown box that triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    #Get the new value from the dropdown:
    newValue = self.dropDownBoxes[config_id].currentText()
    #Change the value if it&#39;s a true value
    if newValue != &#34;&#34; and newValue != &#34; &#34;:
        #Get the config group name:
        configGroupName = self.config_groups[config_id].configGroupName()
        #Set in MM:
        self.config_groups[config_id].core.set_config(configGroupName,newValue)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.oneDstageLayout"><code class="name flex">
<span>def <span class="ident">oneDstageLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oneDstageLayout(self):
    #Create a layout
    self.oneDStageLayout = QGridLayout()
    
    #Creates a UI layout to move all found 1D stages
    #Find all 1D stages
    allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
    
    #Create a drop-down menu that has these stages as options
    self.oneDstageDropdown = QComboBox()
    for stage in allStages:
        self.oneDstageDropdown.addItem(stage)
    #If it changes, call the update routine
    self.oneDstageDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageLayout())
    #Add the dropdown to the layout:
    self.oneDStageLayout.addWidget(self.oneDstageDropdown,0,0)
    
    #Add left/right buttons and a label for the position
    self.oneDmoveButtons = {}
    for m in range(1,3):
        #Initialize buttons
        self.oneDmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;⮝&#34;*(3-m))
        self.oneDmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(-m))
        self.oneDmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;⮟&#34;*(3-m))
        self.oneDmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(m))
        
        #Add buttons to layout
        self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Left_{m}&#39;],m-1+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Right_{m}&#39;],5-m+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
    
    #Get current info of the widget
    self.oneDinfoWidget = QLabel()
    self.oneDStageLayout.addWidget(self.oneDinfoWidget,1,0)
    #update the text
    self.updateOneDstageLayout()
    
    return self.oneDStageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.resetROI"><code class="name flex">
<span>def <span class="ident">resetROI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetROI(self):
    self.core.clear_roi()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.setROI"><code class="name flex">
<span>def <span class="ident">setROI</span></span>(<span>self, ROIpos)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setROI(self,ROIpos):
    #ROIpos should be a list of [x,y,width,height]
    logging.debug(&#39;Zooming ROI to &#39; + str(ROIpos))
    try:
        if shared_data.liveMode == False:
            self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3])
            self.core.wait_for_system()
        else:
            shared_data.liveMode = False
            self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3])
            time.sleep(0.5)
            shared_data.liveMode = True
    except:
        logging.error(&#39;ZOOMING DIDN\&#39;T WORK!&#39;)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.set_font_and_margins_recursive"><code class="name flex">
<span>def <span class="ident">set_font_and_margins_recursive</span></span>(<span>self, widget, font=&lt;PyQt5.QtGui.QFont object&gt;)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
    if widget is None:
        return
    
    if isinstance(widget, (QLabel, QPushButton, QComboBox)):
        widget.setFont(font)
        widget.setContentsMargins(0, 0, 0, 0)
        widget.setMinimumSize(0, 0)
        # widget.setSizePolicy(
        #     QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        # )

    if hasattr(widget, &#39;layout&#39;):
        layout = widget.layout()
        if layout:
            layout.setContentsMargins(0, 0, 0, 0)
            # layout.setSpacing(0)  # Optionally, remove spacing between widgets
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if hasattr(item, &#39;widget&#39;):
                    self.set_font_and_margins_recursive(item.widget(), font=font)
                if hasattr(item, &#39;layout&#39;):
                    self.set_font_and_margins_recursive(item.layout(), font=font)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.stagesLayout"><code class="name flex">
<span>def <span class="ident">stagesLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stagesLayout(self):
    stageLayout = QHBoxLayout()
    stageLayout.addLayout(self.XYstageLayout())
    stageLayout.addLayout(self.oneDstageLayout())
    return stageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateAllMMinfo"><code class="name flex">
<span>def <span class="ident">updateAllMMinfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateAllMMinfo(self):
    logging.debug(&#39;Updating all MM info&#39;)
    self.updateConfigsFromMM()
    self.updateXYStageInfoWidget()
    self.updateOneDstageLayout()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateConfigsFromMM"><code class="name flex">
<span>def <span class="ident">updateConfigsFromMM</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateConfigsFromMM(self):
    #Update all values from MM:
    for config_id in range(len(self.config_groups)):
        self.updateValuefromMM(config_id)
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateOneDstageLayout"><code class="name flex">
<span>def <span class="ident">updateOneDstageLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateOneDstageLayout(self):
    self.oneDinfoWidget.setText(f&#34;{self.oneDstageDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageDropdown.currentText()):.1f}&#34;)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateValuefromMM"><code class="name flex">
<span>def <span class="ident">updateValuefromMM</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateValuefromMM(self,config_id):
    logging.debug(&#34;Updating value from &#34; + self.config_groups[config_id].configGroupName())
    #Get the value of the config_id from micromanager:
    currentValue = self.config_groups[config_id].getCurrentMMValue()
    #Set the value of the dropdown to the current MM value
    if self.config_groups[config_id].isDropDown():
        self.dropDownBoxes[config_id].setCurrentText(currentValue)
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateXYStageInfoWidget"><code class="name flex">
<span>def <span class="ident">updateXYStageInfoWidget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateXYStageInfoWidget(self):#Obtain the stage info from MM:
    XYStageName = self.core.get_xy_stage_device()
    #Get the stage position
    XYStagePos = self.core.get_xy_stage_position(XYStageName)
    self.XYStageInfoWidget.setText(f&#34;{XYStageName}\r\n {XYStagePos.x:.0f}/{XYStagePos.y:.0f}&#34;)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.zoomROI"><code class="name flex">
<span>def <span class="ident">zoomROI</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zoomROI(self,option):
    #Get the current ROI info
    #[x,y,width,height]
    roiv = [self.core.get_roi().x,self.core.get_roi().y,self.core.get_roi().width,self.core.get_roi().height]
    logging.debug(&#39;ROI zoom requested, current size: &#39;+str(roiv))
    if option == &#39;ZoomIn&#39;:
        #zoom in twice
        try:
            #Get current widht/height and new width/height
            curTotWidth = roiv[2]
            curTotHeight = roiv[3]
            newTotWidth = int(curTotWidth/2)
            newTotHeight = int(curTotHeight/2)
            newX = int(roiv[0]+(curTotWidth-newTotWidth)/2)
            newY = int(roiv[1]+(curTotHeight-newTotHeight)/2)
            #Set the new ROI size
            self.setROI([newX,newY,newTotWidth,newTotHeight])
        except:
            logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
    elif option == &#39;ZoomOut&#39;:
        #zoom in twice
        try:
            #Get current widht/height and new width/height
            curTotWidth = roiv[2]
            curTotHeight = roiv[3]
            newTotWidth = int(curTotWidth*2)
            newTotHeight = int(curTotHeight*2)
            newX = int(roiv[0]-(newTotWidth-curTotWidth)/2)
            newY = int(roiv[1]-(newTotHeight-curTotHeight)/2)
            #Set the new ROI size
            self.setROI([newX,newY,newTotWidth,newTotHeight])
        except:
            logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MMcontrols.microManagerControlsUI" href="#MMcontrols.microManagerControlsUI">microManagerControlsUI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MMcontrols.ConfigInfo" href="#MMcontrols.ConfigInfo">ConfigInfo</a></code></h4>
<ul class="">
<li><code><a title="MMcontrols.ConfigInfo.configGroupName" href="#MMcontrols.ConfigInfo.configGroupName">configGroupName</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.configName" href="#MMcontrols.ConfigInfo.configName">configName</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.deviceNameProperty_fromVerbose" href="#MMcontrols.ConfigInfo.deviceNameProperty_fromVerbose">deviceNameProperty_fromVerbose</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.getCurrentMMValue" href="#MMcontrols.ConfigInfo.getCurrentMMValue">getCurrentMMValue</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.hasPropertyLimits" href="#MMcontrols.ConfigInfo.hasPropertyLimits">hasPropertyLimits</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.helpStringInfo" href="#MMcontrols.ConfigInfo.helpStringInfo">helpStringInfo</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.isDropDown" href="#MMcontrols.ConfigInfo.isDropDown">isDropDown</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.isInputField" href="#MMcontrols.ConfigInfo.isInputField">isInputField</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.isSlider" href="#MMcontrols.ConfigInfo.isSlider">isSlider</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.lowerLimit" href="#MMcontrols.ConfigInfo.lowerLimit">lowerLimit</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.nrConfigs" href="#MMcontrols.ConfigInfo.nrConfigs">nrConfigs</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.upperLimit" href="#MMcontrols.ConfigInfo.upperLimit">upperLimit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MMcontrols.MMConfigUI" href="#MMcontrols.MMConfigUI">MMConfigUI</a></code></h4>
<ul class="">
<li><code><a title="MMcontrols.MMConfigUI.ROIoptionsLayout" href="#MMcontrols.MMConfigUI.ROIoptionsLayout">ROIoptionsLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.Vseparator_line" href="#MMcontrols.MMConfigUI.Vseparator_line">Vseparator_line</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.XYstageLayout" href="#MMcontrols.MMConfigUI.XYstageLayout">XYstageLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addDropDown" href="#MMcontrols.MMConfigUI.addDropDown">addDropDown</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addInputField" href="#MMcontrols.MMConfigUI.addInputField">addInputField</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addLabel" href="#MMcontrols.MMConfigUI.addLabel">addLabel</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addRow" href="#MMcontrols.MMConfigUI.addRow">addRow</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addSlider" href="#MMcontrols.MMConfigUI.addSlider">addSlider</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.changeLiveMode" href="#MMcontrols.MMConfigUI.changeLiveMode">changeLiveMode</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.getDevicesOfDeviceType" href="#MMcontrols.MMConfigUI.getDevicesOfDeviceType">getDevicesOfDeviceType</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.get_device_properties" href="#MMcontrols.MMConfigUI.get_device_properties">get_device_properties</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.liveModeLayout" href="#MMcontrols.MMConfigUI.liveModeLayout">liveModeLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.moveOneDStage" href="#MMcontrols.MMConfigUI.moveOneDStage">moveOneDStage</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.moveXYStage" href="#MMcontrols.MMConfigUI.moveXYStage">moveXYStage</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.on_dropDownChanged" href="#MMcontrols.MMConfigUI.on_dropDownChanged">on_dropDownChanged</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.oneDstageLayout" href="#MMcontrols.MMConfigUI.oneDstageLayout">oneDstageLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.resetROI" href="#MMcontrols.MMConfigUI.resetROI">resetROI</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.setROI" href="#MMcontrols.MMConfigUI.setROI">setROI</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.set_font_and_margins_recursive" href="#MMcontrols.MMConfigUI.set_font_and_margins_recursive">set_font_and_margins_recursive</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.stagesLayout" href="#MMcontrols.MMConfigUI.stagesLayout">stagesLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateAllMMinfo" href="#MMcontrols.MMConfigUI.updateAllMMinfo">updateAllMMinfo</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateConfigsFromMM" href="#MMcontrols.MMConfigUI.updateConfigsFromMM">updateConfigsFromMM</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateOneDstageLayout" href="#MMcontrols.MMConfigUI.updateOneDstageLayout">updateOneDstageLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateValuefromMM" href="#MMcontrols.MMConfigUI.updateValuefromMM">updateValuefromMM</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateXYStageInfoWidget" href="#MMcontrols.MMConfigUI.updateXYStageInfoWidget">updateXYStageInfoWidget</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.zoomROI" href="#MMcontrols.MMConfigUI.zoomROI">zoomROI</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>