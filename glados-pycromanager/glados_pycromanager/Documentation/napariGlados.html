<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>napariGlados API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>napariGlados</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import tempfile
import zarr
from PyQt5.QtCore import pyqtSignal, QObject
import napari
import math
from napari.qt import thread_worker
import time
import queue
from PyQt5.QtWidgets import QMainWindow
from pycromanager import Core
from magicgui import magicgui
from qtpy.QtWidgets import QMainWindow, QVBoxLayout, QWidget, QScrollArea
import sys
import logging
import os

def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__

if is_pip_installed():
    from glados_pycromanager.GUI.LaserControlScripts import *
    import glados_pycromanager.GUI.napariGlados as napariGlados
    from glados_pycromanager.GUI.MMcontrols import microManagerControlsUI
    from glados_pycromanager.GUI.AnalysisClass import *
    from glados_pycromanager.GUI.Analysis_dockWidgets import *
    from glados_pycromanager.GUI.FlowChart_dockWidgets import *
    from glados_pycromanager.GUI.napariHelperFunctions import getLayerIdFromName, InitateNapariUI
    from glados_pycromanager.GUI.utils import cleanUpTemporaryFiles
    import glados_pycromanager.GUI.utils as utils
    from glados_pycromanager.GUI.custom_widget_ui import Ui_CustomDockWidget  # Import the generated UI module
    from glados_pycromanager.GUI.MDAGlados import MDAGlados
else:
    from custom_widget_ui import Ui_CustomDockWidget  # Import the generated UI module
    from LaserControlScripts import *
    from MMcontrols import microManagerControlsUI
    from AnalysisClass import *
    from Analysis_dockWidgets import *
    from FlowChart_dockWidgets import *
    from napariHelperFunctions import getLayerIdFromName, InitateNapariUI
    from utils import cleanUpTemporaryFiles
    import utils as utils
    from MDAGlados import MDAGlados


# # Define a flag to control the continuous task
# stop_continuous_task = False
# # empty queue for (live) image data
# img_queue = queue.Queue()
# # Create a queue to pass image data between threads
# image_queue_analysis = queue.Queue()
# # Create a signal to communicate between threads
# analysis_done_signal = pyqtSignal(object)

# #Sleep time to keep responsiveness
# sleep_time = 0.05


#This needs to be a function outside of any class due to Yield-calling
def napariUpdateLive(DataStructure):
    &#34;&#34;&#34; 
    Function that finally shows the  image in napari
    
    Basically the core visualisation method
    &#34;&#34;&#34;
    
    #TODO: Make this an advanced variable or so. 
    display_update_time = 0.1 #0.05
    
    if time.time() - shared_data.last_display_update_time &lt; display_update_time: #less than a 50ms ago already update live mode? don&#39;t display live then.
        return
    
    napariViewer = DataStructure[&#39;napariViewer&#39;]
    acqstate = DataStructure[&#39;acqState&#39;]
    core = DataStructure[&#39;core&#39;]
    image_queue_analysisA = DataStructure[&#39;image_queue_analysis&#39;]
    analysisThreads = DataStructure[&#39;analysisThreads&#39;]
    shared_data.last_display_update_time = time.time()
    logging.debug(&#39;NapariUpdateLive Ran at time {}&#39;.format(time.time()))
    layerName = DataStructure[&#39;layer_name&#39;]
    
    #Visualise the MDA data on a frame-by-frame method - i.e. not a &#39;stack&#39;, but simply a single image which is replaced every frame update
    if shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;frameByFrame&#39; or DataStructure[&#39;layer_name&#39;]==&#39;Live&#39;:
        liveImage = DataStructure[&#39;data&#39;][0]
        metadata = DataStructure[&#39;data&#39;][1]
        if liveImage is None:
            return
        if acqstate == False:
            return
        liveImageLayer = getLayerIdFromName(layerName,napariViewer)

        #If it&#39;s the first liveImageLayer
        if not liveImageLayer:
            nrLayersBefore = len(napariViewer.layers)
            layer = napariViewer.add_image(liveImage, rendering=&#39;attenuated_mip&#39;, colormap=DataStructure[&#39;layer_color_map&#39;],name = layerName)
            #Set correct scale - in nm
            layer.scale = [core.get_pixel_size_um(),core.get_pixel_size_um()] #type:ignore
            layer._keep_auto_contrast = True #type:ignore
            #Move to the front of the layers
            # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
            napariViewer.reset_view()
        #Else if the layer already exists, replace it!
        else:
            # layer is present, replace its data
            layer = napariViewer.layers[liveImageLayer[0]]
            #Also move to top
            # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
            layer.data = liveImage
    #Visualise the MDA data via a &#39;stack&#39; - i.e. a multiD method where the user can (later) scroll through the frames
    elif shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;multiDstack&#39;:
        if DataStructure[&#39;finalisationProcedure&#39;] == False:
            liveImage = DataStructure[&#39;data&#39;][0]
            metadata = DataStructure[&#39;data&#39;][1]
            latestImage = DataStructure[&#39;data&#39;][0]
            metadata = DataStructure[&#39;data&#39;][1]
            if latestImage is None:
                return
            if acqstate == False:
                return
            liveImageLayer = getLayerIdFromName(layerName,napariViewer)
        
        
            if layerName != &#39;Live&#39;:
                #In case MDA is done repeatedly, the layer already exists, but the dimensions might be wrong. If this is the case, we reshape the MDA layer
                if liveImageLayer:
                    dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
                    
                    #Assume the dimensions are correct
                    correctDimensions = True
                    
                    #Then check if anywhere the dimensions of the layer are wrong
                    #Check if we have the correct nr of dimensions
                    CurrentLayer = napariViewer.layers[liveImageLayer[0]]
                    if CurrentLayer.ndim != len(uniqueEntriesAllDims)+2: #Note: +2 for image xy
                        correctDimensions = False
                    else:
                        layerData = CurrentLayer.data
                        #Check each dimension as follows:
                        for dim_id in range(0,len(uniqueEntriesAllDims)):
                            #Check if it has the correct label
                            # logging.debug(f&#39;axis_labels: {napariViewer.dims.axis_labels[dim_id]} vs {dimensionOrder[dim_id]}&#39;)
                            # if napariViewer.dims.axis_labels[dim_id] != dimensionOrder[dim_id]:
                            #     correctDimensions = False
                            #     break
                            #Check it has the correct length:
                            logging.debug(f&#39;range: {layerData.shape[dim_id]} vs {n_entries_in_dims[dim_id]}&#39;)
                            if int(layerData.shape[dim_id]) != n_entries_in_dims[dim_id]:
                                correctDimensions = False
                                break
                            
                    #Remove the layer if the dimensions are wrong
                    if correctDimensions == False:
                        logging.debug(&#39;removing mdaZarrData - looping over layers&#39;)
                        #Remove the mdaZarrData array and ensure that we create a new layer
                        for tLayerIndex in range(0,len(napariViewer.layers)):
                            tLayer = napariViewer.layers[tLayerIndex]
                            logging.debug(f&#39;layer: {tLayer}, comparing with {napariViewer.layers[liveImageLayer[0]].name}, boolTest {str(tLayer) == str(napariViewer.layers[liveImageLayer[0]].name)}&#39;)
                            if str(tLayer) == str(napariViewer.layers[liveImageLayer[0]].name):
                                #If we found the layer, delete it, and ensure we create a new one
                                logging.debug(f&#39;found layer to remove: {tLayer} at {tLayerIndex}&#39;)
                                napariViewer.layers.pop(tLayerIndex)
                                shared_data.mdaZarrData[layerName] = None
                                liveImageLayer = False
                                break
        
            #If it&#39;s the first layer
            if not liveImageLayer:
                if layerName != &#39;Live&#39;:
                    logging.debug(f&#39;creating layer with name {layerName} via multiDstack method&#39;)
                    dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
                    logging.debug(f&#34;obtained dimensions: {dimensionOrder} and n_entries_in_dims: {n_entries_in_dims}&#34;)
                    
                    shape = n_entries_in_dims
                    shared_data.mdaZarrData[layerName] = zarr.open(
                            str(tempfile.TemporaryDirectory().name),
                            shape = shape+[latestImage.shape[0],latestImage.shape[1]],
                            chunks = tuple([1] * len(shape) + [latestImage.shape[0],liveImage.shape[1]]),
                            )
                    #Changing the first image to the latest acquired image
                    shared_data.mdaZarrData[layerName][(0,) * len(shape) + (slice(None),slice(None))] = latestImage
                    shared_data.allMDAslicesRendered = {}
                    
                    layer = napariViewer.add_image(shared_data.mdaZarrData[layerName], colormap=DataStructure[&#39;layer_color_map&#39;],name = layerName)
                    #Set correct scale - in nm
                    layer.scale = [core.get_pixel_size_um(),core.get_pixel_size_um()] #type:ignore
                    layer._keep_auto_contrast = True #type:ignore
                    
                    for dim_id in range(len(n_entries_in_dims)):
                        napariViewer.dims.set_axis_label(dim_id, dimensionOrder[dim_id])
                    #Move to the front of the layers
                    # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
                    napariViewer.reset_view()
                    
                    #set the napariViewer to the correct slices:
                    for dim_id in range(len(n_entries_in_dims)):
                        napariViewer.dims.set_current_step(dim_id,0)
                else:
                    nrLayersBefore = len(napariViewer.layers)
                    layer = napariViewer.add_image(latestImage, colormap=DataStructure[&#39;layer_color_map&#39;],name = layerName)
                    #Set correct scale - in nm
                    layer.scale = [core.get_pixel_size_um(),core.get_pixel_size_um()] #type:ignore
                    layer._keep_auto_contrast = True #type:ignore
                    #Move to the front of the layers
                    # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
                    napariViewer.reset_view()
            #Else if the layer already exists, replace it!
            else:
                if layerName != &#39;Live&#39;:
                    # logging.debug(f&#39;updating layer with name {layerName} via multiDstack method&#39;)
                    dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
                    
                    #Determine in which multi-D slice the image should be added:
                    sliceTuple = ()
                    for dim_id in range(len(n_entries_in_dims)):
                        currentSlice = metadata[&#39;Axes&#39;][dimensionOrder[dim_id]]
                        currentSliceID = uniqueEntriesAllDims[dimensionOrder[dim_id]].tolist().index(currentSlice)
                        logging.debug(f&#34;currentSlice[{dim_id}]: {currentSliceID}&#34;)
                        sliceTuple += (int(currentSliceID),)
                        
                    shared_data.mdaZarrData[layerName][sliceTuple + (slice(None),slice(None))] = liveImage #type:ignore
                    
                    #set the napariViewer to the correct slice:
                    for dim_id in range(len(n_entries_in_dims)):
                        currentSlice = metadata[&#39;Axes&#39;][dimensionOrder[dim_id]]
                        currentSliceID = uniqueEntriesAllDims[dimensionOrder[dim_id]].tolist().index(currentSlice)
                        napariViewer.dims.set_current_step(dim_id,int(currentSliceID))
                    
                    #Store exactly which axes is rendered
                    shared_data.allMDAslicesRendered[len(shared_data.allMDAslicesRendered)] = metadata[&#39;Axes&#39;]
                else:
                    # layer is present, replace its data
                    layer = napariViewer.layers[liveImageLayer[0]]
                    #Also move to top
                    napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
                    layer.data = liveImage
                    
        elif DataStructure[&#39;finalisationProcedure&#39;] == True:
            #Render the missing images in the MDA acquisition
            shared_data._busy = True
            renderedSlices = shared_data.allMDAslicesRendered
            dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
            for expectedEntry in shared_data._mdaModeParams:
                #check in the rendered sclies if this is in there:
                entry_found = any(expectedEntry[&#39;axes&#39;].items() &lt;= item.items() for item in renderedSlices.values())
                if not entry_found:
                    time.sleep(0.001) #Can&#39;t explain why, but a sleep of 1 ms is super important for stability
                    
                    #Figure out which slice to read
                    readChannel = None
                    readZ = None
                    readTime = None
                    readPosition = None
                    readRow = None
                    readColumn = None
                    for key, value in expectedEntry[&#39;axes&#39;].items():
                        if key == &#39;channel&#39;:
                            readChannel = value
                        if key == &#39;z&#39;:
                            readZ = value
                        if key == &#39;time&#39;:
                            readTime = value
                        if key == &#39;position&#39;:
                            readPosition = value
                        if key == &#39;row&#39;:
                            readRow = value
                        if key == &#39;column&#39;:
                            readColumn = value
                    #Read this slice from the NDDataset:
                    try:
                        # logging.debug(shared_data._mdaModeAcqData._dataset)
                        # logging.debug(f&#34;Attempting reading slice at: {readChannel}, {readZ}, {readTime}, {readPosition}, {readRow}, {readColumn}&#34;)
                        sliceImage = shared_data._mdaModeAcqData._dataset.read_image(channel=readChannel,z=readZ,time=readTime,position=readPosition,row=readRow,column=readColumn)
                        # logging.debug(f&#34;sliceImage: {sliceImage}&#34;)
                        
                        #Find the correct slice to slot it in
                        sliceTuple = ()
                        for dim_id in range(len(n_entries_in_dims)):
                            currentSlice = expectedEntry[&#39;axes&#39;][dimensionOrder[dim_id]]
                            currentSliceID = uniqueEntriesAllDims[dimensionOrder[dim_id]].tolist().index(currentSlice)
                            sliceTuple += (int(currentSliceID),)
                        #Put it in
                        shared_data.mdaZarrData[layerName][sliceTuple + (slice(None),slice(None))] = sliceImage 
                        logging.debug(f&#34;Added entry {expectedEntry} not rendered in the MDA acquisition&#34;)
                    except:
                        logging.debug(f&#39;Entry {expectedEntry} tried, but not acquired&#39;)
            
            logging.debug(&#39;Finalised up visualisation...&#39;)
            #Move to the end
            # napariViewer.dims.set_point(0,timeslice)
            shared_data._busy = False
    
    
def napariUpdateAnalysisThreads(DataStructure):
    &#34;&#34;&#34; 
    Function that finally shows the  image in napari
    &#34;&#34;&#34;
    napariViewer = DataStructure[&#39;napariViewer&#39;]
    acqstate = DataStructure[&#39;acqState&#39;]
    core = DataStructure[&#39;core&#39;]
    image_queue_analysisA = DataStructure[&#39;image_queue_analysis&#39;]
    analysisThreads = DataStructure[&#39;analysisThreads&#39;]
    logging.debug(&#39;NapariUpdateLive Ran at time {}&#39;.format(time.time()))
    liveImage = DataStructure[&#39;data&#39;][0]
    metadata = DataStructure[&#39;data&#39;][1]
    layerName = DataStructure[&#39;layer_name&#39;]
    if liveImage is None:
        return
    if acqstate == False:
        return
    liveImageLayer = getLayerIdFromName(layerName,napariViewer)

    # Check if the queue is empty
    if image_queue_analysisA.empty():
        image_queue_analysisA.put_nowait([liveImage,metadata])
        #Start all analysisthreads
        for analysisThread in analysisThreads:
            if not analysisThread.isRunning():
                logging.debug(f&#39;starting analysis thread: {analysisThread}&#39;)
                analysisThread.start()


class napariHandler():
    def __init__(self, shared_data,liveOrMda=&#39;live&#39;) -&gt; None:
        self.shared_data = shared_data
        self.napariViewer = shared_data.napariViewer
        if liveOrMda == &#39;live&#39;:
            self.liveOrMda = &#39;live&#39;
            self.acqstate = shared_data.liveMode
        elif liveOrMda == &#39;mda&#39;:
            self.liveOrMda = &#39;mda&#39;
            self.acqstate = shared_data.mdaMode
        # Define a flag to control the continuous task
        self.stop_continuous_task = False
        # empty queue for (live) image data
        self.img_queue = queue.Queue()
        # Create a queue to pass image data between threads
        self.image_queue_analysis = queue.Queue()
        # Create a signal to communicate between threads
        self.mda_acq_done_signal = pyqtSignal(bool)

        #Sleep time to keep responsiveness
        self.sleep_time = 1/shared_data.globalData[&#39;VISUALISATION-FPS&#39;][&#39;value&#39;] #in sec
        self.layerName = &#39;newLayer&#39;

    def mdaacqdonefunction(self):
        logging.debug(&#39;mdaacqdonefunction called in napariHandler&#39;)
        self.shared_data.mdaacqdonefunction()
        
    def grab_image(self,image, metadata, event_queue):
        &#34;&#34;&#34; 
        Function that runs on every frame obtained in live mode and putis in the image queue
        
        Inputs: array image: image from micromanager
                metadata: metadata from micromanager
        &#34;&#34;&#34;
        if self.acqstate:
            if self.img_queue.qsize() &lt; 3:
                self.img_queue.put([image,metadata])
                
            #Loop over all queues in shared_data.liveImageQueues and also append the image there:
            for queue in self.shared_data.liveImageQueues:
                if queue.qsize() &lt; 2:
                    queue.put([image,metadata])
                        
            if self.image_queue_analysis.qsize() &lt; 3:
                self.image_queue_analysis.put([image,metadata])
            
        else:
            logging.info(&#39;Broke off live mode&#39;)
            event_queue.put(None)
            try:
                acq.abort()
                logging.debug(&#39;aborted acquisition&#39;)
            except:
                logging.debug(&#39;attemped to abort acq&#39;)
        
        return image, metadata
    
    
    def grab_image_savedfn(self,axes,dataset, event_queue):
        &#34;&#34;&#34; 
        Function that runs on every frame obtained in live mode and putis in the image queue
        
        Inputs: array image: image from micromanager
                metadata: metadata from micromanager
        &#34;&#34;&#34;
        if self.acqstate:
            #Check if there is any reason to read the image:
            reasonToReadImage = False
            if self.img_queue.qsize() &lt; 3:
                reasonToReadImage = True
            for queue in self.shared_data.liveImageQueues:
                if queue.qsize() &lt; 2:
                    reasonToReadImage = True
            if self.image_queue_analysis.qsize() &lt; 3:
                reasonToReadImage = True
            
            if reasonToReadImage:
                image = dataset.read_image(**axes)
                metadata = {}
                metadata[&#39;Axes&#39;]=axes
                logging.debug(f&#39;grab_image_savedfn called in napariHandler read image: {dataset}, axes: {axes}, metadata: {metadata}&#39;)
                if self.img_queue.qsize() &lt; 3:
                    self.img_queue.put([image,metadata])
                    
                #Loop over all queues in shared_data.liveImageQueues and also append the image there:
                for queue in self.shared_data.liveImageQueues:
                    if queue.qsize() &lt; 2:
                        queue.put([image,metadata])
                            
                if self.image_queue_analysis.qsize() &lt; 3:
                    self.image_queue_analysis.put([image,metadata])
            
        else:
            logging.info(&#39;Broke off live mode&#39;)
            event_queue.put(None)
            try:
                acq.abort()
                logging.debug(&#39;aborted acquisition&#39;)
            except:
                logging.debug(&#39;attemped to abort acq&#39;)
        
        # return image, metadata

    @thread_worker
    def run_pycroManagerAcquisition_worker(self,parent):
        &#34;&#34;&#34; 
        Worker which handles live mode on/off turning etc
        
        Inputs: img_queue (unused, but required)
        &#34;&#34;&#34;
        img_queue = parent.img_queue
        global acq
        # shared_data = self.shared_data
        logging.debug(&#39;in run_pycroManagerAcquisition_worker&#39;)
        #The idea of live mode is that we do a very very long acquisition (10k frames), and real-time show the images, and then abort the acquisition when we stop life.
        #The abortion is handled in grab_image_livemode
        if self.liveOrMda == &#39;live&#39;:
            while self.acqstate:
                if self.shared_data.mdaMode:
                    logging.error(&#39;LIVE NOT STARTED! MDA IS RUNNING&#39;)
                    self.shared_data.liveMode = False
                else:        
                    #JavaBackendAcquisition is an acquisition on a different thread to not block napari I believe
                    logging.debug(&#39;starting acq&#39;)
                    self.shared_data.allMDAslicesRendered = {}
                    #Already move the live layer to top
                    logging.debug(&#39;BMoved layer to top&#39;)
                    # moveLayerToTop(self.shared_data.napariViewer,&#34;Live&#34;)
                    with Acquisition(directory=&#39;./temp&#39;, name=&#39;LiveAcqShouldBeRemoved&#39;, show_display=False, image_saved_fn = self.grab_image_savedfn) as acq: #type:ignore
                        self.shared_data._mdaModeAcqData = acq
                        events = multi_d_acquisition_events(num_time_points=9999, time_interval_s=0)
                        acq.acquire(events)

                    logging.debug(&#39;After Acq Live&#39;)
            #Now we&#39;re after the livestate
            self.shared_data.core.stop_sequence_acquisition()
            self.shared_data.liveMode = False
            #We clean up, removing all LiveAcqShouldBeRemoved folders in /Temp:
            cleanUpTemporaryFiles(shared_data=self.shared_data)
        elif self.liveOrMda == &#39;mda&#39;:
            while self.acqstate:
                if self.shared_data.liveMode:
                    self.shared_data.liveMode = False
                    time.sleep(1)
                    
                #JavaBackendAcquisition is an acquisition on a different thread to not block napari I believe
                logging.debug(&#39;starting MDA acq - before JavaBackendAcquisition&#39;)
                savefolder = &#39;./temp&#39;
                savename = &#39;MdaAcqShouldBeRemoved&#39;
                if self.shared_data._mdaModeSaveLoc[0] != &#39;&#39;:
                    savefolder = self.shared_data._mdaModeSaveLoc[0]
                    
                    savefolderAdv = utils.nodz_evaluateAdv(savefolder,self.shared_data.nodzInstance)
                    if savefolderAdv != None:
                        savefolder = savefolderAdv
                    logging.debug(savefolder)
                    
                if self.shared_data._mdaModeSaveLoc[1] != &#39;&#39;:
                    savename = self.shared_data._mdaModeSaveLoc[1]
                    savenameAdv = utils.nodz_evaluateAdv(savename,self.shared_data.nodzInstance)
                    if savenameAdv != None:
                        savename = savenameAdv
                    logging.debug(savename)
                if self.shared_data._mdaModeNapariViewer != None:
                    napariViewer = self.shared_data._mdaModeNapariViewer
                    showdisplay = True
                else:
                    napariViewer = None
                    showdisplay = False
                    
                napariViewer = None
                showdisplay = False
                self.shared_data.allMDAslicesRendered = {}
                #Already move the layer to top
                # if self.shared_data.newestLayerName != &#39;&#39;:
                #     moveLayerToTop(self.shared_data.napariViewer,self.shared_data.newestLayerName)
                with Acquisition(directory=savefolder, name=savename, show_display=showdisplay, image_saved_fn = self.grab_image_savedfn,napari_viewer=napariViewer) as acq: #type:ignore
                    self.shared_data._mdaModeAcqData = acq
                    events = self.shared_data._mdaModeParams
                    acq.acquire(events)
                # with Acquisition(directory=savefolder, name=savename, show_display=showdisplay, image_process_fn = self.grab_image,napari_viewer=napariViewer) as acq: #type:ignore
                
                self.shared_data.mdaMode = False
                self.acqstate = False #End the MDA acq state
                self.shared_data.appendNewMDAdataset(acq.get_dataset())

            logging.debug(&#39;Stopping the acquisition from napariHandler&#39;)
            #Now we&#39;re after the acquisition
            self.shared_data.core.stop_sequence_acquisition()
            self.shared_data.mdaMode = False
            
            #Signal to all parents that the MDA acquisition is done - in the Nodz MDA, now we would trigger the MDA-based analysis for scoring or so
            parent.mdaacqdonefunction()
            
            #We clean up, removing all LiveAcqShouldBeRemoved folders in /Temp:
            cleanUpTemporaryFiles(shared_data=self.shared_data)
    
    
    @thread_worker(connect={&#39;yielded&#39;: napariUpdateAnalysisThreads})
    def run_analysis_worker(self,parent,layerName=&#39;Layer&#39;,layerColorMap=&#39;gray&#39;):
        &#34;&#34;&#34;
        Worker which handles the visualisation of the live mode queue
        Connected to display_napari function to update display 
        &#34;&#34;&#34;
        img_queue = parent.image_queue_analysis
        while self.acqstate:
            time.sleep(0)
            # get elements from queue while there is more than one element
            # playing it safe: I&#39;m always leaving one element in the queue
            while img_queue.qsize() &gt; 1:
                DataStructure = {}
                DataStructure[&#39;data&#39;] = img_queue.get(block = False)
                DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
                DataStructure[&#39;acqState&#39;] = self.acqstate
                DataStructure[&#39;core&#39;] = self.shared_data.core
                DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
                DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
                DataStructure[&#39;layer_name&#39;] = layerName
                DataStructure[&#39;layer_color_map&#39;] = layerColorMap
                DataStructure[&#39;finalisationProcedure&#39;] = False
                yield DataStructure

    
    @thread_worker(connect={&#39;yielded&#39;: napariUpdateLive})
    def run_napariVisualisation_worker(self,parent,layerName=&#39;Layer&#39;,layerColorMap=&#39;gray&#39;):
        &#34;&#34;&#34;
        Worker which handles the visualisation of the live mode queue
        Connected to display_napari function to update display 
        &#34;&#34;&#34;
        img_queue = parent.img_queue
        while self.acqstate:
            time.sleep(self.sleep_time)
            logging.debug(&#39;in while-loop in visualise_live_mode_worker, len of img_queue: &#39;+str(img_queue.qsize()))
            # get elements from queue while there is more than one element
            # playing it safe: I&#39;m always leaving one element in the queue
            while img_queue.qsize() &gt; 0:
                DataStructure = {}
                DataStructure[&#39;data&#39;] = img_queue.get()
                DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
                DataStructure[&#39;acqState&#39;] = self.acqstate
                DataStructure[&#39;core&#39;] = self.shared_data.core
                DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
                DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
                DataStructure[&#39;layer_name&#39;] = layerName
                DataStructure[&#39;layer_color_map&#39;] = layerColorMap
                DataStructure[&#39;finalisationProcedure&#39;] = False
                yield DataStructure
                # self.napariUpdateLive(img_queue.get(block=False))

        # read out last remaining element(s) after end of acquisition
        while img_queue.qsize() &gt; 0:
            DataStructure = {}
            DataStructure[&#39;data&#39;] = img_queue.get()
            DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
            DataStructure[&#39;acqState&#39;] = self.acqstate
            DataStructure[&#39;core&#39;] = self.shared_data.core
            DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
            DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
            DataStructure[&#39;layer_name&#39;] = layerName
            DataStructure[&#39;layer_color_map&#39;] = layerColorMap
            DataStructure[&#39;finalisationProcedure&#39;] = False
            yield DataStructure#img_queue.get(block = False)
            
        #Do the final N images
        if self.shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;multiDstack&#39;:
            if layerName == &#39;MDA&#39;:
                logging.debug(&#39;Finalising MDA visualisation...&#39;)
                DataStructure = {}
                DataStructure[&#39;data&#39;] = None
                DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
                DataStructure[&#39;acqState&#39;] = self.acqstate
                DataStructure[&#39;core&#39;] = self.shared_data.core
                DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
                DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
                DataStructure[&#39;layer_name&#39;] = layerName
                DataStructure[&#39;layer_color_map&#39;] = layerColorMap
                DataStructure[&#39;finalisationProcedure&#39;] = True
                napariUpdateLive(DataStructure)
        
        # shared_data.analysisThreads.remove(shared_data.lastMDAThread)
        # shared_data.lastMDAThread.destroy()
        # shared_data.lastMDAThread = None
        logging.debug(&#34;acquisition done&#34;)

    def acqModeChanged(self, newSharedData = None):
        &#34;&#34;&#34;
        General function which is called if live mode is changed or not. Generally called from sharedFunction - when self._liveMode is altered
        
        Is called, and shared_data.liveMode should be changed seperately from running this funciton
        &#34;&#34;&#34;
        logging.debug(&#39;acqModeChanged called from napariHandler&#39;)
        if newSharedData is not None:
            global napariViewer, shared_data, Core
            self.shared_data = newSharedData
            shared_data = self.shared_data
            napariViewer = self.shared_data.napariViewer
            core = self.shared_data.core
            
        if self.liveOrMda == &#39;live&#39;:
            #Hook the live mode into the scripts here
            if self.shared_data.liveMode == False:
                self.acqstate = False
                self.stop_continuous_task = True
                #Clear the image queue
                self.img_queue.queue.clear()
                logging.info(&#34;Live mode stopped&#34;)
            else:
                logging.debug(&#39;liveMode changed to TRUE&#39;)
                self.acqstate = True
                self.stop_continuous_task = False
                #Always start live-mode visualisation:
                napariGlados.startLiveModeVisualisation(self.shared_data)
                #Move layer to top - if it isn&#39;t created yet, it will fail
                moveLayerToTop(self.shared_data.napariViewer,&#34;Live&#34;)
                
                #Start the worker to run the pycromanager acquisition
                worker1 = self.run_pycroManagerAcquisition_worker(self) #type:ignore
                worker1.start() #type:ignore
                worker2 = self.run_analysis_worker(self) #type:ignore
                
                logging.info(&#34;Live mode started&#34;)
        elif self.liveOrMda == &#39;mda&#39;:
            #Hook the live mode into the scripts here
            if self.shared_data.mdaMode == False:
                self.acqstate = False
                self.stop_continuous_task = True
                #Clear the image queue
                self.img_queue.queue.clear()
                logging.info(&#34;MDA mode stopped from acqModeChanged&#34;)
                # self.mdaacqdonefunction()
            else:
                logging.debug(&#39;mdaMode changed to TRUE&#39;)
                self.acqstate = True
                self.stop_continuous_task = False
                #Move layer to top - if it isn&#39;t created yet, it will fail
                if self.shared_data.newestLayerName != &#39;&#39;:
                    moveLayerToTop(self.shared_data.napariViewer,self.shared_data.newestLayerName)
                #Start the two workers, one to run it, one to visualise it.
                worker1 = self.run_pycroManagerAcquisition_worker(self) #type:ignore
                # worker2 = self.run_napariVisualisation_worker(self) #type:ignore
                worker1.start() #type:ignore
                # worker2.start()
                logging.debug(&#34;MDA mode started from acqModeChanged&#34;)


class napariHandler_liveMode(napariHandler):
    def __init__(self, shared_data) -&gt; None:
        super().__init__(shared_data, liveOrMda=&#39;live&#39;)

class napariHandler_mdaMode(napariHandler):
    def __init__(self, shared_data) -&gt; None:
        super().__init__(shared_data, liveOrMda=&#39;mda&#39;)
&#34;&#34;&#34; 
Napari widgets
&#34;&#34;&#34;

class dockWidgets(QMainWindow):
    sizeChanged = pyqtSignal(QSize)
    
    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.sizeChanged.emit(event.size())
        
    def __init__(self):
        logging.debug(&#39;dockwidget started&#39;)
        super().__init__()
        #Create all the widgets/layouts:
        self.central_widget = QWidget(self)
        self.central_layout = QVBoxLayout()
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.content_widget = QWidget()
        self.layout = QGridLayout() #type:ignore
        
        #Order them logically:
        self.content_widget.setLayout(self.layout)
        self.scroll_area.setWidget(self.content_widget)
        self.central_layout.addWidget(self.scroll_area)
        self.central_widget.setLayout(self.central_layout)
        self.setCentralWidget(self.central_widget)
        
        self.dockWidget = None

        #we end up with self.layout() that&#39;s changed by every indiv dockwidget
        
    def getDockWidget(self):
        return self.dockWidget

class dockWidget_MMcontrol(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_MMcontrol started&#34;)
        super().__init__()
        #Add the full micro manager controls UI
        self.dockWidget = microManagerControlsUI(core,MM_JSON,self.layout,shared_data)

class dockWidget_MDA(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_MDA started&#34;)
        super().__init__()
        
        #load from appdata
        appdata_folder = os.getenv(&#39;APPDATA&#39;)
        if appdata_folder is None:
            raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
        os.makedirs(app_specific_folder, exist_ok=True)
        if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
            #Load the mda state
            with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
                gladosInfo = json.load(file)
                mdaInfo = gladosInfo[&#39;MDA&#39;]
            
            try:
                #Add the full micro manager controls UI
                self.dockWidget = MDAGlados(core,MM_JSON,self.layout,shared_data,
                            hasGUI=True,
                            num_time_points = mdaInfo[&#39;num_time_points&#39;], 
                            time_interval_s = mdaInfo[&#39;time_interval_s&#39;], 
                            time_interval_s_or_ms = mdaInfo[&#39;time_interval_s_or_ms&#39;],
                            z_start = mdaInfo[&#39;z_start&#39;],
                            z_end = mdaInfo[&#39;z_end&#39;],
                            z_step = mdaInfo[&#39;z_step&#39;],
                            z_stage_sel = mdaInfo[&#39;z_stage_sel&#39;],
                            z_nr_steps = mdaInfo[&#39;z_nr_steps&#39;],
                            z_step_distance = mdaInfo[&#39;z_step_distance&#39;],
                            z_nrsteps_radio_sel = mdaInfo[&#39;z_nrsteps_radio_sel&#39;],
                            z_stepdistance_radio_sel = mdaInfo[&#39;z_stepdistance_radio_sel&#39;],
                            channel_group = mdaInfo[&#39;channel_group&#39;],
                            channels = mdaInfo[&#39;channels&#39;],
                            channel_exposures_ms = mdaInfo[&#39;channel_exposures_ms&#39;],
                            xy_positions = mdaInfo[&#39;xy_positions&#39;],
                            xyz_positions = mdaInfo[&#39;xyz_positions&#39;],
                            position_labels = mdaInfo[&#39;position_labels&#39;],
                            exposure_ms = mdaInfo[&#39;exposure_ms&#39;],
                            exposure_s_or_ms = mdaInfo[&#39;exposure_s_or_ms&#39;],
                            storage_folder = mdaInfo[&#39;storage_folder&#39;],
                            storage_file_name = mdaInfo[&#39;storage_file_name&#39;],
                            order = mdaInfo[&#39;order&#39;],
                            GUI_show_exposure = mdaInfo[&#39;GUI_show_exposure&#39;], 
                            GUI_show_xy = mdaInfo[&#39;GUI_show_xy&#39;], 
                            GUI_show_z = mdaInfo[&#39;GUI_show_z&#39;], 
                            GUI_show_channel = mdaInfo[&#39;GUI_show_channel&#39;], 
                            GUI_show_time = mdaInfo[&#39;GUI_show_time&#39;], 
                            GUI_show_order = mdaInfo[&#39;GUI_show_order&#39;], 
                            GUI_show_storage = mdaInfo[&#39;GUI_show_storage&#39;], 
                            GUI_xy_pos_fullInfo = mdaInfo[&#39;xy_positions_saveInfo&#39;],
                            GUI_acquire_button = True,
                            autoSaveLoad=True).getGui()
            except KeyError:
                #Add the full micro manager controls UI
                self.dockWidget = MDAGlados(core,MM_JSON,self.layout,shared_data,
                            hasGUI=True,
                            GUI_acquire_button = True,
                            autoSaveLoad=True).getGui()
        else: #If no MDA state is yet saved, open a new MDAGlados from scratch
            #Add the full micro manager controls UI
            self.dockWidget = MDAGlados(core,MM_JSON,self.layout,shared_data,
                        hasGUI=True,
                        GUI_acquire_button = True,
                        autoSaveLoad=True).getGui()
            
        self.sizeChanged.connect(self.dockWidget.handleSizeChange)

class dockWidget_flowChart(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_flowchart started&#34;)
        super().__init__()
        
        #Add the full micro manager controls UI
        self.dockWidget = flowChart_dockWidgets(core,MM_JSON,self.layout,shared_data)

#--- below here not fully necessary---
# class dockWidget_mdaAnalysisScoringTest(dockWidgets):
#     def __init__(self): 
#         logging.debug(&#34;dockwidgetMDAANALYSISSCORINGTEST started&#34;)
#         super().__init__()
        
#         #Add the full micro manager controls UI
#         self.dockWidget = mdaAnalysisScoringTest_dockWidget(core,MM_JSON,self.layout,shared_data)

# class dockWidget_analysisThreads(dockWidgets):
#     def __init__(self): 
#         logging.debug(&#34;dockWidget_analysisThreads started&#34;)
#         super().__init__()
        
#         #Add the full micro manager controls UI
#         self.dockWidget = analysis_dockWidget(MM_JSON,self.layout,shared_data)

class dockWidget_fullGladosUI(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_fullGladosUI started&#34;)
        super().__init__()
        # #new QWidget:
        tempWidget = QMainWindow()
        
        
        
    
    
        
        ui = Ui_CustomDockWidget()
        ui.setupUi(tempWidget)
        #Open JSON file with MM settings
        MM_JSON_path = os.path.join(sys.path[0], &#39;MM_PycroManager_JSON.json&#39;)
        # with open(os.path.join(sys.path[0], &#39;MM_PycroManager_JSON.json&#39;), &#39;r&#39;) as f:
        with open(MM_JSON_path) as f:
            MM_JSON = json.load(f)
            
        runlaserControllerUI(core,MM_JSON,ui,shared_data)
        #Run the laserController UI
        logging.debug(&#34;dockWidget_fullGladosUI halfway&#34;)
        
        #
        #Create a Vertical+horizontal layout:
        self.dockwidgetLayout = QGridLayout()
        #Create a layout for the configs:
        self.analysisLayout = QGridLayout()
        #Add this to the mainLayout:
        self.dockwidgetLayout.addLayout(self.analysisLayout,0,0)
        
        self.analysisLayout.addWidget(ui.centralwidget.children()[1].children()[0],1,1)
        
        self.dockWidget = self.layout.addLayout(self.dockwidgetLayout,0,0)

        

def startLiveModeVisualisation(shared_data,layerName=&#39;Live&#39;):
    create_analysis_thread(shared_data,analysisInfo=&#39;LiveModeVisualisation&#39;,createNewThread=False,throughputThread=shared_data._livemodeNapariHandler.image_queue_analysis)
    shared_data._livemodeNapariHandler.run_napariVisualisation_worker(shared_data._livemodeNapariHandler,layerName = layerName)

def startMDAVisualisation(shared_data,layerName=&#39;MDA&#39;,layerColorMap=&#39;gray&#39;):
    #Set the latest layer name to be the layer name
    shared_data.newestLayerName = layerName
    #Create an analysis thread which runs this MDA visualisation
    create_analysis_thread(shared_data,analysisInfo=&#39;mdaVisualisation&#39;,createNewThread=False,throughputThread=shared_data._mdamodeNapariHandler.image_queue_analysis)
    shared_data._mdamodeNapariHandler.run_napariVisualisation_worker(shared_data._mdamodeNapariHandler,layerName = layerName,layerColorMap=layerColorMap)

def layer_removed_event_callback(event, shared_data):
    #The name of the layer that is being removed:
    layerRemoved = shared_data.napariViewer.layers[event.index].name
    #Find this layer in the analysis threads
    for l in shared_data.analysisThreads:
        if l.getLayer() is not None:
            if l.getLayer().name == layerRemoved:
                #Destroy the analysis thread
                shared_data.analysisThreads.remove(l)
                
                if &#39;skipAnalysisThreadDeletion&#39; in vars(shared_data):
                    if not shared_data.skipAnalysisThreadDeletion:
                        l.destroy()
                    else:
                        shared_data.skipAnalysisThreadDeletion = False
                else:
                    l.destroy()

def runNapariPycroManager(score,sMM_JSON,sshared_data,includecustomUI = False,include_flowChart_automatedMicroscopy = True):
    #Go from self to global variables
    global core, MM_JSON, livestate, napariViewer, shared_data
    core = score
    MM_JSON = sMM_JSON
    livestate = False
    shared_data = sshared_data
    
    #Get some info from core to put in shared_data
    shared_data._defaultFocusDevice = core.get_focus_device()
    logging.debug(f&#34;Default focus device set to {shared_data._defaultFocusDevice}&#34;)

    #Napari start
    napariViewer = napari.Viewer()
    #Add a connect event if a layer is removed - to stop background processes
    napariViewer.layers.events.removing.connect(lambda event: layer_removed_event_callback(event,shared_data))
    shared_data.napariViewer = napariViewer
    
    # create_analysis_thread(shared_data,analysisInfo=&#39;LiveModeVisualisation&#39;,createNewThread=False,throughputThread=shared_data._livemodeNapariHandler.image_queue_analysis)
    # create_analysis_thread(shared_data,analysisInfo=&#39;mdaVisualisation&#39;,createNewThread=False,throughputThread=shared_data._mdamodeNapariHandler.image_queue_analysis)
    logging.debug(&#34;Live mode pseudo-analysis thread created&#34;)
    
    #Set some common things for the UI (scale bar on and such)
    InitateNapariUI(napariViewer)
    
    #Add widgets as wanted
    # custom_widget_analysisThreads = dockWidget_analysisThreads()
    # napariViewer.window.add_dock_widget(custom_widget_analysisThreads, area=&#34;top&#34;, name=&#34;Real-time analysis&#34;,tabify=True)
    
    logging.debug(&#39;In runNapariPycroManager&#39;)
    
    custom_widget_MMcontrols = dockWidget_MMcontrol()
    napariViewer.window.add_dock_widget(custom_widget_MMcontrols, area=&#34;top&#34;, name=&#34;Controls&#34;,tabify=True)
    
    custom_widget_MDA = dockWidget_MDA()
    napariViewer.window.add_dock_widget(custom_widget_MDA, area=&#34;top&#34;, name=&#34;Multi-D acquisition&#34;,tabify=True)
    
    if include_flowChart_automatedMicroscopy:
        custom_widget_flowChart = dockWidget_flowChart()
        napariViewer.window.add_dock_widget(custom_widget_flowChart, area=&#34;top&#34;, name=&#34;Autonomous microscopy&#34;,tabify=True)
        custom_widget_flowChart.dockWidget.focus()
    
    if includecustomUI:
        gladosLaserInfo = dockWidget_fullGladosUI()
        napariViewer.window.add_dock_widget(gladosLaserInfo, area=&#34;right&#34;, name=&#34;GladosUI&#34;)

    returnInfo = {}
    returnInfo[&#39;napariViewer&#39;] = napariViewer
    returnInfo[&#39;MMcontrolWidget&#39;] = custom_widget_MMcontrols.getDockWidget()
    
    # breakpoint
    return returnInfo</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="napariGlados.layer_removed_event_callback"><code class="name flex">
<span>def <span class="ident">layer_removed_event_callback</span></span>(<span>event, shared_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def layer_removed_event_callback(event, shared_data):
    #The name of the layer that is being removed:
    layerRemoved = shared_data.napariViewer.layers[event.index].name
    #Find this layer in the analysis threads
    for l in shared_data.analysisThreads:
        if l.getLayer() is not None:
            if l.getLayer().name == layerRemoved:
                #Destroy the analysis thread
                shared_data.analysisThreads.remove(l)
                
                if &#39;skipAnalysisThreadDeletion&#39; in vars(shared_data):
                    if not shared_data.skipAnalysisThreadDeletion:
                        l.destroy()
                    else:
                        shared_data.skipAnalysisThreadDeletion = False
                else:
                    l.destroy()</code></pre>
</details>
</dd>
<dt id="napariGlados.napariUpdateAnalysisThreads"><code class="name flex">
<span>def <span class="ident">napariUpdateAnalysisThreads</span></span>(<span>DataStructure)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that finally shows the
image in napari</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def napariUpdateAnalysisThreads(DataStructure):
    &#34;&#34;&#34; 
    Function that finally shows the  image in napari
    &#34;&#34;&#34;
    napariViewer = DataStructure[&#39;napariViewer&#39;]
    acqstate = DataStructure[&#39;acqState&#39;]
    core = DataStructure[&#39;core&#39;]
    image_queue_analysisA = DataStructure[&#39;image_queue_analysis&#39;]
    analysisThreads = DataStructure[&#39;analysisThreads&#39;]
    logging.debug(&#39;NapariUpdateLive Ran at time {}&#39;.format(time.time()))
    liveImage = DataStructure[&#39;data&#39;][0]
    metadata = DataStructure[&#39;data&#39;][1]
    layerName = DataStructure[&#39;layer_name&#39;]
    if liveImage is None:
        return
    if acqstate == False:
        return
    liveImageLayer = getLayerIdFromName(layerName,napariViewer)

    # Check if the queue is empty
    if image_queue_analysisA.empty():
        image_queue_analysisA.put_nowait([liveImage,metadata])
        #Start all analysisthreads
        for analysisThread in analysisThreads:
            if not analysisThread.isRunning():
                logging.debug(f&#39;starting analysis thread: {analysisThread}&#39;)
                analysisThread.start()</code></pre>
</details>
</dd>
<dt id="napariGlados.napariUpdateLive"><code class="name flex">
<span>def <span class="ident">napariUpdateLive</span></span>(<span>DataStructure)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that finally shows the
image in napari</p>
<p>Basically the core visualisation method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def napariUpdateLive(DataStructure):
    &#34;&#34;&#34; 
    Function that finally shows the  image in napari
    
    Basically the core visualisation method
    &#34;&#34;&#34;
    
    #TODO: Make this an advanced variable or so. 
    display_update_time = 0.1 #0.05
    
    if time.time() - shared_data.last_display_update_time &lt; display_update_time: #less than a 50ms ago already update live mode? don&#39;t display live then.
        return
    
    napariViewer = DataStructure[&#39;napariViewer&#39;]
    acqstate = DataStructure[&#39;acqState&#39;]
    core = DataStructure[&#39;core&#39;]
    image_queue_analysisA = DataStructure[&#39;image_queue_analysis&#39;]
    analysisThreads = DataStructure[&#39;analysisThreads&#39;]
    shared_data.last_display_update_time = time.time()
    logging.debug(&#39;NapariUpdateLive Ran at time {}&#39;.format(time.time()))
    layerName = DataStructure[&#39;layer_name&#39;]
    
    #Visualise the MDA data on a frame-by-frame method - i.e. not a &#39;stack&#39;, but simply a single image which is replaced every frame update
    if shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;frameByFrame&#39; or DataStructure[&#39;layer_name&#39;]==&#39;Live&#39;:
        liveImage = DataStructure[&#39;data&#39;][0]
        metadata = DataStructure[&#39;data&#39;][1]
        if liveImage is None:
            return
        if acqstate == False:
            return
        liveImageLayer = getLayerIdFromName(layerName,napariViewer)

        #If it&#39;s the first liveImageLayer
        if not liveImageLayer:
            nrLayersBefore = len(napariViewer.layers)
            layer = napariViewer.add_image(liveImage, rendering=&#39;attenuated_mip&#39;, colormap=DataStructure[&#39;layer_color_map&#39;],name = layerName)
            #Set correct scale - in nm
            layer.scale = [core.get_pixel_size_um(),core.get_pixel_size_um()] #type:ignore
            layer._keep_auto_contrast = True #type:ignore
            #Move to the front of the layers
            # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
            napariViewer.reset_view()
        #Else if the layer already exists, replace it!
        else:
            # layer is present, replace its data
            layer = napariViewer.layers[liveImageLayer[0]]
            #Also move to top
            # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
            layer.data = liveImage
    #Visualise the MDA data via a &#39;stack&#39; - i.e. a multiD method where the user can (later) scroll through the frames
    elif shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;multiDstack&#39;:
        if DataStructure[&#39;finalisationProcedure&#39;] == False:
            liveImage = DataStructure[&#39;data&#39;][0]
            metadata = DataStructure[&#39;data&#39;][1]
            latestImage = DataStructure[&#39;data&#39;][0]
            metadata = DataStructure[&#39;data&#39;][1]
            if latestImage is None:
                return
            if acqstate == False:
                return
            liveImageLayer = getLayerIdFromName(layerName,napariViewer)
        
        
            if layerName != &#39;Live&#39;:
                #In case MDA is done repeatedly, the layer already exists, but the dimensions might be wrong. If this is the case, we reshape the MDA layer
                if liveImageLayer:
                    dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
                    
                    #Assume the dimensions are correct
                    correctDimensions = True
                    
                    #Then check if anywhere the dimensions of the layer are wrong
                    #Check if we have the correct nr of dimensions
                    CurrentLayer = napariViewer.layers[liveImageLayer[0]]
                    if CurrentLayer.ndim != len(uniqueEntriesAllDims)+2: #Note: +2 for image xy
                        correctDimensions = False
                    else:
                        layerData = CurrentLayer.data
                        #Check each dimension as follows:
                        for dim_id in range(0,len(uniqueEntriesAllDims)):
                            #Check if it has the correct label
                            # logging.debug(f&#39;axis_labels: {napariViewer.dims.axis_labels[dim_id]} vs {dimensionOrder[dim_id]}&#39;)
                            # if napariViewer.dims.axis_labels[dim_id] != dimensionOrder[dim_id]:
                            #     correctDimensions = False
                            #     break
                            #Check it has the correct length:
                            logging.debug(f&#39;range: {layerData.shape[dim_id]} vs {n_entries_in_dims[dim_id]}&#39;)
                            if int(layerData.shape[dim_id]) != n_entries_in_dims[dim_id]:
                                correctDimensions = False
                                break
                            
                    #Remove the layer if the dimensions are wrong
                    if correctDimensions == False:
                        logging.debug(&#39;removing mdaZarrData - looping over layers&#39;)
                        #Remove the mdaZarrData array and ensure that we create a new layer
                        for tLayerIndex in range(0,len(napariViewer.layers)):
                            tLayer = napariViewer.layers[tLayerIndex]
                            logging.debug(f&#39;layer: {tLayer}, comparing with {napariViewer.layers[liveImageLayer[0]].name}, boolTest {str(tLayer) == str(napariViewer.layers[liveImageLayer[0]].name)}&#39;)
                            if str(tLayer) == str(napariViewer.layers[liveImageLayer[0]].name):
                                #If we found the layer, delete it, and ensure we create a new one
                                logging.debug(f&#39;found layer to remove: {tLayer} at {tLayerIndex}&#39;)
                                napariViewer.layers.pop(tLayerIndex)
                                shared_data.mdaZarrData[layerName] = None
                                liveImageLayer = False
                                break
        
            #If it&#39;s the first layer
            if not liveImageLayer:
                if layerName != &#39;Live&#39;:
                    logging.debug(f&#39;creating layer with name {layerName} via multiDstack method&#39;)
                    dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
                    logging.debug(f&#34;obtained dimensions: {dimensionOrder} and n_entries_in_dims: {n_entries_in_dims}&#34;)
                    
                    shape = n_entries_in_dims
                    shared_data.mdaZarrData[layerName] = zarr.open(
                            str(tempfile.TemporaryDirectory().name),
                            shape = shape+[latestImage.shape[0],latestImage.shape[1]],
                            chunks = tuple([1] * len(shape) + [latestImage.shape[0],liveImage.shape[1]]),
                            )
                    #Changing the first image to the latest acquired image
                    shared_data.mdaZarrData[layerName][(0,) * len(shape) + (slice(None),slice(None))] = latestImage
                    shared_data.allMDAslicesRendered = {}
                    
                    layer = napariViewer.add_image(shared_data.mdaZarrData[layerName], colormap=DataStructure[&#39;layer_color_map&#39;],name = layerName)
                    #Set correct scale - in nm
                    layer.scale = [core.get_pixel_size_um(),core.get_pixel_size_um()] #type:ignore
                    layer._keep_auto_contrast = True #type:ignore
                    
                    for dim_id in range(len(n_entries_in_dims)):
                        napariViewer.dims.set_axis_label(dim_id, dimensionOrder[dim_id])
                    #Move to the front of the layers
                    # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
                    napariViewer.reset_view()
                    
                    #set the napariViewer to the correct slices:
                    for dim_id in range(len(n_entries_in_dims)):
                        napariViewer.dims.set_current_step(dim_id,0)
                else:
                    nrLayersBefore = len(napariViewer.layers)
                    layer = napariViewer.add_image(latestImage, colormap=DataStructure[&#39;layer_color_map&#39;],name = layerName)
                    #Set correct scale - in nm
                    layer.scale = [core.get_pixel_size_um(),core.get_pixel_size_um()] #type:ignore
                    layer._keep_auto_contrast = True #type:ignore
                    #Move to the front of the layers
                    # napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
                    napariViewer.reset_view()
            #Else if the layer already exists, replace it!
            else:
                if layerName != &#39;Live&#39;:
                    # logging.debug(f&#39;updating layer with name {layerName} via multiDstack method&#39;)
                    dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
                    
                    #Determine in which multi-D slice the image should be added:
                    sliceTuple = ()
                    for dim_id in range(len(n_entries_in_dims)):
                        currentSlice = metadata[&#39;Axes&#39;][dimensionOrder[dim_id]]
                        currentSliceID = uniqueEntriesAllDims[dimensionOrder[dim_id]].tolist().index(currentSlice)
                        logging.debug(f&#34;currentSlice[{dim_id}]: {currentSliceID}&#34;)
                        sliceTuple += (int(currentSliceID),)
                        
                    shared_data.mdaZarrData[layerName][sliceTuple + (slice(None),slice(None))] = liveImage #type:ignore
                    
                    #set the napariViewer to the correct slice:
                    for dim_id in range(len(n_entries_in_dims)):
                        currentSlice = metadata[&#39;Axes&#39;][dimensionOrder[dim_id]]
                        currentSliceID = uniqueEntriesAllDims[dimensionOrder[dim_id]].tolist().index(currentSlice)
                        napariViewer.dims.set_current_step(dim_id,int(currentSliceID))
                    
                    #Store exactly which axes is rendered
                    shared_data.allMDAslicesRendered[len(shared_data.allMDAslicesRendered)] = metadata[&#39;Axes&#39;]
                else:
                    # layer is present, replace its data
                    layer = napariViewer.layers[liveImageLayer[0]]
                    #Also move to top
                    napariViewer.layers.move_multiple([liveImageLayer[0]],len(napariViewer.layers))
                    layer.data = liveImage
                    
        elif DataStructure[&#39;finalisationProcedure&#39;] == True:
            #Render the missing images in the MDA acquisition
            shared_data._busy = True
            renderedSlices = shared_data.allMDAslicesRendered
            dimensionOrder, n_entries_in_dims, uniqueEntriesAllDims = utils.getDimensionsFromAcqData(shared_data._mdaModeParams)
            for expectedEntry in shared_data._mdaModeParams:
                #check in the rendered sclies if this is in there:
                entry_found = any(expectedEntry[&#39;axes&#39;].items() &lt;= item.items() for item in renderedSlices.values())
                if not entry_found:
                    time.sleep(0.001) #Can&#39;t explain why, but a sleep of 1 ms is super important for stability
                    
                    #Figure out which slice to read
                    readChannel = None
                    readZ = None
                    readTime = None
                    readPosition = None
                    readRow = None
                    readColumn = None
                    for key, value in expectedEntry[&#39;axes&#39;].items():
                        if key == &#39;channel&#39;:
                            readChannel = value
                        if key == &#39;z&#39;:
                            readZ = value
                        if key == &#39;time&#39;:
                            readTime = value
                        if key == &#39;position&#39;:
                            readPosition = value
                        if key == &#39;row&#39;:
                            readRow = value
                        if key == &#39;column&#39;:
                            readColumn = value
                    #Read this slice from the NDDataset:
                    try:
                        # logging.debug(shared_data._mdaModeAcqData._dataset)
                        # logging.debug(f&#34;Attempting reading slice at: {readChannel}, {readZ}, {readTime}, {readPosition}, {readRow}, {readColumn}&#34;)
                        sliceImage = shared_data._mdaModeAcqData._dataset.read_image(channel=readChannel,z=readZ,time=readTime,position=readPosition,row=readRow,column=readColumn)
                        # logging.debug(f&#34;sliceImage: {sliceImage}&#34;)
                        
                        #Find the correct slice to slot it in
                        sliceTuple = ()
                        for dim_id in range(len(n_entries_in_dims)):
                            currentSlice = expectedEntry[&#39;axes&#39;][dimensionOrder[dim_id]]
                            currentSliceID = uniqueEntriesAllDims[dimensionOrder[dim_id]].tolist().index(currentSlice)
                            sliceTuple += (int(currentSliceID),)
                        #Put it in
                        shared_data.mdaZarrData[layerName][sliceTuple + (slice(None),slice(None))] = sliceImage 
                        logging.debug(f&#34;Added entry {expectedEntry} not rendered in the MDA acquisition&#34;)
                    except:
                        logging.debug(f&#39;Entry {expectedEntry} tried, but not acquired&#39;)
            
            logging.debug(&#39;Finalised up visualisation...&#39;)
            #Move to the end
            # napariViewer.dims.set_point(0,timeslice)
            shared_data._busy = False</code></pre>
</details>
</dd>
<dt id="napariGlados.runNapariPycroManager"><code class="name flex">
<span>def <span class="ident">runNapariPycroManager</span></span>(<span>score, sMM_JSON, sshared_data, includecustomUI=False, include_flowChart_automatedMicroscopy=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runNapariPycroManager(score,sMM_JSON,sshared_data,includecustomUI = False,include_flowChart_automatedMicroscopy = True):
    #Go from self to global variables
    global core, MM_JSON, livestate, napariViewer, shared_data
    core = score
    MM_JSON = sMM_JSON
    livestate = False
    shared_data = sshared_data
    
    #Get some info from core to put in shared_data
    shared_data._defaultFocusDevice = core.get_focus_device()
    logging.debug(f&#34;Default focus device set to {shared_data._defaultFocusDevice}&#34;)

    #Napari start
    napariViewer = napari.Viewer()
    #Add a connect event if a layer is removed - to stop background processes
    napariViewer.layers.events.removing.connect(lambda event: layer_removed_event_callback(event,shared_data))
    shared_data.napariViewer = napariViewer
    
    # create_analysis_thread(shared_data,analysisInfo=&#39;LiveModeVisualisation&#39;,createNewThread=False,throughputThread=shared_data._livemodeNapariHandler.image_queue_analysis)
    # create_analysis_thread(shared_data,analysisInfo=&#39;mdaVisualisation&#39;,createNewThread=False,throughputThread=shared_data._mdamodeNapariHandler.image_queue_analysis)
    logging.debug(&#34;Live mode pseudo-analysis thread created&#34;)
    
    #Set some common things for the UI (scale bar on and such)
    InitateNapariUI(napariViewer)
    
    #Add widgets as wanted
    # custom_widget_analysisThreads = dockWidget_analysisThreads()
    # napariViewer.window.add_dock_widget(custom_widget_analysisThreads, area=&#34;top&#34;, name=&#34;Real-time analysis&#34;,tabify=True)
    
    logging.debug(&#39;In runNapariPycroManager&#39;)
    
    custom_widget_MMcontrols = dockWidget_MMcontrol()
    napariViewer.window.add_dock_widget(custom_widget_MMcontrols, area=&#34;top&#34;, name=&#34;Controls&#34;,tabify=True)
    
    custom_widget_MDA = dockWidget_MDA()
    napariViewer.window.add_dock_widget(custom_widget_MDA, area=&#34;top&#34;, name=&#34;Multi-D acquisition&#34;,tabify=True)
    
    if include_flowChart_automatedMicroscopy:
        custom_widget_flowChart = dockWidget_flowChart()
        napariViewer.window.add_dock_widget(custom_widget_flowChart, area=&#34;top&#34;, name=&#34;Autonomous microscopy&#34;,tabify=True)
        custom_widget_flowChart.dockWidget.focus()
    
    if includecustomUI:
        gladosLaserInfo = dockWidget_fullGladosUI()
        napariViewer.window.add_dock_widget(gladosLaserInfo, area=&#34;right&#34;, name=&#34;GladosUI&#34;)

    returnInfo = {}
    returnInfo[&#39;napariViewer&#39;] = napariViewer
    returnInfo[&#39;MMcontrolWidget&#39;] = custom_widget_MMcontrols.getDockWidget()
    
    # breakpoint
    return returnInfo</code></pre>
</details>
</dd>
<dt id="napariGlados.startLiveModeVisualisation"><code class="name flex">
<span>def <span class="ident">startLiveModeVisualisation</span></span>(<span>shared_data, layerName='Live')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startLiveModeVisualisation(shared_data,layerName=&#39;Live&#39;):
    create_analysis_thread(shared_data,analysisInfo=&#39;LiveModeVisualisation&#39;,createNewThread=False,throughputThread=shared_data._livemodeNapariHandler.image_queue_analysis)
    shared_data._livemodeNapariHandler.run_napariVisualisation_worker(shared_data._livemodeNapariHandler,layerName = layerName)</code></pre>
</details>
</dd>
<dt id="napariGlados.startMDAVisualisation"><code class="name flex">
<span>def <span class="ident">startMDAVisualisation</span></span>(<span>shared_data, layerName='MDA', layerColorMap='gray')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startMDAVisualisation(shared_data,layerName=&#39;MDA&#39;,layerColorMap=&#39;gray&#39;):
    #Set the latest layer name to be the layer name
    shared_data.newestLayerName = layerName
    #Create an analysis thread which runs this MDA visualisation
    create_analysis_thread(shared_data,analysisInfo=&#39;mdaVisualisation&#39;,createNewThread=False,throughputThread=shared_data._mdamodeNapariHandler.image_queue_analysis)
    shared_data._mdamodeNapariHandler.run_napariVisualisation_worker(shared_data._mdamodeNapariHandler,layerName = layerName,layerColorMap=layerColorMap)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="napariGlados.dockWidget_MDA"><code class="flex name class">
<span>class <span class="ident">dockWidget_MDA</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dockWidget_MDA(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_MDA started&#34;)
        super().__init__()
        
        #load from appdata
        appdata_folder = os.getenv(&#39;APPDATA&#39;)
        if appdata_folder is None:
            raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
        os.makedirs(app_specific_folder, exist_ok=True)
        if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
            #Load the mda state
            with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
                gladosInfo = json.load(file)
                mdaInfo = gladosInfo[&#39;MDA&#39;]
            
            try:
                #Add the full micro manager controls UI
                self.dockWidget = MDAGlados(core,MM_JSON,self.layout,shared_data,
                            hasGUI=True,
                            num_time_points = mdaInfo[&#39;num_time_points&#39;], 
                            time_interval_s = mdaInfo[&#39;time_interval_s&#39;], 
                            time_interval_s_or_ms = mdaInfo[&#39;time_interval_s_or_ms&#39;],
                            z_start = mdaInfo[&#39;z_start&#39;],
                            z_end = mdaInfo[&#39;z_end&#39;],
                            z_step = mdaInfo[&#39;z_step&#39;],
                            z_stage_sel = mdaInfo[&#39;z_stage_sel&#39;],
                            z_nr_steps = mdaInfo[&#39;z_nr_steps&#39;],
                            z_step_distance = mdaInfo[&#39;z_step_distance&#39;],
                            z_nrsteps_radio_sel = mdaInfo[&#39;z_nrsteps_radio_sel&#39;],
                            z_stepdistance_radio_sel = mdaInfo[&#39;z_stepdistance_radio_sel&#39;],
                            channel_group = mdaInfo[&#39;channel_group&#39;],
                            channels = mdaInfo[&#39;channels&#39;],
                            channel_exposures_ms = mdaInfo[&#39;channel_exposures_ms&#39;],
                            xy_positions = mdaInfo[&#39;xy_positions&#39;],
                            xyz_positions = mdaInfo[&#39;xyz_positions&#39;],
                            position_labels = mdaInfo[&#39;position_labels&#39;],
                            exposure_ms = mdaInfo[&#39;exposure_ms&#39;],
                            exposure_s_or_ms = mdaInfo[&#39;exposure_s_or_ms&#39;],
                            storage_folder = mdaInfo[&#39;storage_folder&#39;],
                            storage_file_name = mdaInfo[&#39;storage_file_name&#39;],
                            order = mdaInfo[&#39;order&#39;],
                            GUI_show_exposure = mdaInfo[&#39;GUI_show_exposure&#39;], 
                            GUI_show_xy = mdaInfo[&#39;GUI_show_xy&#39;], 
                            GUI_show_z = mdaInfo[&#39;GUI_show_z&#39;], 
                            GUI_show_channel = mdaInfo[&#39;GUI_show_channel&#39;], 
                            GUI_show_time = mdaInfo[&#39;GUI_show_time&#39;], 
                            GUI_show_order = mdaInfo[&#39;GUI_show_order&#39;], 
                            GUI_show_storage = mdaInfo[&#39;GUI_show_storage&#39;], 
                            GUI_xy_pos_fullInfo = mdaInfo[&#39;xy_positions_saveInfo&#39;],
                            GUI_acquire_button = True,
                            autoSaveLoad=True).getGui()
            except KeyError:
                #Add the full micro manager controls UI
                self.dockWidget = MDAGlados(core,MM_JSON,self.layout,shared_data,
                            hasGUI=True,
                            GUI_acquire_button = True,
                            autoSaveLoad=True).getGui()
        else: #If no MDA state is yet saved, open a new MDAGlados from scratch
            #Add the full micro manager controls UI
            self.dockWidget = MDAGlados(core,MM_JSON,self.layout,shared_data,
                        hasGUI=True,
                        GUI_acquire_button = True,
                        autoSaveLoad=True).getGui()
            
        self.sizeChanged.connect(self.dockWidget.handleSizeChange)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></li>
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></b></code>:
<ul class="hlist">
<li><code><a title="napariGlados.dockWidgets.resizeEvent" href="#napariGlados.dockWidgets.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="napariGlados.dockWidgets.sizeChanged" href="#napariGlados.dockWidgets.sizeChanged">sizeChanged</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="napariGlados.dockWidget_MMcontrol"><code class="flex name class">
<span>class <span class="ident">dockWidget_MMcontrol</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dockWidget_MMcontrol(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_MMcontrol started&#34;)
        super().__init__()
        #Add the full micro manager controls UI
        self.dockWidget = microManagerControlsUI(core,MM_JSON,self.layout,shared_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></li>
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></b></code>:
<ul class="hlist">
<li><code><a title="napariGlados.dockWidgets.resizeEvent" href="#napariGlados.dockWidgets.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="napariGlados.dockWidgets.sizeChanged" href="#napariGlados.dockWidgets.sizeChanged">sizeChanged</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="napariGlados.dockWidget_flowChart"><code class="flex name class">
<span>class <span class="ident">dockWidget_flowChart</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dockWidget_flowChart(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_flowchart started&#34;)
        super().__init__()
        
        #Add the full micro manager controls UI
        self.dockWidget = flowChart_dockWidgets(core,MM_JSON,self.layout,shared_data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></li>
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></b></code>:
<ul class="hlist">
<li><code><a title="napariGlados.dockWidgets.resizeEvent" href="#napariGlados.dockWidgets.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="napariGlados.dockWidgets.sizeChanged" href="#napariGlados.dockWidgets.sizeChanged">sizeChanged</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="napariGlados.dockWidget_fullGladosUI"><code class="flex name class">
<span>class <span class="ident">dockWidget_fullGladosUI</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dockWidget_fullGladosUI(dockWidgets):
    def __init__(self): 
        logging.debug(&#34;dockWidget_fullGladosUI started&#34;)
        super().__init__()
        # #new QWidget:
        tempWidget = QMainWindow()
        
        
        
    
    
        
        ui = Ui_CustomDockWidget()
        ui.setupUi(tempWidget)
        #Open JSON file with MM settings
        MM_JSON_path = os.path.join(sys.path[0], &#39;MM_PycroManager_JSON.json&#39;)
        # with open(os.path.join(sys.path[0], &#39;MM_PycroManager_JSON.json&#39;), &#39;r&#39;) as f:
        with open(MM_JSON_path) as f:
            MM_JSON = json.load(f)
            
        runlaserControllerUI(core,MM_JSON,ui,shared_data)
        #Run the laserController UI
        logging.debug(&#34;dockWidget_fullGladosUI halfway&#34;)
        
        #
        #Create a Vertical+horizontal layout:
        self.dockwidgetLayout = QGridLayout()
        #Create a layout for the configs:
        self.analysisLayout = QGridLayout()
        #Add this to the mainLayout:
        self.dockwidgetLayout.addLayout(self.analysisLayout,0,0)
        
        self.analysisLayout.addWidget(ui.centralwidget.children()[1].children()[0],1,1)
        
        self.dockWidget = self.layout.addLayout(self.dockwidgetLayout,0,0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></li>
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></b></code>:
<ul class="hlist">
<li><code><a title="napariGlados.dockWidgets.resizeEvent" href="#napariGlados.dockWidgets.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="napariGlados.dockWidgets.sizeChanged" href="#napariGlados.dockWidgets.sizeChanged">sizeChanged</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="napariGlados.dockWidgets"><code class="flex name class">
<span>class <span class="ident">dockWidgets</span></span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dockWidgets(QMainWindow):
    sizeChanged = pyqtSignal(QSize)
    
    def resizeEvent(self, event):
        super().resizeEvent(event)
        self.sizeChanged.emit(event.size())
        
    def __init__(self):
        logging.debug(&#39;dockwidget started&#39;)
        super().__init__()
        #Create all the widgets/layouts:
        self.central_widget = QWidget(self)
        self.central_layout = QVBoxLayout()
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.content_widget = QWidget()
        self.layout = QGridLayout() #type:ignore
        
        #Order them logically:
        self.content_widget.setLayout(self.layout)
        self.scroll_area.setWidget(self.content_widget)
        self.central_layout.addWidget(self.scroll_area)
        self.central_widget.setLayout(self.central_layout)
        self.setCentralWidget(self.central_widget)
        
        self.dockWidget = None

        #we end up with self.layout() that&#39;s changed by every indiv dockwidget
        
    def getDockWidget(self):
        return self.dockWidget</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="napariGlados.dockWidget_MDA" href="#napariGlados.dockWidget_MDA">dockWidget_MDA</a></li>
<li><a title="napariGlados.dockWidget_MMcontrol" href="#napariGlados.dockWidget_MMcontrol">dockWidget_MMcontrol</a></li>
<li><a title="napariGlados.dockWidget_flowChart" href="#napariGlados.dockWidget_flowChart">dockWidget_flowChart</a></li>
<li><a title="napariGlados.dockWidget_fullGladosUI" href="#napariGlados.dockWidget_fullGladosUI">dockWidget_fullGladosUI</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="napariGlados.dockWidgets.getDockWidget"><code class="name flex">
<span>def <span class="ident">getDockWidget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDockWidget(self):
    return self.dockWidget</code></pre>
</details>
</dd>
<dt id="napariGlados.dockWidgets.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>resizeEvent(self, a0: QResizeEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event):
    super().resizeEvent(event)
    self.sizeChanged.emit(event.size())</code></pre>
</details>
</dd>
<dt id="napariGlados.dockWidgets.sizeChanged"><code class="name flex">
<span>def <span class="ident">sizeChanged</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
</dl>
</dd>
<dt id="napariGlados.napariHandler"><code class="flex name class">
<span>class <span class="ident">napariHandler</span></span>
<span>(</span><span>shared_data, liveOrMda='live')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class napariHandler():
    def __init__(self, shared_data,liveOrMda=&#39;live&#39;) -&gt; None:
        self.shared_data = shared_data
        self.napariViewer = shared_data.napariViewer
        if liveOrMda == &#39;live&#39;:
            self.liveOrMda = &#39;live&#39;
            self.acqstate = shared_data.liveMode
        elif liveOrMda == &#39;mda&#39;:
            self.liveOrMda = &#39;mda&#39;
            self.acqstate = shared_data.mdaMode
        # Define a flag to control the continuous task
        self.stop_continuous_task = False
        # empty queue for (live) image data
        self.img_queue = queue.Queue()
        # Create a queue to pass image data between threads
        self.image_queue_analysis = queue.Queue()
        # Create a signal to communicate between threads
        self.mda_acq_done_signal = pyqtSignal(bool)

        #Sleep time to keep responsiveness
        self.sleep_time = 1/shared_data.globalData[&#39;VISUALISATION-FPS&#39;][&#39;value&#39;] #in sec
        self.layerName = &#39;newLayer&#39;

    def mdaacqdonefunction(self):
        logging.debug(&#39;mdaacqdonefunction called in napariHandler&#39;)
        self.shared_data.mdaacqdonefunction()
        
    def grab_image(self,image, metadata, event_queue):
        &#34;&#34;&#34; 
        Function that runs on every frame obtained in live mode and putis in the image queue
        
        Inputs: array image: image from micromanager
                metadata: metadata from micromanager
        &#34;&#34;&#34;
        if self.acqstate:
            if self.img_queue.qsize() &lt; 3:
                self.img_queue.put([image,metadata])
                
            #Loop over all queues in shared_data.liveImageQueues and also append the image there:
            for queue in self.shared_data.liveImageQueues:
                if queue.qsize() &lt; 2:
                    queue.put([image,metadata])
                        
            if self.image_queue_analysis.qsize() &lt; 3:
                self.image_queue_analysis.put([image,metadata])
            
        else:
            logging.info(&#39;Broke off live mode&#39;)
            event_queue.put(None)
            try:
                acq.abort()
                logging.debug(&#39;aborted acquisition&#39;)
            except:
                logging.debug(&#39;attemped to abort acq&#39;)
        
        return image, metadata
    
    
    def grab_image_savedfn(self,axes,dataset, event_queue):
        &#34;&#34;&#34; 
        Function that runs on every frame obtained in live mode and putis in the image queue
        
        Inputs: array image: image from micromanager
                metadata: metadata from micromanager
        &#34;&#34;&#34;
        if self.acqstate:
            #Check if there is any reason to read the image:
            reasonToReadImage = False
            if self.img_queue.qsize() &lt; 3:
                reasonToReadImage = True
            for queue in self.shared_data.liveImageQueues:
                if queue.qsize() &lt; 2:
                    reasonToReadImage = True
            if self.image_queue_analysis.qsize() &lt; 3:
                reasonToReadImage = True
            
            if reasonToReadImage:
                image = dataset.read_image(**axes)
                metadata = {}
                metadata[&#39;Axes&#39;]=axes
                logging.debug(f&#39;grab_image_savedfn called in napariHandler read image: {dataset}, axes: {axes}, metadata: {metadata}&#39;)
                if self.img_queue.qsize() &lt; 3:
                    self.img_queue.put([image,metadata])
                    
                #Loop over all queues in shared_data.liveImageQueues and also append the image there:
                for queue in self.shared_data.liveImageQueues:
                    if queue.qsize() &lt; 2:
                        queue.put([image,metadata])
                            
                if self.image_queue_analysis.qsize() &lt; 3:
                    self.image_queue_analysis.put([image,metadata])
            
        else:
            logging.info(&#39;Broke off live mode&#39;)
            event_queue.put(None)
            try:
                acq.abort()
                logging.debug(&#39;aborted acquisition&#39;)
            except:
                logging.debug(&#39;attemped to abort acq&#39;)
        
        # return image, metadata

    @thread_worker
    def run_pycroManagerAcquisition_worker(self,parent):
        &#34;&#34;&#34; 
        Worker which handles live mode on/off turning etc
        
        Inputs: img_queue (unused, but required)
        &#34;&#34;&#34;
        img_queue = parent.img_queue
        global acq
        # shared_data = self.shared_data
        logging.debug(&#39;in run_pycroManagerAcquisition_worker&#39;)
        #The idea of live mode is that we do a very very long acquisition (10k frames), and real-time show the images, and then abort the acquisition when we stop life.
        #The abortion is handled in grab_image_livemode
        if self.liveOrMda == &#39;live&#39;:
            while self.acqstate:
                if self.shared_data.mdaMode:
                    logging.error(&#39;LIVE NOT STARTED! MDA IS RUNNING&#39;)
                    self.shared_data.liveMode = False
                else:        
                    #JavaBackendAcquisition is an acquisition on a different thread to not block napari I believe
                    logging.debug(&#39;starting acq&#39;)
                    self.shared_data.allMDAslicesRendered = {}
                    #Already move the live layer to top
                    logging.debug(&#39;BMoved layer to top&#39;)
                    # moveLayerToTop(self.shared_data.napariViewer,&#34;Live&#34;)
                    with Acquisition(directory=&#39;./temp&#39;, name=&#39;LiveAcqShouldBeRemoved&#39;, show_display=False, image_saved_fn = self.grab_image_savedfn) as acq: #type:ignore
                        self.shared_data._mdaModeAcqData = acq
                        events = multi_d_acquisition_events(num_time_points=9999, time_interval_s=0)
                        acq.acquire(events)

                    logging.debug(&#39;After Acq Live&#39;)
            #Now we&#39;re after the livestate
            self.shared_data.core.stop_sequence_acquisition()
            self.shared_data.liveMode = False
            #We clean up, removing all LiveAcqShouldBeRemoved folders in /Temp:
            cleanUpTemporaryFiles(shared_data=self.shared_data)
        elif self.liveOrMda == &#39;mda&#39;:
            while self.acqstate:
                if self.shared_data.liveMode:
                    self.shared_data.liveMode = False
                    time.sleep(1)
                    
                #JavaBackendAcquisition is an acquisition on a different thread to not block napari I believe
                logging.debug(&#39;starting MDA acq - before JavaBackendAcquisition&#39;)
                savefolder = &#39;./temp&#39;
                savename = &#39;MdaAcqShouldBeRemoved&#39;
                if self.shared_data._mdaModeSaveLoc[0] != &#39;&#39;:
                    savefolder = self.shared_data._mdaModeSaveLoc[0]
                    
                    savefolderAdv = utils.nodz_evaluateAdv(savefolder,self.shared_data.nodzInstance)
                    if savefolderAdv != None:
                        savefolder = savefolderAdv
                    logging.debug(savefolder)
                    
                if self.shared_data._mdaModeSaveLoc[1] != &#39;&#39;:
                    savename = self.shared_data._mdaModeSaveLoc[1]
                    savenameAdv = utils.nodz_evaluateAdv(savename,self.shared_data.nodzInstance)
                    if savenameAdv != None:
                        savename = savenameAdv
                    logging.debug(savename)
                if self.shared_data._mdaModeNapariViewer != None:
                    napariViewer = self.shared_data._mdaModeNapariViewer
                    showdisplay = True
                else:
                    napariViewer = None
                    showdisplay = False
                    
                napariViewer = None
                showdisplay = False
                self.shared_data.allMDAslicesRendered = {}
                #Already move the layer to top
                # if self.shared_data.newestLayerName != &#39;&#39;:
                #     moveLayerToTop(self.shared_data.napariViewer,self.shared_data.newestLayerName)
                with Acquisition(directory=savefolder, name=savename, show_display=showdisplay, image_saved_fn = self.grab_image_savedfn,napari_viewer=napariViewer) as acq: #type:ignore
                    self.shared_data._mdaModeAcqData = acq
                    events = self.shared_data._mdaModeParams
                    acq.acquire(events)
                # with Acquisition(directory=savefolder, name=savename, show_display=showdisplay, image_process_fn = self.grab_image,napari_viewer=napariViewer) as acq: #type:ignore
                
                self.shared_data.mdaMode = False
                self.acqstate = False #End the MDA acq state
                self.shared_data.appendNewMDAdataset(acq.get_dataset())

            logging.debug(&#39;Stopping the acquisition from napariHandler&#39;)
            #Now we&#39;re after the acquisition
            self.shared_data.core.stop_sequence_acquisition()
            self.shared_data.mdaMode = False
            
            #Signal to all parents that the MDA acquisition is done - in the Nodz MDA, now we would trigger the MDA-based analysis for scoring or so
            parent.mdaacqdonefunction()
            
            #We clean up, removing all LiveAcqShouldBeRemoved folders in /Temp:
            cleanUpTemporaryFiles(shared_data=self.shared_data)
    
    
    @thread_worker(connect={&#39;yielded&#39;: napariUpdateAnalysisThreads})
    def run_analysis_worker(self,parent,layerName=&#39;Layer&#39;,layerColorMap=&#39;gray&#39;):
        &#34;&#34;&#34;
        Worker which handles the visualisation of the live mode queue
        Connected to display_napari function to update display 
        &#34;&#34;&#34;
        img_queue = parent.image_queue_analysis
        while self.acqstate:
            time.sleep(0)
            # get elements from queue while there is more than one element
            # playing it safe: I&#39;m always leaving one element in the queue
            while img_queue.qsize() &gt; 1:
                DataStructure = {}
                DataStructure[&#39;data&#39;] = img_queue.get(block = False)
                DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
                DataStructure[&#39;acqState&#39;] = self.acqstate
                DataStructure[&#39;core&#39;] = self.shared_data.core
                DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
                DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
                DataStructure[&#39;layer_name&#39;] = layerName
                DataStructure[&#39;layer_color_map&#39;] = layerColorMap
                DataStructure[&#39;finalisationProcedure&#39;] = False
                yield DataStructure

    
    @thread_worker(connect={&#39;yielded&#39;: napariUpdateLive})
    def run_napariVisualisation_worker(self,parent,layerName=&#39;Layer&#39;,layerColorMap=&#39;gray&#39;):
        &#34;&#34;&#34;
        Worker which handles the visualisation of the live mode queue
        Connected to display_napari function to update display 
        &#34;&#34;&#34;
        img_queue = parent.img_queue
        while self.acqstate:
            time.sleep(self.sleep_time)
            logging.debug(&#39;in while-loop in visualise_live_mode_worker, len of img_queue: &#39;+str(img_queue.qsize()))
            # get elements from queue while there is more than one element
            # playing it safe: I&#39;m always leaving one element in the queue
            while img_queue.qsize() &gt; 0:
                DataStructure = {}
                DataStructure[&#39;data&#39;] = img_queue.get()
                DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
                DataStructure[&#39;acqState&#39;] = self.acqstate
                DataStructure[&#39;core&#39;] = self.shared_data.core
                DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
                DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
                DataStructure[&#39;layer_name&#39;] = layerName
                DataStructure[&#39;layer_color_map&#39;] = layerColorMap
                DataStructure[&#39;finalisationProcedure&#39;] = False
                yield DataStructure
                # self.napariUpdateLive(img_queue.get(block=False))

        # read out last remaining element(s) after end of acquisition
        while img_queue.qsize() &gt; 0:
            DataStructure = {}
            DataStructure[&#39;data&#39;] = img_queue.get()
            DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
            DataStructure[&#39;acqState&#39;] = self.acqstate
            DataStructure[&#39;core&#39;] = self.shared_data.core
            DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
            DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
            DataStructure[&#39;layer_name&#39;] = layerName
            DataStructure[&#39;layer_color_map&#39;] = layerColorMap
            DataStructure[&#39;finalisationProcedure&#39;] = False
            yield DataStructure#img_queue.get(block = False)
            
        #Do the final N images
        if self.shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;multiDstack&#39;:
            if layerName == &#39;MDA&#39;:
                logging.debug(&#39;Finalising MDA visualisation...&#39;)
                DataStructure = {}
                DataStructure[&#39;data&#39;] = None
                DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
                DataStructure[&#39;acqState&#39;] = self.acqstate
                DataStructure[&#39;core&#39;] = self.shared_data.core
                DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
                DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
                DataStructure[&#39;layer_name&#39;] = layerName
                DataStructure[&#39;layer_color_map&#39;] = layerColorMap
                DataStructure[&#39;finalisationProcedure&#39;] = True
                napariUpdateLive(DataStructure)
        
        # shared_data.analysisThreads.remove(shared_data.lastMDAThread)
        # shared_data.lastMDAThread.destroy()
        # shared_data.lastMDAThread = None
        logging.debug(&#34;acquisition done&#34;)

    def acqModeChanged(self, newSharedData = None):
        &#34;&#34;&#34;
        General function which is called if live mode is changed or not. Generally called from sharedFunction - when self._liveMode is altered
        
        Is called, and shared_data.liveMode should be changed seperately from running this funciton
        &#34;&#34;&#34;
        logging.debug(&#39;acqModeChanged called from napariHandler&#39;)
        if newSharedData is not None:
            global napariViewer, shared_data, Core
            self.shared_data = newSharedData
            shared_data = self.shared_data
            napariViewer = self.shared_data.napariViewer
            core = self.shared_data.core
            
        if self.liveOrMda == &#39;live&#39;:
            #Hook the live mode into the scripts here
            if self.shared_data.liveMode == False:
                self.acqstate = False
                self.stop_continuous_task = True
                #Clear the image queue
                self.img_queue.queue.clear()
                logging.info(&#34;Live mode stopped&#34;)
            else:
                logging.debug(&#39;liveMode changed to TRUE&#39;)
                self.acqstate = True
                self.stop_continuous_task = False
                #Always start live-mode visualisation:
                napariGlados.startLiveModeVisualisation(self.shared_data)
                #Move layer to top - if it isn&#39;t created yet, it will fail
                moveLayerToTop(self.shared_data.napariViewer,&#34;Live&#34;)
                
                #Start the worker to run the pycromanager acquisition
                worker1 = self.run_pycroManagerAcquisition_worker(self) #type:ignore
                worker1.start() #type:ignore
                worker2 = self.run_analysis_worker(self) #type:ignore
                
                logging.info(&#34;Live mode started&#34;)
        elif self.liveOrMda == &#39;mda&#39;:
            #Hook the live mode into the scripts here
            if self.shared_data.mdaMode == False:
                self.acqstate = False
                self.stop_continuous_task = True
                #Clear the image queue
                self.img_queue.queue.clear()
                logging.info(&#34;MDA mode stopped from acqModeChanged&#34;)
                # self.mdaacqdonefunction()
            else:
                logging.debug(&#39;mdaMode changed to TRUE&#39;)
                self.acqstate = True
                self.stop_continuous_task = False
                #Move layer to top - if it isn&#39;t created yet, it will fail
                if self.shared_data.newestLayerName != &#39;&#39;:
                    moveLayerToTop(self.shared_data.napariViewer,self.shared_data.newestLayerName)
                #Start the two workers, one to run it, one to visualise it.
                worker1 = self.run_pycroManagerAcquisition_worker(self) #type:ignore
                # worker2 = self.run_napariVisualisation_worker(self) #type:ignore
                worker1.start() #type:ignore
                # worker2.start()
                logging.debug(&#34;MDA mode started from acqModeChanged&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="napariGlados.napariHandler_liveMode" href="#napariGlados.napariHandler_liveMode">napariHandler_liveMode</a></li>
<li><a title="napariGlados.napariHandler_mdaMode" href="#napariGlados.napariHandler_mdaMode">napariHandler_mdaMode</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="napariGlados.napariHandler.acqModeChanged"><code class="name flex">
<span>def <span class="ident">acqModeChanged</span></span>(<span>self, newSharedData=None)</span>
</code></dt>
<dd>
<div class="desc"><p>General function which is called if live mode is changed or not. Generally called from sharedFunction - when self._liveMode is altered</p>
<p>Is called, and shared_data.liveMode should be changed seperately from running this funciton</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acqModeChanged(self, newSharedData = None):
    &#34;&#34;&#34;
    General function which is called if live mode is changed or not. Generally called from sharedFunction - when self._liveMode is altered
    
    Is called, and shared_data.liveMode should be changed seperately from running this funciton
    &#34;&#34;&#34;
    logging.debug(&#39;acqModeChanged called from napariHandler&#39;)
    if newSharedData is not None:
        global napariViewer, shared_data, Core
        self.shared_data = newSharedData
        shared_data = self.shared_data
        napariViewer = self.shared_data.napariViewer
        core = self.shared_data.core
        
    if self.liveOrMda == &#39;live&#39;:
        #Hook the live mode into the scripts here
        if self.shared_data.liveMode == False:
            self.acqstate = False
            self.stop_continuous_task = True
            #Clear the image queue
            self.img_queue.queue.clear()
            logging.info(&#34;Live mode stopped&#34;)
        else:
            logging.debug(&#39;liveMode changed to TRUE&#39;)
            self.acqstate = True
            self.stop_continuous_task = False
            #Always start live-mode visualisation:
            napariGlados.startLiveModeVisualisation(self.shared_data)
            #Move layer to top - if it isn&#39;t created yet, it will fail
            moveLayerToTop(self.shared_data.napariViewer,&#34;Live&#34;)
            
            #Start the worker to run the pycromanager acquisition
            worker1 = self.run_pycroManagerAcquisition_worker(self) #type:ignore
            worker1.start() #type:ignore
            worker2 = self.run_analysis_worker(self) #type:ignore
            
            logging.info(&#34;Live mode started&#34;)
    elif self.liveOrMda == &#39;mda&#39;:
        #Hook the live mode into the scripts here
        if self.shared_data.mdaMode == False:
            self.acqstate = False
            self.stop_continuous_task = True
            #Clear the image queue
            self.img_queue.queue.clear()
            logging.info(&#34;MDA mode stopped from acqModeChanged&#34;)
            # self.mdaacqdonefunction()
        else:
            logging.debug(&#39;mdaMode changed to TRUE&#39;)
            self.acqstate = True
            self.stop_continuous_task = False
            #Move layer to top - if it isn&#39;t created yet, it will fail
            if self.shared_data.newestLayerName != &#39;&#39;:
                moveLayerToTop(self.shared_data.napariViewer,self.shared_data.newestLayerName)
            #Start the two workers, one to run it, one to visualise it.
            worker1 = self.run_pycroManagerAcquisition_worker(self) #type:ignore
            # worker2 = self.run_napariVisualisation_worker(self) #type:ignore
            worker1.start() #type:ignore
            # worker2.start()
            logging.debug(&#34;MDA mode started from acqModeChanged&#34;)</code></pre>
</details>
</dd>
<dt id="napariGlados.napariHandler.grab_image"><code class="name flex">
<span>def <span class="ident">grab_image</span></span>(<span>self, image, metadata, event_queue)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that runs on every frame obtained in live mode and putis in the image queue</p>
<p>Inputs: array image: image from micromanager
metadata: metadata from micromanager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grab_image(self,image, metadata, event_queue):
    &#34;&#34;&#34; 
    Function that runs on every frame obtained in live mode and putis in the image queue
    
    Inputs: array image: image from micromanager
            metadata: metadata from micromanager
    &#34;&#34;&#34;
    if self.acqstate:
        if self.img_queue.qsize() &lt; 3:
            self.img_queue.put([image,metadata])
            
        #Loop over all queues in shared_data.liveImageQueues and also append the image there:
        for queue in self.shared_data.liveImageQueues:
            if queue.qsize() &lt; 2:
                queue.put([image,metadata])
                    
        if self.image_queue_analysis.qsize() &lt; 3:
            self.image_queue_analysis.put([image,metadata])
        
    else:
        logging.info(&#39;Broke off live mode&#39;)
        event_queue.put(None)
        try:
            acq.abort()
            logging.debug(&#39;aborted acquisition&#39;)
        except:
            logging.debug(&#39;attemped to abort acq&#39;)
    
    return image, metadata</code></pre>
</details>
</dd>
<dt id="napariGlados.napariHandler.grab_image_savedfn"><code class="name flex">
<span>def <span class="ident">grab_image_savedfn</span></span>(<span>self, axes, dataset, event_queue)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that runs on every frame obtained in live mode and putis in the image queue</p>
<p>Inputs: array image: image from micromanager
metadata: metadata from micromanager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grab_image_savedfn(self,axes,dataset, event_queue):
    &#34;&#34;&#34; 
    Function that runs on every frame obtained in live mode and putis in the image queue
    
    Inputs: array image: image from micromanager
            metadata: metadata from micromanager
    &#34;&#34;&#34;
    if self.acqstate:
        #Check if there is any reason to read the image:
        reasonToReadImage = False
        if self.img_queue.qsize() &lt; 3:
            reasonToReadImage = True
        for queue in self.shared_data.liveImageQueues:
            if queue.qsize() &lt; 2:
                reasonToReadImage = True
        if self.image_queue_analysis.qsize() &lt; 3:
            reasonToReadImage = True
        
        if reasonToReadImage:
            image = dataset.read_image(**axes)
            metadata = {}
            metadata[&#39;Axes&#39;]=axes
            logging.debug(f&#39;grab_image_savedfn called in napariHandler read image: {dataset}, axes: {axes}, metadata: {metadata}&#39;)
            if self.img_queue.qsize() &lt; 3:
                self.img_queue.put([image,metadata])
                
            #Loop over all queues in shared_data.liveImageQueues and also append the image there:
            for queue in self.shared_data.liveImageQueues:
                if queue.qsize() &lt; 2:
                    queue.put([image,metadata])
                        
            if self.image_queue_analysis.qsize() &lt; 3:
                self.image_queue_analysis.put([image,metadata])
        
    else:
        logging.info(&#39;Broke off live mode&#39;)
        event_queue.put(None)
        try:
            acq.abort()
            logging.debug(&#39;aborted acquisition&#39;)
        except:
            logging.debug(&#39;attemped to abort acq&#39;)
    
    # return image, metadata</code></pre>
</details>
</dd>
<dt id="napariGlados.napariHandler.mdaacqdonefunction"><code class="name flex">
<span>def <span class="ident">mdaacqdonefunction</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mdaacqdonefunction(self):
    logging.debug(&#39;mdaacqdonefunction called in napariHandler&#39;)
    self.shared_data.mdaacqdonefunction()</code></pre>
</details>
</dd>
<dt id="napariGlados.napariHandler.run_analysis_worker"><code class="name flex">
<span>def <span class="ident">run_analysis_worker</span></span>(<span>self, parent, layerName='Layer', layerColorMap='gray')</span>
</code></dt>
<dd>
<div class="desc"><p>Worker which handles the visualisation of the live mode queue
Connected to display_napari function to update display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@thread_worker(connect={&#39;yielded&#39;: napariUpdateAnalysisThreads})
def run_analysis_worker(self,parent,layerName=&#39;Layer&#39;,layerColorMap=&#39;gray&#39;):
    &#34;&#34;&#34;
    Worker which handles the visualisation of the live mode queue
    Connected to display_napari function to update display 
    &#34;&#34;&#34;
    img_queue = parent.image_queue_analysis
    while self.acqstate:
        time.sleep(0)
        # get elements from queue while there is more than one element
        # playing it safe: I&#39;m always leaving one element in the queue
        while img_queue.qsize() &gt; 1:
            DataStructure = {}
            DataStructure[&#39;data&#39;] = img_queue.get(block = False)
            DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
            DataStructure[&#39;acqState&#39;] = self.acqstate
            DataStructure[&#39;core&#39;] = self.shared_data.core
            DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
            DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
            DataStructure[&#39;layer_name&#39;] = layerName
            DataStructure[&#39;layer_color_map&#39;] = layerColorMap
            DataStructure[&#39;finalisationProcedure&#39;] = False
            yield DataStructure</code></pre>
</details>
</dd>
<dt id="napariGlados.napariHandler.run_napariVisualisation_worker"><code class="name flex">
<span>def <span class="ident">run_napariVisualisation_worker</span></span>(<span>self, parent, layerName='Layer', layerColorMap='gray')</span>
</code></dt>
<dd>
<div class="desc"><p>Worker which handles the visualisation of the live mode queue
Connected to display_napari function to update display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@thread_worker(connect={&#39;yielded&#39;: napariUpdateLive})
def run_napariVisualisation_worker(self,parent,layerName=&#39;Layer&#39;,layerColorMap=&#39;gray&#39;):
    &#34;&#34;&#34;
    Worker which handles the visualisation of the live mode queue
    Connected to display_napari function to update display 
    &#34;&#34;&#34;
    img_queue = parent.img_queue
    while self.acqstate:
        time.sleep(self.sleep_time)
        logging.debug(&#39;in while-loop in visualise_live_mode_worker, len of img_queue: &#39;+str(img_queue.qsize()))
        # get elements from queue while there is more than one element
        # playing it safe: I&#39;m always leaving one element in the queue
        while img_queue.qsize() &gt; 0:
            DataStructure = {}
            DataStructure[&#39;data&#39;] = img_queue.get()
            DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
            DataStructure[&#39;acqState&#39;] = self.acqstate
            DataStructure[&#39;core&#39;] = self.shared_data.core
            DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
            DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
            DataStructure[&#39;layer_name&#39;] = layerName
            DataStructure[&#39;layer_color_map&#39;] = layerColorMap
            DataStructure[&#39;finalisationProcedure&#39;] = False
            yield DataStructure
            # self.napariUpdateLive(img_queue.get(block=False))

    # read out last remaining element(s) after end of acquisition
    while img_queue.qsize() &gt; 0:
        DataStructure = {}
        DataStructure[&#39;data&#39;] = img_queue.get()
        DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
        DataStructure[&#39;acqState&#39;] = self.acqstate
        DataStructure[&#39;core&#39;] = self.shared_data.core
        DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
        DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
        DataStructure[&#39;layer_name&#39;] = layerName
        DataStructure[&#39;layer_color_map&#39;] = layerColorMap
        DataStructure[&#39;finalisationProcedure&#39;] = False
        yield DataStructure#img_queue.get(block = False)
        
    #Do the final N images
    if self.shared_data.globalData[&#39;MDAVISMETHOD&#39;][&#39;value&#39;] == &#39;multiDstack&#39;:
        if layerName == &#39;MDA&#39;:
            logging.debug(&#39;Finalising MDA visualisation...&#39;)
            DataStructure = {}
            DataStructure[&#39;data&#39;] = None
            DataStructure[&#39;napariViewer&#39;] = self.shared_data.napariViewer
            DataStructure[&#39;acqState&#39;] = self.acqstate
            DataStructure[&#39;core&#39;] = self.shared_data.core
            DataStructure[&#39;image_queue_analysis&#39;] = self.image_queue_analysis
            DataStructure[&#39;analysisThreads&#39;] = self.shared_data.analysisThreads
            DataStructure[&#39;layer_name&#39;] = layerName
            DataStructure[&#39;layer_color_map&#39;] = layerColorMap
            DataStructure[&#39;finalisationProcedure&#39;] = True
            napariUpdateLive(DataStructure)
    
    # shared_data.analysisThreads.remove(shared_data.lastMDAThread)
    # shared_data.lastMDAThread.destroy()
    # shared_data.lastMDAThread = None
    logging.debug(&#34;acquisition done&#34;)</code></pre>
</details>
</dd>
<dt id="napariGlados.napariHandler.run_pycroManagerAcquisition_worker"><code class="name flex">
<span>def <span class="ident">run_pycroManagerAcquisition_worker</span></span>(<span>self, parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Worker which handles live mode on/off turning etc</p>
<p>Inputs: img_queue (unused, but required)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@thread_worker
def run_pycroManagerAcquisition_worker(self,parent):
    &#34;&#34;&#34; 
    Worker which handles live mode on/off turning etc
    
    Inputs: img_queue (unused, but required)
    &#34;&#34;&#34;
    img_queue = parent.img_queue
    global acq
    # shared_data = self.shared_data
    logging.debug(&#39;in run_pycroManagerAcquisition_worker&#39;)
    #The idea of live mode is that we do a very very long acquisition (10k frames), and real-time show the images, and then abort the acquisition when we stop life.
    #The abortion is handled in grab_image_livemode
    if self.liveOrMda == &#39;live&#39;:
        while self.acqstate:
            if self.shared_data.mdaMode:
                logging.error(&#39;LIVE NOT STARTED! MDA IS RUNNING&#39;)
                self.shared_data.liveMode = False
            else:        
                #JavaBackendAcquisition is an acquisition on a different thread to not block napari I believe
                logging.debug(&#39;starting acq&#39;)
                self.shared_data.allMDAslicesRendered = {}
                #Already move the live layer to top
                logging.debug(&#39;BMoved layer to top&#39;)
                # moveLayerToTop(self.shared_data.napariViewer,&#34;Live&#34;)
                with Acquisition(directory=&#39;./temp&#39;, name=&#39;LiveAcqShouldBeRemoved&#39;, show_display=False, image_saved_fn = self.grab_image_savedfn) as acq: #type:ignore
                    self.shared_data._mdaModeAcqData = acq
                    events = multi_d_acquisition_events(num_time_points=9999, time_interval_s=0)
                    acq.acquire(events)

                logging.debug(&#39;After Acq Live&#39;)
        #Now we&#39;re after the livestate
        self.shared_data.core.stop_sequence_acquisition()
        self.shared_data.liveMode = False
        #We clean up, removing all LiveAcqShouldBeRemoved folders in /Temp:
        cleanUpTemporaryFiles(shared_data=self.shared_data)
    elif self.liveOrMda == &#39;mda&#39;:
        while self.acqstate:
            if self.shared_data.liveMode:
                self.shared_data.liveMode = False
                time.sleep(1)
                
            #JavaBackendAcquisition is an acquisition on a different thread to not block napari I believe
            logging.debug(&#39;starting MDA acq - before JavaBackendAcquisition&#39;)
            savefolder = &#39;./temp&#39;
            savename = &#39;MdaAcqShouldBeRemoved&#39;
            if self.shared_data._mdaModeSaveLoc[0] != &#39;&#39;:
                savefolder = self.shared_data._mdaModeSaveLoc[0]
                
                savefolderAdv = utils.nodz_evaluateAdv(savefolder,self.shared_data.nodzInstance)
                if savefolderAdv != None:
                    savefolder = savefolderAdv
                logging.debug(savefolder)
                
            if self.shared_data._mdaModeSaveLoc[1] != &#39;&#39;:
                savename = self.shared_data._mdaModeSaveLoc[1]
                savenameAdv = utils.nodz_evaluateAdv(savename,self.shared_data.nodzInstance)
                if savenameAdv != None:
                    savename = savenameAdv
                logging.debug(savename)
            if self.shared_data._mdaModeNapariViewer != None:
                napariViewer = self.shared_data._mdaModeNapariViewer
                showdisplay = True
            else:
                napariViewer = None
                showdisplay = False
                
            napariViewer = None
            showdisplay = False
            self.shared_data.allMDAslicesRendered = {}
            #Already move the layer to top
            # if self.shared_data.newestLayerName != &#39;&#39;:
            #     moveLayerToTop(self.shared_data.napariViewer,self.shared_data.newestLayerName)
            with Acquisition(directory=savefolder, name=savename, show_display=showdisplay, image_saved_fn = self.grab_image_savedfn,napari_viewer=napariViewer) as acq: #type:ignore
                self.shared_data._mdaModeAcqData = acq
                events = self.shared_data._mdaModeParams
                acq.acquire(events)
            # with Acquisition(directory=savefolder, name=savename, show_display=showdisplay, image_process_fn = self.grab_image,napari_viewer=napariViewer) as acq: #type:ignore
            
            self.shared_data.mdaMode = False
            self.acqstate = False #End the MDA acq state
            self.shared_data.appendNewMDAdataset(acq.get_dataset())

        logging.debug(&#39;Stopping the acquisition from napariHandler&#39;)
        #Now we&#39;re after the acquisition
        self.shared_data.core.stop_sequence_acquisition()
        self.shared_data.mdaMode = False
        
        #Signal to all parents that the MDA acquisition is done - in the Nodz MDA, now we would trigger the MDA-based analysis for scoring or so
        parent.mdaacqdonefunction()
        
        #We clean up, removing all LiveAcqShouldBeRemoved folders in /Temp:
        cleanUpTemporaryFiles(shared_data=self.shared_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="napariGlados.napariHandler_liveMode"><code class="flex name class">
<span>class <span class="ident">napariHandler_liveMode</span></span>
<span>(</span><span>shared_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class napariHandler_liveMode(napariHandler):
    def __init__(self, shared_data) -&gt; None:
        super().__init__(shared_data, liveOrMda=&#39;live&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="napariGlados.napariHandler" href="#napariGlados.napariHandler">napariHandler</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="napariGlados.napariHandler" href="#napariGlados.napariHandler">napariHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="napariGlados.napariHandler.acqModeChanged" href="#napariGlados.napariHandler.acqModeChanged">acqModeChanged</a></code></li>
<li><code><a title="napariGlados.napariHandler.grab_image" href="#napariGlados.napariHandler.grab_image">grab_image</a></code></li>
<li><code><a title="napariGlados.napariHandler.grab_image_savedfn" href="#napariGlados.napariHandler.grab_image_savedfn">grab_image_savedfn</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_analysis_worker" href="#napariGlados.napariHandler.run_analysis_worker">run_analysis_worker</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_napariVisualisation_worker" href="#napariGlados.napariHandler.run_napariVisualisation_worker">run_napariVisualisation_worker</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_pycroManagerAcquisition_worker" href="#napariGlados.napariHandler.run_pycroManagerAcquisition_worker">run_pycroManagerAcquisition_worker</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="napariGlados.napariHandler_mdaMode"><code class="flex name class">
<span>class <span class="ident">napariHandler_mdaMode</span></span>
<span>(</span><span>shared_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class napariHandler_mdaMode(napariHandler):
    def __init__(self, shared_data) -&gt; None:
        super().__init__(shared_data, liveOrMda=&#39;mda&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="napariGlados.napariHandler" href="#napariGlados.napariHandler">napariHandler</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="napariGlados.napariHandler" href="#napariGlados.napariHandler">napariHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="napariGlados.napariHandler.acqModeChanged" href="#napariGlados.napariHandler.acqModeChanged">acqModeChanged</a></code></li>
<li><code><a title="napariGlados.napariHandler.grab_image" href="#napariGlados.napariHandler.grab_image">grab_image</a></code></li>
<li><code><a title="napariGlados.napariHandler.grab_image_savedfn" href="#napariGlados.napariHandler.grab_image_savedfn">grab_image_savedfn</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_analysis_worker" href="#napariGlados.napariHandler.run_analysis_worker">run_analysis_worker</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_napariVisualisation_worker" href="#napariGlados.napariHandler.run_napariVisualisation_worker">run_napariVisualisation_worker</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_pycroManagerAcquisition_worker" href="#napariGlados.napariHandler.run_pycroManagerAcquisition_worker">run_pycroManagerAcquisition_worker</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="napariGlados.layer_removed_event_callback" href="#napariGlados.layer_removed_event_callback">layer_removed_event_callback</a></code></li>
<li><code><a title="napariGlados.napariUpdateAnalysisThreads" href="#napariGlados.napariUpdateAnalysisThreads">napariUpdateAnalysisThreads</a></code></li>
<li><code><a title="napariGlados.napariUpdateLive" href="#napariGlados.napariUpdateLive">napariUpdateLive</a></code></li>
<li><code><a title="napariGlados.runNapariPycroManager" href="#napariGlados.runNapariPycroManager">runNapariPycroManager</a></code></li>
<li><code><a title="napariGlados.startLiveModeVisualisation" href="#napariGlados.startLiveModeVisualisation">startLiveModeVisualisation</a></code></li>
<li><code><a title="napariGlados.startMDAVisualisation" href="#napariGlados.startMDAVisualisation">startMDAVisualisation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="napariGlados.dockWidget_MDA" href="#napariGlados.dockWidget_MDA">dockWidget_MDA</a></code></h4>
</li>
<li>
<h4><code><a title="napariGlados.dockWidget_MMcontrol" href="#napariGlados.dockWidget_MMcontrol">dockWidget_MMcontrol</a></code></h4>
</li>
<li>
<h4><code><a title="napariGlados.dockWidget_flowChart" href="#napariGlados.dockWidget_flowChart">dockWidget_flowChart</a></code></h4>
</li>
<li>
<h4><code><a title="napariGlados.dockWidget_fullGladosUI" href="#napariGlados.dockWidget_fullGladosUI">dockWidget_fullGladosUI</a></code></h4>
</li>
<li>
<h4><code><a title="napariGlados.dockWidgets" href="#napariGlados.dockWidgets">dockWidgets</a></code></h4>
<ul class="">
<li><code><a title="napariGlados.dockWidgets.getDockWidget" href="#napariGlados.dockWidgets.getDockWidget">getDockWidget</a></code></li>
<li><code><a title="napariGlados.dockWidgets.resizeEvent" href="#napariGlados.dockWidgets.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="napariGlados.dockWidgets.sizeChanged" href="#napariGlados.dockWidgets.sizeChanged">sizeChanged</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="napariGlados.napariHandler" href="#napariGlados.napariHandler">napariHandler</a></code></h4>
<ul class="">
<li><code><a title="napariGlados.napariHandler.acqModeChanged" href="#napariGlados.napariHandler.acqModeChanged">acqModeChanged</a></code></li>
<li><code><a title="napariGlados.napariHandler.grab_image" href="#napariGlados.napariHandler.grab_image">grab_image</a></code></li>
<li><code><a title="napariGlados.napariHandler.grab_image_savedfn" href="#napariGlados.napariHandler.grab_image_savedfn">grab_image_savedfn</a></code></li>
<li><code><a title="napariGlados.napariHandler.mdaacqdonefunction" href="#napariGlados.napariHandler.mdaacqdonefunction">mdaacqdonefunction</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_analysis_worker" href="#napariGlados.napariHandler.run_analysis_worker">run_analysis_worker</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_napariVisualisation_worker" href="#napariGlados.napariHandler.run_napariVisualisation_worker">run_napariVisualisation_worker</a></code></li>
<li><code><a title="napariGlados.napariHandler.run_pycroManagerAcquisition_worker" href="#napariGlados.napariHandler.run_pycroManagerAcquisition_worker">run_pycroManagerAcquisition_worker</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="napariGlados.napariHandler_liveMode" href="#napariGlados.napariHandler_liveMode">napariHandler_liveMode</a></code></h4>
</li>
<li>
<h4><code><a title="napariGlados.napariHandler_mdaMode" href="#napariGlados.napariHandler_mdaMode">napariHandler_mdaMode</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>