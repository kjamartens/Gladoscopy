<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>AnalysisClass API documentation</title>
<meta name="description" content="Handles the GUI display of Glados-pycromanager, as well as the structure for analysis (normal and real-time) to run on secondary threads." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AnalysisClass</code></h1>
</header>
<section id="section-intro">
<p>Handles the GUI display of Glados-pycromanager, as well as the structure for analysis (normal and real-time) to run on secondary threads.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Handles the GUI display of Glados-pycromanager, as well as the structure for analysis (normal and real-time) to run on secondary threads.
&#34;&#34;&#34;

import numpy as np
from PyQt5.QtCore import pyqtSignal, QThread
import random
import napari
from napari.qt import thread_worker
import time
import queue
from PyQt5.QtWidgets import QMainWindow
from pycromanager import Core
from magicgui import magicgui
from qtpy.QtWidgets import QMainWindow, QVBoxLayout, QWidget
import sys
from napari.layers import Shapes
from typing import Union, Tuple, List
import logging
# from stardist.models import StarDist2D
from PIL import Image, ImageDraw

def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__

if is_pip_installed():
    from glados_pycromanager.GUI.custom_widget_ui import Ui_CustomDockWidget  # Import the generated UI module
    import glados_pycromanager.GUI.utils
    from glados_pycromanager.AutonomousMicroscopy.Analysis_Images import * #type: ignore
    from glados_pycromanager.AutonomousMicroscopy.Analysis_Measurements import * #type: ignore
    from glados_pycromanager.AutonomousMicroscopy.Analysis_Shapes import * #type: ignore
    from glados_pycromanager.AutonomousMicroscopy.CustomFunctions import * #type: ignore
    from glados_pycromanager.AutonomousMicroscopy.Real_Time_Analysis import * #type: ignore
else:
    from custom_widget_ui import Ui_CustomDockWidget  # Import the generated UI module
    import utils
    sys.path.append(&#39;AutonomousMicroscopy&#39;)
    sys.path.append(&#39;AutonomousMicroscopy/MainScripts&#39;)
    #Import all scripts in the custom script folders
    from Analysis_Images import * #type: ignore
    from Analysis_Measurements import * #type: ignore
    from Analysis_Shapes import * #type: ignore
    from CustomFunctions import * #type: ignore
    from Real_Time_Analysis import * #type: ignore

#Class for overlays and their update and such
class napariOverlay():
    def __init__(self,napariViewer,layer_name:Union[str,None]=&#39;new Layer&#39;,colormap=&#39;gray&#39;,opacity=1,visible=True,blending=&#39;translucent&#39;,layerType = None,RT_analysisObject=None):
        &#34;&#34;&#34;
        Initializes an instance of the class with the specified `napariViewer` and `layer_name`.

        Args:
            napariViewer (napari.Viewer): The napari viewer object.
            layer_name (Union[str, None], optional): The name of the layer. Defaults to &#39;new Layer&#39;.
            colormap (str, optional): The colormap to use. Defaults to &#39;gray&#39;.
            opacity (float, optional): The opacity of the layer. Defaults to 1.
            visible (bool, optional): Whether the layer is visible. Defaults to True.
            blending (str, optional): The blending mode. Defaults to &#39;opaque&#39;, options are {&#39;opaque&#39;, &#39;translucent&#39;, and &#39;additive&#39;}

        Returns:
            None
        &#34;&#34;&#34;
        self.napariViewer = napariViewer
        self.layer_name = layer_name
        self.colormap = colormap
        self.opacity = opacity
        self.visible = visible
        self.blending = blending
        self.RT_analysisObject = RT_analysisObject
        self.layerType = layerType
        try:
            self.layer_scale = napariViewer.layers[0].scale
        except:
            self.layer_scale = [1,1]
        
        #Get info from a RT analysis object (i.e. outside-based-analysis)
        if self.RT_analysisObject is not None:
            self.layer_name, self.layerType = self.RT_analysisObject.visualise_init()
            logging.debug(f&#34;Initialised napariOverlay with layer_name: {self.layer_name}, layerType: {self.layerType}&#34;)
            
        #Create the layer if layer_name is not none
        #layer_name is None if we only want to instantialise the napariOverlay but not get any shape
        if self.layer_name is not None:
            if self.layerType is not None:
                
                #check if a layer with this name already exists:
                if self.layer_name in napariViewer.layers:
                    self.layer = napariViewer.layers[self.layer_name]
                        
                else: #else create the layer
                    if self.layerType == &#39;image&#39;:
                        self.layer = napariViewer.add_image(name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;labels&#39;:
                        self.layer = napariViewer.add_labels([],name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;points&#39;:
                        self.layer = napariViewer.add_points(name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;shapes&#39;:
                        self.layer = napariViewer.add_shapes(name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;surface&#39;:
                        self.layer = napariViewer.add_surface([],name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;tracks&#39;:
                        self.layer = napariViewer.add_tracks([],name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;vectors&#39;:
                        self.layer = napariViewer.add_vectors(name=self.layer_name,scale=self.layer_scale)
            else: #Fallback if no layer type is specified at all
                self.layer = napariViewer.add_shapes(name=self.layer_name,scale=self.layer_scale)
        
            logging.debug(f&#34;Using layer {self.layer}&#34;)
        
    #Update the name of the overlay
    def changeName(self,new_name):
        &#34;&#34;&#34;
        Change the name of the napariOverlay

        Args:
            new_name (str): The new name for the napariOverlay.

        Returns:
            None
        &#34;&#34;&#34;
        self.layer_name = new_name
        self.layer.name = self.layer_name
        #Return the layer
        
    def getLayer(self):
        &#34;&#34;&#34;
        Returns the layer attribute of the object.

        Args:
            None

        Returns:
            layer (object or None): The layer attribute of the object if it exists, None otherwise.
        &#34;&#34;&#34;
        if hasattr(self, &#39;layer&#39;):
            return self.layer
        else:
            return None
        
    #Initialise drawing a text overly (single string of text)
    def drawTextOverlay_init(self):
        &#34;&#34;&#34;
        Initializes the text overlay for drawing text on the napari viewer.

        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        polygons = [np.array([[0, 0], [0, 1], [1, 1], [1, 0]])]
        # create properties
        properties = {&#39;value&#39;: [0]}
        text_properties = {&#39;text&#39;: &#39;{value:0.1f}&#39;,&#39;anchor&#39;: &#39;upper_left&#39;,&#39;translation&#39;: [-5, 0],&#39;size&#39;: 8,&#39;color&#39;: &#39;green&#39;,}
        #Remove old layer
        napariViewer.layers.remove(self.layer)
        # new layer with polygons and text
        self.layer = napariViewer.add_shapes(polygons,properties=properties,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;,text=text_properties,name=self.layer_name,scale=self.layer_scale,opacity = self.opacity,visible=self.visible)
    
    #Update routine for drawing a text overly (single string of text)
    def drawTextOverlay(self,text=&#39;&#39;,pos=[0,0],textCol=&#39;red&#39;,textSize=8):
        &#34;&#34;&#34;
        Running loop to draw/update the text overlay. Requires drawTextOverlay_init to be ran beforehand

        Args:
            text (str): The text to be displayed on the overlay. Defaults to an empty string.
            pos ([int of size (2,1)]): The position of the overlay on the image. Defaults to [0, 0].
            textCol (str): The color of the text. Defaults to &#39;red&#39;.
            textSize (int): The size of the text. Defaults to 8.

        Returns:
            None
        &#34;&#34;&#34;
        # Update the properties - this contains the text
        new_properties = {&#39;text&#39;: np.array([text]).astype(object)}
        self.layer.properties = new_properties
        #update the polygon - this contains the position
        pseudo_size = 0.1
        polygons = [np.array([[pos[0], pos[1]], [pos[0]+pseudo_size, pos[1]], [pos[0]+pseudo_size, pos[1]+pseudo_size], [pos[0], pos[1]+pseudo_size]])]
        #Remove the old polygon
        self.layer.data = []
        # add the new polygon
        self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;)
        #Update the text surrounding the invisible shape
        text_properties = {&#39;text&#39;: &#39;{text}&#39;,&#39;anchor&#39;: &#39;upper_left&#39;,&#39;translation&#39;: [0, 0],&#39;size&#39;: textSize,&#39;color&#39;: textCol}
        self.layer.text = text_properties
        
    #Initialise an overlay that only has shapes
    def shapesOverlay_init(self):
        &#34;&#34;&#34;
        Initialise an overlay that only draws shapes.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        #Initialise an overlay that only has shapes
        #Create a single shape (polygon) and show it
        polygons = [np.array([[225, 146], [283, 146], [283, 211], [225, 211]])]
        #Remove old layer
        self.napariViewer.layers.remove(self.layer)
        # new layer with polygons and text
        self.layer = self.napariViewer.add_shapes(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;,name=self.layer_name,scale=self.layer_scale,opacity = self.opacity,visible=self.visible)
    
    #Update routine for an overlay that only has shapes
    def drawSquaresOverlay(self,shapePosList = [[0,0,10,10]],shapeCol: List[Union[str, Tuple[float, float, float]]] = [&#39;black&#39;]):
        &#34;&#34;&#34;
        Running loop to draw/update and overlay with one or multiple rectangles. Requires shapesOverlay_init to be ran beforehand

        Args:
            shapePosList (List[List[int]]): A list of shape positions in the format [[x, y, w, h], [x, y, w, h], ...].
                Default is [[0, 0, 10, 10]].
            shapeCol (List[Union[str, Tuple[float, float, float]]]): A single entry or an array with the same size as shapePosList.
                Default is [&#39;black&#39;].

        Returns:
            None
        &#34;&#34;&#34;        
        #Update the shapes
        polygons = []
        for p in range(len(shapePosList)):
            polygons.append(np.array([[shapePosList[p][0], shapePosList[p][1]], [shapePosList[p][0]+shapePosList[p][2], shapePosList[p][1]], [shapePosList[p][0]+shapePosList[p][2], shapePosList[p][1]+shapePosList[p][3]], [shapePosList[p][0], shapePosList[p][1]+shapePosList[p][3]]]))
        #Remove the old polygon
        self.layer.data = []
        # add the new polygon
        if len(shapeCol) == 1:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol[0])
        else:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol)
    
    #Update routine for an overlay that only has shapes
    def drawShapesOverlay(self,shapePosList = [[0,0],[0,10],[10,10],[10,0]],shapeCol: List[Union[str, Tuple[float, float, float]]] = [&#39;black&#39;]):
        &#34;&#34;&#34;
        Running loop to draw arbitrary-shaped polygon shapes. Requires shapesOverlay_init to be ran beforehand

        Args:
            shapePosList (List[List[float]]): A list of shape positions. A [[x1-1,y1-1],[x1-2,y1-2],...],[[x2-1,y2-1],[x2-2,y2-2],...] array of size [n,2,m], drawing m shapes with n points each. Default is [[0,0],[0,10],[10,10],[10,0]].
            shapeCol (List[Union[str, Tuple[float, float, float]]]): A list of shape colors. Default is [&#39;black&#39;].

        Returns:
            None
        &#34;&#34;&#34;
        #Update the shapes
        polygons = []
        for p in range((shapePosList.shape[2])):
            polygons.append(shapePosList[:,:,p])
        #Remove the old polygon
        self.layer.data = []
        # add the new polygon
        if len(shapeCol) == 1:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol[0])
        else:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol)
    
    #Initialise an overlay that only shows an image
    def imageOverlay_init(self,opacity=None,visible=None,blending=None,colormap=None):
        &#34;&#34;&#34;
        Initialize a napari overlay that only draws an image

        Args:
            opacity (float, optional): The opacity of the layer. If None, the value will be taken from self.opacity.
            visible (bool, optional): Whether the layer is visible. If None, the value will be taken from self.visible.
            blending (str, optional): The blending mode. If None, the value will be taken from self.blending.
            colormap (str, optional): The colormap to use. If None, the value will be taken from self.colormap.
        
        Returns:
            None
        &#34;&#34;&#34;
        # Assign values from self if the corresponding argument is None
        self.opacity = self.opacity if opacity is None else opacity
        self.visible = self.visible if visible is None else visible
        self.blending = self.blending if blending is None else blending
        self.colormap = self.colormap if colormap is None else colormap
        #Load image
        im = np.random.random((300, 300))
        #Remove old layer
        self.napariViewer.layers.remove(self.layer)
        # new layer with polygons and text
        self.layer = self.napariViewer.add_image(im,scale=self.layer_scale,opacity = self.opacity,visible=self.visible,blending=self.blending,colormap=self.colormap)
        
    #Update an overlay that shows an image
    def drawImageOverlay(self,im=np.zeros((300,300))):
        &#34;&#34;&#34;
        Running loop to draw an image as napari overlay. Requires imageOverlay_init to be ran beforehand

        Parameters:
            im (numpy.ndarray): The image to be overlaid. Default is np.zeros((300, 300)).

        Returns:
            None
        &#34;&#34;&#34;
        #Remove the old image
        self.layer.data = np.ones(np.shape(self.layer.data))
        #Update the image
        self.layer.data = im
        
    def destroy(self):
        &#34;&#34;&#34;
        Deletes the instance of the class.
        &#34;&#34;&#34;
        del self

#This code gets some image and does some analysis on this
class AnalysisThread(QThread):
    # Define analysis_done_signal as a class attribute, shared among all instances of AnalysisThread class
    # Create a signal to communicate between threads
    analysis_done_signal = pyqtSignal(object)
    finished = pyqtSignal()# signal to indicate that the thread has finished
    def __init__(self,shared_data,analysisInfo: Union[str, None] = &#39;Random&#39;,visualisationInfo: Union[str, None] = &#39;Random&#39;,analysisQueue=None,sleepTimeMs=500):
        &#34;&#34;&#34;
        Initializes the AnalysisThread object.

        Args:
            shared_data: The shared data object. See Shared_data class for more information
            analysisInfo (Union[str, None]): Optional. The analysis &#39;title/method&#39;. Default is &#39;Random&#39;.
            visualisationInfo (Union[str, None]): Optional. The visualisation &#39;title/method&#39;. Default is &#39;Random&#39;.

        Returns:
        None
        &#34;&#34;&#34;
        super().__init__()      
        self.is_running = True
        self.analysis_ongoing = False
        self.shared_data = shared_data
        self.analysisInfo = analysisInfo
        self.visualisationInfo = visualisationInfo
        self.napariViewer = shared_data.napariViewer
        self.image_queue_analysis = analysisQueue
        self.sleepTimeMs = sleepTimeMs
        if self.analysisInfo == &#39;CellSegmentOverlay&#39;:
            storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDistModel&#39;
            # storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDist_hfx_20220823&#39;
            modelDirectory = storageloc.rsplit(&#39;/&#39;, 1)
            #Load the model - better to do this out of the loop for time reasons
            self.stardistModel = StarDist2D(None,name=modelDirectory[1],basedir=modelDirectory[0]+&#34;/&#34;) #type:ignore
        if analysisInfo == None:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        elif analysisInfo == &#39;LiveModeVisualisation&#39;:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        elif analysisInfo == &#39;mdaVisualisation&#39;:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        else:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=analysisInfo)
            #Create an empty overlay
            if visualisationInfo != None:
                #Activate layer
                self.initialise_napariLayer()
    
    def run(self):
        &#34;&#34;&#34;
        Runs the function in a loop as long as `self.is_running` is True.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        while not self.isInterruptionRequested():
            #Run analysis on the image from the queue
            # logging.debug(self.image_queue_analysis.get())
            self.analysis_result = self.runAnalysis(self.image_queue_analysis.get()) #type:ignore
            self.analysis_done_signal.emit(self.analysis_result)
            # self.finished.emit()
            if self.is_running == False:
                # self.finished.emit()
                return
        
        # Thread has finished, emit the finished signal
        self.finished.emit()
    
    def stop(self):
        &#34;&#34;&#34;
        Stops the execution of the function
        &#34;&#34;&#34;
        self.is_running = False
        #Also remove the image queue requestion from live mode
        if self.image_queue_analysis in self.shared_data.liveImageQueues:
            self.shared_data.liveImageQueues.remove(self.image_queue_analysis)
        elif self.image_queue_analysis in self.shared_data.mdaImageQueues:
            self.shared_data.mdaImageQueues.remove(self.image_queue_analysis)
    
    def destroy(self):
        &#34;&#34;&#34;
        Destroy the object.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        try:
            logging.debug(&#39;Destroying &#39;+str(self.analysisInfo))
        except:
            logging.debug(&#39;Destroying some analysis thread&#39;)
        #Wait for the thread to be finished
        self.stop()
        self.requestInterruption()
        self.quit()
        #Officially we&#39;d need to wait here, but that seems to start an infinite loop somewhere
        # self.wait()
        # self.deleteLater()
    
    #Get corresponding layer of napariOverlay
    def getLayer(self):
        &#34;&#34;&#34;
        Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread
        
        Args:
            None

        Returns:
            napari.layers.Layer: The layer associated with the napari overlay.
        &#34;&#34;&#34;
        return self.napariOverlay.getLayer()
    
    #Analysis is split into two parts: obtaining the analysis result and displaying this.
    #Here, we calculate the analysis result based on the analysisInfo
    def runAnalysis(self,data): 
        &#34;&#34;&#34;
        Runs the analysis on the given image based on the analysis information provided.

        Args:
            data, containing:
            image (Image): The image on which the analysis needs to be performed.
            metadata: corresponding metadata

        Returns:
            analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.

        Notes:
            - The layer should be open before running the analysis.
            - The analysisInfo parameter should be set before calling this function.
            - If analysisInfo is &#39;AvgGrayValueText&#39;, the analysisResult will be the result of calcAnalysisAvgGrayValue.
            - If analysisInfo is &#39;GrayValueOverlay&#39;, the analysisResult will be the result of calcGrayValueOverlay.
            - If analysisInfo is &#39;CellSegmentOverlay&#39;, the analysisResult will be the result of calcCellSegmentOverlay.
            - If analysisInfo is not set or is invalid, the analysisResult will be None.
        &#34;&#34;&#34;
        if data is not None:
            image = data[0]
            metadata = data[1]
            if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
                self.msleep(self.sleepTimeMs)
                #Do analysis here - the info in analysisResult will be passed to Visualise_Analysis_results
                if self.analysisInfo == &#39;AvgGrayValueText&#39;:
                    analysisResult = self.calcAnalysisAvgGrayValue(image,metadata=metadata)
                elif self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
                    analysisResult = self.changeStageAtFrame(image,metadata=metadata,core=self.shared_data.core,frame=500)
                elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
                    analysisResult = self.calcGrayValueOverlay(image,metadata=metadata)
                else:
                    analysisResult = None
                return [analysisResult,metadata]
            elif self.analysisInfo == &#39;LiveModeVisualisation&#39; or self.analysisInfo == &#39;mdaVisualisation&#39;:
                self.setPriority(self.HighestPriority) #type:ignore
                return None
            else:
                return None
        else:
            return None

    #And here we perform the visualisation - can be fully separate from performing the analysis
    #Initialisation is called upon creation
    def initialise_napariLayer(self):
        if self.visualisationInfo == &#39;AvgGrayValueText&#39;:
            self.initAvgGrayValueText()
        elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
            self.initGrayScaleImageOverlay()
        elif self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
            self.initChangeStageAtFrame()
        else:
            self.initRandomOverlay()
            
    #Update ir called every time the analysis is done
    def update_napariLayer(self,analysis_data):
        if analysis_data is not None:
            analysis_result = analysis_data[0]
            metadata = analysis_data[1]
            # logging.debug(analysis_result)
            if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
                if self.visualisationInfo == &#39;AvgGrayValueText&#39;:
                    self.visualiseAvgGrayValueText(analysis_result=analysis_result,metadata=metadata)
                elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
                    self.visualiseGrayScaleImageOverlay(analysis_result=analysis_result,metadata=metadata)
                # else:
                #     self.visualiseRandomOverlay()
    
    def outlineCoordinatesToImage(self,coords):
    # Create a blank grayscale image with a white background
        image = Image.new(&#34;L&#34;, (self.shared_data.core.get_roi().width,self.shared_data.core.get_roi().height), &#34;black&#34;)
        draw = ImageDraw.Draw(image)

        # Iterate over each n in N
        for n in range(coords.shape[0]):
            # Get the x and y coordinates for the current n
            x = coords[n, 0, :]
            y = coords[n, 1, :]

            # Create a list of (x, y) tuples for drawing the lines
            points = [(x[i], y[i]) for i in range(len(x))]

            # Draw the lines on the image
            draw.line(points, fill=&#34;white&#34;,width=2)  # Use black for the lines

        # Convert the image to grayscale mode (L)
        grayscale_image = image.convert(&#34;L&#34;)
        return np.fliplr(np.rot90(np.array(grayscale_image),k=3))
    
    &#34;&#34;&#34;
    Testing updating a stage during acq
    &#34;&#34;&#34;
    
    def changeStageAtFrame(self,image,metadata=None,core=None,frame=100):
        logging.debug(float(metadata[&#39;ImageNumber&#39;])) #type:ignore
        
        if float(metadata[&#39;ImageNumber&#39;])&gt;frame and self.notyetchanged == True: #type:ignore
            core.set_relative_position(&#39;Z&#39;,100.0) #type:ignore
            self.notyetchanged = False
            logging.debug(&#39;Z position changed!&#39;)
        
    def initChangeStageAtFrame(self):
        logging.debug(&#39;Initted changestageatframe&#39;)
        self.notyetchanged = True
    
    &#34;&#34;&#34;
    Average gray value calculation and display
    &#34;&#34;&#34;
    #Calculating average gray value of an image
    def calcAnalysisAvgGrayValue(self,image,metadata=None):
        return np.mean(np.mean(image))
    
    def visualiseAvgGrayValueText(self,analysis_result=&#39;Random&#39;,metadata={}):
        self.napariOverlay.drawTextOverlay(text=&#39;Mean gray value: {:.0f}, at frame: {:.0f}&#39;.format(analysis_result,float(metadata[&#39;ImageNumber&#39;])),pos=[0,0],textCol=&#39;white&#39;,textSize=12)
        
    def initAvgGrayValueText(self):
        self.napariOverlay.changeName(&#39;Average Gray Value&#39;)
        self.napariOverlay.drawTextOverlay_init()
    
    &#34;&#34;&#34;
    Random overlay display
    &#34;&#34;&#34;   
    def visualiseRandomOverlay(self,analysis_result=None,metadata={}):
        self.napariOverlay.drawSquaresOverlay(shapePosList=[[random.random()*100,random.random()*100,50,50],[100+random.random()*100,random.random()*100,100,100]],shapeCol=[(random.random(),random.random(),random.random()),(random.random(),random.random(),random.random())])
        
    def initRandomOverlay(self):
        self.napariOverlay.changeName(&#39;RandomOverlay&#39;)
        self.napariOverlay.shapesOverlay_init()    
    
    &#34;&#34;&#34;
    Testing overlay of image - based on grayscale value
    &#34;&#34;&#34;
    def calcGrayValueOverlay(self,image,metadata=None):
        #Get an image that simply provides a Boolean based on percentile:
        image2 = np.where(image&lt;np.percentile(image,25),1,0)
        return image2
    
    def visualiseGrayScaleImageOverlay(self,analysis_result=None,metadata={}):
        #Expected analysis_result is a boolean image.
        #Create an image overlay from napari
        self.napariOverlay.drawImageOverlay(im=analysis_result) #type:ignore
    
    def initGrayScaleImageOverlay(self):
        self.napariOverlay.imageOverlay_init()
        self.napariOverlay.changeName(&#39;Grayscale Image Overlay&#39;)

class AnalysisThread_customFunction_Visualisation(QThread):
    finished = pyqtSignal()# signal to indicate that the thread has finished
    def __init__(self,analysisObject,shared_data,analysisInfo: Union[str, None] = &#39;Random&#39;,delay=None):
        super().__init__()
        #Initiate some variables
        if delay==None:
            #Get the delay of the function from the realTimeAnalysis module
            delay = utils.realTimeAnalysis_getDelay(analysisInfo,runOrVis=&#39;visualise&#39;)
            
        self.is_running = True
        self.analysis_ongoing = False
        self.shared_data = shared_data
        self.analysisInfo = analysisInfo
        self.napariViewer = shared_data.napariViewer
        self.sleepTimeMs = delay
        self.napariOverlay = napariOverlay(self.napariViewer,RT_analysisObject=analysisObject,layer_name=&#39;TestLayer_VIS&#39;)
        self.visualisation_queue = queue.Queue()
        #And start  the thread
        self.running = True
        # self.process_queue()
    
    def run(self):
        while self.running:
            logging.debug(&#39;Attempting to take from queue&#39;)
            time.sleep(self.sleepTimeMs/1000.0)
            if not self.visualisation_queue.empty():
                data = self.visualisation_queue.get()
                RT_analysis_object,analysisInfo,image,metadata,core = data
                logging.debug(&#39;Ran updateVisualisation with RT analysis object&#39;)
                self.updateVisualisation(RT_analysis_object,analysisInfo,image,metadata,core)
            
    
    def updateVisualisation(self,RT_analysis_object,analysisInfo,image,metadata=None,core=None):
        # logging.info(&#39;visualisation should be updated here :)&#39;)
        utils.realTimeAnalysis_visualisation(RT_analysis_object,analysisInfo,image,metadata,core,self.napariOverlay.layer)

#This code gets some image and does some analysis on this
class AnalysisThread_customFunction(QThread):
    # Define analysis_done_signal as a class attribute, shared among all instances of AnalysisThread class
    # Create a signal to communicate between threads
    analysis_done_signal = pyqtSignal(object)
    finished = pyqtSignal()# signal to indicate that the thread has finished
    def __init__(self,shared_data,analysisInfo: Union[str, None] = &#39;Random&#39;,analysisQueue=None,sleepTimeMs=100,nodzInfo=None):
        &#34;&#34;&#34;
        Initializes the AnalysisThread object.

        Args:
            shared_data: The shared data object. See Shared_data class for more information
            analysisInfo (Union[str, None]): Optional. The analysis &#39;title/method&#39;. Default is &#39;Random&#39;.
            visualisationInfo (Union[str, None]): Optional. The visualisation &#39;title/method&#39;. Default is &#39;Random&#39;.

        Returns:
        None
        &#34;&#34;&#34;
        super().__init__()
        #Initiate some variables
        self.is_running = True
        self.analysis_ongoing = False
        self.shared_data = shared_data
        self.analysisInfo = analysisInfo
        self.napariViewer = shared_data.napariViewer
        self.image_queue_analysis = analysisQueue
        self.sleepTimeMs = sleepTimeMs
        self.napariOverlay = None
        self.nodzInfo=nodzInfo
        # self.napariOverlay = napariOverlay(self.napariViewer,layer_name=&#39;TestLayer&#39;)
        
        self.initAnalysis()
        
        # self.analysis_done_signal.connect(self.update_napariLayer)
        # if self.analysisInfo == &#39;CellSegmentOverlay&#39;:
        #     storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDistModel&#39;
        #     # storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDist_hfx_20220823&#39;
        #     modelDirectory = storageloc.rsplit(&#39;/&#39;, 1)
        #     #Load the model - better to do this out of the loop for time reasons
        #     self.stardistModel = StarDist2D(None,name=modelDirectory[1],basedir=modelDirectory[0]+&#34;/&#34;) #type:ignore
        # if analysisInfo == None:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        # elif analysisInfo == &#39;LiveModeVisualisation&#39;:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        # elif analysisInfo == &#39;mdaVisualisation&#39;:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        # else:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=analysisInfo)
            #Create an empty overlay
            # if visualisationInfo != None:
            #     #Activate layer
            #     self.initialise_napariLayer()
    
    def run(self):
        &#34;&#34;&#34;
        Runs the function in a loop as long as `self.is_running` is True.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        while not self.isInterruptionRequested():
            #Run analysis on the image from the queue
            # logging.debug(self.image_queue_analysis.get())
            self.analysis_result = self.runAnalysis(self.image_queue_analysis.get()) #type:ignore
            self.analysis_done_signal.emit(self.analysis_result)
            # self.finished.emit()
            if self.is_running == False:
                # self.finished.emit()
                return
        
        # Thread has finished, emit the finished signal
        self.finished.emit()
    
    def stop(self):
        &#34;&#34;&#34;
        Stops the execution of the function
        &#34;&#34;&#34;
        self.endAnalysis(self.analysisInfo,core=self.shared_data.core)
        self.is_running = False
        #Also remove the image queue requestion from live mode
        if self.image_queue_analysis in self.shared_data.liveImageQueues:
            self.shared_data.liveImageQueues.remove(self.image_queue_analysis)
        elif self.image_queue_analysis in self.shared_data.mdaImageQueues:
            self.shared_data.mdaImageQueues.remove(self.image_queue_analysis)
    
        try:
            #check if there&#39;s a layer associated with this...
            # layer = self.getLayer()
            #and remove it
            self.shared_data.skipAnalysisThreadDeletion = True
            # self.shared_data.napariViewer.layers.remove(layer)
        except:
            pass
        
    def destroy(self):
        &#34;&#34;&#34;
        Destroy the object.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        self.endAnalysis(self.analysisInfo,core=self.shared_data.core)
        try:
            logging.debug(&#39;Destroying &#39;+str(self.analysisInfo))
        except:
            logging.debug(&#39;Destroying some analysis thread&#39;)
        #Wait for the thread to be finished
        self.stop()
        self.requestInterruption()
        self.quit()
        #Officially we&#39;d need to wait here, but that seems to start an infinite loop somewhere
        # self.wait()
        # self.deleteLater()
    
    #Get corresponding layer of napariOverlay
    def getLayer(self):
        &#34;&#34;&#34;
        Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread
        
        Args:
            None

        Returns:
            napari.layers.Layer: The layer associated with the napari overlay.
        &#34;&#34;&#34;
        if self.napariOverlay is not None:
            return self.napariOverlay.getLayer()
        else:
            return None
    
    #Analysis is split into two parts: obtaining the analysis result and displaying this.
    #Here, we calculate the analysis result based on the analysisInfo
    def runAnalysis(self,data): 
        &#34;&#34;&#34;
        Runs the analysis on the given image based on the analysis information provided.

        Args:
            data, containing:
            image (Image): The image on which the analysis needs to be performed.
            metadata: corresponding metadata

        Returns:
            analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.

        Notes:
            - The layer should be open before running the analysis.
            - The analysisInfo parameter should be set before calling this function.
            - If analysisInfo is &#39;AvgGrayValueText&#39;, the analysisResult will be the result of calcAnalysisAvgGrayValue.
            - If analysisInfo is &#39;GrayValueOverlay&#39;, the analysisResult will be the result of calcGrayValueOverlay.
            - If analysisInfo is &#39;CellSegmentOverlay&#39;, the analysisResult will be the result of calcCellSegmentOverlay.
            - If analysisInfo is not set or is invalid, the analysisResult will be None.
        &#34;&#34;&#34;
        if data is not None:
            image = data[0]
            metadata = data[1]
            if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
                self.msleep(self.sleepTimeMs)
                #Do analysis here - the info in analysisResult will be passed to Visualise_Analysis_results
                analysisResult = self.runAnalysisThisImage(self.analysisInfo,image,metadata=metadata,core=self.shared_data.core)
                # if self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
                #     analysisResult = self.changeStageAtFrame(image,metadata=metadata,core=self.shared_data.core,frame=500)
                    
                return [analysisResult,metadata]
            elif self.analysisInfo == &#39;LiveModeVisualisation&#39; or self.analysisInfo == &#39;mdaVisualisation&#39;:
                self.setPriority(self.HighestPriority) #type:ignore
                return None
            else:
                return None
        else:
            return None



    # #And here we perform the visualisation - can be fully separate from performing the analysis
    # #Initialisation is called upon creation
    # def initialise_napariLayer(self):
    #     logging.debug(&#39;init_napariLayer&#39;)
            
    # #Update ir called every time the analysis is done
    # def update_napariLayer(self,analysisInfo,image,metadata=None,core=None):
    #     self.visualisationObject.updateVisualisation(analysisInfo,image,metadata,core)
    #     # utils.realTimeAnalysis_visualisation(self.RT_analysis_object,analysisInfo,image,metadata,core)
    
    
    
    
    def initAnalysis(self):
        self.RT_analysis_object = utils.realTimeAnalysis_init(self.analysisInfo,core=self.shared_data.core,nodzInfo=self.nodzInfo)
        if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]: #type:ignore
            self.queue_visualisation = queue.Queue()
            self.visualisationObject=AnalysisThread_customFunction_Visualisation(self.RT_analysis_object,self.shared_data,analysisInfo=self.analysisInfo)
            self.visualisationObject.start()
    
    def runAnalysisThisImage(self,analysisInfo,image,metadata=None,core=None):
        self.msleep(self.sleepTimeMs)
        result = utils.realTimeAnalysis_run(self.RT_analysis_object,analysisInfo,image,metadata,core,nodzInfo=self.nodzInfo)
        
        if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]:#type:ignore
            logging.debug(&#39;Attempting RT visualisation!&#39;)
            # self.update_napariLayer(analysisInfo,image,metadata=metadata,core=core)
            if self.visualisationObject.visualisation_queue.empty():
                data = (self.RT_analysis_object,analysisInfo,image,metadata,core)
                self.visualisationObject.visualisation_queue.put(data)
                logging.debug(&#39;Put data in visualisation_queue!&#39;)
                # self.visualisationObject.process_queue()
        
        return result
    
    def endAnalysis(self,analysisInfo,core=None):
        self.msleep(self.sleepTimeMs)
        result = utils.realTimeAnalysis_end(self.RT_analysis_object,analysisInfo,core,nodzInfo=self.nodzInfo)
        
        if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]:#type:ignore
            #End the visualisation
            self.visualisationObject.running=False
        return result

#This function probably gets deprecated soon
def create_analysis_thread(shared_data,analysisInfo = None,visualisationInfo = None,createNewThread = True,throughputThread=None,liveorMDA=&#39;live&#39;):
    global image_queue_analysis, napariViewer
    napariViewer = shared_data.napariViewer
    if createNewThread == False:
        image_queue_analysis = throughputThread
    else:
        #Create a new analysis thread
        logging.debug(&#39;starting new image queue analysis&#39;)
        image_queue_analysis = queue.Queue() #This now needs to be linked to pycromanager so that pycromanager pushes images to all image queues and not just one
        if liveorMDA == &#39;live&#39;:
            shared_data.liveImageQueues.append(image_queue_analysis)
        elif liveorMDA == &#39;MDA&#39;:
            shared_data.mdaImageQueues.append(image_queue_analysis)
        
    # image_queue_analysis = image_queue_transfer
    #Instantiate an analysis thread and add a signal
    if analysisInfo == &#39;ChangeStageAtFrame&#39;:
        delay = 0
    else:
        delay = 500
    analysis_thread = AnalysisThread(shared_data,analysisInfo=analysisInfo,visualisationInfo=analysisInfo,analysisQueue=image_queue_analysis,sleepTimeMs = delay)
    analysis_thread.analysis_done_signal.connect(analysis_thread.update_napariLayer)
    analysis_thread.finished.connect(analysis_thread.deleteLater)
    analysis_thread.start()
    
    #Append it to the list of analysisThreads
    shared_data.analysisThreads.append(analysis_thread)
    
    return analysis_thread

#Use this function from now on
def create_real_time_analysis_thread(shared_data,analysisInfo = None,createNewThread = True,throughputThread=None,delay: float|None = None,nodzInfo=None):
    
    #Created/tested via nodz
    
    global image_queue_analysis, napariViewer
    napariViewer = shared_data.napariViewer
    if createNewThread == False:
        image_queue_analysis = throughputThread
    else:
        #Create a new analysis thread
        image_queue_analysis = queue.Queue() #This now needs to be linked to pycromanager so that pycromanager pushes images to all image queues and not just one
        shared_data.liveImageQueues.append(image_queue_analysis)
            
    if delay==None:
        #Get the delay of the function from the realTimeAnalysis module
        delay = utils.realTimeAnalysis_getDelay(analysisInfo,runOrVis=&#39;run&#39;)
    
    # image_queue_analysis = image_queue_transfer
    #Instantiate an analysis thread and add a signal
    analysis_thread = AnalysisThread_customFunction(shared_data,analysisInfo=analysisInfo, analysisQueue=image_queue_analysis,sleepTimeMs = delay,nodzInfo=nodzInfo) #type:ignore
        
    analysis_thread.finished.connect(analysis_thread.deleteLater)
    analysis_thread.start()
    
    #Append it to the list of analysisThreads
    shared_data.analysisThreads.append(analysis_thread)
    
    return analysis_thread</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AnalysisClass.create_analysis_thread"><code class="name flex">
<span>def <span class="ident">create_analysis_thread</span></span>(<span>shared_data, analysisInfo=None, visualisationInfo=None, createNewThread=True, throughputThread=None, liveorMDA='live')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_analysis_thread(shared_data,analysisInfo = None,visualisationInfo = None,createNewThread = True,throughputThread=None,liveorMDA=&#39;live&#39;):
    global image_queue_analysis, napariViewer
    napariViewer = shared_data.napariViewer
    if createNewThread == False:
        image_queue_analysis = throughputThread
    else:
        #Create a new analysis thread
        logging.debug(&#39;starting new image queue analysis&#39;)
        image_queue_analysis = queue.Queue() #This now needs to be linked to pycromanager so that pycromanager pushes images to all image queues and not just one
        if liveorMDA == &#39;live&#39;:
            shared_data.liveImageQueues.append(image_queue_analysis)
        elif liveorMDA == &#39;MDA&#39;:
            shared_data.mdaImageQueues.append(image_queue_analysis)
        
    # image_queue_analysis = image_queue_transfer
    #Instantiate an analysis thread and add a signal
    if analysisInfo == &#39;ChangeStageAtFrame&#39;:
        delay = 0
    else:
        delay = 500
    analysis_thread = AnalysisThread(shared_data,analysisInfo=analysisInfo,visualisationInfo=analysisInfo,analysisQueue=image_queue_analysis,sleepTimeMs = delay)
    analysis_thread.analysis_done_signal.connect(analysis_thread.update_napariLayer)
    analysis_thread.finished.connect(analysis_thread.deleteLater)
    analysis_thread.start()
    
    #Append it to the list of analysisThreads
    shared_data.analysisThreads.append(analysis_thread)
    
    return analysis_thread</code></pre>
</details>
</dd>
<dt id="AnalysisClass.create_real_time_analysis_thread"><code class="name flex">
<span>def <span class="ident">create_real_time_analysis_thread</span></span>(<span>shared_data, analysisInfo=None, createNewThread=True, throughputThread=None, delay:float|None=None, nodzInfo=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_real_time_analysis_thread(shared_data,analysisInfo = None,createNewThread = True,throughputThread=None,delay: float|None = None,nodzInfo=None):
    
    #Created/tested via nodz
    
    global image_queue_analysis, napariViewer
    napariViewer = shared_data.napariViewer
    if createNewThread == False:
        image_queue_analysis = throughputThread
    else:
        #Create a new analysis thread
        image_queue_analysis = queue.Queue() #This now needs to be linked to pycromanager so that pycromanager pushes images to all image queues and not just one
        shared_data.liveImageQueues.append(image_queue_analysis)
            
    if delay==None:
        #Get the delay of the function from the realTimeAnalysis module
        delay = utils.realTimeAnalysis_getDelay(analysisInfo,runOrVis=&#39;run&#39;)
    
    # image_queue_analysis = image_queue_transfer
    #Instantiate an analysis thread and add a signal
    analysis_thread = AnalysisThread_customFunction(shared_data,analysisInfo=analysisInfo, analysisQueue=image_queue_analysis,sleepTimeMs = delay,nodzInfo=nodzInfo) #type:ignore
        
    analysis_thread.finished.connect(analysis_thread.deleteLater)
    analysis_thread.start()
    
    #Append it to the list of analysisThreads
    shared_data.analysisThreads.append(analysis_thread)
    
    return analysis_thread</code></pre>
</details>
</dd>
<dt id="AnalysisClass.is_pip_installed"><code class="name flex">
<span>def <span class="ident">is_pip_installed</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AnalysisClass.AnalysisThread"><code class="flex name class">
<span>class <span class="ident">AnalysisThread</span></span>
<span>(</span><span>shared_data, analysisInfo:Optional[str]='Random', visualisationInfo:Optional[str]='Random', analysisQueue=None, sleepTimeMs=500)</span>
</code></dt>
<dd>
<div class="desc"><p>QThread(parent: typing.Optional[QObject] = None)</p>
<p>Initializes the AnalysisThread object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shared_data</code></strong></dt>
<dd>The shared data object. See Shared_data class for more information</dd>
<dt><strong><code>analysisInfo</code></strong> :&ensp;<code>Union[str, None]</code></dt>
<dd>Optional. The analysis 'title/method'. Default is 'Random'.</dd>
<dt><strong><code>visualisationInfo</code></strong> :&ensp;<code>Union[str, None]</code></dt>
<dd>Optional. The visualisation 'title/method'. Default is 'Random'.</dd>
</dl>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisThread(QThread):
    # Define analysis_done_signal as a class attribute, shared among all instances of AnalysisThread class
    # Create a signal to communicate between threads
    analysis_done_signal = pyqtSignal(object)
    finished = pyqtSignal()# signal to indicate that the thread has finished
    def __init__(self,shared_data,analysisInfo: Union[str, None] = &#39;Random&#39;,visualisationInfo: Union[str, None] = &#39;Random&#39;,analysisQueue=None,sleepTimeMs=500):
        &#34;&#34;&#34;
        Initializes the AnalysisThread object.

        Args:
            shared_data: The shared data object. See Shared_data class for more information
            analysisInfo (Union[str, None]): Optional. The analysis &#39;title/method&#39;. Default is &#39;Random&#39;.
            visualisationInfo (Union[str, None]): Optional. The visualisation &#39;title/method&#39;. Default is &#39;Random&#39;.

        Returns:
        None
        &#34;&#34;&#34;
        super().__init__()      
        self.is_running = True
        self.analysis_ongoing = False
        self.shared_data = shared_data
        self.analysisInfo = analysisInfo
        self.visualisationInfo = visualisationInfo
        self.napariViewer = shared_data.napariViewer
        self.image_queue_analysis = analysisQueue
        self.sleepTimeMs = sleepTimeMs
        if self.analysisInfo == &#39;CellSegmentOverlay&#39;:
            storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDistModel&#39;
            # storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDist_hfx_20220823&#39;
            modelDirectory = storageloc.rsplit(&#39;/&#39;, 1)
            #Load the model - better to do this out of the loop for time reasons
            self.stardistModel = StarDist2D(None,name=modelDirectory[1],basedir=modelDirectory[0]+&#34;/&#34;) #type:ignore
        if analysisInfo == None:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        elif analysisInfo == &#39;LiveModeVisualisation&#39;:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        elif analysisInfo == &#39;mdaVisualisation&#39;:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        else:
            self.napariOverlay = napariOverlay(self.napariViewer,layer_name=analysisInfo)
            #Create an empty overlay
            if visualisationInfo != None:
                #Activate layer
                self.initialise_napariLayer()
    
    def run(self):
        &#34;&#34;&#34;
        Runs the function in a loop as long as `self.is_running` is True.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        while not self.isInterruptionRequested():
            #Run analysis on the image from the queue
            # logging.debug(self.image_queue_analysis.get())
            self.analysis_result = self.runAnalysis(self.image_queue_analysis.get()) #type:ignore
            self.analysis_done_signal.emit(self.analysis_result)
            # self.finished.emit()
            if self.is_running == False:
                # self.finished.emit()
                return
        
        # Thread has finished, emit the finished signal
        self.finished.emit()
    
    def stop(self):
        &#34;&#34;&#34;
        Stops the execution of the function
        &#34;&#34;&#34;
        self.is_running = False
        #Also remove the image queue requestion from live mode
        if self.image_queue_analysis in self.shared_data.liveImageQueues:
            self.shared_data.liveImageQueues.remove(self.image_queue_analysis)
        elif self.image_queue_analysis in self.shared_data.mdaImageQueues:
            self.shared_data.mdaImageQueues.remove(self.image_queue_analysis)
    
    def destroy(self):
        &#34;&#34;&#34;
        Destroy the object.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        try:
            logging.debug(&#39;Destroying &#39;+str(self.analysisInfo))
        except:
            logging.debug(&#39;Destroying some analysis thread&#39;)
        #Wait for the thread to be finished
        self.stop()
        self.requestInterruption()
        self.quit()
        #Officially we&#39;d need to wait here, but that seems to start an infinite loop somewhere
        # self.wait()
        # self.deleteLater()
    
    #Get corresponding layer of napariOverlay
    def getLayer(self):
        &#34;&#34;&#34;
        Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread
        
        Args:
            None

        Returns:
            napari.layers.Layer: The layer associated with the napari overlay.
        &#34;&#34;&#34;
        return self.napariOverlay.getLayer()
    
    #Analysis is split into two parts: obtaining the analysis result and displaying this.
    #Here, we calculate the analysis result based on the analysisInfo
    def runAnalysis(self,data): 
        &#34;&#34;&#34;
        Runs the analysis on the given image based on the analysis information provided.

        Args:
            data, containing:
            image (Image): The image on which the analysis needs to be performed.
            metadata: corresponding metadata

        Returns:
            analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.

        Notes:
            - The layer should be open before running the analysis.
            - The analysisInfo parameter should be set before calling this function.
            - If analysisInfo is &#39;AvgGrayValueText&#39;, the analysisResult will be the result of calcAnalysisAvgGrayValue.
            - If analysisInfo is &#39;GrayValueOverlay&#39;, the analysisResult will be the result of calcGrayValueOverlay.
            - If analysisInfo is &#39;CellSegmentOverlay&#39;, the analysisResult will be the result of calcCellSegmentOverlay.
            - If analysisInfo is not set or is invalid, the analysisResult will be None.
        &#34;&#34;&#34;
        if data is not None:
            image = data[0]
            metadata = data[1]
            if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
                self.msleep(self.sleepTimeMs)
                #Do analysis here - the info in analysisResult will be passed to Visualise_Analysis_results
                if self.analysisInfo == &#39;AvgGrayValueText&#39;:
                    analysisResult = self.calcAnalysisAvgGrayValue(image,metadata=metadata)
                elif self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
                    analysisResult = self.changeStageAtFrame(image,metadata=metadata,core=self.shared_data.core,frame=500)
                elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
                    analysisResult = self.calcGrayValueOverlay(image,metadata=metadata)
                else:
                    analysisResult = None
                return [analysisResult,metadata]
            elif self.analysisInfo == &#39;LiveModeVisualisation&#39; or self.analysisInfo == &#39;mdaVisualisation&#39;:
                self.setPriority(self.HighestPriority) #type:ignore
                return None
            else:
                return None
        else:
            return None

    #And here we perform the visualisation - can be fully separate from performing the analysis
    #Initialisation is called upon creation
    def initialise_napariLayer(self):
        if self.visualisationInfo == &#39;AvgGrayValueText&#39;:
            self.initAvgGrayValueText()
        elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
            self.initGrayScaleImageOverlay()
        elif self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
            self.initChangeStageAtFrame()
        else:
            self.initRandomOverlay()
            
    #Update ir called every time the analysis is done
    def update_napariLayer(self,analysis_data):
        if analysis_data is not None:
            analysis_result = analysis_data[0]
            metadata = analysis_data[1]
            # logging.debug(analysis_result)
            if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
                if self.visualisationInfo == &#39;AvgGrayValueText&#39;:
                    self.visualiseAvgGrayValueText(analysis_result=analysis_result,metadata=metadata)
                elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
                    self.visualiseGrayScaleImageOverlay(analysis_result=analysis_result,metadata=metadata)
                # else:
                #     self.visualiseRandomOverlay()
    
    def outlineCoordinatesToImage(self,coords):
    # Create a blank grayscale image with a white background
        image = Image.new(&#34;L&#34;, (self.shared_data.core.get_roi().width,self.shared_data.core.get_roi().height), &#34;black&#34;)
        draw = ImageDraw.Draw(image)

        # Iterate over each n in N
        for n in range(coords.shape[0]):
            # Get the x and y coordinates for the current n
            x = coords[n, 0, :]
            y = coords[n, 1, :]

            # Create a list of (x, y) tuples for drawing the lines
            points = [(x[i], y[i]) for i in range(len(x))]

            # Draw the lines on the image
            draw.line(points, fill=&#34;white&#34;,width=2)  # Use black for the lines

        # Convert the image to grayscale mode (L)
        grayscale_image = image.convert(&#34;L&#34;)
        return np.fliplr(np.rot90(np.array(grayscale_image),k=3))
    
    &#34;&#34;&#34;
    Testing updating a stage during acq
    &#34;&#34;&#34;
    
    def changeStageAtFrame(self,image,metadata=None,core=None,frame=100):
        logging.debug(float(metadata[&#39;ImageNumber&#39;])) #type:ignore
        
        if float(metadata[&#39;ImageNumber&#39;])&gt;frame and self.notyetchanged == True: #type:ignore
            core.set_relative_position(&#39;Z&#39;,100.0) #type:ignore
            self.notyetchanged = False
            logging.debug(&#39;Z position changed!&#39;)
        
    def initChangeStageAtFrame(self):
        logging.debug(&#39;Initted changestageatframe&#39;)
        self.notyetchanged = True
    
    &#34;&#34;&#34;
    Average gray value calculation and display
    &#34;&#34;&#34;
    #Calculating average gray value of an image
    def calcAnalysisAvgGrayValue(self,image,metadata=None):
        return np.mean(np.mean(image))
    
    def visualiseAvgGrayValueText(self,analysis_result=&#39;Random&#39;,metadata={}):
        self.napariOverlay.drawTextOverlay(text=&#39;Mean gray value: {:.0f}, at frame: {:.0f}&#39;.format(analysis_result,float(metadata[&#39;ImageNumber&#39;])),pos=[0,0],textCol=&#39;white&#39;,textSize=12)
        
    def initAvgGrayValueText(self):
        self.napariOverlay.changeName(&#39;Average Gray Value&#39;)
        self.napariOverlay.drawTextOverlay_init()
    
    &#34;&#34;&#34;
    Random overlay display
    &#34;&#34;&#34;   
    def visualiseRandomOverlay(self,analysis_result=None,metadata={}):
        self.napariOverlay.drawSquaresOverlay(shapePosList=[[random.random()*100,random.random()*100,50,50],[100+random.random()*100,random.random()*100,100,100]],shapeCol=[(random.random(),random.random(),random.random()),(random.random(),random.random(),random.random())])
        
    def initRandomOverlay(self):
        self.napariOverlay.changeName(&#39;RandomOverlay&#39;)
        self.napariOverlay.shapesOverlay_init()    
    
    &#34;&#34;&#34;
    Testing overlay of image - based on grayscale value
    &#34;&#34;&#34;
    def calcGrayValueOverlay(self,image,metadata=None):
        #Get an image that simply provides a Boolean based on percentile:
        image2 = np.where(image&lt;np.percentile(image,25),1,0)
        return image2
    
    def visualiseGrayScaleImageOverlay(self,analysis_result=None,metadata={}):
        #Expected analysis_result is a boolean image.
        #Create an image overlay from napari
        self.napariOverlay.drawImageOverlay(im=analysis_result) #type:ignore
    
    def initGrayScaleImageOverlay(self):
        self.napariOverlay.imageOverlay_init()
        self.napariOverlay.changeName(&#39;Grayscale Image Overlay&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QThread</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="AnalysisClass.AnalysisThread.analysis_done_signal"><code class="name flex">
<span>def <span class="ident">analysis_done_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="AnalysisClass.AnalysisThread.calcAnalysisAvgGrayValue"><code class="name flex">
<span>def <span class="ident">calcAnalysisAvgGrayValue</span></span>(<span>self, image, metadata=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcAnalysisAvgGrayValue(self,image,metadata=None):
    return np.mean(np.mean(image))</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.calcGrayValueOverlay"><code class="name flex">
<span>def <span class="ident">calcGrayValueOverlay</span></span>(<span>self, image, metadata=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcGrayValueOverlay(self,image,metadata=None):
    #Get an image that simply provides a Boolean based on percentile:
    image2 = np.where(image&lt;np.percentile(image,25),1,0)
    return image2</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.changeStageAtFrame"><code class="name flex">
<span>def <span class="ident">changeStageAtFrame</span></span>(<span>self, image, metadata=None, core=None, frame=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeStageAtFrame(self,image,metadata=None,core=None,frame=100):
    logging.debug(float(metadata[&#39;ImageNumber&#39;])) #type:ignore
    
    if float(metadata[&#39;ImageNumber&#39;])&gt;frame and self.notyetchanged == True: #type:ignore
        core.set_relative_position(&#39;Z&#39;,100.0) #type:ignore
        self.notyetchanged = False
        logging.debug(&#39;Z position changed!&#39;)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy the object.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Destroy the object.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    try:
        logging.debug(&#39;Destroying &#39;+str(self.analysisInfo))
    except:
        logging.debug(&#39;Destroying some analysis thread&#39;)
    #Wait for the thread to be finished
    self.stop()
    self.requestInterruption()
    self.quit()
    #Officially we&#39;d need to wait here, but that seems to start an infinite loop somewhere
    # self.wait()
    # self.deleteLater()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="AnalysisClass.AnalysisThread.getLayer"><code class="name flex">
<span>def <span class="ident">getLayer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>napari.layers.Layer</code></dt>
<dd>The layer associated with the napari overlay.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLayer(self):
    &#34;&#34;&#34;
    Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread
    
    Args:
        None

    Returns:
        napari.layers.Layer: The layer associated with the napari overlay.
    &#34;&#34;&#34;
    return self.napariOverlay.getLayer()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.initAvgGrayValueText"><code class="name flex">
<span>def <span class="ident">initAvgGrayValueText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initAvgGrayValueText(self):
    self.napariOverlay.changeName(&#39;Average Gray Value&#39;)
    self.napariOverlay.drawTextOverlay_init()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.initChangeStageAtFrame"><code class="name flex">
<span>def <span class="ident">initChangeStageAtFrame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initChangeStageAtFrame(self):
    logging.debug(&#39;Initted changestageatframe&#39;)
    self.notyetchanged = True</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.initGrayScaleImageOverlay"><code class="name flex">
<span>def <span class="ident">initGrayScaleImageOverlay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initGrayScaleImageOverlay(self):
    self.napariOverlay.imageOverlay_init()
    self.napariOverlay.changeName(&#39;Grayscale Image Overlay&#39;)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.initRandomOverlay"><code class="name flex">
<span>def <span class="ident">initRandomOverlay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initRandomOverlay(self):
    self.napariOverlay.changeName(&#39;RandomOverlay&#39;)
    self.napariOverlay.shapesOverlay_init()    </code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.initialise_napariLayer"><code class="name flex">
<span>def <span class="ident">initialise_napariLayer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialise_napariLayer(self):
    if self.visualisationInfo == &#39;AvgGrayValueText&#39;:
        self.initAvgGrayValueText()
    elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
        self.initGrayScaleImageOverlay()
    elif self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
        self.initChangeStageAtFrame()
    else:
        self.initRandomOverlay()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.outlineCoordinatesToImage"><code class="name flex">
<span>def <span class="ident">outlineCoordinatesToImage</span></span>(<span>self, coords)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outlineCoordinatesToImage(self,coords):
# Create a blank grayscale image with a white background
    image = Image.new(&#34;L&#34;, (self.shared_data.core.get_roi().width,self.shared_data.core.get_roi().height), &#34;black&#34;)
    draw = ImageDraw.Draw(image)

    # Iterate over each n in N
    for n in range(coords.shape[0]):
        # Get the x and y coordinates for the current n
        x = coords[n, 0, :]
        y = coords[n, 1, :]

        # Create a list of (x, y) tuples for drawing the lines
        points = [(x[i], y[i]) for i in range(len(x))]

        # Draw the lines on the image
        draw.line(points, fill=&#34;white&#34;,width=2)  # Use black for the lines

    # Convert the image to grayscale mode (L)
    grayscale_image = image.convert(&#34;L&#34;)
    return np.fliplr(np.rot90(np.array(grayscale_image),k=3))</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the function in a loop as long as <code>self.is_running</code> is True.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Runs the function in a loop as long as `self.is_running` is True.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    while not self.isInterruptionRequested():
        #Run analysis on the image from the queue
        # logging.debug(self.image_queue_analysis.get())
        self.analysis_result = self.runAnalysis(self.image_queue_analysis.get()) #type:ignore
        self.analysis_done_signal.emit(self.analysis_result)
        # self.finished.emit()
        if self.is_running == False:
            # self.finished.emit()
            return
    
    # Thread has finished, emit the finished signal
    self.finished.emit()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.runAnalysis"><code class="name flex">
<span>def <span class="ident">runAnalysis</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the analysis on the given image based on the analysis information provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt>data, containing:</dt>
<dt><strong><code>image</code></strong> :&ensp;<code>Image</code></dt>
<dd>The image on which the analysis needs to be performed.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>corresponding metadata</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The layer should be open before running the analysis.</li>
<li>The analysisInfo parameter should be set before calling this function.</li>
<li>If analysisInfo is 'AvgGrayValueText', the analysisResult will be the result of calcAnalysisAvgGrayValue.</li>
<li>If analysisInfo is 'GrayValueOverlay', the analysisResult will be the result of calcGrayValueOverlay.</li>
<li>If analysisInfo is 'CellSegmentOverlay', the analysisResult will be the result of calcCellSegmentOverlay.</li>
<li>If analysisInfo is not set or is invalid, the analysisResult will be None.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runAnalysis(self,data): 
    &#34;&#34;&#34;
    Runs the analysis on the given image based on the analysis information provided.

    Args:
        data, containing:
        image (Image): The image on which the analysis needs to be performed.
        metadata: corresponding metadata

    Returns:
        analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.

    Notes:
        - The layer should be open before running the analysis.
        - The analysisInfo parameter should be set before calling this function.
        - If analysisInfo is &#39;AvgGrayValueText&#39;, the analysisResult will be the result of calcAnalysisAvgGrayValue.
        - If analysisInfo is &#39;GrayValueOverlay&#39;, the analysisResult will be the result of calcGrayValueOverlay.
        - If analysisInfo is &#39;CellSegmentOverlay&#39;, the analysisResult will be the result of calcCellSegmentOverlay.
        - If analysisInfo is not set or is invalid, the analysisResult will be None.
    &#34;&#34;&#34;
    if data is not None:
        image = data[0]
        metadata = data[1]
        if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
            self.msleep(self.sleepTimeMs)
            #Do analysis here - the info in analysisResult will be passed to Visualise_Analysis_results
            if self.analysisInfo == &#39;AvgGrayValueText&#39;:
                analysisResult = self.calcAnalysisAvgGrayValue(image,metadata=metadata)
            elif self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
                analysisResult = self.changeStageAtFrame(image,metadata=metadata,core=self.shared_data.core,frame=500)
            elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
                analysisResult = self.calcGrayValueOverlay(image,metadata=metadata)
            else:
                analysisResult = None
            return [analysisResult,metadata]
        elif self.analysisInfo == &#39;LiveModeVisualisation&#39; or self.analysisInfo == &#39;mdaVisualisation&#39;:
            self.setPriority(self.HighestPriority) #type:ignore
            return None
        else:
            return None
    else:
        return None</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the execution of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;
    Stops the execution of the function
    &#34;&#34;&#34;
    self.is_running = False
    #Also remove the image queue requestion from live mode
    if self.image_queue_analysis in self.shared_data.liveImageQueues:
        self.shared_data.liveImageQueues.remove(self.image_queue_analysis)
    elif self.image_queue_analysis in self.shared_data.mdaImageQueues:
        self.shared_data.mdaImageQueues.remove(self.image_queue_analysis)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.update_napariLayer"><code class="name flex">
<span>def <span class="ident">update_napariLayer</span></span>(<span>self, analysis_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_napariLayer(self,analysis_data):
    if analysis_data is not None:
        analysis_result = analysis_data[0]
        metadata = analysis_data[1]
        # logging.debug(analysis_result)
        if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
            if self.visualisationInfo == &#39;AvgGrayValueText&#39;:
                self.visualiseAvgGrayValueText(analysis_result=analysis_result,metadata=metadata)
            elif self.analysisInfo == &#39;GrayValueOverlay&#39;:
                self.visualiseGrayScaleImageOverlay(analysis_result=analysis_result,metadata=metadata)
            # else:
            #     self.visualiseRandomOverlay()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.visualiseAvgGrayValueText"><code class="name flex">
<span>def <span class="ident">visualiseAvgGrayValueText</span></span>(<span>self, analysis_result='Random', metadata={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualiseAvgGrayValueText(self,analysis_result=&#39;Random&#39;,metadata={}):
    self.napariOverlay.drawTextOverlay(text=&#39;Mean gray value: {:.0f}, at frame: {:.0f}&#39;.format(analysis_result,float(metadata[&#39;ImageNumber&#39;])),pos=[0,0],textCol=&#39;white&#39;,textSize=12)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.visualiseGrayScaleImageOverlay"><code class="name flex">
<span>def <span class="ident">visualiseGrayScaleImageOverlay</span></span>(<span>self, analysis_result=None, metadata={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualiseGrayScaleImageOverlay(self,analysis_result=None,metadata={}):
    #Expected analysis_result is a boolean image.
    #Create an image overlay from napari
    self.napariOverlay.drawImageOverlay(im=analysis_result) #type:ignore</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread.visualiseRandomOverlay"><code class="name flex">
<span>def <span class="ident">visualiseRandomOverlay</span></span>(<span>self, analysis_result=None, metadata={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualiseRandomOverlay(self,analysis_result=None,metadata={}):
    self.napariOverlay.drawSquaresOverlay(shapePosList=[[random.random()*100,random.random()*100,50,50],[100+random.random()*100,random.random()*100,100,100]],shapeCol=[(random.random(),random.random(),random.random()),(random.random(),random.random(),random.random())])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction"><code class="flex name class">
<span>class <span class="ident">AnalysisThread_customFunction</span></span>
<span>(</span><span>shared_data, analysisInfo:Optional[str]='Random', analysisQueue=None, sleepTimeMs=100, nodzInfo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QThread(parent: typing.Optional[QObject] = None)</p>
<p>Initializes the AnalysisThread object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shared_data</code></strong></dt>
<dd>The shared data object. See Shared_data class for more information</dd>
<dt><strong><code>analysisInfo</code></strong> :&ensp;<code>Union[str, None]</code></dt>
<dd>Optional. The analysis 'title/method'. Default is 'Random'.</dd>
<dt><strong><code>visualisationInfo</code></strong> :&ensp;<code>Union[str, None]</code></dt>
<dd>Optional. The visualisation 'title/method'. Default is 'Random'.</dd>
</dl>
<p>Returns:
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisThread_customFunction(QThread):
    # Define analysis_done_signal as a class attribute, shared among all instances of AnalysisThread class
    # Create a signal to communicate between threads
    analysis_done_signal = pyqtSignal(object)
    finished = pyqtSignal()# signal to indicate that the thread has finished
    def __init__(self,shared_data,analysisInfo: Union[str, None] = &#39;Random&#39;,analysisQueue=None,sleepTimeMs=100,nodzInfo=None):
        &#34;&#34;&#34;
        Initializes the AnalysisThread object.

        Args:
            shared_data: The shared data object. See Shared_data class for more information
            analysisInfo (Union[str, None]): Optional. The analysis &#39;title/method&#39;. Default is &#39;Random&#39;.
            visualisationInfo (Union[str, None]): Optional. The visualisation &#39;title/method&#39;. Default is &#39;Random&#39;.

        Returns:
        None
        &#34;&#34;&#34;
        super().__init__()
        #Initiate some variables
        self.is_running = True
        self.analysis_ongoing = False
        self.shared_data = shared_data
        self.analysisInfo = analysisInfo
        self.napariViewer = shared_data.napariViewer
        self.image_queue_analysis = analysisQueue
        self.sleepTimeMs = sleepTimeMs
        self.napariOverlay = None
        self.nodzInfo=nodzInfo
        # self.napariOverlay = napariOverlay(self.napariViewer,layer_name=&#39;TestLayer&#39;)
        
        self.initAnalysis()
        
        # self.analysis_done_signal.connect(self.update_napariLayer)
        # if self.analysisInfo == &#39;CellSegmentOverlay&#39;:
        #     storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDistModel&#39;
        #     # storageloc = &#39;./AutonomousMicroscopy/ExampleData/StarDist_hfx_20220823&#39;
        #     modelDirectory = storageloc.rsplit(&#39;/&#39;, 1)
        #     #Load the model - better to do this out of the loop for time reasons
        #     self.stardistModel = StarDist2D(None,name=modelDirectory[1],basedir=modelDirectory[0]+&#34;/&#34;) #type:ignore
        # if analysisInfo == None:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        # elif analysisInfo == &#39;LiveModeVisualisation&#39;:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        # elif analysisInfo == &#39;mdaVisualisation&#39;:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=None)
        # else:
        #     self.napariOverlay = napariOverlay(self.napariViewer,layer_name=analysisInfo)
            #Create an empty overlay
            # if visualisationInfo != None:
            #     #Activate layer
            #     self.initialise_napariLayer()
    
    def run(self):
        &#34;&#34;&#34;
        Runs the function in a loop as long as `self.is_running` is True.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        while not self.isInterruptionRequested():
            #Run analysis on the image from the queue
            # logging.debug(self.image_queue_analysis.get())
            self.analysis_result = self.runAnalysis(self.image_queue_analysis.get()) #type:ignore
            self.analysis_done_signal.emit(self.analysis_result)
            # self.finished.emit()
            if self.is_running == False:
                # self.finished.emit()
                return
        
        # Thread has finished, emit the finished signal
        self.finished.emit()
    
    def stop(self):
        &#34;&#34;&#34;
        Stops the execution of the function
        &#34;&#34;&#34;
        self.endAnalysis(self.analysisInfo,core=self.shared_data.core)
        self.is_running = False
        #Also remove the image queue requestion from live mode
        if self.image_queue_analysis in self.shared_data.liveImageQueues:
            self.shared_data.liveImageQueues.remove(self.image_queue_analysis)
        elif self.image_queue_analysis in self.shared_data.mdaImageQueues:
            self.shared_data.mdaImageQueues.remove(self.image_queue_analysis)
    
        try:
            #check if there&#39;s a layer associated with this...
            # layer = self.getLayer()
            #and remove it
            self.shared_data.skipAnalysisThreadDeletion = True
            # self.shared_data.napariViewer.layers.remove(layer)
        except:
            pass
        
    def destroy(self):
        &#34;&#34;&#34;
        Destroy the object.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        self.endAnalysis(self.analysisInfo,core=self.shared_data.core)
        try:
            logging.debug(&#39;Destroying &#39;+str(self.analysisInfo))
        except:
            logging.debug(&#39;Destroying some analysis thread&#39;)
        #Wait for the thread to be finished
        self.stop()
        self.requestInterruption()
        self.quit()
        #Officially we&#39;d need to wait here, but that seems to start an infinite loop somewhere
        # self.wait()
        # self.deleteLater()
    
    #Get corresponding layer of napariOverlay
    def getLayer(self):
        &#34;&#34;&#34;
        Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread
        
        Args:
            None

        Returns:
            napari.layers.Layer: The layer associated with the napari overlay.
        &#34;&#34;&#34;
        if self.napariOverlay is not None:
            return self.napariOverlay.getLayer()
        else:
            return None
    
    #Analysis is split into two parts: obtaining the analysis result and displaying this.
    #Here, we calculate the analysis result based on the analysisInfo
    def runAnalysis(self,data): 
        &#34;&#34;&#34;
        Runs the analysis on the given image based on the analysis information provided.

        Args:
            data, containing:
            image (Image): The image on which the analysis needs to be performed.
            metadata: corresponding metadata

        Returns:
            analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.

        Notes:
            - The layer should be open before running the analysis.
            - The analysisInfo parameter should be set before calling this function.
            - If analysisInfo is &#39;AvgGrayValueText&#39;, the analysisResult will be the result of calcAnalysisAvgGrayValue.
            - If analysisInfo is &#39;GrayValueOverlay&#39;, the analysisResult will be the result of calcGrayValueOverlay.
            - If analysisInfo is &#39;CellSegmentOverlay&#39;, the analysisResult will be the result of calcCellSegmentOverlay.
            - If analysisInfo is not set or is invalid, the analysisResult will be None.
        &#34;&#34;&#34;
        if data is not None:
            image = data[0]
            metadata = data[1]
            if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
                self.msleep(self.sleepTimeMs)
                #Do analysis here - the info in analysisResult will be passed to Visualise_Analysis_results
                analysisResult = self.runAnalysisThisImage(self.analysisInfo,image,metadata=metadata,core=self.shared_data.core)
                # if self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
                #     analysisResult = self.changeStageAtFrame(image,metadata=metadata,core=self.shared_data.core,frame=500)
                    
                return [analysisResult,metadata]
            elif self.analysisInfo == &#39;LiveModeVisualisation&#39; or self.analysisInfo == &#39;mdaVisualisation&#39;:
                self.setPriority(self.HighestPriority) #type:ignore
                return None
            else:
                return None
        else:
            return None



    # #And here we perform the visualisation - can be fully separate from performing the analysis
    # #Initialisation is called upon creation
    # def initialise_napariLayer(self):
    #     logging.debug(&#39;init_napariLayer&#39;)
            
    # #Update ir called every time the analysis is done
    # def update_napariLayer(self,analysisInfo,image,metadata=None,core=None):
    #     self.visualisationObject.updateVisualisation(analysisInfo,image,metadata,core)
    #     # utils.realTimeAnalysis_visualisation(self.RT_analysis_object,analysisInfo,image,metadata,core)
    
    
    
    
    def initAnalysis(self):
        self.RT_analysis_object = utils.realTimeAnalysis_init(self.analysisInfo,core=self.shared_data.core,nodzInfo=self.nodzInfo)
        if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]: #type:ignore
            self.queue_visualisation = queue.Queue()
            self.visualisationObject=AnalysisThread_customFunction_Visualisation(self.RT_analysis_object,self.shared_data,analysisInfo=self.analysisInfo)
            self.visualisationObject.start()
    
    def runAnalysisThisImage(self,analysisInfo,image,metadata=None,core=None):
        self.msleep(self.sleepTimeMs)
        result = utils.realTimeAnalysis_run(self.RT_analysis_object,analysisInfo,image,metadata,core,nodzInfo=self.nodzInfo)
        
        if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]:#type:ignore
            logging.debug(&#39;Attempting RT visualisation!&#39;)
            # self.update_napariLayer(analysisInfo,image,metadata=metadata,core=core)
            if self.visualisationObject.visualisation_queue.empty():
                data = (self.RT_analysis_object,analysisInfo,image,metadata,core)
                self.visualisationObject.visualisation_queue.put(data)
                logging.debug(&#39;Put data in visualisation_queue!&#39;)
                # self.visualisationObject.process_queue()
        
        return result
    
    def endAnalysis(self,analysisInfo,core=None):
        self.msleep(self.sleepTimeMs)
        result = utils.realTimeAnalysis_end(self.RT_analysis_object,analysisInfo,core,nodzInfo=self.nodzInfo)
        
        if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]:#type:ignore
            #End the visualisation
            self.visualisationObject.running=False
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QThread</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="AnalysisClass.AnalysisThread_customFunction.analysis_done_signal"><code class="name flex">
<span>def <span class="ident">analysis_done_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroy the object.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Destroy the object.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    self.endAnalysis(self.analysisInfo,core=self.shared_data.core)
    try:
        logging.debug(&#39;Destroying &#39;+str(self.analysisInfo))
    except:
        logging.debug(&#39;Destroying some analysis thread&#39;)
    #Wait for the thread to be finished
    self.stop()
    self.requestInterruption()
    self.quit()
    #Officially we&#39;d need to wait here, but that seems to start an infinite loop somewhere
    # self.wait()
    # self.deleteLater()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.endAnalysis"><code class="name flex">
<span>def <span class="ident">endAnalysis</span></span>(<span>self, analysisInfo, core=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endAnalysis(self,analysisInfo,core=None):
    self.msleep(self.sleepTimeMs)
    result = utils.realTimeAnalysis_end(self.RT_analysis_object,analysisInfo,core,nodzInfo=self.nodzInfo)
    
    if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]:#type:ignore
        #End the visualisation
        self.visualisationObject.running=False
    return result</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.getLayer"><code class="name flex">
<span>def <span class="ident">getLayer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>napari.layers.Layer</code></dt>
<dd>The layer associated with the napari overlay.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLayer(self):
    &#34;&#34;&#34;
    Obtain the napari overlay layer (napariOverlay class) associated with this analysisThread
    
    Args:
        None

    Returns:
        napari.layers.Layer: The layer associated with the napari overlay.
    &#34;&#34;&#34;
    if self.napariOverlay is not None:
        return self.napariOverlay.getLayer()
    else:
        return None</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.initAnalysis"><code class="name flex">
<span>def <span class="ident">initAnalysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initAnalysis(self):
    self.RT_analysis_object = utils.realTimeAnalysis_init(self.analysisInfo,core=self.shared_data.core,nodzInfo=self.nodzInfo)
    if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]: #type:ignore
        self.queue_visualisation = queue.Queue()
        self.visualisationObject=AnalysisThread_customFunction_Visualisation(self.RT_analysis_object,self.shared_data,analysisInfo=self.analysisInfo)
        self.visualisationObject.start()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the function in a loop as long as <code>self.is_running</code> is True.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Runs the function in a loop as long as `self.is_running` is True.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    while not self.isInterruptionRequested():
        #Run analysis on the image from the queue
        # logging.debug(self.image_queue_analysis.get())
        self.analysis_result = self.runAnalysis(self.image_queue_analysis.get()) #type:ignore
        self.analysis_done_signal.emit(self.analysis_result)
        # self.finished.emit()
        if self.is_running == False:
            # self.finished.emit()
            return
    
    # Thread has finished, emit the finished signal
    self.finished.emit()</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.runAnalysis"><code class="name flex">
<span>def <span class="ident">runAnalysis</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the analysis on the given image based on the analysis information provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt>data, containing:</dt>
<dt><strong><code>image</code></strong> :&ensp;<code>Image</code></dt>
<dd>The image on which the analysis needs to be performed.</dd>
<dt><strong><code>metadata</code></strong></dt>
<dd>corresponding metadata</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The layer should be open before running the analysis.</li>
<li>The analysisInfo parameter should be set before calling this function.</li>
<li>If analysisInfo is 'AvgGrayValueText', the analysisResult will be the result of calcAnalysisAvgGrayValue.</li>
<li>If analysisInfo is 'GrayValueOverlay', the analysisResult will be the result of calcGrayValueOverlay.</li>
<li>If analysisInfo is 'CellSegmentOverlay', the analysisResult will be the result of calcCellSegmentOverlay.</li>
<li>If analysisInfo is not set or is invalid, the analysisResult will be None.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runAnalysis(self,data): 
    &#34;&#34;&#34;
    Runs the analysis on the given image based on the analysis information provided.

    Args:
        data, containing:
        image (Image): The image on which the analysis needs to be performed.
        metadata: corresponding metadata

    Returns:
        analysisResult (Any): The result of the analysis. The analysis result will be passed to Visualise_Analysis_results.

    Notes:
        - The layer should be open before running the analysis.
        - The analysisInfo parameter should be set before calling this function.
        - If analysisInfo is &#39;AvgGrayValueText&#39;, the analysisResult will be the result of calcAnalysisAvgGrayValue.
        - If analysisInfo is &#39;GrayValueOverlay&#39;, the analysisResult will be the result of calcGrayValueOverlay.
        - If analysisInfo is &#39;CellSegmentOverlay&#39;, the analysisResult will be the result of calcCellSegmentOverlay.
        - If analysisInfo is not set or is invalid, the analysisResult will be None.
    &#34;&#34;&#34;
    if data is not None:
        image = data[0]
        metadata = data[1]
        if self.analysisInfo is not None and self.analysisInfo != &#39;LiveModeVisualisation&#39; and self.analysisInfo != &#39;mdaVisualisation&#39;:
            self.msleep(self.sleepTimeMs)
            #Do analysis here - the info in analysisResult will be passed to Visualise_Analysis_results
            analysisResult = self.runAnalysisThisImage(self.analysisInfo,image,metadata=metadata,core=self.shared_data.core)
            # if self.analysisInfo == &#39;ChangeStageAtFrame&#39;:
            #     analysisResult = self.changeStageAtFrame(image,metadata=metadata,core=self.shared_data.core,frame=500)
                
            return [analysisResult,metadata]
        elif self.analysisInfo == &#39;LiveModeVisualisation&#39; or self.analysisInfo == &#39;mdaVisualisation&#39;:
            self.setPriority(self.HighestPriority) #type:ignore
            return None
        else:
            return None
    else:
        return None</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.runAnalysisThisImage"><code class="name flex">
<span>def <span class="ident">runAnalysisThisImage</span></span>(<span>self, analysisInfo, image, metadata=None, core=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runAnalysisThisImage(self,analysisInfo,image,metadata=None,core=None):
    self.msleep(self.sleepTimeMs)
    result = utils.realTimeAnalysis_run(self.RT_analysis_object,analysisInfo,image,metadata,core,nodzInfo=self.nodzInfo)
    
    if &#39;__realTimeVisualisation__&#39; in self.analysisInfo and self.analysisInfo[&#39;__realTimeVisualisation__&#39;]:#type:ignore
        logging.debug(&#39;Attempting RT visualisation!&#39;)
        # self.update_napariLayer(analysisInfo,image,metadata=metadata,core=core)
        if self.visualisationObject.visualisation_queue.empty():
            data = (self.RT_analysis_object,analysisInfo,image,metadata,core)
            self.visualisationObject.visualisation_queue.put(data)
            logging.debug(&#39;Put data in visualisation_queue!&#39;)
            # self.visualisationObject.process_queue()
    
    return result</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the execution of the function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    &#34;&#34;&#34;
    Stops the execution of the function
    &#34;&#34;&#34;
    self.endAnalysis(self.analysisInfo,core=self.shared_data.core)
    self.is_running = False
    #Also remove the image queue requestion from live mode
    if self.image_queue_analysis in self.shared_data.liveImageQueues:
        self.shared_data.liveImageQueues.remove(self.image_queue_analysis)
    elif self.image_queue_analysis in self.shared_data.mdaImageQueues:
        self.shared_data.mdaImageQueues.remove(self.image_queue_analysis)

    try:
        #check if there&#39;s a layer associated with this...
        # layer = self.getLayer()
        #and remove it
        self.shared_data.skipAnalysisThreadDeletion = True
        # self.shared_data.napariViewer.layers.remove(layer)
    except:
        pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction_Visualisation"><code class="flex name class">
<span>class <span class="ident">AnalysisThread_customFunction_Visualisation</span></span>
<span>(</span><span>analysisObject, shared_data, analysisInfo:Optional[str]='Random', delay=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QThread(parent: typing.Optional[QObject] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisThread_customFunction_Visualisation(QThread):
    finished = pyqtSignal()# signal to indicate that the thread has finished
    def __init__(self,analysisObject,shared_data,analysisInfo: Union[str, None] = &#39;Random&#39;,delay=None):
        super().__init__()
        #Initiate some variables
        if delay==None:
            #Get the delay of the function from the realTimeAnalysis module
            delay = utils.realTimeAnalysis_getDelay(analysisInfo,runOrVis=&#39;visualise&#39;)
            
        self.is_running = True
        self.analysis_ongoing = False
        self.shared_data = shared_data
        self.analysisInfo = analysisInfo
        self.napariViewer = shared_data.napariViewer
        self.sleepTimeMs = delay
        self.napariOverlay = napariOverlay(self.napariViewer,RT_analysisObject=analysisObject,layer_name=&#39;TestLayer_VIS&#39;)
        self.visualisation_queue = queue.Queue()
        #And start  the thread
        self.running = True
        # self.process_queue()
    
    def run(self):
        while self.running:
            logging.debug(&#39;Attempting to take from queue&#39;)
            time.sleep(self.sleepTimeMs/1000.0)
            if not self.visualisation_queue.empty():
                data = self.visualisation_queue.get()
                RT_analysis_object,analysisInfo,image,metadata,core = data
                logging.debug(&#39;Ran updateVisualisation with RT analysis object&#39;)
                self.updateVisualisation(RT_analysis_object,analysisInfo,image,metadata,core)
            
    
    def updateVisualisation(self,RT_analysis_object,analysisInfo,image,metadata=None,core=None):
        # logging.info(&#39;visualisation should be updated here :)&#39;)
        utils.realTimeAnalysis_visualisation(RT_analysis_object,analysisInfo,image,metadata,core,self.napariOverlay.layer)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QThread</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="AnalysisClass.AnalysisThread_customFunction_Visualisation.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction_Visualisation.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>run(self)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    while self.running:
        logging.debug(&#39;Attempting to take from queue&#39;)
        time.sleep(self.sleepTimeMs/1000.0)
        if not self.visualisation_queue.empty():
            data = self.visualisation_queue.get()
            RT_analysis_object,analysisInfo,image,metadata,core = data
            logging.debug(&#39;Ran updateVisualisation with RT analysis object&#39;)
            self.updateVisualisation(RT_analysis_object,analysisInfo,image,metadata,core)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.AnalysisThread_customFunction_Visualisation.updateVisualisation"><code class="name flex">
<span>def <span class="ident">updateVisualisation</span></span>(<span>self, RT_analysis_object, analysisInfo, image, metadata=None, core=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateVisualisation(self,RT_analysis_object,analysisInfo,image,metadata=None,core=None):
    # logging.info(&#39;visualisation should be updated here :)&#39;)
    utils.realTimeAnalysis_visualisation(RT_analysis_object,analysisInfo,image,metadata,core,self.napariOverlay.layer)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="AnalysisClass.napariOverlay"><code class="flex name class">
<span>class <span class="ident">napariOverlay</span></span>
<span>(</span><span>napariViewer, layer_name:Optional[str]='new Layer', colormap='gray', opacity=1, visible=True, blending='translucent', layerType=None, RT_analysisObject=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes an instance of the class with the specified <code>napariViewer</code> and <code>layer_name</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>napariViewer</code></strong> :&ensp;<code>napari.Viewer</code></dt>
<dd>The napari viewer object.</dd>
<dt><strong><code>layer_name</code></strong> :&ensp;<code>Union[str, None]</code>, optional</dt>
<dd>The name of the layer. Defaults to 'new Layer'.</dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The colormap to use. Defaults to 'gray'.</dd>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The opacity of the layer. Defaults to 1.</dd>
<dt><strong><code>visible</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the layer is visible. Defaults to True.</dd>
<dt><strong><code>blending</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The blending mode. Defaults to 'opaque', options are {'opaque', 'translucent', and 'additive'}</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class napariOverlay():
    def __init__(self,napariViewer,layer_name:Union[str,None]=&#39;new Layer&#39;,colormap=&#39;gray&#39;,opacity=1,visible=True,blending=&#39;translucent&#39;,layerType = None,RT_analysisObject=None):
        &#34;&#34;&#34;
        Initializes an instance of the class with the specified `napariViewer` and `layer_name`.

        Args:
            napariViewer (napari.Viewer): The napari viewer object.
            layer_name (Union[str, None], optional): The name of the layer. Defaults to &#39;new Layer&#39;.
            colormap (str, optional): The colormap to use. Defaults to &#39;gray&#39;.
            opacity (float, optional): The opacity of the layer. Defaults to 1.
            visible (bool, optional): Whether the layer is visible. Defaults to True.
            blending (str, optional): The blending mode. Defaults to &#39;opaque&#39;, options are {&#39;opaque&#39;, &#39;translucent&#39;, and &#39;additive&#39;}

        Returns:
            None
        &#34;&#34;&#34;
        self.napariViewer = napariViewer
        self.layer_name = layer_name
        self.colormap = colormap
        self.opacity = opacity
        self.visible = visible
        self.blending = blending
        self.RT_analysisObject = RT_analysisObject
        self.layerType = layerType
        try:
            self.layer_scale = napariViewer.layers[0].scale
        except:
            self.layer_scale = [1,1]
        
        #Get info from a RT analysis object (i.e. outside-based-analysis)
        if self.RT_analysisObject is not None:
            self.layer_name, self.layerType = self.RT_analysisObject.visualise_init()
            logging.debug(f&#34;Initialised napariOverlay with layer_name: {self.layer_name}, layerType: {self.layerType}&#34;)
            
        #Create the layer if layer_name is not none
        #layer_name is None if we only want to instantialise the napariOverlay but not get any shape
        if self.layer_name is not None:
            if self.layerType is not None:
                
                #check if a layer with this name already exists:
                if self.layer_name in napariViewer.layers:
                    self.layer = napariViewer.layers[self.layer_name]
                        
                else: #else create the layer
                    if self.layerType == &#39;image&#39;:
                        self.layer = napariViewer.add_image(name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;labels&#39;:
                        self.layer = napariViewer.add_labels([],name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;points&#39;:
                        self.layer = napariViewer.add_points(name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;shapes&#39;:
                        self.layer = napariViewer.add_shapes(name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;surface&#39;:
                        self.layer = napariViewer.add_surface([],name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;tracks&#39;:
                        self.layer = napariViewer.add_tracks([],name=self.layer_name,scale=self.layer_scale)
                    elif self.layerType == &#39;vectors&#39;:
                        self.layer = napariViewer.add_vectors(name=self.layer_name,scale=self.layer_scale)
            else: #Fallback if no layer type is specified at all
                self.layer = napariViewer.add_shapes(name=self.layer_name,scale=self.layer_scale)
        
            logging.debug(f&#34;Using layer {self.layer}&#34;)
        
    #Update the name of the overlay
    def changeName(self,new_name):
        &#34;&#34;&#34;
        Change the name of the napariOverlay

        Args:
            new_name (str): The new name for the napariOverlay.

        Returns:
            None
        &#34;&#34;&#34;
        self.layer_name = new_name
        self.layer.name = self.layer_name
        #Return the layer
        
    def getLayer(self):
        &#34;&#34;&#34;
        Returns the layer attribute of the object.

        Args:
            None

        Returns:
            layer (object or None): The layer attribute of the object if it exists, None otherwise.
        &#34;&#34;&#34;
        if hasattr(self, &#39;layer&#39;):
            return self.layer
        else:
            return None
        
    #Initialise drawing a text overly (single string of text)
    def drawTextOverlay_init(self):
        &#34;&#34;&#34;
        Initializes the text overlay for drawing text on the napari viewer.

        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        polygons = [np.array([[0, 0], [0, 1], [1, 1], [1, 0]])]
        # create properties
        properties = {&#39;value&#39;: [0]}
        text_properties = {&#39;text&#39;: &#39;{value:0.1f}&#39;,&#39;anchor&#39;: &#39;upper_left&#39;,&#39;translation&#39;: [-5, 0],&#39;size&#39;: 8,&#39;color&#39;: &#39;green&#39;,}
        #Remove old layer
        napariViewer.layers.remove(self.layer)
        # new layer with polygons and text
        self.layer = napariViewer.add_shapes(polygons,properties=properties,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;,text=text_properties,name=self.layer_name,scale=self.layer_scale,opacity = self.opacity,visible=self.visible)
    
    #Update routine for drawing a text overly (single string of text)
    def drawTextOverlay(self,text=&#39;&#39;,pos=[0,0],textCol=&#39;red&#39;,textSize=8):
        &#34;&#34;&#34;
        Running loop to draw/update the text overlay. Requires drawTextOverlay_init to be ran beforehand

        Args:
            text (str): The text to be displayed on the overlay. Defaults to an empty string.
            pos ([int of size (2,1)]): The position of the overlay on the image. Defaults to [0, 0].
            textCol (str): The color of the text. Defaults to &#39;red&#39;.
            textSize (int): The size of the text. Defaults to 8.

        Returns:
            None
        &#34;&#34;&#34;
        # Update the properties - this contains the text
        new_properties = {&#39;text&#39;: np.array([text]).astype(object)}
        self.layer.properties = new_properties
        #update the polygon - this contains the position
        pseudo_size = 0.1
        polygons = [np.array([[pos[0], pos[1]], [pos[0]+pseudo_size, pos[1]], [pos[0]+pseudo_size, pos[1]+pseudo_size], [pos[0], pos[1]+pseudo_size]])]
        #Remove the old polygon
        self.layer.data = []
        # add the new polygon
        self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;)
        #Update the text surrounding the invisible shape
        text_properties = {&#39;text&#39;: &#39;{text}&#39;,&#39;anchor&#39;: &#39;upper_left&#39;,&#39;translation&#39;: [0, 0],&#39;size&#39;: textSize,&#39;color&#39;: textCol}
        self.layer.text = text_properties
        
    #Initialise an overlay that only has shapes
    def shapesOverlay_init(self):
        &#34;&#34;&#34;
        Initialise an overlay that only draws shapes.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        #Initialise an overlay that only has shapes
        #Create a single shape (polygon) and show it
        polygons = [np.array([[225, 146], [283, 146], [283, 211], [225, 211]])]
        #Remove old layer
        self.napariViewer.layers.remove(self.layer)
        # new layer with polygons and text
        self.layer = self.napariViewer.add_shapes(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;,name=self.layer_name,scale=self.layer_scale,opacity = self.opacity,visible=self.visible)
    
    #Update routine for an overlay that only has shapes
    def drawSquaresOverlay(self,shapePosList = [[0,0,10,10]],shapeCol: List[Union[str, Tuple[float, float, float]]] = [&#39;black&#39;]):
        &#34;&#34;&#34;
        Running loop to draw/update and overlay with one or multiple rectangles. Requires shapesOverlay_init to be ran beforehand

        Args:
            shapePosList (List[List[int]]): A list of shape positions in the format [[x, y, w, h], [x, y, w, h], ...].
                Default is [[0, 0, 10, 10]].
            shapeCol (List[Union[str, Tuple[float, float, float]]]): A single entry or an array with the same size as shapePosList.
                Default is [&#39;black&#39;].

        Returns:
            None
        &#34;&#34;&#34;        
        #Update the shapes
        polygons = []
        for p in range(len(shapePosList)):
            polygons.append(np.array([[shapePosList[p][0], shapePosList[p][1]], [shapePosList[p][0]+shapePosList[p][2], shapePosList[p][1]], [shapePosList[p][0]+shapePosList[p][2], shapePosList[p][1]+shapePosList[p][3]], [shapePosList[p][0], shapePosList[p][1]+shapePosList[p][3]]]))
        #Remove the old polygon
        self.layer.data = []
        # add the new polygon
        if len(shapeCol) == 1:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol[0])
        else:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol)
    
    #Update routine for an overlay that only has shapes
    def drawShapesOverlay(self,shapePosList = [[0,0],[0,10],[10,10],[10,0]],shapeCol: List[Union[str, Tuple[float, float, float]]] = [&#39;black&#39;]):
        &#34;&#34;&#34;
        Running loop to draw arbitrary-shaped polygon shapes. Requires shapesOverlay_init to be ran beforehand

        Args:
            shapePosList (List[List[float]]): A list of shape positions. A [[x1-1,y1-1],[x1-2,y1-2],...],[[x2-1,y2-1],[x2-2,y2-2],...] array of size [n,2,m], drawing m shapes with n points each. Default is [[0,0],[0,10],[10,10],[10,0]].
            shapeCol (List[Union[str, Tuple[float, float, float]]]): A list of shape colors. Default is [&#39;black&#39;].

        Returns:
            None
        &#34;&#34;&#34;
        #Update the shapes
        polygons = []
        for p in range((shapePosList.shape[2])):
            polygons.append(shapePosList[:,:,p])
        #Remove the old polygon
        self.layer.data = []
        # add the new polygon
        if len(shapeCol) == 1:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol[0])
        else:
            self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol)
    
    #Initialise an overlay that only shows an image
    def imageOverlay_init(self,opacity=None,visible=None,blending=None,colormap=None):
        &#34;&#34;&#34;
        Initialize a napari overlay that only draws an image

        Args:
            opacity (float, optional): The opacity of the layer. If None, the value will be taken from self.opacity.
            visible (bool, optional): Whether the layer is visible. If None, the value will be taken from self.visible.
            blending (str, optional): The blending mode. If None, the value will be taken from self.blending.
            colormap (str, optional): The colormap to use. If None, the value will be taken from self.colormap.
        
        Returns:
            None
        &#34;&#34;&#34;
        # Assign values from self if the corresponding argument is None
        self.opacity = self.opacity if opacity is None else opacity
        self.visible = self.visible if visible is None else visible
        self.blending = self.blending if blending is None else blending
        self.colormap = self.colormap if colormap is None else colormap
        #Load image
        im = np.random.random((300, 300))
        #Remove old layer
        self.napariViewer.layers.remove(self.layer)
        # new layer with polygons and text
        self.layer = self.napariViewer.add_image(im,scale=self.layer_scale,opacity = self.opacity,visible=self.visible,blending=self.blending,colormap=self.colormap)
        
    #Update an overlay that shows an image
    def drawImageOverlay(self,im=np.zeros((300,300))):
        &#34;&#34;&#34;
        Running loop to draw an image as napari overlay. Requires imageOverlay_init to be ran beforehand

        Parameters:
            im (numpy.ndarray): The image to be overlaid. Default is np.zeros((300, 300)).

        Returns:
            None
        &#34;&#34;&#34;
        #Remove the old image
        self.layer.data = np.ones(np.shape(self.layer.data))
        #Update the image
        self.layer.data = im
        
    def destroy(self):
        &#34;&#34;&#34;
        Deletes the instance of the class.
        &#34;&#34;&#34;
        del self</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="AnalysisClass.napariOverlay.changeName"><code class="name flex">
<span>def <span class="ident">changeName</span></span>(<span>self, new_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the name of the napariOverlay</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The new name for the napariOverlay.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeName(self,new_name):
    &#34;&#34;&#34;
    Change the name of the napariOverlay

    Args:
        new_name (str): The new name for the napariOverlay.

    Returns:
        None
    &#34;&#34;&#34;
    self.layer_name = new_name
    self.layer.name = self.layer_name
    #Return the layer</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the instance of the class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
    Deletes the instance of the class.
    &#34;&#34;&#34;
    del self</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.drawImageOverlay"><code class="name flex">
<span>def <span class="ident">drawImageOverlay</span></span>(<span>self, im=array([[0., 0., 0., ..., 0., 0., 0.],
[0., 0., 0., ..., 0., 0., 0.],
[0., 0., 0., ..., 0., 0., 0.],
...,
[0., 0., 0., ..., 0., 0., 0.],
[0., 0., 0., ..., 0., 0., 0.],
[0., 0., 0., ..., 0., 0., 0.]]))</span>
</code></dt>
<dd>
<div class="desc"><p>Running loop to draw an image as napari overlay. Requires imageOverlay_init to be ran beforehand</p>
<h2 id="parameters">Parameters</h2>
<p>im (numpy.ndarray): The image to be overlaid. Default is np.zeros((300, 300)).</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawImageOverlay(self,im=np.zeros((300,300))):
    &#34;&#34;&#34;
    Running loop to draw an image as napari overlay. Requires imageOverlay_init to be ran beforehand

    Parameters:
        im (numpy.ndarray): The image to be overlaid. Default is np.zeros((300, 300)).

    Returns:
        None
    &#34;&#34;&#34;
    #Remove the old image
    self.layer.data = np.ones(np.shape(self.layer.data))
    #Update the image
    self.layer.data = im</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.drawShapesOverlay"><code class="name flex">
<span>def <span class="ident">drawShapesOverlay</span></span>(<span>self, shapePosList=[[0, 0], [0, 10], [10, 10], [10, 0]], shapeCol:List[Union[str,Tuple[float,float,float]]]=['black'])</span>
</code></dt>
<dd>
<div class="desc"><p>Running loop to draw arbitrary-shaped polygon shapes. Requires shapesOverlay_init to be ran beforehand</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shapePosList</code></strong> :&ensp;<code>List[List[float]]</code></dt>
<dd>A list of shape positions. A [[x1-1,y1-1],[x1-2,y1-2],&hellip;],[[x2-1,y2-1],[x2-2,y2-2],&hellip;] array of size [n,2,m], drawing m shapes with n points each. Default is [[0,0],[0,10],[10,10],[10,0]].</dd>
<dt><strong><code>shapeCol</code></strong> :&ensp;<code>List[Union[str, Tuple[float, float, float]]]</code></dt>
<dd>A list of shape colors. Default is ['black'].</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawShapesOverlay(self,shapePosList = [[0,0],[0,10],[10,10],[10,0]],shapeCol: List[Union[str, Tuple[float, float, float]]] = [&#39;black&#39;]):
    &#34;&#34;&#34;
    Running loop to draw arbitrary-shaped polygon shapes. Requires shapesOverlay_init to be ran beforehand

    Args:
        shapePosList (List[List[float]]): A list of shape positions. A [[x1-1,y1-1],[x1-2,y1-2],...],[[x2-1,y2-1],[x2-2,y2-2],...] array of size [n,2,m], drawing m shapes with n points each. Default is [[0,0],[0,10],[10,10],[10,0]].
        shapeCol (List[Union[str, Tuple[float, float, float]]]): A list of shape colors. Default is [&#39;black&#39;].

    Returns:
        None
    &#34;&#34;&#34;
    #Update the shapes
    polygons = []
    for p in range((shapePosList.shape[2])):
        polygons.append(shapePosList[:,:,p])
    #Remove the old polygon
    self.layer.data = []
    # add the new polygon
    if len(shapeCol) == 1:
        self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol[0])
    else:
        self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.drawSquaresOverlay"><code class="name flex">
<span>def <span class="ident">drawSquaresOverlay</span></span>(<span>self, shapePosList=[[0, 0, 10, 10]], shapeCol:List[Union[str,Tuple[float,float,float]]]=['black'])</span>
</code></dt>
<dd>
<div class="desc"><p>Running loop to draw/update and overlay with one or multiple rectangles. Requires shapesOverlay_init to be ran beforehand</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shapePosList</code></strong> :&ensp;<code>List[List[int]]</code></dt>
<dd>A list of shape positions in the format [[x, y, w, h], [x, y, w, h], &hellip;].
Default is [[0, 0, 10, 10]].</dd>
<dt><strong><code>shapeCol</code></strong> :&ensp;<code>List[Union[str, Tuple[float, float, float]]]</code></dt>
<dd>A single entry or an array with the same size as shapePosList.
Default is ['black'].</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawSquaresOverlay(self,shapePosList = [[0,0,10,10]],shapeCol: List[Union[str, Tuple[float, float, float]]] = [&#39;black&#39;]):
    &#34;&#34;&#34;
    Running loop to draw/update and overlay with one or multiple rectangles. Requires shapesOverlay_init to be ran beforehand

    Args:
        shapePosList (List[List[int]]): A list of shape positions in the format [[x, y, w, h], [x, y, w, h], ...].
            Default is [[0, 0, 10, 10]].
        shapeCol (List[Union[str, Tuple[float, float, float]]]): A single entry or an array with the same size as shapePosList.
            Default is [&#39;black&#39;].

    Returns:
        None
    &#34;&#34;&#34;        
    #Update the shapes
    polygons = []
    for p in range(len(shapePosList)):
        polygons.append(np.array([[shapePosList[p][0], shapePosList[p][1]], [shapePosList[p][0]+shapePosList[p][2], shapePosList[p][1]], [shapePosList[p][0]+shapePosList[p][2], shapePosList[p][1]+shapePosList[p][3]], [shapePosList[p][0], shapePosList[p][1]+shapePosList[p][3]]]))
    #Remove the old polygon
    self.layer.data = []
    # add the new polygon
    if len(shapeCol) == 1:
        self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol[0])
    else:
        self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=shapeCol)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.drawTextOverlay"><code class="name flex">
<span>def <span class="ident">drawTextOverlay</span></span>(<span>self, text='', pos=[0, 0], textCol='red', textSize=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Running loop to draw/update the text overlay. Requires drawTextOverlay_init to be ran beforehand</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to be displayed on the overlay. Defaults to an empty string.</dd>
<dt>pos ([int of size (2,1)]): The position of the overlay on the image. Defaults to [0, 0].</dt>
<dt><strong><code>textCol</code></strong> :&ensp;<code>str</code></dt>
<dd>The color of the text. Defaults to 'red'.</dd>
<dt><strong><code>textSize</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the text. Defaults to 8.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawTextOverlay(self,text=&#39;&#39;,pos=[0,0],textCol=&#39;red&#39;,textSize=8):
    &#34;&#34;&#34;
    Running loop to draw/update the text overlay. Requires drawTextOverlay_init to be ran beforehand

    Args:
        text (str): The text to be displayed on the overlay. Defaults to an empty string.
        pos ([int of size (2,1)]): The position of the overlay on the image. Defaults to [0, 0].
        textCol (str): The color of the text. Defaults to &#39;red&#39;.
        textSize (int): The size of the text. Defaults to 8.

    Returns:
        None
    &#34;&#34;&#34;
    # Update the properties - this contains the text
    new_properties = {&#39;text&#39;: np.array([text]).astype(object)}
    self.layer.properties = new_properties
    #update the polygon - this contains the position
    pseudo_size = 0.1
    polygons = [np.array([[pos[0], pos[1]], [pos[0]+pseudo_size, pos[1]], [pos[0]+pseudo_size, pos[1]+pseudo_size], [pos[0], pos[1]+pseudo_size]])]
    #Remove the old polygon
    self.layer.data = []
    # add the new polygon
    self.layer.add(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;)
    #Update the text surrounding the invisible shape
    text_properties = {&#39;text&#39;: &#39;{text}&#39;,&#39;anchor&#39;: &#39;upper_left&#39;,&#39;translation&#39;: [0, 0],&#39;size&#39;: textSize,&#39;color&#39;: textCol}
    self.layer.text = text_properties</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.drawTextOverlay_init"><code class="name flex">
<span>def <span class="ident">drawTextOverlay_init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the text overlay for drawing text on the napari viewer.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawTextOverlay_init(self):
    &#34;&#34;&#34;
    Initializes the text overlay for drawing text on the napari viewer.

    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    polygons = [np.array([[0, 0], [0, 1], [1, 1], [1, 0]])]
    # create properties
    properties = {&#39;value&#39;: [0]}
    text_properties = {&#39;text&#39;: &#39;{value:0.1f}&#39;,&#39;anchor&#39;: &#39;upper_left&#39;,&#39;translation&#39;: [-5, 0],&#39;size&#39;: 8,&#39;color&#39;: &#39;green&#39;,}
    #Remove old layer
    napariViewer.layers.remove(self.layer)
    # new layer with polygons and text
    self.layer = napariViewer.add_shapes(polygons,properties=properties,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;,text=text_properties,name=self.layer_name,scale=self.layer_scale,opacity = self.opacity,visible=self.visible)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.getLayer"><code class="name flex">
<span>def <span class="ident">getLayer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the layer attribute of the object.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>layer (object or None): The layer attribute of the object if it exists, None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLayer(self):
    &#34;&#34;&#34;
    Returns the layer attribute of the object.

    Args:
        None

    Returns:
        layer (object or None): The layer attribute of the object if it exists, None otherwise.
    &#34;&#34;&#34;
    if hasattr(self, &#39;layer&#39;):
        return self.layer
    else:
        return None</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.imageOverlay_init"><code class="name flex">
<span>def <span class="ident">imageOverlay_init</span></span>(<span>self, opacity=None, visible=None, blending=None, colormap=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a napari overlay that only draws an image</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>opacity</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The opacity of the layer. If None, the value will be taken from self.opacity.</dd>
<dt><strong><code>visible</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the layer is visible. If None, the value will be taken from self.visible.</dd>
<dt><strong><code>blending</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The blending mode. If None, the value will be taken from self.blending.</dd>
<dt><strong><code>colormap</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The colormap to use. If None, the value will be taken from self.colormap.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imageOverlay_init(self,opacity=None,visible=None,blending=None,colormap=None):
    &#34;&#34;&#34;
    Initialize a napari overlay that only draws an image

    Args:
        opacity (float, optional): The opacity of the layer. If None, the value will be taken from self.opacity.
        visible (bool, optional): Whether the layer is visible. If None, the value will be taken from self.visible.
        blending (str, optional): The blending mode. If None, the value will be taken from self.blending.
        colormap (str, optional): The colormap to use. If None, the value will be taken from self.colormap.
    
    Returns:
        None
    &#34;&#34;&#34;
    # Assign values from self if the corresponding argument is None
    self.opacity = self.opacity if opacity is None else opacity
    self.visible = self.visible if visible is None else visible
    self.blending = self.blending if blending is None else blending
    self.colormap = self.colormap if colormap is None else colormap
    #Load image
    im = np.random.random((300, 300))
    #Remove old layer
    self.napariViewer.layers.remove(self.layer)
    # new layer with polygons and text
    self.layer = self.napariViewer.add_image(im,scale=self.layer_scale,opacity = self.opacity,visible=self.visible,blending=self.blending,colormap=self.colormap)</code></pre>
</details>
</dd>
<dt id="AnalysisClass.napariOverlay.shapesOverlay_init"><code class="name flex">
<span>def <span class="ident">shapesOverlay_init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise an overlay that only draws shapes.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapesOverlay_init(self):
    &#34;&#34;&#34;
    Initialise an overlay that only draws shapes.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    #Initialise an overlay that only has shapes
    #Create a single shape (polygon) and show it
    polygons = [np.array([[225, 146], [283, 146], [283, 211], [225, 211]])]
    #Remove old layer
    self.napariViewer.layers.remove(self.layer)
    # new layer with polygons and text
    self.layer = self.napariViewer.add_shapes(polygons,shape_type=&#39;polygon&#39;,edge_color=&#39;transparent&#39;,face_color=&#39;transparent&#39;,name=self.layer_name,scale=self.layer_scale,opacity = self.opacity,visible=self.visible)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AnalysisClass.create_analysis_thread" href="#AnalysisClass.create_analysis_thread">create_analysis_thread</a></code></li>
<li><code><a title="AnalysisClass.create_real_time_analysis_thread" href="#AnalysisClass.create_real_time_analysis_thread">create_real_time_analysis_thread</a></code></li>
<li><code><a title="AnalysisClass.is_pip_installed" href="#AnalysisClass.is_pip_installed">is_pip_installed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AnalysisClass.AnalysisThread" href="#AnalysisClass.AnalysisThread">AnalysisThread</a></code></h4>
<ul class="">
<li><code><a title="AnalysisClass.AnalysisThread.analysis_done_signal" href="#AnalysisClass.AnalysisThread.analysis_done_signal">analysis_done_signal</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.calcAnalysisAvgGrayValue" href="#AnalysisClass.AnalysisThread.calcAnalysisAvgGrayValue">calcAnalysisAvgGrayValue</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.calcGrayValueOverlay" href="#AnalysisClass.AnalysisThread.calcGrayValueOverlay">calcGrayValueOverlay</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.changeStageAtFrame" href="#AnalysisClass.AnalysisThread.changeStageAtFrame">changeStageAtFrame</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.destroy" href="#AnalysisClass.AnalysisThread.destroy">destroy</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.finished" href="#AnalysisClass.AnalysisThread.finished">finished</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.getLayer" href="#AnalysisClass.AnalysisThread.getLayer">getLayer</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.initAvgGrayValueText" href="#AnalysisClass.AnalysisThread.initAvgGrayValueText">initAvgGrayValueText</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.initChangeStageAtFrame" href="#AnalysisClass.AnalysisThread.initChangeStageAtFrame">initChangeStageAtFrame</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.initGrayScaleImageOverlay" href="#AnalysisClass.AnalysisThread.initGrayScaleImageOverlay">initGrayScaleImageOverlay</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.initRandomOverlay" href="#AnalysisClass.AnalysisThread.initRandomOverlay">initRandomOverlay</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.initialise_napariLayer" href="#AnalysisClass.AnalysisThread.initialise_napariLayer">initialise_napariLayer</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.outlineCoordinatesToImage" href="#AnalysisClass.AnalysisThread.outlineCoordinatesToImage">outlineCoordinatesToImage</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.run" href="#AnalysisClass.AnalysisThread.run">run</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.runAnalysis" href="#AnalysisClass.AnalysisThread.runAnalysis">runAnalysis</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.stop" href="#AnalysisClass.AnalysisThread.stop">stop</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.update_napariLayer" href="#AnalysisClass.AnalysisThread.update_napariLayer">update_napariLayer</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.visualiseAvgGrayValueText" href="#AnalysisClass.AnalysisThread.visualiseAvgGrayValueText">visualiseAvgGrayValueText</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.visualiseGrayScaleImageOverlay" href="#AnalysisClass.AnalysisThread.visualiseGrayScaleImageOverlay">visualiseGrayScaleImageOverlay</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread.visualiseRandomOverlay" href="#AnalysisClass.AnalysisThread.visualiseRandomOverlay">visualiseRandomOverlay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AnalysisClass.AnalysisThread_customFunction" href="#AnalysisClass.AnalysisThread_customFunction">AnalysisThread_customFunction</a></code></h4>
<ul class="">
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.analysis_done_signal" href="#AnalysisClass.AnalysisThread_customFunction.analysis_done_signal">analysis_done_signal</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.destroy" href="#AnalysisClass.AnalysisThread_customFunction.destroy">destroy</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.endAnalysis" href="#AnalysisClass.AnalysisThread_customFunction.endAnalysis">endAnalysis</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.finished" href="#AnalysisClass.AnalysisThread_customFunction.finished">finished</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.getLayer" href="#AnalysisClass.AnalysisThread_customFunction.getLayer">getLayer</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.initAnalysis" href="#AnalysisClass.AnalysisThread_customFunction.initAnalysis">initAnalysis</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.run" href="#AnalysisClass.AnalysisThread_customFunction.run">run</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.runAnalysis" href="#AnalysisClass.AnalysisThread_customFunction.runAnalysis">runAnalysis</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.runAnalysisThisImage" href="#AnalysisClass.AnalysisThread_customFunction.runAnalysisThisImage">runAnalysisThisImage</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction.stop" href="#AnalysisClass.AnalysisThread_customFunction.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AnalysisClass.AnalysisThread_customFunction_Visualisation" href="#AnalysisClass.AnalysisThread_customFunction_Visualisation">AnalysisThread_customFunction_Visualisation</a></code></h4>
<ul class="">
<li><code><a title="AnalysisClass.AnalysisThread_customFunction_Visualisation.finished" href="#AnalysisClass.AnalysisThread_customFunction_Visualisation.finished">finished</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction_Visualisation.run" href="#AnalysisClass.AnalysisThread_customFunction_Visualisation.run">run</a></code></li>
<li><code><a title="AnalysisClass.AnalysisThread_customFunction_Visualisation.updateVisualisation" href="#AnalysisClass.AnalysisThread_customFunction_Visualisation.updateVisualisation">updateVisualisation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="AnalysisClass.napariOverlay" href="#AnalysisClass.napariOverlay">napariOverlay</a></code></h4>
<ul class="">
<li><code><a title="AnalysisClass.napariOverlay.changeName" href="#AnalysisClass.napariOverlay.changeName">changeName</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.destroy" href="#AnalysisClass.napariOverlay.destroy">destroy</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.drawImageOverlay" href="#AnalysisClass.napariOverlay.drawImageOverlay">drawImageOverlay</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.drawShapesOverlay" href="#AnalysisClass.napariOverlay.drawShapesOverlay">drawShapesOverlay</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.drawSquaresOverlay" href="#AnalysisClass.napariOverlay.drawSquaresOverlay">drawSquaresOverlay</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.drawTextOverlay" href="#AnalysisClass.napariOverlay.drawTextOverlay">drawTextOverlay</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.drawTextOverlay_init" href="#AnalysisClass.napariOverlay.drawTextOverlay_init">drawTextOverlay_init</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.getLayer" href="#AnalysisClass.napariOverlay.getLayer">getLayer</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.imageOverlay_init" href="#AnalysisClass.napariOverlay.imageOverlay_init">imageOverlay_init</a></code></li>
<li><code><a title="AnalysisClass.napariOverlay.shapesOverlay_init" href="#AnalysisClass.napariOverlay.shapesOverlay_init">shapesOverlay_init</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>