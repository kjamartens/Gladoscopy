<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MMcontrols API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MMcontrols</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PyQt5.QtWidgets import QLayout, QLineEdit, QFrame, QGridLayout, QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QComboBox, QSpacerItem, QSizePolicy, QSlider, QCheckBox, QGroupBox, QVBoxLayout, QFileDialog, QRadioButton, QStackedWidget, QTableWidget, QWidget, QInputDialog, QTableWidgetItem
from PyQt5.QtCore import Qt, pyqtSignal, QObject, QThread, QCoreApplication, QSize, pyqtSignal
from PyQt5.QtGui import QResizeEvent, QIcon, QPixmap, QFont, QDoubleValidator, QIntValidator
from PyQt5 import uic
import sys
import os
import json
from pycromanager import Core, multi_d_acquisition_events, Acquisition
import numpy as np
import time
import asyncio
import pyqtgraph as pg
import matplotlib.pyplot as plt
from matplotlib import colormaps # type: ignore
import matplotlib
import pickle
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure
import tifffile
import time
from PyQt5.QtCore import QTimer,QDateTime
import logging
from typing import List, Iterable
import itertools
import queue

#For drawing
matplotlib.use(&#39;Qt5Agg&#39;)

def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__

if is_pip_installed():
    from glados_pycromanager.GUI.utils import CustomMainWindow
    from glados_pycromanager.GUI.AnalysisClass import *
    from glados_pycromanager.GUI.napariHelperFunctions import getLayerIdFromName, InitateNapariUI, checkIfLayerExistsOrCreate, addToExistingOrNewLayer, moveLayerToTop

else:
    from utils import CustomMainWindow
    from AnalysisClass import *
    from napariHelperFunctions import getLayerIdFromName, InitateNapariUI, checkIfLayerExistsOrCreate, addToExistingOrNewLayer, moveLayerToTop
class ConfigInfo:
    &#34;&#34;&#34;
    This class contains information about a pycromanager config group
    Contains info such as name, min/max value etc
    &#34;&#34;&#34;
    def __init__(self,core,config_group_id):
        &#34;&#34;&#34;
        This class contains information about a pycromanager config group
        Contains info such as name, min/max value etc
        
        Attributes:
            core (Core): The pycromanager core object
            config_group_id (int): The id of the config group
        &#34;&#34;&#34;
        self.core = core
        self.config_group_id = config_group_id
        pass
    
    def configGroupName(self):
        &#34;&#34;&#34;
        Returns the config group name
        &#34;&#34;&#34;
        return self.core.get_available_config_groups().get(self.config_group_id)
    
    def nrConfigs(self):
        &#34;&#34;&#34;Returns the number of config options for this config group&#34;&#34;&#34;
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).size()
    
    def configName(self,config_id):
        &#34;&#34;&#34;Returns the name of the config within the config group&#34;&#34;&#34;
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).get(config_id)
    
    def deviceNameProperty_fromVerbose(self):
        &#34;&#34;&#34;Returns the first device name and property from Verbose&#34;&#34;&#34;
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        start_index = verboseInfoCurrentConfigGroup.find(&#34;&lt;html&gt;&#34;) + len(&#34;&lt;html&gt;&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;:&#34;)
        deviceName = verboseInfoCurrentConfigGroup[start_index:end_index]
        start_index = end_index + len(&#34;:&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;=&#34;)
        deviceProperty  = verboseInfoCurrentConfigGroup[start_index:end_index]
        return deviceName,deviceProperty
    
    def hasPropertyLimits(self):
        &#34;&#34;&#34;Returns whether the config group has property limits&#34;&#34;&#34;
        #Get the verbose info from the config group state
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        #Determine the number of devices in the verbose info
        nrDevicesFromVerbose = verboseInfoCurrentConfigGroup.count(&#39;&lt;br&gt;&#39;)
        if nrDevicesFromVerbose == 1 and self.nrConfigs() == 1:
            [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
            #Determines whether the device name/property has limits:
            if self.core.has_property_limits(deviceName,deviceProperty):
                return True
            else:
                return False
        else:
            return False
    
    def lowerLimit(self):
        &#34;&#34;&#34;Finds lower limit of the device property&#34;&#34;&#34;
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            lowerLimit = self.core.get_property_lower_limit(deviceName,deviceProperty)
        else:
            lowerLimit = 0
        return lowerLimit
            
    def upperLimit(self):
        &#34;&#34;&#34;Finds upper limit of the device property&#34;&#34;&#34;
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            upperLimit = self.core.get_property_upper_limit(deviceName,deviceProperty)
        else:
            upperLimit = 0
        return upperLimit
            
    def isDropDown(self):
        &#34;&#34;&#34;Returns Boolean whether the config group should be represented as a drop-down menu&#34;&#34;&#34;
        if self.nrConfigs()&gt;1:
            return True
        else:
            #If there is exactly one option...
            if self.nrConfigs() == 1:
                #And the option is &#39;NewPreset&#39;, it means there are no presets specified
                if self.core.get_available_configs(self.configGroupName()).get(0) == &#39;NewPreset&#39;:
                    return False
                else:
                    return True
        
    def isSlider(self):
        &#34;&#34;&#34;Returns Boolean whether the config group should be represented as a slider&#34;&#34;&#34;
        if self.nrConfigs()&gt;1:
            return False
        else:
            if self.hasPropertyLimits():
                return True
            else:
                return False
    
    def isInputField(self):
        &#34;&#34;&#34;Returns Boolean whether the config group should be represented as an input field&#34;&#34;&#34;
        if self.nrConfigs()&gt;1:
            return False
        else:
            #If there is exactly one option...
            if self.nrConfigs() == 1:
                #And the option is &#39;NewPreset&#39;, it means there are no presets specified
                if self.core.get_available_configs(self.configGroupName()).get(0) == &#39;NewPreset&#39;:
                    #check if it&#39;s not a slider...
                    if self.hasPropertyLimits():
                        return False
                    else:
                        return True
                else:
                    return False

    def helpStringInfo(self):
        &#34;&#34;&#34;Provides some info about the config group, whether it should be a dropdown, slider, input field&#34;&#34;&#34;
        infostring=&#39;No option for this config&#39;
        if self.isDropDown():
            infostring = &#34;Device {} should be an dropdown with {} options&#34;.format(self.configGroupName(),self.nrConfigs())
        if self.isSlider():
            infostring = &#34;Device {} should be an Slider with limits {}-{}&#34;.format(self.configGroupName(),self.lowerLimit(),self.upperLimit())
        if self.isInputField():
            infostring = &#34;Device {} should be an input field&#34;.format(self.configGroupName())
        return infostring
    
    def getCurrentMMValue(self):
        &#34;&#34;&#34;Get the current MM value of this config group:&#34;&#34;&#34;
        return self.core.get_current_config(self.configGroupName())

    def getStorableValue(self):
        &#34;&#34;&#34;Get the current MM value of this config group, in a storable manner - i.e. depending on slider, input, dropdown:&#34;&#34;&#34;
        if self.isDropDown():
            return self.core.get_current_config(self.configGroupName())
        if self.isSlider():
            #A slider config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.configGroupName()
            underlyingProperty = self.core.get_available_configs(configGroupName).get(0)
            configdata = self.core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()
            
            #Finally we get the current value of the slider
            currentSliderValue = float(self.core.get_property(device_label,property_name))
            return currentSliderValue
        if self.isInputField():
            #An input field config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.configGroupName()
            underlyingProperty = self.core.get_available_configs(configGroupName).get(0)
            configdata = self.core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()
            
            #Finally we get the current value of the slider
            try:
                currentValue = (self.core.get_property(device_label,property_name))
            except:
                currentValue = 0
            return currentValue
        

class MMConfigUI(CustomMainWindow):
    &#34;&#34;&#34;
        A class to create a MicroManager config UI
    &#34;&#34;&#34;
    def __init__(self, config_groups,parent=None,showConfigs = True,showStages=True,showROIoptions=True,showShutterOptions=True,showLiveSnapExposureButtons=True,number_config_columns=5,changes_update_MM = True,showCheckboxes = False,checkboxStartInactive=True,showRelativeStages = False,autoSaveLoad=False):
        &#34;&#34;&#34;
        A class to create a MicroManager config UI with the given configuration groups.
        
        This class will create a UI with a layout of checkboxes, sliders, input fields, dropdowns, etc
        The user can select which config groups to show and which configs to show for each config group. The user can also change the configs real-time. 
        
        Parameters:
            config_groups (list): A list of configuration groups. Get this as follows:
                nrconfiggroups = core.get_available_config_groups().size()
                for config_group_id in range(nrconfiggroups):
                    allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
            showConfigs (bool, optional): Whether to show the configurations in the UI. Defaults to True.
            showStages (bool, optional): Whether to show the stages in the UI. Defaults to True.
            showROIoptions (bool, optional): Whether to show the ROI options in the UI. Defaults to True.
            showShutterOptions (bool, optional): Whether to show the Shutter options in the UI. Defaults to True.
            showLiveSnapExposureButtons (bool, optional): Whether to show the live mode in the UI. Defaults to True.
            number_config_columns (int, optional): The number of columns in the layout. Defaults to 5.
            changes_update_MM (bool, optional): Whether to update the configs in MicroManager real-time. Defaults to True.
            showCheckboxes (bool, optional): Whether to show checkboxes for each config group. Defaults to False.
            checkboxStartInactive (bool, optional): Whether the checkboxes should start inactive. Defaults to True.
            showRelativeStages (bool, optional): Whether to show the relative stages in the UI. Defaults to False.
            autoSaveLoad (bool, optional): Whether to automatically save and load the configs to file when the UI is opened and closed. Defaults to False. 
        &#34;&#34;&#34;
        
        if parent is not None:# from napari plugin run
            global core, livestate, napariViewer, shared_data
            core = parent.core
            livestate = parent.livestate
            shared_data = parent.shared_data
            napariViewer = parent.napariViewer
            shared_data.napariViewer = napariViewer
        else: #assuming shared_data is global - from .py run
            try:
                # global core, napariViewer
                core = shared_data.core
                napariViewer = shared_data.napariViewer
            except:
                logging.error(&#39;Line 237 fails&#39;)
        super().__init__()
        self.fullyLoaded = False
        self.autoSaveLoad = autoSaveLoad
        self.showConfigs = showConfigs
        self.showStages = showStages
        self.showROIoptions = showROIoptions
        self.showShutterOptions = showShutterOptions
        self.showLiveSnapExposureButtons = showLiveSnapExposureButtons
        self.showCheckboxes = showCheckboxes
        self.showRelativeStages = showRelativeStages
        self.config_groups = config_groups
        self.number_columns = number_config_columns
        self.changes_update_MM = changes_update_MM
        if self.config_groups is not None:
            self.core = self.config_groups[0].core
        else:
            self.core = None
        self.dropDownBoxes = {}
        self.sliders = {}
        self.editFields = {}
        self.configCheckboxes = {}
        self.sliderPrecision = 1000
        self.config_string_storage = []
        self.relstage_string_storage = []
        #Create a Vertical+horizontal layout:
        self.mainLayout = QGridLayout()
        self.configEntries = {}
        
        import glados_pycromanager
        # Get the installation path of the package
        package_path = os.path.dirname(glados_pycromanager.__file__)
        # Construct the path to the Icons folder
        self.iconFolder = os.path.join(package_path, &#39;GUI&#39;, &#39;Icons&#39;)

        if not os.path.exists(self.iconFolder):
            #Find the iconPath folder
            if os.path.exists(&#39;./glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados_pycromanager/GUI/Icons/&#39;
            elif os.path.exists(&#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/&#39;
            else:
                self.iconFolder = &#39;&#39;
        
        
        if showLiveSnapExposureButtons:
            self.generalImagingGroupBox = QGroupBox(&#34;General&#34;)
            
            #Now add the live mode widget
            # self.liveModeGroupBox = QGroupBox(&#34;Live Mode&#34;)
            self.generalImagingGroupBox.setLayout(self.generalImagingLayout())
            self.mainLayout.addWidget(self.generalImagingGroupBox, 0, 0)
            
            #TODO: add shutter here
            
            
            
        if showConfigs:
            #Create a layout for the configs:
            self.configGroupBox = QGroupBox(&#34;Configurations&#34;)
            self.configLayout = QGridLayout()
            self.configLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
            #Add this to the mainLayout via the groupbox:
            self.configGroupBox.setLayout(self.configLayout)
            self.mainLayout.addWidget(self.configGroupBox,0,2)
            #Fill the configLayout
            for config_id in range(len(config_groups)):
                self.configEntries[config_id] = self.addRow(config_id)
            pass
        
            #Add a button to refresh from MM:
            self.refreshButton = QPushButton(&#34;Refresh configs from MM&#34;)
            totalRowsAdded = int(np.ceil(len(config_groups)/self.number_columns))
            #Add a button spanning the total columns at the bottom
            self.configLayout.addWidget(self.refreshButton,totalRowsAdded+99,0,1,self.number_columns)
            #Connect the button:
            self.refreshButton.clicked.connect(lambda index: self.updateConfigsFromMM())
            
        
        #Add the stages widget to the right of this if wanted
        if showStages:
            #Now add the stages widget
            # self.stagesWidget()
            self.stagesGroupBox = QGroupBox(&#34;Stages&#34;)
            self.stagesGroupBox.setLayout(self.stagesLayout())
            self.mainLayout.addWidget(self.stagesGroupBox, 0, 3)
        
        
        if showRelativeStages:
            self.relativeStagesGroupBox = QGroupBox(&#34;RelativeStages&#34;)
            self.relativeStagesGroupBox.setLayout(self.relativeStagesLayout())
            # self.relativeStagesGroupBox.setLayout(QLayout())
            self.mainLayout.addWidget(self.relativeStagesGroupBox, 0, 4)
        
        #Add a horizontal auto-widening object to mainlayout:
        from PyQt5.QtWidgets import QSpacerItem, QSizePolicy
        from PyQt5 import QtWidgets
        spacer = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.mainLayout.addItem(spacer,0,99)
        
        #Update everything for good measure at the end of init
        self.updateAllMMinfo()
        self.fullyLoaded = True
        self.LoadAllMMFromJSON()
        
        #Inactivate all configs if this is wanted
        if checkboxStartInactive and showCheckboxes and showConfigs:
            for config_id in range(len(config_groups)):
                self.configCheckboxes[config_id].setChecked(False)
                    
        #Change the font of everything in the layout
        self.set_font_and_margins_recursive(self.mainLayout, font=QFont(&#34;Arial&#34;, 7))
        #Twice because it relies on dependancies inside qgridlayouts
        self.set_font_and_margins_recursive(self.mainLayout, font=QFont(&#34;Arial&#34;, 7))
    
    #region General
    def updateAllMMinfo(self):
        &#34;&#34;&#34;
        Update all the info that can be updated from the microscope.
        &#34;&#34;&#34;
        logging.debug(&#39;Updating all MM info&#39;)
        if self.showConfigs:
            self.updateConfigsFromMM()
        if self.showStages:
            self.updateXYStageInfoWidget()
            self.updateOneDstageLayout()
        if self.showShutterOptions:
            self.updateShutterOptions()
        
        #Then store it in JSON for good measure
        if self.autoSaveLoad:
            if self.fullyLoaded:
                #Store in appdata
                appdata_folder = os.getenv(&#39;APPDATA&#39;)
                if appdata_folder is None:
                    raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
                app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
                os.makedirs(app_specific_folder, exist_ok=True)
                self.save_state_MMControls(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
                
        #         #Store in appdata
        #         appdata_folder = os.getenv(&#39;APPDATA&#39;)
        #         if appdata_folder is None:
        #             raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        #         app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
        #         os.makedirs(app_specific_folder, exist_ok=True)
                
                
        #         if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
        #             with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
        #                 gladosInfo = json.load(file)
        #                 MMControlsInfo = gladosInfo[&#39;MMControls&#39;]
                
        #             #Hand-set the values that I want:
        #             if &#39;exposureTimeInputField&#39; in MMControlsInfo:
        #                 self.exposureTimeInputField.setText(MMControlsInfo[&#39;exposureTimeInputField&#39;][&#39;text&#39;])
        #             for key, object in self.XYMoveEditField.items():
        #                 if key in MMControlsInfo:
        #                     object.setText(MMControlsInfo[key][&#39;text&#39;])
        #             for key,object in self.oneDMoveEditField.items():
        #                 for objectLineEditKey in object:
        #                     objectLineEdit = object[objectLineEditKey]
        #                     if objectLineEditKey in MMControlsInfo:
        #                         objectLineEdit.setText(MMControlsInfo[objectLineEditKey][&#39;text&#39;])

    def LoadAllMMFromJSON(self):
        &#34;&#34;&#34;
        Update all the info that can be loaded from the JSON file.
        &#34;&#34;&#34;
        #Load from APPData, if it exists
        appdata_folder = os.getenv(&#39;APPDATA&#39;)
        if appdata_folder is None:
            raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
        
        if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
            #Load the file
            with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
                gladosInfo = json.load(file)
                MMControlsInfo = gladosInfo[&#39;MMControls&#39;]
        
            #Hand-set the values that I want:
            if &#39;exposureTimeInputField&#39; in MMControlsInfo:
                if hasattr(self, &#39;exposureTimeInputField&#39;):
                    self.exposureTimeInputField.setText(MMControlsInfo[&#39;exposureTimeInputField&#39;][&#39;text&#39;])
            if &#39;oneDstageDropdown&#39; in MMControlsInfo:
                if hasattr(self, &#39;oneDstageDropdown&#39;):
                    self.oneDstageDropdown.setCurrentText(MMControlsInfo[&#39;oneDstageDropdown&#39;][&#39;text&#39;])
            
            if hasattr(self, &#39;XYMoveEditField&#39;):
                for key, object in self.XYMoveEditField.items():
                    if key in MMControlsInfo:
                        object.setText(MMControlsInfo[key][&#39;text&#39;])
            if hasattr(self, &#39;oneDMoveEditField&#39;):
                for key,object in self.oneDMoveEditField.items():
                    for objectLineEditKey in object:
                        objectLineEdit = object[objectLineEditKey]
                        if objectLineEditKey in MMControlsInfo:
                            objectLineEdit.setText(MMControlsInfo[objectLineEditKey][&#39;text&#39;])

    def storeAllControlValues(self):
        &#34;&#34;&#34;
        Store all the control values in a dictionary, which can be used to save state.
        &#34;&#34;&#34;
        if self.autoSaveLoad:
            if self.fullyLoaded:
                logging.debug(&#39;Storing glados state.json&#39;)
                
                #Store in appdata
                appdata_folder = os.getenv(&#39;APPDATA&#39;)
                if appdata_folder is None:
                    raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
                app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
                os.makedirs(app_specific_folder, exist_ok=True)
                self.save_state_MMControls(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
                pass

    def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
        &#34;&#34;&#34;
        Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
        Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.

        &#34;&#34;&#34;
        # if widget is None:
        #     return
        #Testing a few things
        # try:
        #     widget.setSizePolicy(
        #         QSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        #     )
        # except:
        #     pass
        # try:
        #     widget.setMimimumSize(10, 10)
        # except:
        #     pass
        
        # if not isinstance(widget, (QPushButton,QComboBox)):
        #     try:
        #         widget.setSizePolicy(
        #             QSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        #         )
        #     except:
        #         pass
        
        if isinstance(widget, (QPushButton)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)
        if isinstance(widget, (QLabel, QComboBox)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)

        if isinstance(widget, QGroupBox):
            widget.setSizePolicy(
                QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            )
            # Ensure QGroupBox respects the size of its contents
            widget.setMinimumSize(widget.minimumSizeHint())  # Set the minimum size of QGroupBox based on its size hint

        if hasattr(widget, &#39;layout&#39;):
            layout = widget.layout()
            if layout:
                # layout.setContentsMargins(0, 0, 0, 0)
                # layout.setSpacing(0)  # Optionally, remove spacing between widgets
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if hasattr(item, &#39;widget&#39;):
                        self.set_font_and_margins_recursive(item.widget(), font=font)
                    if hasattr(item, &#39;layout&#39;):
                        self.set_font_and_margins_recursive(item.layout(), font=font)
    
    #Get all config information as set by the UI:
    def getUIConfigInfo(self,onlyChecked=False):
        &#34;&#34;&#34;
        Get all config information as set by the UI.

        param onlyChecked: If True, only return information for checked configs.
        &#34;&#34;&#34;
        configInfo = {}
        for config_id in range(len(self.config_groups)):
            if onlyChecked and not self.configCheckboxes[config_id].isChecked():
                continue
            configInfo[self.config_groups[config_id].configGroupName()] = self.currentConfigUISingleValue(config_id)
        return configInfo

    def currentConfigUISingleValue(self,config_id):
        &#34;&#34;&#34;
        Get the value of a single config as currently determined by the UI.

        param config_id: The ID of the config_group to get the value for.
        &#34;&#34;&#34;
        #Get the value of a single config as currently determined by the UI
        if self.config_groups[config_id].isDropDown():
            currentUIvalue = self.dropDownBoxes[config_id].currentText()
        elif self.config_groups[config_id].isSlider():
            #Get the value from the slider:
            sliderValue = self.sliders[config_id].value()
            #Get the true value from the conversion:
            currentUIvalue = sliderValue/self.sliders[config_id].slider_conversion_array[2]*(self.sliders[config_id].slider_conversion_array[1]-self.sliders[config_id].slider_conversion_array[0])+self.sliders[config_id].slider_conversion_array[0]
        elif self.config_groups[config_id].isInputField():
            currentUIvalue = self.editFields[config_id].text()
        else:
            currentUIvalue = None
        return currentUIvalue
    #endregion
    
    #region general imaging mode
    def generalImagingLayout(self):
        &#34;&#34;&#34;
        Creates the layout for the general imaging mode options.
        This includes an input field for the exposure time in ms.
        Basically, should be exposure time (ms), snap, addToAlbum, live start/stop

        Returns:
            QGridLayout: The layout for the live mode options.
        &#34;&#34;&#34;
        #Create a Grid layout:
        liveModeLayout = QGridLayout()
        liveModeLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
        #Add a &#39;exposure time&#39; label:
        exposureTimeLabel = QLabel(&#34;Exposure time (ms):&#34;)
        liveModeLayout.addWidget(exposureTimeLabel,0,0)
        #Add a &#39;exposure time&#39; input field:
        self.exposureTimeInputField = QLineEdit()
        self.exposureTimeInputField.setText(str(100))
        self.exposureTimeInputField.editingFinished.connect(lambda: self.storeAllControlValues())
        liveModeLayout.addWidget(self.exposureTimeInputField,0,1)
        
        self.livesnapalbumbuttons = QHBoxLayout()
        
        self.LiveModeButton = QPushButton(&#34;Start Live Mode&#34;)
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Start.png&#39;)
        # icon: Flaticon.com
        self.LiveModeButton.setIcon(icon)
        
        #add a connection to the button:
        self.LiveModeButton.clicked.connect(lambda index: self.changeLiveMode())
        #Add the button to the layout:
        self.livesnapalbumbuttons.addWidget(self.LiveModeButton)
        
        self.SnapButton = QPushButton(&#34;Snap&#34;)
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Snap.png&#39;)
        # icon: Flaticon.com
        self.SnapButton.setIcon(icon)
        #add a connection to the button:
        self.SnapButton.clicked.connect(lambda index: self.snapImage())
        #Add the button to the layout:
        self.livesnapalbumbuttons.addWidget(self.SnapButton)
        
        self.AlbumButton = QPushButton(&#34;Add to Album&#34;)
        #add a connection to the button:
        self.AlbumButton.clicked.connect(lambda index: self.addImageToAlbum())
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Album.png&#39;)
        # icon: Flaticon.com
        self.AlbumButton.setIcon(icon)
        #Add the button to the layout:
        self.livesnapalbumbuttons.addWidget(self.AlbumButton)
        
        liveModeLayout.addLayout(self.livesnapalbumbuttons,1,0,1,2)
        
        if self.showShutterOptions:
            self.shutterOptionsGroupBox = QGroupBox(&#34;Shutter&#34;)
            self.shutterOptionsGroupBox.setLayout(self.shutterOptionsLayout(orientation=&#39;horizontal&#39;))
            liveModeLayout.addWidget(self.shutterOptionsGroupBox, 4,0,1,2)
            
        
        if self.showROIoptions:
            #Now add the ROI options widget
            self.roiOptionsGroupBox = QGroupBox(&#34;ROI Options&#34;)
            self.roiOptionsGroupBox.setLayout(self.ROIoptionsLayout(orientation=&#39;horizontal&#39;))
            liveModeLayout.addWidget(self.roiOptionsGroupBox, 5,0,1,2)
        
        #Add one of those spacers at the bottom:
        verticalSpacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        liveModeLayout.addItem(verticalSpacer)
        
        #Add a button to update all MM info
        
        #Create a &#39;debug-ish&#39; button list:
        debugHbox = QHBoxLayout()
        self.updateAllMMinfoButton = QPushButton(&#34;Update all MM info&#34;)
        self.updateAllMMinfoButton.clicked.connect(self.updateAllMMinfo)
        #all the way at the bottom of the layout
        debugHbox.addWidget(self.updateAllMMinfoButton)
        #Add a button to close all layers
        self.closeAllLayersButton = QPushButton(&#34;Close all Layers&#34;)
        self.closeAllLayersButton.clicked.connect(lambda index, shared_data=shared_data: utils.closeAllLayers(shared_data))
        
        #all the way at the bottom of the layout
        debugHbox.addWidget(self.closeAllLayersButton)
        
        self.forceResetButton = QPushButton(&#34;Force-reset&#34;)
        self.forceResetButton.clicked.connect(lambda index, shared_data=shared_data: utils.forceReset(shared_data))
        debugHbox.addWidget(self.forceResetButton)
        
        
        self.advSettingsButton = QPushButton(&#34;Adv. settings&#34;)
        self.advSettingsButton.clicked.connect(lambda index, shared_data=shared_data: utils.openAdvancedSettings(shared_data))
        debugHbox.addWidget(self.advSettingsButton)
        
        liveModeLayout.addLayout(debugHbox,99,0,1,2)
        
        #Return the layout
        return liveModeLayout
    
    def snapImage(self):
        &#34;&#34;&#34;
        Function that&#39;s called when an image is snapped (i.e. get a single image), uses the float(self.exposureTimeInputField.text()) as time in ms
        &#34;&#34;&#34;
        #Set the correct exposure time
        shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
        #Snap an image
        shared_data.core.snap_image()
        #Get the just-snapped image
        newImage = shared_data.core.get_tagged_image()
        snapLayer = checkIfLayerExistsOrCreate(napariViewer,&#39;Snap&#39;,shared_data_throughput = shared_data, required_size = (newImage.tags[&#34;Height&#34;],newImage.tags[&#34;Width&#34;]))
        snapLayer.data = np.reshape(newImage.pix, newshape=[newImage.tags[&#34;Height&#34;], newImage.tags[&#34;Width&#34;]])
        #Move the layer to top
        moveLayerToTop(napariViewer,&#39;Snap&#39;)
        return
    
    def addImageToAlbum(self):
        &#34;&#34;&#34;
        Add an image to the Album layer in napari
        &#34;&#34;&#34; 
        #Set the correct exposure time
        shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
        #Snap an image
        shared_data.core.snap_image()
        #Get the just-snapped image
        newImage = shared_data.core.get_tagged_image()
        
        #And add to the &#39;Album&#39; layer
        addToExistingOrNewLayer(napariViewer,&#39;Album&#39;,np.reshape(newImage.pix, newshape=[newImage.tags[&#34;Height&#34;], newImage.tags[&#34;Width&#34;]]),shared_data_throughput = shared_data)
        return
    
    def changeLiveMode(self):
        &#34;&#34;&#34;
        Function that should be called when live mode is changed. Sets the shared_data.liveMode to True or False.
        &#34;&#34;&#34;
        if shared_data.liveMode == False:
            #update the button text of the live mode:
            self.LiveModeButton.setText(&#34;Stop Live Mode&#34;)
            icon = QIcon(self.iconFolder+os.sep+&#39;General_Stop.png&#39;)
            # icon: Flaticon.com
            self.LiveModeButton.setIcon(icon)
            #set exposure time first:
            shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
            #Then start live mode:
            shared_data.liveMode = True
        else:
            #update the button text of the live mode:
            self.LiveModeButton.setText(&#34;Start Live Mode&#34;)
            icon = QIcon(self.iconFolder+os.sep+&#39;General_Start.png&#39;)
            # icon: Flaticon.com
            self.LiveModeButton.setIcon(icon)
            #update live mode:
            shared_data.liveMode = False
    #endregion

    #region Shutter
    def shutterOptionsLayout(self,orientation=&#39;horizontal&#39;):
        &#34;&#34;&#34;
        Create a layout with buttons for Shutter options

        Returns
        -------
        ShutterOptionsLayout : QGridLayout
            A layout with buttons for Shutter options
        &#34;&#34;&#34;
        #Create a Grid layout:
        shutterOptionsLayout = QGridLayout()
        #Add a dropdown:
        self.shutterChoiceDropdown = QComboBox()
        shutterDevices = self.getDevicesOfDeviceType(&#39;ShutterDevice&#39;)
        for shutterDevice in shutterDevices:
            self.shutterChoiceDropdown.addItem(shutterDevice)
        self.shutterChoiceDropdown.currentIndexChanged.connect(self.on_shutterChoiceChanged)
        
        self.shutterAutoCheckbox = QCheckBox(&#34;Auto&#34;)
        self.shutterAutoCheckbox.stateChanged.connect(self.on_shutterAutoCheckboxChanged)
        
        self.shutterOpenCloseButton = QPushButton(&#34;Open&#34;)
        self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterOpen.png&#39;))
        self.shutterOpenCloseButton.clicked.connect(self.on_shutterOpenCloseButtonPressed)
        
        shutterOptionsLayout.addWidget(self.shutterChoiceDropdown,0,0,1,2)
        shutterOptionsLayout.addWidget(self.shutterAutoCheckbox,1,0)
        shutterOptionsLayout.addWidget(self.shutterOpenCloseButton,1,1)
        
        return shutterOptionsLayout

    def on_shutterOpenCloseButtonPressed(self):
        &#34;&#34;&#34;&#34; 
        Method that&#39;s called when the Open/Close shutter button is pressed.
        &#34;&#34;&#34;
        current_text = self.shutterOpenCloseButton.text()
        if current_text == &#39;Open&#39;:
            self.core.set_shutter_open(True) #type:ignore
            self.shutterOpenCloseButton.setText(&#39;Close&#39;)
            self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterClosed.png&#39;))
        elif current_text == &#39;Close&#39;:
            self.core.set_shutter_open(False) #type:ignore
            self.shutterOpenCloseButton.setText(&#39;Open&#39;)
            self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterOpen.png&#39;))

    def on_shutterChoiceChanged(self):
        &#34;&#34;&#34;
        Set the shutter to the new choice if the dropdown is changed
        &#34;&#34;&#34; 
        selected_item = self.shutterChoiceDropdown.currentText()
        self.core.set_shutter_device(selected_item) #type:ignore

    def on_shutterAutoCheckboxChanged(self,state):
        &#34;&#34;&#34;
        Set the auto-shutter to whether the checkbox is selected or not
        &#34;&#34;&#34;
        if state == 2:
            self.shutterOpenCloseButton.setEnabled(False)
            self.core.set_auto_shutter(True) #type:ignore
        else:
            self.shutterOpenCloseButton.setEnabled(True)
            self.core.set_auto_shutter(False) #type:ignore
    
    def updateShutterOptions(self):
        &#34;&#34;&#34;&#34; 
        Update the shutter GUI options based on what&#39;s what in MM
        &#34;&#34;&#34;
        #Set the current shutter device to the one in MM
        currentShutterDevice = self.core.get_shutter_device() #type:ignore
        self.shutterChoiceDropdown.currentText = currentShutterDevice
        #Set the auto-method to the one in MM:
        currentShutterAuto = self.core.get_auto_shutter() #type:ignore
        self.shutterAutoCheckbox.setChecked(currentShutterAuto)
        if currentShutterAuto == False:
            self.shutterOpenCloseButton.setEnabled(True)
        #Set the button text
        currentShutterOpen = self.core.get_shutter_open() #type:ignore
        if currentShutterOpen == True:
            self.shutterOpenCloseButton.setText(&#39;Close&#39;)
        else:
            self.shutterOpenCloseButton.setText(&#39;Open&#39;)
        
    #endregion

    #region ROI
    def ROIoptionsLayout(self,orientation=&#39;horizontal&#39;):
        &#34;&#34;&#34;
        Create a layout with buttons for ROI options

        Returns
        -------
        ROIoptionsLayout : QGridLayout
            A layout with buttons for ROI options
        &#34;&#34;&#34;
        #Create a Grid layout:
        ROIoptionsLayout = QGridLayout()
        self.ROIoptionsButtons = {}
        #Following options should be added:
        #Reset ROI to max size
        self.ROIoptionsButtons[&#39;Reset&#39;] = QPushButton(&#34;Reset ROI&#34;)
        self.ROIoptionsButtons[&#39;Reset&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_reset.png&#39;))
        self.ROIoptionsButtons[&#39;Reset&#39;].clicked.connect(lambda index: self.resetROI())
        #Zoom in once to center
        self.ROIoptionsButtons[&#39;ZoomIn&#39;] = QPushButton(&#34;Zoom In&#34;)
        self.ROIoptionsButtons[&#39;ZoomIn&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_zoomIn.png&#39;))
        self.ROIoptionsButtons[&#39;ZoomIn&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomIn&#39;))
        #Zoom out once from center
        self.ROIoptionsButtons[&#39;ZoomOut&#39;] = QPushButton(&#34;Zoom Out&#34;)
        self.ROIoptionsButtons[&#39;ZoomOut&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_zoomOut.png&#39;))
        self.ROIoptionsButtons[&#39;ZoomOut&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomOut&#39;))
        #Draw a ROI
        self.ROIoptionsButtons[&#39;drawROI&#39;] = QPushButton(&#34;Draw ROI&#34;)
        self.ROIoptionsButtons[&#39;drawROI&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_select.png&#39;))
        self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.drawROI())
        if orientation == &#39;vertical&#39;:
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],1,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],2,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;drawROI&#39;],3,0)
        else:
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],0,1)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],0,2)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;drawROI&#39;],0,3)
        return ROIoptionsLayout
    
    def resetROI(self):
        &#34;&#34;&#34;
        Reset the ROI to its maximum size

        This function resets the ROI to its maximum size, which is the size of the image
        &#34;&#34;&#34;
        self.core.clear_roi() #type:ignore
    
    def zoomROI(self,option):
        &#34;&#34;&#34;
        Zoom the ROI in or out from the center
        
        This function zooms the ROI in or out from the center.
        It zooms the ROI by a factor of 2.
        If the option is &#34;ZoomIn&#34;, the ROI is zoomed in twice.
        If the option is &#34;ZoomOut&#34;, the ROI is zoomed out twice
        &#34;&#34;&#34;
        #Get the current ROI info
        #[x,y,width,height]
        roiv = [self.core.get_roi().x,self.core.get_roi().y,self.core.get_roi().width,self.core.get_roi().height] #type:ignore
        logging.debug(&#39;ROI zoom requested, current size: &#39;+str(roiv))
        if option == &#39;ZoomIn&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth/2)
                newTotHeight = int(curTotHeight/2)
                newX = int(roiv[0]+(curTotWidth-newTotWidth)/2)
                newY = int(roiv[1]+(curTotHeight-newTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
        elif option == &#39;ZoomOut&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth*2)
                newTotHeight = int(curTotHeight*2)
                newX = int(roiv[0]-(newTotWidth-curTotWidth)/2)
                newY = int(roiv[1]-(newTotHeight-curTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
    
    def setROI(self,ROIpos):
        &#34;&#34;&#34;
        Set the ROI to the specified position and size.
        
        The ROIpos should be a list of [x,y,width,height]
        &#34;&#34;&#34;
        #ROIpos should be a list of [x,y,width,height]
        logging.debug(&#39;Zooming ROI to &#39; + str(ROIpos))
        try:
            if shared_data.liveMode == False:
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3]) #type:ignore
                self.core.wait_for_system() #type:ignore
            else:
                shared_data.liveMode = False
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3]) #type:ignore
                time.sleep(0.5)
                shared_data.liveMode = True
        except:
            logging.error(&#39;ZOOMING DIDN\&#39;T WORK!&#39;)
    
    def shape_drawn_callback(self, event):
        if len(self.drawROIlayer.data) &gt; 0:
            if not event.source._is_moving and not event.source._is_selecting and not event.source._is_creating and len(event.source._mouse_drag_gen) &gt; 0 and event.source.name != &#39;Draw ROI_&#39;:
                logging.debug(&#39;Finished drawing an area for the ROI size!&#39;)
                
                def acceptFun(dialogV):
                    self.setROItoDrawn()
                    #Close the dialog:
                    dialogV.done(QDialog.Accepted)
                
                
                
                def reDoFun(dialogV,layer):
                    #Remove the layer
                    shared_data.napariViewer.layers.remove(layer)
                    #Restart the drawROI:
                    self.drawROI()
                    #Close the dialog:
                    dialogV.done(QDialog.Rejected)
                
                def cancelFun(dialogV,layer):
                    #Remove the layer
                    shared_data.napariViewer.layers.remove(layer)
                    #Close the dialog:
                    dialogV.done(QDialog.Rejected)
                
                #Change the layer name so this won&#39;t pop up again after dialog is closed.
                event.source.name = &#39;Draw ROI_&#39;
                #Pop up a dialog box to ask if they like it or not:
                #Create a dialog box
                from PyQt5.QtWidgets import QDialog, QDialogButtonBox, QVBoxLayout, QLabel
                dialog =  QDialog()
                dialog.setWindowTitle(&#39;Draw ROI&#39;)
                #Add 3 buttons: 
                QButtonOk = QPushButton(&#39;OK&#39;)
                QButtonRedraw = QPushButton(&#39;Redraw&#39;)
                QButtonCancel = QPushButton(&#39;Cancel&#39;)
                #add the box to dialog:
                layout = QVBoxLayout()
                layout.addWidget(
                    QLabel(&#39;ROI drawn correctly?&#39;)
                )
                buttonBox = QHBoxLayout()
                buttonBox.addWidget(QButtonOk)
                buttonBox.addWidget(QButtonRedraw)
                buttonBox.addWidget(QButtonCancel)
                layout.addLayout(buttonBox)
                dialog.setLayout(layout)
                #Connect the buttons to the dialog:
                QButtonOk.clicked.connect(lambda: acceptFun(dialog))
                QButtonRedraw.clicked.connect(lambda: reDoFun(dialog,event.source))
                QButtonCancel.clicked.connect(lambda: cancelFun(dialog,event.source))
                #Show the dialog:
                dialog.exec_()
            
            
    def drawROI(self):
        &#34;&#34;&#34;
        Draw a ROI. Idea is to create a new layer, let the user draw a rectangle, and ask if they like it or not. Then a small popup window with &#39;OK&#39;, &#39;Let me draw again&#39;, &#39;Stop this futile attempt&#39;
        &#34;&#34;&#34;
        
            
        # Create a shapes layer
        self.drawROIlayer = shared_data.napariViewer.add_shapes(name=&#39;Draw ROI&#39;)
        self.drawROIlayer.events.set_data.connect(self.shape_drawn_callback)


        # Set the shapes layer mode to &#39;add_rectangle&#39;
        self.drawROIlayer.mode = &#39;add_rectangle&#39;
        
        #Changes the button to a different method, which should be pressed once the rectangle is drawn:
        # self.ROIoptionsButtons[&#39;drawROI&#39;].setText(&#39;ROI drawn&#39;)
        # self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.disconnect()
        # self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.setROItoDrawn())
    
    def setROItoDrawn(self):
        &#34;&#34;&#34;
        The setROItoDrawn function is used to set the ROI of the microscope to a drawn shape.
        The function first checks if there are any shapes in self.drawROIlayer, and if so, it gets the vertices of the last added shape (which should be a rectangle). It then sets the ROI using these vertices as top left and bottom right corners.
        It also removes self.drawROIlayer from shared_data.napariViewer
        &#34;&#34;&#34;
        # Get the type of the last added shape
        if len(self.drawROIlayer.data) &gt; 0:
            shape_type = self.drawROIlayer.shape_type[-1]
            if shape_type == &#39;rectangle&#39;:
                vertices = self.drawROIlayer.data[-1]  # Get the vertices of the last added shape
                #Get the topleft, bottomright position from the drawn rectangle
                topleftxy = np.floor(vertices[0][::-1])
                bottomrightxy = np.ceil(vertices[2][::-1])
                #Set the boundaries based on the camera
                mintopleft = [0,0]
                maxbottomright = [shared_data.core.get_roi().width, shared_data.core.get_roi().height]
                #Find the bounded positions
                topleftpos = np.maximum(topleftxy,mintopleft)
                bottomrightpos = np.minimum(bottomrightxy,maxbottomright)
                #Set the ROI correclty
                shared_data.core.set_roi(int(topleftpos[0]),int(topleftpos[1]),int(bottomrightpos[0]-topleftpos[0]),int(bottomrightpos[1]-topleftpos[1]))
                logging.info(f&#34;Set ROI to {topleftpos[0]},{topleftpos[1]},{bottomrightpos[0]},{bottomrightpos[1]} px&#34;)
        else:
            logging.warning(&#39;Attempted to set ROI to drawn, but no shape was added&#39;)
        
        #remove the self.drawROIlayer:
        try:
            shared_data.napariViewer.layers.remove(self.drawROIlayer)
        except:
            logging.error(&#39;Failed to remove the drawROIlayer&#39;)
        
        #Reset the Draw ROI button
        self.ROIoptionsButtons[&#39;drawROI&#39;].setText(&#39;Draw ROI&#39;)
        self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.disconnect()
        self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.drawROI())
    #endregion
    
    #region Stages
    def stagesLayout(self):
        &#34;&#34;&#34;
        Returns the layout with the XY and 1D stage widgets.
        &#34;&#34;&#34;
        stageLayout = QHBoxLayout()
        # self.XYstageLayout()
        xyStageLayout = self.XYstageLayout()
        oneDstageLayout = self.oneDstageLayout()
        stageLayout.addLayout(xyStageLayout)
        stageLayout.addLayout(oneDstageLayout)
        #Add a horizontal spacer:
        stageLayout.addStretch(1)
        stageLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
        # print(stageLayout.children())
        xyLayoutWidth = 0
        for i in range(xyStageLayout.columnCount()):
            xyLayoutWidth += xyStageLayout.columnMinimumWidth(i)
        oneDstageLayoutWidth = 0
        for i in range(oneDstageLayout.columnCount()):
            oneDstageLayoutWidth += oneDstageLayout.columnMinimumWidth(i)
        
        containerWidget = QWidget()
        containerWidget.setLayout(stageLayout)
        containerWidget.setFixedWidth(xyLayoutWidth+oneDstageLayoutWidth)
        
        stageOvercapLayout = QHBoxLayout()
        stageOvercapLayout.addWidget(containerWidget)
        
        return stageLayout
    
    def relativeStagesLayout(self):
        &#34;&#34;&#34;
        Returns the layout with the XY stage widgets in relative mode.

        This layout is used when the user is in relative mode.
        &#34;&#34;&#34;
        stageLayout = QHBoxLayout()
        # stageLayout.addLayout(self.XYstageLayout())
        stageLayout.addLayout(self.oneDstageRelLayout())
        return stageLayout
    
    def XYstageLayout(self):
        &#34;&#34;&#34;
        Returns a layout with the XY stage widgets.

        This layout includes a label with the current position,
        three arrow buttons to move in the XY stage relative to the current position,
        and text fields to set the size of the arrow buttons movement
        &#34;&#34;&#34;
        #Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device() #type: ignore
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName)#type: ignore
        
        #Get current pixel size via self.core.get_pixel_size_um()
        #Then move 0.1, 0.5, or 1 field with the arrows
        field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]#type: ignore
        field_move_fraction = [1,.5,.1]
        
        #Widget itself is a grid layout with 7x7 entries
        XYStageLayout = QGridLayout()
        XYStageLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        #XY move buttons
        self.XYmoveButtons = {}
        for m in range(1,4):
            #Initialize buttons
            self.XYmoveButtons[f&#39;Up_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Up_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,float(self.XYMoveEditField[f&#34;Y_{4-m}&#34;].text())))
            self.XYmoveButtons[f&#39;Down_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Down_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,float(self.XYMoveEditField[f&#34;Y_{4-m}&#34;].text())*-1))
            self.XYmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(float(self.XYMoveEditField[f&#34;X_{4-m}&#34;].text())*-1,0))
            self.XYmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(float(self.XYMoveEditField[f&#34;X_{4-m}&#34;].text()),0))
            
            #Add buttons to layout
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Up_{m}&#39;],m-1,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Down_{m}&#39;],8-m,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Left_{m}&#39;],4,m-1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Right_{m}&#39;],4,8-m,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        
        XYStageSetMovementLayout = QGridLayout()
        XYStageSetMovementLayout.addWidget(QLabel(&#39;X&#39;),0,1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageSetMovementLayout.addWidget(QLabel(&#39;Y&#39;),0,2,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        self.XYMoveEditField = {}
        pushButtonLabelArr = [&#34;0.1 field&#34;,&#34;1 field&#34;,&#34;3 fields&#34;]
        for m in range(1,4):
            XYStageSetMovementLayout.addWidget(QLabel(&#34;&#34;*(m)),m,0,1,1, alignment=Qt.AlignmentFlag.AlignRight)
            self.XYMoveEditField[f&#34;X_{m}&#34;] = QLineEdit()
            XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;X_{m}&#34;],m,1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.XYMoveEditField[f&#34;X_{m}&#34;].editingFinished.connect(lambda: self.storeAllControlValues())
            self.XYMoveEditField[f&#34;Y_{m}&#34;] = QLineEdit()
            XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;Y_{m}&#34;],m,2,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.XYMoveEditField[f&#34;Y_{m}&#34;].editingFinished.connect(lambda: self.storeAllControlValues())
            XYStageSetMovementLayout.addWidget(QLabel(&#34;m&#34;),m,3,1,1, alignment=Qt.AlignmentFlag.AlignLeft)
            self.XYMoveEditField[f&#34;Button_{m}&#34;] = QPushButton(pushButtonLabelArr[m-1])
            
            self.XYMoveEditField[f&#34;Button_{m}&#34;].clicked.connect(lambda index, m=m: self.setXYStageMovementValue(m-1,self.XYMoveEditField[f&#34;X_{m}&#34;],self.XYMoveEditField[f&#34;Y_{m}&#34;]))
            
            XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;Button_{m}&#34;],m,4,1,1, alignment=Qt.AlignmentFlag.AlignLeft)
            
        #Add the setmovementlayout to the XY stage layout
        XYStageLayout.addLayout(XYStageSetMovementLayout,8,0,1,8, alignment=Qt.AlignmentFlag.AlignCenter)
                
        #Add a central label for info
        #this label contains the XY stage name, then an enter, then the current position:
        self.XYStageInfoWidget = QLabel()
        XYStageLayout.addWidget(self.XYStageInfoWidget,4,4)
        #Update the text of it
        self.updateXYStageInfoWidget()
        
        return XYStageLayout
    
    def setXYStageMovementValue(self,m,xEditField,yEditField):
        &#34;&#34;&#34;
        Set the XY stageLineEdits to specific values based on the Buttons next to the fields.
        This function is called when the user presses the &#34;Set&#34; buttons next to the XY EditFields
        &#34;&#34;&#34;
        #Set the values in the XY EditFields based on the buttons
        fieldUnits = [0.1,1,3]
        fieldUnit = fieldUnits[m]
        field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]#type: ignore
        
        x_value_um = field_size_um[0]*fieldUnit
        y_value_um = field_size_um[1]*fieldUnit
        xEditField.setText(str(x_value_um))
        yEditField.setText(str(y_value_um))
        self.storeAllControlValues()
    
    def getDevicesOfDeviceType(self,devicetype):
        &#34;&#34;&#34;
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        &#34;&#34;&#34;
        #Get devices
        devices = self.core.get_loaded_devices() #type:ignore
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.core.get_device_type(device).to_string() == devicetype: #type:ignore
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType
    
    def oneDstageLayout(self):
        &#34;&#34;&#34;
        Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see XYstageLayout()
        &#34;&#34;&#34;
        #Create a layout
        self.oneDStageLayout = QGridLayout()
        
        #Creates a UI layout to move all found 1D stages
        #Find all 1D stages
        allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        
        #Create a drop-down menu that has these stages as options
        self.oneDstageDropdown = QComboBox()
        for stage in allStages:
            self.oneDstageDropdown.addItem(stage)
        #If it changes, call the update routine
        self.oneDstageDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageLayout())
        #Also store the JSON if changed:
        self.oneDstageDropdown.currentTextChanged.connect(lambda: self.storeAllControlValues())
        #Set default value to default z stage of MM
        try:
            self.oneDstageDropdown.setCurrentText(self.core.get_focus_device()) #type:ignore
        except:
            pass
        #Add the dropdown to the layout:
        self.oneDStageLayout.addWidget(self.oneDstageDropdown,0,0)
        
        #Add left/right buttons and a label for the position
        self.oneDmoveButtons = {}
        for m in range(1,3):
            #Initialize buttons
            self.oneDmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(-m))
            
            #Add buttons to layout
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Left_{m}&#39;],m-1+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Right_{m}&#39;],5-m+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        
        #Create a QGridBox for the movement sizes for each stage:
        self.oneDMoveEditFieldGridLayouts={}
        self.oneDMoveEditField={}
        self.oneDStackedWidget = QStackedWidget()
        for stage in allStages:
            self.oneDMoveEditFieldGridLayouts[stage] = QWidget()
            self.oneDMoveEditFieldGridLayouts[stage].setObjectName(stage)
            internalLayout = QGridLayout()
            self.oneDMoveEditFieldGridLayouts[stage].setLayout(internalLayout)
            self.oneDMoveEditField[stage] = {}
            for m in range(1,3):
                internalLayout.addWidget(QLabel(&#34;&#34;*(m)),m,0)
                self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;] = QLineEdit()
                internalLayout.addWidget(self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;],m,1)
                self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;].setText(&#34;10&#34;)
                self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;].editingFinished.connect(lambda: self.storeAllControlValues())
            
            self.oneDStackedWidget.addWidget(self.oneDMoveEditFieldGridLayouts[stage])
        
        self.oneDStageLayout.addWidget(self.oneDStackedWidget,8,0)
        
        #Get current info of the widget
        self.oneDinfoWidget = QLabel()
        self.oneDStageLayout.addWidget(self.oneDinfoWidget,1,0)
        #update the text
        self.updateOneDstageLayout()
        
        #Store the values
        self.storeAllControlValues()
        
        return self.oneDStageLayout
    
    def updateOneDstageLayout(self):
        &#34;&#34;&#34;
        Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage
        &#34;&#34;&#34;
        self.oneDinfoWidget.setText(f&#34;{self.oneDstageDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageDropdown.currentText()):.1f}&#34;) #type:ignore
        
        for widget_id in range(0,self.oneDStackedWidget.count()):
            widget = self.oneDStackedWidget.widget(widget_id)
            if widget.objectName() == self.oneDstageDropdown.currentText():
                self.oneDStackedWidget.setCurrentIndex(widget_id)
    
    def moveOneDStage(self,amount):
        &#34;&#34;&#34;
        Moves the selected one-D stage by the specified amount

        Parameters
        ----------
        amount: int: 1 or 2, &#39;small step&#39; or &#39;big step&#39;
        &#34;&#34;&#34;
        #Get the currently selected one-D stage:
        selectedStage = self.oneDstageDropdown.currentText()
        
        #Get the value currently in the LineEdit
        self.moveoneDstagesmallAmount = float(self.oneDMoveEditField[selectedStage][f&#39;oneDStackedWidget_{selectedStage}_1&#39;].text())
        self.moveoneDstagelargeAmount = float(self.oneDMoveEditField[selectedStage][f&#39;oneDStackedWidget_{selectedStage}_2&#39;].text())
        
        logging.debug(&#34;moving &#34; + selectedStage + &#34; by &#34; + str(amount))
        
        #Move the stage relatively
        if abs(amount) == 2:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagesmallAmount).astype(float)) #type:ignore
        elif abs(amount) == 1:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagelargeAmount).astype(float)) #type:ignore
        self.updateOneDstageLayout()
    
    
    def oneDstageRelLayout(self):
        &#34;&#34;&#34;
        Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see oneDstageLayout()
        &#34;&#34;&#34;
        #Create a layout
        self.oneDStageRelLayout = QGridLayout()
        
        #Creates a UI layout to move all found 1D stages
        #Find all 1D stages
        allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        
        #Create a drop-down menu that has these stages as options
        self.oneDstageRelDropdown = QComboBox()
        for stage in allStages:
            self.oneDstageRelDropdown.addItem(stage)
        #If it changes, call the update routine
        self.oneDstageRelDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageRelLayout())
        #Also store the JSON if changed:
        self.oneDstageRelDropdown.currentTextChanged.connect(lambda: self.storeAllControlValues())
        #Set default value to default z stage of MM
        try:
            self.oneDstageRelDropdown.setCurrentText(self.core.get_focus_device()) #type:ignore
        except:
            pass
        #Add the dropdown to the layout:
        self.oneDStageRelLayout.addWidget(self.oneDstageRelDropdown,0,0)
        
        #Create a QGridBox for the movement sizes for each stage:
        self.oneDMoveRelEditFieldGridLayouts={}
        self.oneDMoveRelEditField={}
        self.oneDRelStackedWidget = QStackedWidget()
        for stage in allStages:
            self.oneDMoveRelEditFieldGridLayouts[stage] = QWidget()
            self.oneDMoveRelEditFieldGridLayouts[stage].setObjectName(stage)
            internalLayout = QGridLayout()
            self.oneDMoveRelEditFieldGridLayouts[stage].setLayout(internalLayout)
            self.oneDMoveRelEditField[stage] = {}
            
            internalLayout.addWidget(QLabel(&#34;Move&#34;),0,0)
            self.oneDMoveRelEditField[stage] = QLineEdit()
            internalLayout.addWidget(self.oneDMoveRelEditField[stage],1,0)
            self.oneDMoveRelEditField[stage].setText(&#34;10&#34;)
            self.oneDMoveRelEditField[stage].editingFinished.connect(lambda: self.storeAllControlValues())
            
            self.oneDRelStackedWidget.addWidget(self.oneDMoveRelEditFieldGridLayouts[stage])
        
        self.oneDStageRelLayout.addWidget(self.oneDRelStackedWidget,1,0)
        
        #Get current info of the widget
        self.oneDinfoRelWidget = QLabel()
        self.oneDStageRelLayout.addWidget(self.oneDinfoRelWidget,2,0)
        #update the text
        # self.updateOneDstageRelLayout()
        
        #Store the values
        # self.storeAllControlValues()
        
        return self.oneDStageRelLayout
    
    def updateOneDstageRelLayout(self):
        &#34;&#34;&#34;
        Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage
        &#34;&#34;&#34;
        logging.debug(&#34;Updating OneD stage layout&#34;)
        self.oneDinfoRelWidget.setText(f&#34;{self.oneDstageRelDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageRelDropdown.currentText()):.1f}&#34;) #type:ignore
        
        for widget_id in range(0,self.oneDRelStackedWidget.count()):
            widget = self.oneDRelStackedWidget.widget(widget_id)
            if widget.objectName() == self.oneDstageRelDropdown.currentText():
                self.oneDRelStackedWidget.setCurrentIndex(widget_id)
    
    def updateXYStageInfoWidget(self):
        &#34;&#34;&#34;
        Updates the XY stage info widget with the current position of the stage

        &#34;&#34;&#34;
        #Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device() #type:ignore
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName) #type:ignore
        self.XYStageInfoWidget.setText(f&#34;{XYStageName}\r\n {XYStagePos.x:.0f}/{XYStagePos.y:.0f}&#34;)
        
    def moveXYStage(self,relX,relY):
        &#34;&#34;&#34;
        Move XY stage with um positions in relx, rely:
        &#34;&#34;&#34;
        self.core.set_relative_xy_position(relX,relY) #type:ignore
        #Update the XYStageInfoWidget (if it exists)
        self.updateXYStageInfoWidget()
    #endregion
    
    #region MM-configs
    def addRow(self,config_id):
        &#34;&#34;&#34;
        Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination
        &#34;&#34;&#34;
        rowLayout = QHBoxLayout()
        #Add the label to it
        self.addLabel(rowLayout,config_id)
        #Add the widget to the QVBoxlayout
        self.configLayout.addLayout(rowLayout,divmod(config_id,self.number_columns)[1],divmod(config_id,self.number_columns)[0])
        
        return rowLayout
    
    def addLabel(self,rowLayout,config_id):
        &#34;&#34;&#34;
        Add a label to the given rowLayout with the label text provided in the MM config.

        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Add a checkbox
            self.configCheckboxes[config_id] = QCheckBox()
            self.configCheckboxes[config_id].setChecked(False)
            #Add callback:
            self.configCheckboxes[config_id].stateChanged.connect(lambda _, self=self, config_id = config_id: self.configLayoutEnableChange(config_id))
            rowLayout.addWidget(self.configCheckboxes[config_id])
        #add a label to the row:
        label = QLabel()
        label.setText(self.config_groups[config_id].configGroupName())
        rowLayout.addWidget(label)
        #Add the dropdown/slider/inputfield:
        if self.config_groups[config_id].isDropDown():
            self.addDropDown(rowLayout,config_id)
        if self.config_groups[config_id].isSlider():
            self.addSlider(rowLayout,config_id)
        if self.config_groups[config_id].isInputField():
            self.addInputField(rowLayout,config_id)
        return rowLayout
        # pass
    
    def addDropDown(self,rowLayout,config_id):
        &#34;&#34;&#34;
        Add a drop-down menu to the given rowLayout
        with the options provided in the MM config.

        &#34;&#34;&#34;
        #Create a drop-down menu:
        self.dropDownBoxes[config_id] = QComboBox()
        #Add an empty option:
        self.dropDownBoxes[config_id].addItem(&#39;&#39;)
        #Populate with the options:
        for i in range(self.config_groups[config_id].nrConfigs()):
            self.dropDownBoxes[config_id].addItem(self.config_groups[config_id].configName(i))
        #Update the value to the current MM value:
        # self.updateValuefromMM(config_id)
        #Add a callback when it is changed:
        self.dropDownBoxes[config_id].currentIndexChanged.connect(lambda index, config_id = config_id: self.on_dropDownChanged(config_id))
        
        #Add dropdown to rowLayout:
        rowLayout.addWidget(self.dropDownBoxes[config_id])
    
    def on_dropDownChanged(self,config_id):
        &#34;&#34;&#34;
        Changes a micromanager config when a dropdown has changed

        Args:
            config_id (int): The ID of the dropdown box that triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Check the corresponding checkbox
            self.configCheckboxes[config_id].setChecked(True)
        if self.changes_update_MM:
            #Get the new value from the dropdown:
            newValue = self.dropDownBoxes[config_id].currentText()
            #Change the value if it&#39;s a true value
            if newValue != &#34;&#34; and newValue != &#34; &#34;:
                #Get the config group name:
                configGroupName = self.config_groups[config_id].configGroupName()
                #Set in MM:
                self.config_groups[config_id].core.set_config(configGroupName,newValue)
    
    def addSlider(self,rowLayout,config_id):
        &#34;&#34;&#34;
        Add a slider to a rowLayout for a given MMConfigItem.

        Args:
            rowLayout (QHBoxLayout): The rowLayout to add the slider to.
            config_id (int): The ID of the MMConfigItem to add a slider for.

        Returns:
            None
        &#34;&#34;&#34;
        #Get the config group name
        configGroupName = self.config_groups[config_id].configGroupName()
        
        #Get the min and max value of the slider:
        lowerLimit = self.config_groups[config_id].lowerLimit()
        upperLimit = self.config_groups[config_id].upperLimit()
        
        #A slider config by definition (?) only has a single property underneath, so get that:
        underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
        configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()
        
        #Finally we get the current value of the slider
        currentSliderValue = float(self.config_groups[config_id].core.get_property(device_label,property_name))
        
        #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
        sliderPrecision = self.sliderPrecision
        sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
        
        
        #First add an editfield that has the value numerically:
        self.editFields[config_id] = QLineEdit()
        self.editFields[config_id].setText(str(currentSliderValue))
        #Only allow numbers/float values
        self.editFields[config_id].setValidator(QDoubleValidator())
        rowLayout.addWidget(self.editFields[config_id])
        self.editFields[config_id].editingFinished.connect(lambda config_id = config_id: self.on_sliderChanged(config_id,fromText=True,fromSlider=False))


        #Create the slider:
        self.sliders[config_id] = QSlider(Qt.Horizontal) #type: ignore
        #Give it a minimum size:
        self.sliders[config_id].setMinimumWidth(50)
        self.sliders[config_id].setRange(0,sliderPrecision)
        self.sliders[config_id].setValue(sliderValInSliderPrecision)
        self.sliders[config_id].slider_conversion_array = [lowerLimit,upperLimit,sliderPrecision]
        #Add a callback when it is changed:
        self.sliders[config_id].valueChanged.connect(lambda value, config_id = config_id: self.on_sliderChanged(config_id,fromSlider=True,fromText=False))
        # #Add the slider to the rowLayout:
        rowLayout.addWidget(self.sliders[config_id])
        pass
    
    def on_sliderChanged(self,config_id,fromText=False,fromSlider=True):
        &#34;&#34;&#34;
        Changes a micromanager config when a slider has changed

        Args:
            config_id (int): The ID of the slider box that triggered the event.
            slider_conversion_array (array): [lowerLimit,upperLimit,sliderPrecision]

        Returns:
            None
        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Check the corresponding checkbox:
            self.configCheckboxes[config_id].setChecked(True)
            
        #Get the new value from the slider:
        if fromSlider:
            newValue = self.sliders[config_id].value()
            #Get the true value from the conversion:
            trueValue = newValue/self.sliders[config_id].slider_conversion_array[2]*(self.sliders[config_id].slider_conversion_array[1]-self.sliders[config_id].slider_conversion_array[0])+self.sliders[config_id].slider_conversion_array[0]
        elif fromText:
            if self.editFields[config_id].text() != &#34;&#34;:
                trueValue = float(self.editFields[config_id].text())
            else:
                trueValue = &#34;&#34;
        else:
            trueValue = &#34;&#34; #error out later on purpose
            
        if self.changes_update_MM:
            #Change the value if it&#39;s a true value
            if trueValue != &#34;&#34; and trueValue != &#34; &#34;:
                #Get the config group name:
                configGroupName = self.config_groups[config_id].configGroupName()
                #Set in MM:
                #A slider config by definition (?) only has a single property underneath, so get that:
                underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
                configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
                device_label = configdata.get_setting(0).get_device_label()
                property_name = configdata.get_setting(0).get_property_name()

                #Set this property:
                self.config_groups[config_id].core.set_property(device_label,property_name,trueValue)
                
        if trueValue != &#34;&#34; and trueValue != &#34; &#34;:
            trueValue = round(trueValue,3)
            #Set the slider/text if the other is changed
            if fromSlider:
                self.editFields[config_id].setText(str(trueValue))
            elif fromText:
                newValue = self.sliders[config_id].slider_conversion_array[2] * (trueValue - self.sliders[config_id].slider_conversion_array[0]) / (self.sliders[config_id].slider_conversion_array[1] - self.sliders[config_id].slider_conversion_array[0])
                self.sliders[config_id].setValue(int(newValue))
    
    def addInputField(self,rowLayout,config_id):
        &#34;&#34;&#34; 
        Add a editfield to a rowLayout for a given MMConfigItem.

        &#34;&#34;&#34;
        #Get the config group name
        configGroupName = self.config_groups[config_id].configGroupName()

        self.editFields[config_id] = QLineEdit()
        #Add a callback when it is changed:
        self.editFields[config_id].editingFinished.connect(lambda config_id = config_id: self.onEditFieldChanged(config_id))
        # Add the editFields to the rowLayout:
        rowLayout.addWidget(self.editFields[config_id])
    
    def onEditFieldChanged(self,config_id):
        &#34;&#34;&#34;
        Changes a micromanager config when an editfield has changed
        Args:
            config_id (int): The ID of the editfield box that triggered the event.
        Returns:
            None
        &#34;&#34;&#34;

        CurrentText = self.editFields[config_id].text()
        #Get the config group name:
        configGroupName = self.config_groups[config_id].configGroupName()

        #An Editfield config by definition (?) only has a single property underneath, so get that:
        underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
        configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()

        #Set this property:
        self.config_groups[config_id].core.set_property(device_label,property_name,CurrentText)
        
    def updateValuefromMM(self,config_id):
        &#34;&#34;&#34;
        Updates the value in the GUI for a single config_id based on the current value in MM

        Args:
            config_id (int): The ID of the config_group to update

        Returns:
            None
        &#34;&#34;&#34;
        logging.debug(&#34;Updating value from &#34; + self.config_groups[config_id].configGroupName())
        #Get the value of the config_id from micromanager:
        currentValue = self.config_groups[config_id].getCurrentMMValue()
        
        #Set the value of the dropdown to the current MM value
        if self.config_groups[config_id].isDropDown():
            self.dropDownBoxes[config_id].setCurrentText(currentValue)
        elif self.config_groups[config_id].isSlider():
            #A slider config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.config_groups[config_id].configGroupName()
            underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
            configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()
            
            #Finally we get the current value of the slider
            currentSliderValue = float(self.config_groups[config_id].core.get_property(device_label,property_name))
                
            #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
            sliderPrecision = self.sliderPrecision
            #Get the min and max value of the slider:
            lowerLimit = self.config_groups[config_id].lowerLimit()
            upperLimit = self.config_groups[config_id].upperLimit()
            sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
            # #Update the slider:
            self.sliders[config_id].setRange(0,sliderPrecision)
            self.sliders[config_id].setValue(sliderValInSliderPrecision)
            #Also update the corresponding editField
            self.editFields[config_id].setText(str(currentSliderValue))
            
        elif self.config_groups[config_id].isInputField():
            #A editfield config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.config_groups[config_id].configGroupName()
            underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
            configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()

            #Finally we get the current value of the editfield
            currentValue = (self.config_groups[config_id].core.get_property(device_label,property_name))

            self.editFields[config_id].setText(currentValue)
        
        #Make inactive if the checkbox is inactive
        self.configLayoutEnableChange(config_id)
        pass
    
    def updateValueInGUI(self,config_id, newValue):
        &#34;&#34;&#34;
        I THINK DEPRECATED, BUT KEEPING FOR KEEPING SAKE
        Updates the GUI to reflect a change in the Micromanager config
        Set the value of the dropdown to the current MM value

        Args:
            config_id (int): The ID of the config box to change
            newValue (str): The new value of the config property

        Returns:
            None
        &#34;&#34;&#34;
        if self.config_groups[config_id].isDropDown():
            self.dropDownBoxes[config_id].setCurrentText(newValue)
        elif self.config_groups[config_id].isSlider():
            #Finally we get the current value of the slider
            currentSliderValue = float(newValue)
                
            #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
            sliderPrecision = self.sliderPrecision
            #Get the min and max value of the slider:
            lowerLimit = self.config_groups[config_id].lowerLimit()
            upperLimit = self.config_groups[config_id].upperLimit()
            sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
            
            self.sliders[config_id].setValue(sliderValInSliderPrecision)
            
        elif self.config_groups[config_id].isInputField():
            pass
    
    def configLayoutEnableChange(self,config_id):
        &#34;&#34;&#34;
        Enables or disables the GUI elements in the layout of the given config box

        Args:
            config_id (int): The ID of the config box to change
        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Disable all children recursively
            def enableDisableLayout(self, layout,config_id,trueFalse):
                &#34;&#34;&#34;
                Enables or disables widgets in a layout based on the provided configuration ID.
                
                Args:
                    layout: The layout containing the widgets to be enabled or disabled.
                    config_id: The configuration ID used to identify the checkbox that should not be disabled.
                    trueFalse: A boolean value indicating whether the widgets should be enabled (True) or disabled (False).
                
                Returns:
                    None
                &#34;&#34;&#34;
                for i in range(layout.count()):
                    item = layout.itemAt(i)

                    if item.widget():
                        #Don&#39;t disable if it&#39;s the checkbox itself
                        if not item.widget() == self.configCheckboxes[config_id]:
                            item.widget().setEnabled(trueFalse)
                    elif item.layout():
                        self.disableLayout(item.layout())
                        
            if self.configCheckboxes[config_id].isChecked():
                enableDisableLayout(self, self.configEntries[config_id],config_id,True)
            else:
                enableDisableLayout(self, self.configEntries[config_id],config_id,False)
        return
    
    def updateConfigsFromMM(self):
        &#34;&#34;&#34;
        Updates all configs from the Micro-Manager backend.
        
        This function iterates over all configs and updates their values in the GUI
        based on the current values in the Micro-Manager backend.
        &#34;&#34;&#34;
        #Update all values from MM:
        for config_id in range(len(self.config_groups)):
            self.updateValuefromMM(config_id)
        pass
    #endregion

    #region deprecated
    def get_device_properties(self):
        &#34;&#34;&#34;
        Get device properties.
        
        Args:
            self: The object itself.
            
        Returns:
            List: A list of dictionaries containing device properties.
        &#34;&#34;&#34;
        
        core = self.core
        devices = core.get_loaded_devices() #type:ignore
        devices = [devices.get(i) for i in range(devices.size())]
        device_items = []
        for device in devices:
            logging.debug(&#39;Device: &#39;+device)
            names = core.get_device_property_names(device) #type:ignore
            props = [names.get(i) for i in range(names.size())]
            property_items = []
            for prop in props:
                logging.debug(&#39;Property&#39;,prop)
                value = core.get_property(device, prop) #type:ignore
                is_read_only = core.is_property_read_only(device, prop) #type:ignore
                if core.has_property_limits(device, prop): #type:ignore
                    lower = core.get_property_lower_limit(device, prop) #type:ignore
                    upper = core.get_property_upper_limit(device, prop) #type:ignore
                    allowed = {
                    &#34;type&#34;: &#34;range&#34;,
                    &#34;min&#34;: lower,
                    &#34;max&#34;: upper,
                    &#34;readOnly&#34;: is_read_only,
                    }
                else:
                    allowed = core.get_allowed_property_values(device, prop) #type:ignore
                    allowed = {
                    &#34;type&#34;: &#34;enum&#34;,
                    &#34;options&#34;: [allowed.get(i) for i in range(allowed.size())],&#34;readOnly&#34;: is_read_only,
                    }
                    property_items.append(
                    {&#34;device&#34;: device, &#34;name&#34;: prop, &#34;value&#34;: value, &#34;allowed&#34;: allowed}
                    )
                    logging.debug(&#39;===&gt;&#39;, device, prop, value, allowed)
            if len(property_items) &gt; 0:
                device_items.append(
                {
                &#34;name&#34;: device,
                &#34;value&#34;: &#34;{} properties&#34;.format(len(props)),
                &#34;items&#34;: property_items,
                }
                )
        return device_items

    def Vseparator_line(self):
        &#34;&#34;&#34;
        Creates a vertical separator line widget.
        
        Args:
            None
        
        Returns:
            QFrame: A vertical separator line widget with frame shape set to QFrame.VLine, frame shadow set to QFrame.Sunken, and background color set to #FFFFFF with a minimum width of 1px.
        &#34;&#34;&#34;
        
        separator_line = QFrame()
        separator_line.setFrameShape(QFrame.VLine)
        separator_line.setFrameShadow(QFrame.Sunken)
        separator_line.setStyleSheet(&#34;background-color: #FFFFFF; min-width: 1px;&#34;)
        return separator_line
    #endregion
    
def microManagerControlsUI(core,MM_JSON,main_layout,sshared_data):
    &#34;&#34;&#34;
    Controls the Micro Manager UI.
    
    Args:
        core: The Micro Manager core object.
        MM_JSON: JSON object for Micro Manager.
        main_layout: The main layout of the UI.
        sshared_data: Shared data for the UI.
    
    Returns:
        MMconfig: The Micro Manager configuration UI object.
    &#34;&#34;&#34;
    global shared_data
    shared_data = sshared_data
    # Get all config groups
    allConfigGroups={}
    nrconfiggroups = core.get_available_config_groups().size()
    for config_group_id in range(nrconfiggroups):
        allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
    
    #Create the MM config via all config groups
    MMconfig = MMConfigUI(allConfigGroups,autoSaveLoad=True)
    main_layout.addLayout(MMconfig.mainLayout,0,0)
    
    return MMconfig
    
    #Test line:
    # breakpoint</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MMcontrols.microManagerControlsUI"><code class="name flex">
<span>def <span class="ident">microManagerControlsUI</span></span>(<span>core, MM_JSON, main_layout, sshared_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Controls the Micro Manager UI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>core</code></strong></dt>
<dd>The Micro Manager core object.</dd>
<dt><strong><code>MM_JSON</code></strong></dt>
<dd>JSON object for Micro Manager.</dd>
<dt><strong><code>main_layout</code></strong></dt>
<dd>The main layout of the UI.</dd>
<dt><strong><code>sshared_data</code></strong></dt>
<dd>Shared data for the UI.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>MMconfig</code></dt>
<dd>The Micro Manager configuration UI object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def microManagerControlsUI(core,MM_JSON,main_layout,sshared_data):
    &#34;&#34;&#34;
    Controls the Micro Manager UI.
    
    Args:
        core: The Micro Manager core object.
        MM_JSON: JSON object for Micro Manager.
        main_layout: The main layout of the UI.
        sshared_data: Shared data for the UI.
    
    Returns:
        MMconfig: The Micro Manager configuration UI object.
    &#34;&#34;&#34;
    global shared_data
    shared_data = sshared_data
    # Get all config groups
    allConfigGroups={}
    nrconfiggroups = core.get_available_config_groups().size()
    for config_group_id in range(nrconfiggroups):
        allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
    
    #Create the MM config via all config groups
    MMconfig = MMConfigUI(allConfigGroups,autoSaveLoad=True)
    main_layout.addLayout(MMconfig.mainLayout,0,0)
    
    return MMconfig
    
    #Test line:
    # breakpoint</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MMcontrols.ConfigInfo"><code class="flex name class">
<span>class <span class="ident">ConfigInfo</span></span>
<span>(</span><span>core, config_group_id)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains information about a pycromanager config group
Contains info such as name, min/max value etc</p>
<p>This class contains information about a pycromanager config group
Contains info such as name, min/max value etc</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>core</code></strong> :&ensp;<code>Core</code></dt>
<dd>The pycromanager core object</dd>
<dt><strong><code>config_group_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The id of the config group</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigInfo:
    &#34;&#34;&#34;
    This class contains information about a pycromanager config group
    Contains info such as name, min/max value etc
    &#34;&#34;&#34;
    def __init__(self,core,config_group_id):
        &#34;&#34;&#34;
        This class contains information about a pycromanager config group
        Contains info such as name, min/max value etc
        
        Attributes:
            core (Core): The pycromanager core object
            config_group_id (int): The id of the config group
        &#34;&#34;&#34;
        self.core = core
        self.config_group_id = config_group_id
        pass
    
    def configGroupName(self):
        &#34;&#34;&#34;
        Returns the config group name
        &#34;&#34;&#34;
        return self.core.get_available_config_groups().get(self.config_group_id)
    
    def nrConfigs(self):
        &#34;&#34;&#34;Returns the number of config options for this config group&#34;&#34;&#34;
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).size()
    
    def configName(self,config_id):
        &#34;&#34;&#34;Returns the name of the config within the config group&#34;&#34;&#34;
        return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).get(config_id)
    
    def deviceNameProperty_fromVerbose(self):
        &#34;&#34;&#34;Returns the first device name and property from Verbose&#34;&#34;&#34;
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        start_index = verboseInfoCurrentConfigGroup.find(&#34;&lt;html&gt;&#34;) + len(&#34;&lt;html&gt;&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;:&#34;)
        deviceName = verboseInfoCurrentConfigGroup[start_index:end_index]
        start_index = end_index + len(&#34;:&#34;)
        end_index = verboseInfoCurrentConfigGroup.find(&#34;=&#34;)
        deviceProperty  = verboseInfoCurrentConfigGroup[start_index:end_index]
        return deviceName,deviceProperty
    
    def hasPropertyLimits(self):
        &#34;&#34;&#34;Returns whether the config group has property limits&#34;&#34;&#34;
        #Get the verbose info from the config group state
        verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
        #Determine the number of devices in the verbose info
        nrDevicesFromVerbose = verboseInfoCurrentConfigGroup.count(&#39;&lt;br&gt;&#39;)
        if nrDevicesFromVerbose == 1 and self.nrConfigs() == 1:
            [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
            #Determines whether the device name/property has limits:
            if self.core.has_property_limits(deviceName,deviceProperty):
                return True
            else:
                return False
        else:
            return False
    
    def lowerLimit(self):
        &#34;&#34;&#34;Finds lower limit of the device property&#34;&#34;&#34;
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            lowerLimit = self.core.get_property_lower_limit(deviceName,deviceProperty)
        else:
            lowerLimit = 0
        return lowerLimit
            
    def upperLimit(self):
        &#34;&#34;&#34;Finds upper limit of the device property&#34;&#34;&#34;
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        if self.core.has_property_limits(deviceName,deviceProperty):
            upperLimit = self.core.get_property_upper_limit(deviceName,deviceProperty)
        else:
            upperLimit = 0
        return upperLimit
            
    def isDropDown(self):
        &#34;&#34;&#34;Returns Boolean whether the config group should be represented as a drop-down menu&#34;&#34;&#34;
        if self.nrConfigs()&gt;1:
            return True
        else:
            #If there is exactly one option...
            if self.nrConfigs() == 1:
                #And the option is &#39;NewPreset&#39;, it means there are no presets specified
                if self.core.get_available_configs(self.configGroupName()).get(0) == &#39;NewPreset&#39;:
                    return False
                else:
                    return True
        
    def isSlider(self):
        &#34;&#34;&#34;Returns Boolean whether the config group should be represented as a slider&#34;&#34;&#34;
        if self.nrConfigs()&gt;1:
            return False
        else:
            if self.hasPropertyLimits():
                return True
            else:
                return False
    
    def isInputField(self):
        &#34;&#34;&#34;Returns Boolean whether the config group should be represented as an input field&#34;&#34;&#34;
        if self.nrConfigs()&gt;1:
            return False
        else:
            #If there is exactly one option...
            if self.nrConfigs() == 1:
                #And the option is &#39;NewPreset&#39;, it means there are no presets specified
                if self.core.get_available_configs(self.configGroupName()).get(0) == &#39;NewPreset&#39;:
                    #check if it&#39;s not a slider...
                    if self.hasPropertyLimits():
                        return False
                    else:
                        return True
                else:
                    return False

    def helpStringInfo(self):
        &#34;&#34;&#34;Provides some info about the config group, whether it should be a dropdown, slider, input field&#34;&#34;&#34;
        infostring=&#39;No option for this config&#39;
        if self.isDropDown():
            infostring = &#34;Device {} should be an dropdown with {} options&#34;.format(self.configGroupName(),self.nrConfigs())
        if self.isSlider():
            infostring = &#34;Device {} should be an Slider with limits {}-{}&#34;.format(self.configGroupName(),self.lowerLimit(),self.upperLimit())
        if self.isInputField():
            infostring = &#34;Device {} should be an input field&#34;.format(self.configGroupName())
        return infostring
    
    def getCurrentMMValue(self):
        &#34;&#34;&#34;Get the current MM value of this config group:&#34;&#34;&#34;
        return self.core.get_current_config(self.configGroupName())

    def getStorableValue(self):
        &#34;&#34;&#34;Get the current MM value of this config group, in a storable manner - i.e. depending on slider, input, dropdown:&#34;&#34;&#34;
        if self.isDropDown():
            return self.core.get_current_config(self.configGroupName())
        if self.isSlider():
            #A slider config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.configGroupName()
            underlyingProperty = self.core.get_available_configs(configGroupName).get(0)
            configdata = self.core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()
            
            #Finally we get the current value of the slider
            currentSliderValue = float(self.core.get_property(device_label,property_name))
            return currentSliderValue
        if self.isInputField():
            #An input field config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.configGroupName()
            underlyingProperty = self.core.get_available_configs(configGroupName).get(0)
            configdata = self.core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()
            
            #Finally we get the current value of the slider
            try:
                currentValue = (self.core.get_property(device_label,property_name))
            except:
                currentValue = 0
            return currentValue</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MMcontrols.ConfigInfo.configGroupName"><code class="name flex">
<span>def <span class="ident">configGroupName</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the config group name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configGroupName(self):
    &#34;&#34;&#34;
    Returns the config group name
    &#34;&#34;&#34;
    return self.core.get_available_config_groups().get(self.config_group_id)</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.configName"><code class="name flex">
<span>def <span class="ident">configName</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the config within the config group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configName(self,config_id):
    &#34;&#34;&#34;Returns the name of the config within the config group&#34;&#34;&#34;
    return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).get(config_id)</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.deviceNameProperty_fromVerbose"><code class="name flex">
<span>def <span class="ident">deviceNameProperty_fromVerbose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the first device name and property from Verbose</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deviceNameProperty_fromVerbose(self):
    &#34;&#34;&#34;Returns the first device name and property from Verbose&#34;&#34;&#34;
    verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
    start_index = verboseInfoCurrentConfigGroup.find(&#34;&lt;html&gt;&#34;) + len(&#34;&lt;html&gt;&#34;)
    end_index = verboseInfoCurrentConfigGroup.find(&#34;:&#34;)
    deviceName = verboseInfoCurrentConfigGroup[start_index:end_index]
    start_index = end_index + len(&#34;:&#34;)
    end_index = verboseInfoCurrentConfigGroup.find(&#34;=&#34;)
    deviceProperty  = verboseInfoCurrentConfigGroup[start_index:end_index]
    return deviceName,deviceProperty</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.getCurrentMMValue"><code class="name flex">
<span>def <span class="ident">getCurrentMMValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current MM value of this config group:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCurrentMMValue(self):
    &#34;&#34;&#34;Get the current MM value of this config group:&#34;&#34;&#34;
    return self.core.get_current_config(self.configGroupName())</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.getStorableValue"><code class="name flex">
<span>def <span class="ident">getStorableValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current MM value of this config group, in a storable manner - i.e. depending on slider, input, dropdown:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getStorableValue(self):
    &#34;&#34;&#34;Get the current MM value of this config group, in a storable manner - i.e. depending on slider, input, dropdown:&#34;&#34;&#34;
    if self.isDropDown():
        return self.core.get_current_config(self.configGroupName())
    if self.isSlider():
        #A slider config by definition (?) only has a single property underneath, so get that:
        configGroupName = self.configGroupName()
        underlyingProperty = self.core.get_available_configs(configGroupName).get(0)
        configdata = self.core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()
        
        #Finally we get the current value of the slider
        currentSliderValue = float(self.core.get_property(device_label,property_name))
        return currentSliderValue
    if self.isInputField():
        #An input field config by definition (?) only has a single property underneath, so get that:
        configGroupName = self.configGroupName()
        underlyingProperty = self.core.get_available_configs(configGroupName).get(0)
        configdata = self.core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()
        
        #Finally we get the current value of the slider
        try:
            currentValue = (self.core.get_property(device_label,property_name))
        except:
            currentValue = 0
        return currentValue</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.hasPropertyLimits"><code class="name flex">
<span>def <span class="ident">hasPropertyLimits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns whether the config group has property limits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasPropertyLimits(self):
    &#34;&#34;&#34;Returns whether the config group has property limits&#34;&#34;&#34;
    #Get the verbose info from the config group state
    verboseInfoCurrentConfigGroup = self.core.get_config_group_state(self.configGroupName()).get_verbose()
    #Determine the number of devices in the verbose info
    nrDevicesFromVerbose = verboseInfoCurrentConfigGroup.count(&#39;&lt;br&gt;&#39;)
    if nrDevicesFromVerbose == 1 and self.nrConfigs() == 1:
        [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
        #Determines whether the device name/property has limits:
        if self.core.has_property_limits(deviceName,deviceProperty):
            return True
        else:
            return False
    else:
        return False</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.helpStringInfo"><code class="name flex">
<span>def <span class="ident">helpStringInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides some info about the config group, whether it should be a dropdown, slider, input field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def helpStringInfo(self):
    &#34;&#34;&#34;Provides some info about the config group, whether it should be a dropdown, slider, input field&#34;&#34;&#34;
    infostring=&#39;No option for this config&#39;
    if self.isDropDown():
        infostring = &#34;Device {} should be an dropdown with {} options&#34;.format(self.configGroupName(),self.nrConfigs())
    if self.isSlider():
        infostring = &#34;Device {} should be an Slider with limits {}-{}&#34;.format(self.configGroupName(),self.lowerLimit(),self.upperLimit())
    if self.isInputField():
        infostring = &#34;Device {} should be an input field&#34;.format(self.configGroupName())
    return infostring</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.isDropDown"><code class="name flex">
<span>def <span class="ident">isDropDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Boolean whether the config group should be represented as a drop-down menu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isDropDown(self):
    &#34;&#34;&#34;Returns Boolean whether the config group should be represented as a drop-down menu&#34;&#34;&#34;
    if self.nrConfigs()&gt;1:
        return True
    else:
        #If there is exactly one option...
        if self.nrConfigs() == 1:
            #And the option is &#39;NewPreset&#39;, it means there are no presets specified
            if self.core.get_available_configs(self.configGroupName()).get(0) == &#39;NewPreset&#39;:
                return False
            else:
                return True</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.isInputField"><code class="name flex">
<span>def <span class="ident">isInputField</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Boolean whether the config group should be represented as an input field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isInputField(self):
    &#34;&#34;&#34;Returns Boolean whether the config group should be represented as an input field&#34;&#34;&#34;
    if self.nrConfigs()&gt;1:
        return False
    else:
        #If there is exactly one option...
        if self.nrConfigs() == 1:
            #And the option is &#39;NewPreset&#39;, it means there are no presets specified
            if self.core.get_available_configs(self.configGroupName()).get(0) == &#39;NewPreset&#39;:
                #check if it&#39;s not a slider...
                if self.hasPropertyLimits():
                    return False
                else:
                    return True
            else:
                return False</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.isSlider"><code class="name flex">
<span>def <span class="ident">isSlider</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Boolean whether the config group should be represented as a slider</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isSlider(self):
    &#34;&#34;&#34;Returns Boolean whether the config group should be represented as a slider&#34;&#34;&#34;
    if self.nrConfigs()&gt;1:
        return False
    else:
        if self.hasPropertyLimits():
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.lowerLimit"><code class="name flex">
<span>def <span class="ident">lowerLimit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds lower limit of the device property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lowerLimit(self):
    &#34;&#34;&#34;Finds lower limit of the device property&#34;&#34;&#34;
    [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
    if self.core.has_property_limits(deviceName,deviceProperty):
        lowerLimit = self.core.get_property_lower_limit(deviceName,deviceProperty)
    else:
        lowerLimit = 0
    return lowerLimit</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.nrConfigs"><code class="name flex">
<span>def <span class="ident">nrConfigs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of config options for this config group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nrConfigs(self):
    &#34;&#34;&#34;Returns the number of config options for this config group&#34;&#34;&#34;
    return self.core.get_available_configs(self.core.get_available_config_groups().get(self.config_group_id)).size()</code></pre>
</details>
</dd>
<dt id="MMcontrols.ConfigInfo.upperLimit"><code class="name flex">
<span>def <span class="ident">upperLimit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds upper limit of the device property</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upperLimit(self):
    &#34;&#34;&#34;Finds upper limit of the device property&#34;&#34;&#34;
    [deviceName,deviceProperty] = self.deviceNameProperty_fromVerbose()
    if self.core.has_property_limits(deviceName,deviceProperty):
        upperLimit = self.core.get_property_upper_limit(deviceName,deviceProperty)
    else:
        upperLimit = 0
    return upperLimit</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MMcontrols.MMConfigUI"><code class="flex name class">
<span>class <span class="ident">MMConfigUI</span></span>
<span>(</span><span>config_groups, parent=None, showConfigs=True, showStages=True, showROIoptions=True, showShutterOptions=True, showLiveSnapExposureButtons=True, number_config_columns=5, changes_update_MM=True, showCheckboxes=False, checkboxStartInactive=True, showRelativeStages=False, autoSaveLoad=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to create a MicroManager config UI</p>
<p>A class to create a MicroManager config UI with the given configuration groups.</p>
<p>This class will create a UI with a layout of checkboxes, sliders, input fields, dropdowns, etc
The user can select which config groups to show and which configs to show for each config group. The user can also change the configs real-time. </p>
<h2 id="parameters">Parameters</h2>
<p>config_groups (list): A list of configuration groups. Get this as follows:
nrconfiggroups = core.get_available_config_groups().size()
for config_group_id in range(nrconfiggroups):
allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
showConfigs (bool, optional): Whether to show the configurations in the UI. Defaults to True.
showStages (bool, optional): Whether to show the stages in the UI. Defaults to True.
showROIoptions (bool, optional): Whether to show the ROI options in the UI. Defaults to True.
showShutterOptions (bool, optional): Whether to show the Shutter options in the UI. Defaults to True.
showLiveSnapExposureButtons (bool, optional): Whether to show the live mode in the UI. Defaults to True.
number_config_columns (int, optional): The number of columns in the layout. Defaults to 5.
changes_update_MM (bool, optional): Whether to update the configs in MicroManager real-time. Defaults to True.
showCheckboxes (bool, optional): Whether to show checkboxes for each config group. Defaults to False.
checkboxStartInactive (bool, optional): Whether the checkboxes should start inactive. Defaults to True.
showRelativeStages (bool, optional): Whether to show the relative stages in the UI. Defaults to False.
autoSaveLoad (bool, optional): Whether to automatically save and load the configs to file when the UI is opened and closed. Defaults to False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MMConfigUI(CustomMainWindow):
    &#34;&#34;&#34;
        A class to create a MicroManager config UI
    &#34;&#34;&#34;
    def __init__(self, config_groups,parent=None,showConfigs = True,showStages=True,showROIoptions=True,showShutterOptions=True,showLiveSnapExposureButtons=True,number_config_columns=5,changes_update_MM = True,showCheckboxes = False,checkboxStartInactive=True,showRelativeStages = False,autoSaveLoad=False):
        &#34;&#34;&#34;
        A class to create a MicroManager config UI with the given configuration groups.
        
        This class will create a UI with a layout of checkboxes, sliders, input fields, dropdowns, etc
        The user can select which config groups to show and which configs to show for each config group. The user can also change the configs real-time. 
        
        Parameters:
            config_groups (list): A list of configuration groups. Get this as follows:
                nrconfiggroups = core.get_available_config_groups().size()
                for config_group_id in range(nrconfiggroups):
                    allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
            showConfigs (bool, optional): Whether to show the configurations in the UI. Defaults to True.
            showStages (bool, optional): Whether to show the stages in the UI. Defaults to True.
            showROIoptions (bool, optional): Whether to show the ROI options in the UI. Defaults to True.
            showShutterOptions (bool, optional): Whether to show the Shutter options in the UI. Defaults to True.
            showLiveSnapExposureButtons (bool, optional): Whether to show the live mode in the UI. Defaults to True.
            number_config_columns (int, optional): The number of columns in the layout. Defaults to 5.
            changes_update_MM (bool, optional): Whether to update the configs in MicroManager real-time. Defaults to True.
            showCheckboxes (bool, optional): Whether to show checkboxes for each config group. Defaults to False.
            checkboxStartInactive (bool, optional): Whether the checkboxes should start inactive. Defaults to True.
            showRelativeStages (bool, optional): Whether to show the relative stages in the UI. Defaults to False.
            autoSaveLoad (bool, optional): Whether to automatically save and load the configs to file when the UI is opened and closed. Defaults to False. 
        &#34;&#34;&#34;
        
        if parent is not None:# from napari plugin run
            global core, livestate, napariViewer, shared_data
            core = parent.core
            livestate = parent.livestate
            shared_data = parent.shared_data
            napariViewer = parent.napariViewer
            shared_data.napariViewer = napariViewer
        else: #assuming shared_data is global - from .py run
            try:
                # global core, napariViewer
                core = shared_data.core
                napariViewer = shared_data.napariViewer
            except:
                logging.error(&#39;Line 237 fails&#39;)
        super().__init__()
        self.fullyLoaded = False
        self.autoSaveLoad = autoSaveLoad
        self.showConfigs = showConfigs
        self.showStages = showStages
        self.showROIoptions = showROIoptions
        self.showShutterOptions = showShutterOptions
        self.showLiveSnapExposureButtons = showLiveSnapExposureButtons
        self.showCheckboxes = showCheckboxes
        self.showRelativeStages = showRelativeStages
        self.config_groups = config_groups
        self.number_columns = number_config_columns
        self.changes_update_MM = changes_update_MM
        if self.config_groups is not None:
            self.core = self.config_groups[0].core
        else:
            self.core = None
        self.dropDownBoxes = {}
        self.sliders = {}
        self.editFields = {}
        self.configCheckboxes = {}
        self.sliderPrecision = 1000
        self.config_string_storage = []
        self.relstage_string_storage = []
        #Create a Vertical+horizontal layout:
        self.mainLayout = QGridLayout()
        self.configEntries = {}
        
        import glados_pycromanager
        # Get the installation path of the package
        package_path = os.path.dirname(glados_pycromanager.__file__)
        # Construct the path to the Icons folder
        self.iconFolder = os.path.join(package_path, &#39;GUI&#39;, &#39;Icons&#39;)

        if not os.path.exists(self.iconFolder):
            #Find the iconPath folder
            if os.path.exists(&#39;./glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados_pycromanager/GUI/Icons/&#39;
            elif os.path.exists(&#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/&#39;
            else:
                self.iconFolder = &#39;&#39;
        
        
        if showLiveSnapExposureButtons:
            self.generalImagingGroupBox = QGroupBox(&#34;General&#34;)
            
            #Now add the live mode widget
            # self.liveModeGroupBox = QGroupBox(&#34;Live Mode&#34;)
            self.generalImagingGroupBox.setLayout(self.generalImagingLayout())
            self.mainLayout.addWidget(self.generalImagingGroupBox, 0, 0)
            
            #TODO: add shutter here
            
            
            
        if showConfigs:
            #Create a layout for the configs:
            self.configGroupBox = QGroupBox(&#34;Configurations&#34;)
            self.configLayout = QGridLayout()
            self.configLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
            #Add this to the mainLayout via the groupbox:
            self.configGroupBox.setLayout(self.configLayout)
            self.mainLayout.addWidget(self.configGroupBox,0,2)
            #Fill the configLayout
            for config_id in range(len(config_groups)):
                self.configEntries[config_id] = self.addRow(config_id)
            pass
        
            #Add a button to refresh from MM:
            self.refreshButton = QPushButton(&#34;Refresh configs from MM&#34;)
            totalRowsAdded = int(np.ceil(len(config_groups)/self.number_columns))
            #Add a button spanning the total columns at the bottom
            self.configLayout.addWidget(self.refreshButton,totalRowsAdded+99,0,1,self.number_columns)
            #Connect the button:
            self.refreshButton.clicked.connect(lambda index: self.updateConfigsFromMM())
            
        
        #Add the stages widget to the right of this if wanted
        if showStages:
            #Now add the stages widget
            # self.stagesWidget()
            self.stagesGroupBox = QGroupBox(&#34;Stages&#34;)
            self.stagesGroupBox.setLayout(self.stagesLayout())
            self.mainLayout.addWidget(self.stagesGroupBox, 0, 3)
        
        
        if showRelativeStages:
            self.relativeStagesGroupBox = QGroupBox(&#34;RelativeStages&#34;)
            self.relativeStagesGroupBox.setLayout(self.relativeStagesLayout())
            # self.relativeStagesGroupBox.setLayout(QLayout())
            self.mainLayout.addWidget(self.relativeStagesGroupBox, 0, 4)
        
        #Add a horizontal auto-widening object to mainlayout:
        from PyQt5.QtWidgets import QSpacerItem, QSizePolicy
        from PyQt5 import QtWidgets
        spacer = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.mainLayout.addItem(spacer,0,99)
        
        #Update everything for good measure at the end of init
        self.updateAllMMinfo()
        self.fullyLoaded = True
        self.LoadAllMMFromJSON()
        
        #Inactivate all configs if this is wanted
        if checkboxStartInactive and showCheckboxes and showConfigs:
            for config_id in range(len(config_groups)):
                self.configCheckboxes[config_id].setChecked(False)
                    
        #Change the font of everything in the layout
        self.set_font_and_margins_recursive(self.mainLayout, font=QFont(&#34;Arial&#34;, 7))
        #Twice because it relies on dependancies inside qgridlayouts
        self.set_font_and_margins_recursive(self.mainLayout, font=QFont(&#34;Arial&#34;, 7))
    
    #region General
    def updateAllMMinfo(self):
        &#34;&#34;&#34;
        Update all the info that can be updated from the microscope.
        &#34;&#34;&#34;
        logging.debug(&#39;Updating all MM info&#39;)
        if self.showConfigs:
            self.updateConfigsFromMM()
        if self.showStages:
            self.updateXYStageInfoWidget()
            self.updateOneDstageLayout()
        if self.showShutterOptions:
            self.updateShutterOptions()
        
        #Then store it in JSON for good measure
        if self.autoSaveLoad:
            if self.fullyLoaded:
                #Store in appdata
                appdata_folder = os.getenv(&#39;APPDATA&#39;)
                if appdata_folder is None:
                    raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
                app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
                os.makedirs(app_specific_folder, exist_ok=True)
                self.save_state_MMControls(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
                
        #         #Store in appdata
        #         appdata_folder = os.getenv(&#39;APPDATA&#39;)
        #         if appdata_folder is None:
        #             raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        #         app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
        #         os.makedirs(app_specific_folder, exist_ok=True)
                
                
        #         if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
        #             with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
        #                 gladosInfo = json.load(file)
        #                 MMControlsInfo = gladosInfo[&#39;MMControls&#39;]
                
        #             #Hand-set the values that I want:
        #             if &#39;exposureTimeInputField&#39; in MMControlsInfo:
        #                 self.exposureTimeInputField.setText(MMControlsInfo[&#39;exposureTimeInputField&#39;][&#39;text&#39;])
        #             for key, object in self.XYMoveEditField.items():
        #                 if key in MMControlsInfo:
        #                     object.setText(MMControlsInfo[key][&#39;text&#39;])
        #             for key,object in self.oneDMoveEditField.items():
        #                 for objectLineEditKey in object:
        #                     objectLineEdit = object[objectLineEditKey]
        #                     if objectLineEditKey in MMControlsInfo:
        #                         objectLineEdit.setText(MMControlsInfo[objectLineEditKey][&#39;text&#39;])

    def LoadAllMMFromJSON(self):
        &#34;&#34;&#34;
        Update all the info that can be loaded from the JSON file.
        &#34;&#34;&#34;
        #Load from APPData, if it exists
        appdata_folder = os.getenv(&#39;APPDATA&#39;)
        if appdata_folder is None:
            raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
        
        if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
            #Load the file
            with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
                gladosInfo = json.load(file)
                MMControlsInfo = gladosInfo[&#39;MMControls&#39;]
        
            #Hand-set the values that I want:
            if &#39;exposureTimeInputField&#39; in MMControlsInfo:
                if hasattr(self, &#39;exposureTimeInputField&#39;):
                    self.exposureTimeInputField.setText(MMControlsInfo[&#39;exposureTimeInputField&#39;][&#39;text&#39;])
            if &#39;oneDstageDropdown&#39; in MMControlsInfo:
                if hasattr(self, &#39;oneDstageDropdown&#39;):
                    self.oneDstageDropdown.setCurrentText(MMControlsInfo[&#39;oneDstageDropdown&#39;][&#39;text&#39;])
            
            if hasattr(self, &#39;XYMoveEditField&#39;):
                for key, object in self.XYMoveEditField.items():
                    if key in MMControlsInfo:
                        object.setText(MMControlsInfo[key][&#39;text&#39;])
            if hasattr(self, &#39;oneDMoveEditField&#39;):
                for key,object in self.oneDMoveEditField.items():
                    for objectLineEditKey in object:
                        objectLineEdit = object[objectLineEditKey]
                        if objectLineEditKey in MMControlsInfo:
                            objectLineEdit.setText(MMControlsInfo[objectLineEditKey][&#39;text&#39;])

    def storeAllControlValues(self):
        &#34;&#34;&#34;
        Store all the control values in a dictionary, which can be used to save state.
        &#34;&#34;&#34;
        if self.autoSaveLoad:
            if self.fullyLoaded:
                logging.debug(&#39;Storing glados state.json&#39;)
                
                #Store in appdata
                appdata_folder = os.getenv(&#39;APPDATA&#39;)
                if appdata_folder is None:
                    raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
                app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
                os.makedirs(app_specific_folder, exist_ok=True)
                self.save_state_MMControls(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
                pass

    def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
        &#34;&#34;&#34;
        Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
        Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.

        &#34;&#34;&#34;
        # if widget is None:
        #     return
        #Testing a few things
        # try:
        #     widget.setSizePolicy(
        #         QSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        #     )
        # except:
        #     pass
        # try:
        #     widget.setMimimumSize(10, 10)
        # except:
        #     pass
        
        # if not isinstance(widget, (QPushButton,QComboBox)):
        #     try:
        #         widget.setSizePolicy(
        #             QSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        #         )
        #     except:
        #         pass
        
        if isinstance(widget, (QPushButton)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)
        if isinstance(widget, (QLabel, QComboBox)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)

        if isinstance(widget, QGroupBox):
            widget.setSizePolicy(
                QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            )
            # Ensure QGroupBox respects the size of its contents
            widget.setMinimumSize(widget.minimumSizeHint())  # Set the minimum size of QGroupBox based on its size hint

        if hasattr(widget, &#39;layout&#39;):
            layout = widget.layout()
            if layout:
                # layout.setContentsMargins(0, 0, 0, 0)
                # layout.setSpacing(0)  # Optionally, remove spacing between widgets
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if hasattr(item, &#39;widget&#39;):
                        self.set_font_and_margins_recursive(item.widget(), font=font)
                    if hasattr(item, &#39;layout&#39;):
                        self.set_font_and_margins_recursive(item.layout(), font=font)
    
    #Get all config information as set by the UI:
    def getUIConfigInfo(self,onlyChecked=False):
        &#34;&#34;&#34;
        Get all config information as set by the UI.

        param onlyChecked: If True, only return information for checked configs.
        &#34;&#34;&#34;
        configInfo = {}
        for config_id in range(len(self.config_groups)):
            if onlyChecked and not self.configCheckboxes[config_id].isChecked():
                continue
            configInfo[self.config_groups[config_id].configGroupName()] = self.currentConfigUISingleValue(config_id)
        return configInfo

    def currentConfigUISingleValue(self,config_id):
        &#34;&#34;&#34;
        Get the value of a single config as currently determined by the UI.

        param config_id: The ID of the config_group to get the value for.
        &#34;&#34;&#34;
        #Get the value of a single config as currently determined by the UI
        if self.config_groups[config_id].isDropDown():
            currentUIvalue = self.dropDownBoxes[config_id].currentText()
        elif self.config_groups[config_id].isSlider():
            #Get the value from the slider:
            sliderValue = self.sliders[config_id].value()
            #Get the true value from the conversion:
            currentUIvalue = sliderValue/self.sliders[config_id].slider_conversion_array[2]*(self.sliders[config_id].slider_conversion_array[1]-self.sliders[config_id].slider_conversion_array[0])+self.sliders[config_id].slider_conversion_array[0]
        elif self.config_groups[config_id].isInputField():
            currentUIvalue = self.editFields[config_id].text()
        else:
            currentUIvalue = None
        return currentUIvalue
    #endregion
    
    #region general imaging mode
    def generalImagingLayout(self):
        &#34;&#34;&#34;
        Creates the layout for the general imaging mode options.
        This includes an input field for the exposure time in ms.
        Basically, should be exposure time (ms), snap, addToAlbum, live start/stop

        Returns:
            QGridLayout: The layout for the live mode options.
        &#34;&#34;&#34;
        #Create a Grid layout:
        liveModeLayout = QGridLayout()
        liveModeLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
        #Add a &#39;exposure time&#39; label:
        exposureTimeLabel = QLabel(&#34;Exposure time (ms):&#34;)
        liveModeLayout.addWidget(exposureTimeLabel,0,0)
        #Add a &#39;exposure time&#39; input field:
        self.exposureTimeInputField = QLineEdit()
        self.exposureTimeInputField.setText(str(100))
        self.exposureTimeInputField.editingFinished.connect(lambda: self.storeAllControlValues())
        liveModeLayout.addWidget(self.exposureTimeInputField,0,1)
        
        self.livesnapalbumbuttons = QHBoxLayout()
        
        self.LiveModeButton = QPushButton(&#34;Start Live Mode&#34;)
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Start.png&#39;)
        # icon: Flaticon.com
        self.LiveModeButton.setIcon(icon)
        
        #add a connection to the button:
        self.LiveModeButton.clicked.connect(lambda index: self.changeLiveMode())
        #Add the button to the layout:
        self.livesnapalbumbuttons.addWidget(self.LiveModeButton)
        
        self.SnapButton = QPushButton(&#34;Snap&#34;)
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Snap.png&#39;)
        # icon: Flaticon.com
        self.SnapButton.setIcon(icon)
        #add a connection to the button:
        self.SnapButton.clicked.connect(lambda index: self.snapImage())
        #Add the button to the layout:
        self.livesnapalbumbuttons.addWidget(self.SnapButton)
        
        self.AlbumButton = QPushButton(&#34;Add to Album&#34;)
        #add a connection to the button:
        self.AlbumButton.clicked.connect(lambda index: self.addImageToAlbum())
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Album.png&#39;)
        # icon: Flaticon.com
        self.AlbumButton.setIcon(icon)
        #Add the button to the layout:
        self.livesnapalbumbuttons.addWidget(self.AlbumButton)
        
        liveModeLayout.addLayout(self.livesnapalbumbuttons,1,0,1,2)
        
        if self.showShutterOptions:
            self.shutterOptionsGroupBox = QGroupBox(&#34;Shutter&#34;)
            self.shutterOptionsGroupBox.setLayout(self.shutterOptionsLayout(orientation=&#39;horizontal&#39;))
            liveModeLayout.addWidget(self.shutterOptionsGroupBox, 4,0,1,2)
            
        
        if self.showROIoptions:
            #Now add the ROI options widget
            self.roiOptionsGroupBox = QGroupBox(&#34;ROI Options&#34;)
            self.roiOptionsGroupBox.setLayout(self.ROIoptionsLayout(orientation=&#39;horizontal&#39;))
            liveModeLayout.addWidget(self.roiOptionsGroupBox, 5,0,1,2)
        
        #Add one of those spacers at the bottom:
        verticalSpacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        liveModeLayout.addItem(verticalSpacer)
        
        #Add a button to update all MM info
        
        #Create a &#39;debug-ish&#39; button list:
        debugHbox = QHBoxLayout()
        self.updateAllMMinfoButton = QPushButton(&#34;Update all MM info&#34;)
        self.updateAllMMinfoButton.clicked.connect(self.updateAllMMinfo)
        #all the way at the bottom of the layout
        debugHbox.addWidget(self.updateAllMMinfoButton)
        #Add a button to close all layers
        self.closeAllLayersButton = QPushButton(&#34;Close all Layers&#34;)
        self.closeAllLayersButton.clicked.connect(lambda index, shared_data=shared_data: utils.closeAllLayers(shared_data))
        
        #all the way at the bottom of the layout
        debugHbox.addWidget(self.closeAllLayersButton)
        
        self.forceResetButton = QPushButton(&#34;Force-reset&#34;)
        self.forceResetButton.clicked.connect(lambda index, shared_data=shared_data: utils.forceReset(shared_data))
        debugHbox.addWidget(self.forceResetButton)
        
        
        self.advSettingsButton = QPushButton(&#34;Adv. settings&#34;)
        self.advSettingsButton.clicked.connect(lambda index, shared_data=shared_data: utils.openAdvancedSettings(shared_data))
        debugHbox.addWidget(self.advSettingsButton)
        
        liveModeLayout.addLayout(debugHbox,99,0,1,2)
        
        #Return the layout
        return liveModeLayout
    
    def snapImage(self):
        &#34;&#34;&#34;
        Function that&#39;s called when an image is snapped (i.e. get a single image), uses the float(self.exposureTimeInputField.text()) as time in ms
        &#34;&#34;&#34;
        #Set the correct exposure time
        shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
        #Snap an image
        shared_data.core.snap_image()
        #Get the just-snapped image
        newImage = shared_data.core.get_tagged_image()
        snapLayer = checkIfLayerExistsOrCreate(napariViewer,&#39;Snap&#39;,shared_data_throughput = shared_data, required_size = (newImage.tags[&#34;Height&#34;],newImage.tags[&#34;Width&#34;]))
        snapLayer.data = np.reshape(newImage.pix, newshape=[newImage.tags[&#34;Height&#34;], newImage.tags[&#34;Width&#34;]])
        #Move the layer to top
        moveLayerToTop(napariViewer,&#39;Snap&#39;)
        return
    
    def addImageToAlbum(self):
        &#34;&#34;&#34;
        Add an image to the Album layer in napari
        &#34;&#34;&#34; 
        #Set the correct exposure time
        shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
        #Snap an image
        shared_data.core.snap_image()
        #Get the just-snapped image
        newImage = shared_data.core.get_tagged_image()
        
        #And add to the &#39;Album&#39; layer
        addToExistingOrNewLayer(napariViewer,&#39;Album&#39;,np.reshape(newImage.pix, newshape=[newImage.tags[&#34;Height&#34;], newImage.tags[&#34;Width&#34;]]),shared_data_throughput = shared_data)
        return
    
    def changeLiveMode(self):
        &#34;&#34;&#34;
        Function that should be called when live mode is changed. Sets the shared_data.liveMode to True or False.
        &#34;&#34;&#34;
        if shared_data.liveMode == False:
            #update the button text of the live mode:
            self.LiveModeButton.setText(&#34;Stop Live Mode&#34;)
            icon = QIcon(self.iconFolder+os.sep+&#39;General_Stop.png&#39;)
            # icon: Flaticon.com
            self.LiveModeButton.setIcon(icon)
            #set exposure time first:
            shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
            #Then start live mode:
            shared_data.liveMode = True
        else:
            #update the button text of the live mode:
            self.LiveModeButton.setText(&#34;Start Live Mode&#34;)
            icon = QIcon(self.iconFolder+os.sep+&#39;General_Start.png&#39;)
            # icon: Flaticon.com
            self.LiveModeButton.setIcon(icon)
            #update live mode:
            shared_data.liveMode = False
    #endregion

    #region Shutter
    def shutterOptionsLayout(self,orientation=&#39;horizontal&#39;):
        &#34;&#34;&#34;
        Create a layout with buttons for Shutter options

        Returns
        -------
        ShutterOptionsLayout : QGridLayout
            A layout with buttons for Shutter options
        &#34;&#34;&#34;
        #Create a Grid layout:
        shutterOptionsLayout = QGridLayout()
        #Add a dropdown:
        self.shutterChoiceDropdown = QComboBox()
        shutterDevices = self.getDevicesOfDeviceType(&#39;ShutterDevice&#39;)
        for shutterDevice in shutterDevices:
            self.shutterChoiceDropdown.addItem(shutterDevice)
        self.shutterChoiceDropdown.currentIndexChanged.connect(self.on_shutterChoiceChanged)
        
        self.shutterAutoCheckbox = QCheckBox(&#34;Auto&#34;)
        self.shutterAutoCheckbox.stateChanged.connect(self.on_shutterAutoCheckboxChanged)
        
        self.shutterOpenCloseButton = QPushButton(&#34;Open&#34;)
        self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterOpen.png&#39;))
        self.shutterOpenCloseButton.clicked.connect(self.on_shutterOpenCloseButtonPressed)
        
        shutterOptionsLayout.addWidget(self.shutterChoiceDropdown,0,0,1,2)
        shutterOptionsLayout.addWidget(self.shutterAutoCheckbox,1,0)
        shutterOptionsLayout.addWidget(self.shutterOpenCloseButton,1,1)
        
        return shutterOptionsLayout

    def on_shutterOpenCloseButtonPressed(self):
        &#34;&#34;&#34;&#34; 
        Method that&#39;s called when the Open/Close shutter button is pressed.
        &#34;&#34;&#34;
        current_text = self.shutterOpenCloseButton.text()
        if current_text == &#39;Open&#39;:
            self.core.set_shutter_open(True) #type:ignore
            self.shutterOpenCloseButton.setText(&#39;Close&#39;)
            self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterClosed.png&#39;))
        elif current_text == &#39;Close&#39;:
            self.core.set_shutter_open(False) #type:ignore
            self.shutterOpenCloseButton.setText(&#39;Open&#39;)
            self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterOpen.png&#39;))

    def on_shutterChoiceChanged(self):
        &#34;&#34;&#34;
        Set the shutter to the new choice if the dropdown is changed
        &#34;&#34;&#34; 
        selected_item = self.shutterChoiceDropdown.currentText()
        self.core.set_shutter_device(selected_item) #type:ignore

    def on_shutterAutoCheckboxChanged(self,state):
        &#34;&#34;&#34;
        Set the auto-shutter to whether the checkbox is selected or not
        &#34;&#34;&#34;
        if state == 2:
            self.shutterOpenCloseButton.setEnabled(False)
            self.core.set_auto_shutter(True) #type:ignore
        else:
            self.shutterOpenCloseButton.setEnabled(True)
            self.core.set_auto_shutter(False) #type:ignore
    
    def updateShutterOptions(self):
        &#34;&#34;&#34;&#34; 
        Update the shutter GUI options based on what&#39;s what in MM
        &#34;&#34;&#34;
        #Set the current shutter device to the one in MM
        currentShutterDevice = self.core.get_shutter_device() #type:ignore
        self.shutterChoiceDropdown.currentText = currentShutterDevice
        #Set the auto-method to the one in MM:
        currentShutterAuto = self.core.get_auto_shutter() #type:ignore
        self.shutterAutoCheckbox.setChecked(currentShutterAuto)
        if currentShutterAuto == False:
            self.shutterOpenCloseButton.setEnabled(True)
        #Set the button text
        currentShutterOpen = self.core.get_shutter_open() #type:ignore
        if currentShutterOpen == True:
            self.shutterOpenCloseButton.setText(&#39;Close&#39;)
        else:
            self.shutterOpenCloseButton.setText(&#39;Open&#39;)
        
    #endregion

    #region ROI
    def ROIoptionsLayout(self,orientation=&#39;horizontal&#39;):
        &#34;&#34;&#34;
        Create a layout with buttons for ROI options

        Returns
        -------
        ROIoptionsLayout : QGridLayout
            A layout with buttons for ROI options
        &#34;&#34;&#34;
        #Create a Grid layout:
        ROIoptionsLayout = QGridLayout()
        self.ROIoptionsButtons = {}
        #Following options should be added:
        #Reset ROI to max size
        self.ROIoptionsButtons[&#39;Reset&#39;] = QPushButton(&#34;Reset ROI&#34;)
        self.ROIoptionsButtons[&#39;Reset&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_reset.png&#39;))
        self.ROIoptionsButtons[&#39;Reset&#39;].clicked.connect(lambda index: self.resetROI())
        #Zoom in once to center
        self.ROIoptionsButtons[&#39;ZoomIn&#39;] = QPushButton(&#34;Zoom In&#34;)
        self.ROIoptionsButtons[&#39;ZoomIn&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_zoomIn.png&#39;))
        self.ROIoptionsButtons[&#39;ZoomIn&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomIn&#39;))
        #Zoom out once from center
        self.ROIoptionsButtons[&#39;ZoomOut&#39;] = QPushButton(&#34;Zoom Out&#34;)
        self.ROIoptionsButtons[&#39;ZoomOut&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_zoomOut.png&#39;))
        self.ROIoptionsButtons[&#39;ZoomOut&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomOut&#39;))
        #Draw a ROI
        self.ROIoptionsButtons[&#39;drawROI&#39;] = QPushButton(&#34;Draw ROI&#34;)
        self.ROIoptionsButtons[&#39;drawROI&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_select.png&#39;))
        self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.drawROI())
        if orientation == &#39;vertical&#39;:
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],1,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],2,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;drawROI&#39;],3,0)
        else:
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],0,1)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],0,2)
            ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;drawROI&#39;],0,3)
        return ROIoptionsLayout
    
    def resetROI(self):
        &#34;&#34;&#34;
        Reset the ROI to its maximum size

        This function resets the ROI to its maximum size, which is the size of the image
        &#34;&#34;&#34;
        self.core.clear_roi() #type:ignore
    
    def zoomROI(self,option):
        &#34;&#34;&#34;
        Zoom the ROI in or out from the center
        
        This function zooms the ROI in or out from the center.
        It zooms the ROI by a factor of 2.
        If the option is &#34;ZoomIn&#34;, the ROI is zoomed in twice.
        If the option is &#34;ZoomOut&#34;, the ROI is zoomed out twice
        &#34;&#34;&#34;
        #Get the current ROI info
        #[x,y,width,height]
        roiv = [self.core.get_roi().x,self.core.get_roi().y,self.core.get_roi().width,self.core.get_roi().height] #type:ignore
        logging.debug(&#39;ROI zoom requested, current size: &#39;+str(roiv))
        if option == &#39;ZoomIn&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth/2)
                newTotHeight = int(curTotHeight/2)
                newX = int(roiv[0]+(curTotWidth-newTotWidth)/2)
                newY = int(roiv[1]+(curTotHeight-newTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
        elif option == &#39;ZoomOut&#39;:
            #zoom in twice
            try:
                #Get current widht/height and new width/height
                curTotWidth = roiv[2]
                curTotHeight = roiv[3]
                newTotWidth = int(curTotWidth*2)
                newTotHeight = int(curTotHeight*2)
                newX = int(roiv[0]-(newTotWidth-curTotWidth)/2)
                newY = int(roiv[1]-(newTotHeight-curTotHeight)/2)
                #Set the new ROI size
                self.setROI([newX,newY,newTotWidth,newTotHeight])
            except:
                logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
    
    def setROI(self,ROIpos):
        &#34;&#34;&#34;
        Set the ROI to the specified position and size.
        
        The ROIpos should be a list of [x,y,width,height]
        &#34;&#34;&#34;
        #ROIpos should be a list of [x,y,width,height]
        logging.debug(&#39;Zooming ROI to &#39; + str(ROIpos))
        try:
            if shared_data.liveMode == False:
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3]) #type:ignore
                self.core.wait_for_system() #type:ignore
            else:
                shared_data.liveMode = False
                self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3]) #type:ignore
                time.sleep(0.5)
                shared_data.liveMode = True
        except:
            logging.error(&#39;ZOOMING DIDN\&#39;T WORK!&#39;)
    
    def shape_drawn_callback(self, event):
        if len(self.drawROIlayer.data) &gt; 0:
            if not event.source._is_moving and not event.source._is_selecting and not event.source._is_creating and len(event.source._mouse_drag_gen) &gt; 0 and event.source.name != &#39;Draw ROI_&#39;:
                logging.debug(&#39;Finished drawing an area for the ROI size!&#39;)
                
                def acceptFun(dialogV):
                    self.setROItoDrawn()
                    #Close the dialog:
                    dialogV.done(QDialog.Accepted)
                
                
                
                def reDoFun(dialogV,layer):
                    #Remove the layer
                    shared_data.napariViewer.layers.remove(layer)
                    #Restart the drawROI:
                    self.drawROI()
                    #Close the dialog:
                    dialogV.done(QDialog.Rejected)
                
                def cancelFun(dialogV,layer):
                    #Remove the layer
                    shared_data.napariViewer.layers.remove(layer)
                    #Close the dialog:
                    dialogV.done(QDialog.Rejected)
                
                #Change the layer name so this won&#39;t pop up again after dialog is closed.
                event.source.name = &#39;Draw ROI_&#39;
                #Pop up a dialog box to ask if they like it or not:
                #Create a dialog box
                from PyQt5.QtWidgets import QDialog, QDialogButtonBox, QVBoxLayout, QLabel
                dialog =  QDialog()
                dialog.setWindowTitle(&#39;Draw ROI&#39;)
                #Add 3 buttons: 
                QButtonOk = QPushButton(&#39;OK&#39;)
                QButtonRedraw = QPushButton(&#39;Redraw&#39;)
                QButtonCancel = QPushButton(&#39;Cancel&#39;)
                #add the box to dialog:
                layout = QVBoxLayout()
                layout.addWidget(
                    QLabel(&#39;ROI drawn correctly?&#39;)
                )
                buttonBox = QHBoxLayout()
                buttonBox.addWidget(QButtonOk)
                buttonBox.addWidget(QButtonRedraw)
                buttonBox.addWidget(QButtonCancel)
                layout.addLayout(buttonBox)
                dialog.setLayout(layout)
                #Connect the buttons to the dialog:
                QButtonOk.clicked.connect(lambda: acceptFun(dialog))
                QButtonRedraw.clicked.connect(lambda: reDoFun(dialog,event.source))
                QButtonCancel.clicked.connect(lambda: cancelFun(dialog,event.source))
                #Show the dialog:
                dialog.exec_()
            
            
    def drawROI(self):
        &#34;&#34;&#34;
        Draw a ROI. Idea is to create a new layer, let the user draw a rectangle, and ask if they like it or not. Then a small popup window with &#39;OK&#39;, &#39;Let me draw again&#39;, &#39;Stop this futile attempt&#39;
        &#34;&#34;&#34;
        
            
        # Create a shapes layer
        self.drawROIlayer = shared_data.napariViewer.add_shapes(name=&#39;Draw ROI&#39;)
        self.drawROIlayer.events.set_data.connect(self.shape_drawn_callback)


        # Set the shapes layer mode to &#39;add_rectangle&#39;
        self.drawROIlayer.mode = &#39;add_rectangle&#39;
        
        #Changes the button to a different method, which should be pressed once the rectangle is drawn:
        # self.ROIoptionsButtons[&#39;drawROI&#39;].setText(&#39;ROI drawn&#39;)
        # self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.disconnect()
        # self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.setROItoDrawn())
    
    def setROItoDrawn(self):
        &#34;&#34;&#34;
        The setROItoDrawn function is used to set the ROI of the microscope to a drawn shape.
        The function first checks if there are any shapes in self.drawROIlayer, and if so, it gets the vertices of the last added shape (which should be a rectangle). It then sets the ROI using these vertices as top left and bottom right corners.
        It also removes self.drawROIlayer from shared_data.napariViewer
        &#34;&#34;&#34;
        # Get the type of the last added shape
        if len(self.drawROIlayer.data) &gt; 0:
            shape_type = self.drawROIlayer.shape_type[-1]
            if shape_type == &#39;rectangle&#39;:
                vertices = self.drawROIlayer.data[-1]  # Get the vertices of the last added shape
                #Get the topleft, bottomright position from the drawn rectangle
                topleftxy = np.floor(vertices[0][::-1])
                bottomrightxy = np.ceil(vertices[2][::-1])
                #Set the boundaries based on the camera
                mintopleft = [0,0]
                maxbottomright = [shared_data.core.get_roi().width, shared_data.core.get_roi().height]
                #Find the bounded positions
                topleftpos = np.maximum(topleftxy,mintopleft)
                bottomrightpos = np.minimum(bottomrightxy,maxbottomright)
                #Set the ROI correclty
                shared_data.core.set_roi(int(topleftpos[0]),int(topleftpos[1]),int(bottomrightpos[0]-topleftpos[0]),int(bottomrightpos[1]-topleftpos[1]))
                logging.info(f&#34;Set ROI to {topleftpos[0]},{topleftpos[1]},{bottomrightpos[0]},{bottomrightpos[1]} px&#34;)
        else:
            logging.warning(&#39;Attempted to set ROI to drawn, but no shape was added&#39;)
        
        #remove the self.drawROIlayer:
        try:
            shared_data.napariViewer.layers.remove(self.drawROIlayer)
        except:
            logging.error(&#39;Failed to remove the drawROIlayer&#39;)
        
        #Reset the Draw ROI button
        self.ROIoptionsButtons[&#39;drawROI&#39;].setText(&#39;Draw ROI&#39;)
        self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.disconnect()
        self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.drawROI())
    #endregion
    
    #region Stages
    def stagesLayout(self):
        &#34;&#34;&#34;
        Returns the layout with the XY and 1D stage widgets.
        &#34;&#34;&#34;
        stageLayout = QHBoxLayout()
        # self.XYstageLayout()
        xyStageLayout = self.XYstageLayout()
        oneDstageLayout = self.oneDstageLayout()
        stageLayout.addLayout(xyStageLayout)
        stageLayout.addLayout(oneDstageLayout)
        #Add a horizontal spacer:
        stageLayout.addStretch(1)
        stageLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
        # print(stageLayout.children())
        xyLayoutWidth = 0
        for i in range(xyStageLayout.columnCount()):
            xyLayoutWidth += xyStageLayout.columnMinimumWidth(i)
        oneDstageLayoutWidth = 0
        for i in range(oneDstageLayout.columnCount()):
            oneDstageLayoutWidth += oneDstageLayout.columnMinimumWidth(i)
        
        containerWidget = QWidget()
        containerWidget.setLayout(stageLayout)
        containerWidget.setFixedWidth(xyLayoutWidth+oneDstageLayoutWidth)
        
        stageOvercapLayout = QHBoxLayout()
        stageOvercapLayout.addWidget(containerWidget)
        
        return stageLayout
    
    def relativeStagesLayout(self):
        &#34;&#34;&#34;
        Returns the layout with the XY stage widgets in relative mode.

        This layout is used when the user is in relative mode.
        &#34;&#34;&#34;
        stageLayout = QHBoxLayout()
        # stageLayout.addLayout(self.XYstageLayout())
        stageLayout.addLayout(self.oneDstageRelLayout())
        return stageLayout
    
    def XYstageLayout(self):
        &#34;&#34;&#34;
        Returns a layout with the XY stage widgets.

        This layout includes a label with the current position,
        three arrow buttons to move in the XY stage relative to the current position,
        and text fields to set the size of the arrow buttons movement
        &#34;&#34;&#34;
        #Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device() #type: ignore
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName)#type: ignore
        
        #Get current pixel size via self.core.get_pixel_size_um()
        #Then move 0.1, 0.5, or 1 field with the arrows
        field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]#type: ignore
        field_move_fraction = [1,.5,.1]
        
        #Widget itself is a grid layout with 7x7 entries
        XYStageLayout = QGridLayout()
        XYStageLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        #XY move buttons
        self.XYmoveButtons = {}
        for m in range(1,4):
            #Initialize buttons
            self.XYmoveButtons[f&#39;Up_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Up_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,float(self.XYMoveEditField[f&#34;Y_{4-m}&#34;].text())))
            self.XYmoveButtons[f&#39;Down_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Down_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,float(self.XYMoveEditField[f&#34;Y_{4-m}&#34;].text())*-1))
            self.XYmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(float(self.XYMoveEditField[f&#34;X_{4-m}&#34;].text())*-1,0))
            self.XYmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
            self.XYmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(float(self.XYMoveEditField[f&#34;X_{4-m}&#34;].text()),0))
            
            #Add buttons to layout
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Up_{m}&#39;],m-1,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Down_{m}&#39;],8-m,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Left_{m}&#39;],4,m-1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Right_{m}&#39;],4,8-m,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        
        XYStageSetMovementLayout = QGridLayout()
        XYStageSetMovementLayout.addWidget(QLabel(&#39;X&#39;),0,1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageSetMovementLayout.addWidget(QLabel(&#39;Y&#39;),0,2,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        self.XYMoveEditField = {}
        pushButtonLabelArr = [&#34;0.1 field&#34;,&#34;1 field&#34;,&#34;3 fields&#34;]
        for m in range(1,4):
            XYStageSetMovementLayout.addWidget(QLabel(&#34;&#34;*(m)),m,0,1,1, alignment=Qt.AlignmentFlag.AlignRight)
            self.XYMoveEditField[f&#34;X_{m}&#34;] = QLineEdit()
            XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;X_{m}&#34;],m,1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.XYMoveEditField[f&#34;X_{m}&#34;].editingFinished.connect(lambda: self.storeAllControlValues())
            self.XYMoveEditField[f&#34;Y_{m}&#34;] = QLineEdit()
            XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;Y_{m}&#34;],m,2,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.XYMoveEditField[f&#34;Y_{m}&#34;].editingFinished.connect(lambda: self.storeAllControlValues())
            XYStageSetMovementLayout.addWidget(QLabel(&#34;m&#34;),m,3,1,1, alignment=Qt.AlignmentFlag.AlignLeft)
            self.XYMoveEditField[f&#34;Button_{m}&#34;] = QPushButton(pushButtonLabelArr[m-1])
            
            self.XYMoveEditField[f&#34;Button_{m}&#34;].clicked.connect(lambda index, m=m: self.setXYStageMovementValue(m-1,self.XYMoveEditField[f&#34;X_{m}&#34;],self.XYMoveEditField[f&#34;Y_{m}&#34;]))
            
            XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;Button_{m}&#34;],m,4,1,1, alignment=Qt.AlignmentFlag.AlignLeft)
            
        #Add the setmovementlayout to the XY stage layout
        XYStageLayout.addLayout(XYStageSetMovementLayout,8,0,1,8, alignment=Qt.AlignmentFlag.AlignCenter)
                
        #Add a central label for info
        #this label contains the XY stage name, then an enter, then the current position:
        self.XYStageInfoWidget = QLabel()
        XYStageLayout.addWidget(self.XYStageInfoWidget,4,4)
        #Update the text of it
        self.updateXYStageInfoWidget()
        
        return XYStageLayout
    
    def setXYStageMovementValue(self,m,xEditField,yEditField):
        &#34;&#34;&#34;
        Set the XY stageLineEdits to specific values based on the Buttons next to the fields.
        This function is called when the user presses the &#34;Set&#34; buttons next to the XY EditFields
        &#34;&#34;&#34;
        #Set the values in the XY EditFields based on the buttons
        fieldUnits = [0.1,1,3]
        fieldUnit = fieldUnits[m]
        field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]#type: ignore
        
        x_value_um = field_size_um[0]*fieldUnit
        y_value_um = field_size_um[1]*fieldUnit
        xEditField.setText(str(x_value_um))
        yEditField.setText(str(y_value_um))
        self.storeAllControlValues()
    
    def getDevicesOfDeviceType(self,devicetype):
        &#34;&#34;&#34;
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        &#34;&#34;&#34;
        #Get devices
        devices = self.core.get_loaded_devices() #type:ignore
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.core.get_device_type(device).to_string() == devicetype: #type:ignore
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType
    
    def oneDstageLayout(self):
        &#34;&#34;&#34;
        Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see XYstageLayout()
        &#34;&#34;&#34;
        #Create a layout
        self.oneDStageLayout = QGridLayout()
        
        #Creates a UI layout to move all found 1D stages
        #Find all 1D stages
        allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        
        #Create a drop-down menu that has these stages as options
        self.oneDstageDropdown = QComboBox()
        for stage in allStages:
            self.oneDstageDropdown.addItem(stage)
        #If it changes, call the update routine
        self.oneDstageDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageLayout())
        #Also store the JSON if changed:
        self.oneDstageDropdown.currentTextChanged.connect(lambda: self.storeAllControlValues())
        #Set default value to default z stage of MM
        try:
            self.oneDstageDropdown.setCurrentText(self.core.get_focus_device()) #type:ignore
        except:
            pass
        #Add the dropdown to the layout:
        self.oneDStageLayout.addWidget(self.oneDstageDropdown,0,0)
        
        #Add left/right buttons and a label for the position
        self.oneDmoveButtons = {}
        for m in range(1,3):
            #Initialize buttons
            self.oneDmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;&#34;*(3-m))
            self.oneDmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(-m))
            
            #Add buttons to layout
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Left_{m}&#39;],m-1+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
            self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Right_{m}&#39;],5-m+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        
        #Create a QGridBox for the movement sizes for each stage:
        self.oneDMoveEditFieldGridLayouts={}
        self.oneDMoveEditField={}
        self.oneDStackedWidget = QStackedWidget()
        for stage in allStages:
            self.oneDMoveEditFieldGridLayouts[stage] = QWidget()
            self.oneDMoveEditFieldGridLayouts[stage].setObjectName(stage)
            internalLayout = QGridLayout()
            self.oneDMoveEditFieldGridLayouts[stage].setLayout(internalLayout)
            self.oneDMoveEditField[stage] = {}
            for m in range(1,3):
                internalLayout.addWidget(QLabel(&#34;&#34;*(m)),m,0)
                self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;] = QLineEdit()
                internalLayout.addWidget(self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;],m,1)
                self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;].setText(&#34;10&#34;)
                self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;].editingFinished.connect(lambda: self.storeAllControlValues())
            
            self.oneDStackedWidget.addWidget(self.oneDMoveEditFieldGridLayouts[stage])
        
        self.oneDStageLayout.addWidget(self.oneDStackedWidget,8,0)
        
        #Get current info of the widget
        self.oneDinfoWidget = QLabel()
        self.oneDStageLayout.addWidget(self.oneDinfoWidget,1,0)
        #update the text
        self.updateOneDstageLayout()
        
        #Store the values
        self.storeAllControlValues()
        
        return self.oneDStageLayout
    
    def updateOneDstageLayout(self):
        &#34;&#34;&#34;
        Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage
        &#34;&#34;&#34;
        self.oneDinfoWidget.setText(f&#34;{self.oneDstageDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageDropdown.currentText()):.1f}&#34;) #type:ignore
        
        for widget_id in range(0,self.oneDStackedWidget.count()):
            widget = self.oneDStackedWidget.widget(widget_id)
            if widget.objectName() == self.oneDstageDropdown.currentText():
                self.oneDStackedWidget.setCurrentIndex(widget_id)
    
    def moveOneDStage(self,amount):
        &#34;&#34;&#34;
        Moves the selected one-D stage by the specified amount

        Parameters
        ----------
        amount: int: 1 or 2, &#39;small step&#39; or &#39;big step&#39;
        &#34;&#34;&#34;
        #Get the currently selected one-D stage:
        selectedStage = self.oneDstageDropdown.currentText()
        
        #Get the value currently in the LineEdit
        self.moveoneDstagesmallAmount = float(self.oneDMoveEditField[selectedStage][f&#39;oneDStackedWidget_{selectedStage}_1&#39;].text())
        self.moveoneDstagelargeAmount = float(self.oneDMoveEditField[selectedStage][f&#39;oneDStackedWidget_{selectedStage}_2&#39;].text())
        
        logging.debug(&#34;moving &#34; + selectedStage + &#34; by &#34; + str(amount))
        
        #Move the stage relatively
        if abs(amount) == 2:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagesmallAmount).astype(float)) #type:ignore
        elif abs(amount) == 1:
            self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagelargeAmount).astype(float)) #type:ignore
        self.updateOneDstageLayout()
    
    
    def oneDstageRelLayout(self):
        &#34;&#34;&#34;
        Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see oneDstageLayout()
        &#34;&#34;&#34;
        #Create a layout
        self.oneDStageRelLayout = QGridLayout()
        
        #Creates a UI layout to move all found 1D stages
        #Find all 1D stages
        allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        
        #Create a drop-down menu that has these stages as options
        self.oneDstageRelDropdown = QComboBox()
        for stage in allStages:
            self.oneDstageRelDropdown.addItem(stage)
        #If it changes, call the update routine
        self.oneDstageRelDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageRelLayout())
        #Also store the JSON if changed:
        self.oneDstageRelDropdown.currentTextChanged.connect(lambda: self.storeAllControlValues())
        #Set default value to default z stage of MM
        try:
            self.oneDstageRelDropdown.setCurrentText(self.core.get_focus_device()) #type:ignore
        except:
            pass
        #Add the dropdown to the layout:
        self.oneDStageRelLayout.addWidget(self.oneDstageRelDropdown,0,0)
        
        #Create a QGridBox for the movement sizes for each stage:
        self.oneDMoveRelEditFieldGridLayouts={}
        self.oneDMoveRelEditField={}
        self.oneDRelStackedWidget = QStackedWidget()
        for stage in allStages:
            self.oneDMoveRelEditFieldGridLayouts[stage] = QWidget()
            self.oneDMoveRelEditFieldGridLayouts[stage].setObjectName(stage)
            internalLayout = QGridLayout()
            self.oneDMoveRelEditFieldGridLayouts[stage].setLayout(internalLayout)
            self.oneDMoveRelEditField[stage] = {}
            
            internalLayout.addWidget(QLabel(&#34;Move&#34;),0,0)
            self.oneDMoveRelEditField[stage] = QLineEdit()
            internalLayout.addWidget(self.oneDMoveRelEditField[stage],1,0)
            self.oneDMoveRelEditField[stage].setText(&#34;10&#34;)
            self.oneDMoveRelEditField[stage].editingFinished.connect(lambda: self.storeAllControlValues())
            
            self.oneDRelStackedWidget.addWidget(self.oneDMoveRelEditFieldGridLayouts[stage])
        
        self.oneDStageRelLayout.addWidget(self.oneDRelStackedWidget,1,0)
        
        #Get current info of the widget
        self.oneDinfoRelWidget = QLabel()
        self.oneDStageRelLayout.addWidget(self.oneDinfoRelWidget,2,0)
        #update the text
        # self.updateOneDstageRelLayout()
        
        #Store the values
        # self.storeAllControlValues()
        
        return self.oneDStageRelLayout
    
    def updateOneDstageRelLayout(self):
        &#34;&#34;&#34;
        Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage
        &#34;&#34;&#34;
        logging.debug(&#34;Updating OneD stage layout&#34;)
        self.oneDinfoRelWidget.setText(f&#34;{self.oneDstageRelDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageRelDropdown.currentText()):.1f}&#34;) #type:ignore
        
        for widget_id in range(0,self.oneDRelStackedWidget.count()):
            widget = self.oneDRelStackedWidget.widget(widget_id)
            if widget.objectName() == self.oneDstageRelDropdown.currentText():
                self.oneDRelStackedWidget.setCurrentIndex(widget_id)
    
    def updateXYStageInfoWidget(self):
        &#34;&#34;&#34;
        Updates the XY stage info widget with the current position of the stage

        &#34;&#34;&#34;
        #Obtain the stage info from MM:
        XYStageName = self.core.get_xy_stage_device() #type:ignore
        #Get the stage position
        XYStagePos = self.core.get_xy_stage_position(XYStageName) #type:ignore
        self.XYStageInfoWidget.setText(f&#34;{XYStageName}\r\n {XYStagePos.x:.0f}/{XYStagePos.y:.0f}&#34;)
        
    def moveXYStage(self,relX,relY):
        &#34;&#34;&#34;
        Move XY stage with um positions in relx, rely:
        &#34;&#34;&#34;
        self.core.set_relative_xy_position(relX,relY) #type:ignore
        #Update the XYStageInfoWidget (if it exists)
        self.updateXYStageInfoWidget()
    #endregion
    
    #region MM-configs
    def addRow(self,config_id):
        &#34;&#34;&#34;
        Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination
        &#34;&#34;&#34;
        rowLayout = QHBoxLayout()
        #Add the label to it
        self.addLabel(rowLayout,config_id)
        #Add the widget to the QVBoxlayout
        self.configLayout.addLayout(rowLayout,divmod(config_id,self.number_columns)[1],divmod(config_id,self.number_columns)[0])
        
        return rowLayout
    
    def addLabel(self,rowLayout,config_id):
        &#34;&#34;&#34;
        Add a label to the given rowLayout with the label text provided in the MM config.

        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Add a checkbox
            self.configCheckboxes[config_id] = QCheckBox()
            self.configCheckboxes[config_id].setChecked(False)
            #Add callback:
            self.configCheckboxes[config_id].stateChanged.connect(lambda _, self=self, config_id = config_id: self.configLayoutEnableChange(config_id))
            rowLayout.addWidget(self.configCheckboxes[config_id])
        #add a label to the row:
        label = QLabel()
        label.setText(self.config_groups[config_id].configGroupName())
        rowLayout.addWidget(label)
        #Add the dropdown/slider/inputfield:
        if self.config_groups[config_id].isDropDown():
            self.addDropDown(rowLayout,config_id)
        if self.config_groups[config_id].isSlider():
            self.addSlider(rowLayout,config_id)
        if self.config_groups[config_id].isInputField():
            self.addInputField(rowLayout,config_id)
        return rowLayout
        # pass
    
    def addDropDown(self,rowLayout,config_id):
        &#34;&#34;&#34;
        Add a drop-down menu to the given rowLayout
        with the options provided in the MM config.

        &#34;&#34;&#34;
        #Create a drop-down menu:
        self.dropDownBoxes[config_id] = QComboBox()
        #Add an empty option:
        self.dropDownBoxes[config_id].addItem(&#39;&#39;)
        #Populate with the options:
        for i in range(self.config_groups[config_id].nrConfigs()):
            self.dropDownBoxes[config_id].addItem(self.config_groups[config_id].configName(i))
        #Update the value to the current MM value:
        # self.updateValuefromMM(config_id)
        #Add a callback when it is changed:
        self.dropDownBoxes[config_id].currentIndexChanged.connect(lambda index, config_id = config_id: self.on_dropDownChanged(config_id))
        
        #Add dropdown to rowLayout:
        rowLayout.addWidget(self.dropDownBoxes[config_id])
    
    def on_dropDownChanged(self,config_id):
        &#34;&#34;&#34;
        Changes a micromanager config when a dropdown has changed

        Args:
            config_id (int): The ID of the dropdown box that triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Check the corresponding checkbox
            self.configCheckboxes[config_id].setChecked(True)
        if self.changes_update_MM:
            #Get the new value from the dropdown:
            newValue = self.dropDownBoxes[config_id].currentText()
            #Change the value if it&#39;s a true value
            if newValue != &#34;&#34; and newValue != &#34; &#34;:
                #Get the config group name:
                configGroupName = self.config_groups[config_id].configGroupName()
                #Set in MM:
                self.config_groups[config_id].core.set_config(configGroupName,newValue)
    
    def addSlider(self,rowLayout,config_id):
        &#34;&#34;&#34;
        Add a slider to a rowLayout for a given MMConfigItem.

        Args:
            rowLayout (QHBoxLayout): The rowLayout to add the slider to.
            config_id (int): The ID of the MMConfigItem to add a slider for.

        Returns:
            None
        &#34;&#34;&#34;
        #Get the config group name
        configGroupName = self.config_groups[config_id].configGroupName()
        
        #Get the min and max value of the slider:
        lowerLimit = self.config_groups[config_id].lowerLimit()
        upperLimit = self.config_groups[config_id].upperLimit()
        
        #A slider config by definition (?) only has a single property underneath, so get that:
        underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
        configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()
        
        #Finally we get the current value of the slider
        currentSliderValue = float(self.config_groups[config_id].core.get_property(device_label,property_name))
        
        #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
        sliderPrecision = self.sliderPrecision
        sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
        
        
        #First add an editfield that has the value numerically:
        self.editFields[config_id] = QLineEdit()
        self.editFields[config_id].setText(str(currentSliderValue))
        #Only allow numbers/float values
        self.editFields[config_id].setValidator(QDoubleValidator())
        rowLayout.addWidget(self.editFields[config_id])
        self.editFields[config_id].editingFinished.connect(lambda config_id = config_id: self.on_sliderChanged(config_id,fromText=True,fromSlider=False))


        #Create the slider:
        self.sliders[config_id] = QSlider(Qt.Horizontal) #type: ignore
        #Give it a minimum size:
        self.sliders[config_id].setMinimumWidth(50)
        self.sliders[config_id].setRange(0,sliderPrecision)
        self.sliders[config_id].setValue(sliderValInSliderPrecision)
        self.sliders[config_id].slider_conversion_array = [lowerLimit,upperLimit,sliderPrecision]
        #Add a callback when it is changed:
        self.sliders[config_id].valueChanged.connect(lambda value, config_id = config_id: self.on_sliderChanged(config_id,fromSlider=True,fromText=False))
        # #Add the slider to the rowLayout:
        rowLayout.addWidget(self.sliders[config_id])
        pass
    
    def on_sliderChanged(self,config_id,fromText=False,fromSlider=True):
        &#34;&#34;&#34;
        Changes a micromanager config when a slider has changed

        Args:
            config_id (int): The ID of the slider box that triggered the event.
            slider_conversion_array (array): [lowerLimit,upperLimit,sliderPrecision]

        Returns:
            None
        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Check the corresponding checkbox:
            self.configCheckboxes[config_id].setChecked(True)
            
        #Get the new value from the slider:
        if fromSlider:
            newValue = self.sliders[config_id].value()
            #Get the true value from the conversion:
            trueValue = newValue/self.sliders[config_id].slider_conversion_array[2]*(self.sliders[config_id].slider_conversion_array[1]-self.sliders[config_id].slider_conversion_array[0])+self.sliders[config_id].slider_conversion_array[0]
        elif fromText:
            if self.editFields[config_id].text() != &#34;&#34;:
                trueValue = float(self.editFields[config_id].text())
            else:
                trueValue = &#34;&#34;
        else:
            trueValue = &#34;&#34; #error out later on purpose
            
        if self.changes_update_MM:
            #Change the value if it&#39;s a true value
            if trueValue != &#34;&#34; and trueValue != &#34; &#34;:
                #Get the config group name:
                configGroupName = self.config_groups[config_id].configGroupName()
                #Set in MM:
                #A slider config by definition (?) only has a single property underneath, so get that:
                underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
                configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
                device_label = configdata.get_setting(0).get_device_label()
                property_name = configdata.get_setting(0).get_property_name()

                #Set this property:
                self.config_groups[config_id].core.set_property(device_label,property_name,trueValue)
                
        if trueValue != &#34;&#34; and trueValue != &#34; &#34;:
            trueValue = round(trueValue,3)
            #Set the slider/text if the other is changed
            if fromSlider:
                self.editFields[config_id].setText(str(trueValue))
            elif fromText:
                newValue = self.sliders[config_id].slider_conversion_array[2] * (trueValue - self.sliders[config_id].slider_conversion_array[0]) / (self.sliders[config_id].slider_conversion_array[1] - self.sliders[config_id].slider_conversion_array[0])
                self.sliders[config_id].setValue(int(newValue))
    
    def addInputField(self,rowLayout,config_id):
        &#34;&#34;&#34; 
        Add a editfield to a rowLayout for a given MMConfigItem.

        &#34;&#34;&#34;
        #Get the config group name
        configGroupName = self.config_groups[config_id].configGroupName()

        self.editFields[config_id] = QLineEdit()
        #Add a callback when it is changed:
        self.editFields[config_id].editingFinished.connect(lambda config_id = config_id: self.onEditFieldChanged(config_id))
        # Add the editFields to the rowLayout:
        rowLayout.addWidget(self.editFields[config_id])
    
    def onEditFieldChanged(self,config_id):
        &#34;&#34;&#34;
        Changes a micromanager config when an editfield has changed
        Args:
            config_id (int): The ID of the editfield box that triggered the event.
        Returns:
            None
        &#34;&#34;&#34;

        CurrentText = self.editFields[config_id].text()
        #Get the config group name:
        configGroupName = self.config_groups[config_id].configGroupName()

        #An Editfield config by definition (?) only has a single property underneath, so get that:
        underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
        configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()

        #Set this property:
        self.config_groups[config_id].core.set_property(device_label,property_name,CurrentText)
        
    def updateValuefromMM(self,config_id):
        &#34;&#34;&#34;
        Updates the value in the GUI for a single config_id based on the current value in MM

        Args:
            config_id (int): The ID of the config_group to update

        Returns:
            None
        &#34;&#34;&#34;
        logging.debug(&#34;Updating value from &#34; + self.config_groups[config_id].configGroupName())
        #Get the value of the config_id from micromanager:
        currentValue = self.config_groups[config_id].getCurrentMMValue()
        
        #Set the value of the dropdown to the current MM value
        if self.config_groups[config_id].isDropDown():
            self.dropDownBoxes[config_id].setCurrentText(currentValue)
        elif self.config_groups[config_id].isSlider():
            #A slider config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.config_groups[config_id].configGroupName()
            underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
            configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()
            
            #Finally we get the current value of the slider
            currentSliderValue = float(self.config_groups[config_id].core.get_property(device_label,property_name))
                
            #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
            sliderPrecision = self.sliderPrecision
            #Get the min and max value of the slider:
            lowerLimit = self.config_groups[config_id].lowerLimit()
            upperLimit = self.config_groups[config_id].upperLimit()
            sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
            # #Update the slider:
            self.sliders[config_id].setRange(0,sliderPrecision)
            self.sliders[config_id].setValue(sliderValInSliderPrecision)
            #Also update the corresponding editField
            self.editFields[config_id].setText(str(currentSliderValue))
            
        elif self.config_groups[config_id].isInputField():
            #A editfield config by definition (?) only has a single property underneath, so get that:
            configGroupName = self.config_groups[config_id].configGroupName()
            underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
            configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()

            #Finally we get the current value of the editfield
            currentValue = (self.config_groups[config_id].core.get_property(device_label,property_name))

            self.editFields[config_id].setText(currentValue)
        
        #Make inactive if the checkbox is inactive
        self.configLayoutEnableChange(config_id)
        pass
    
    def updateValueInGUI(self,config_id, newValue):
        &#34;&#34;&#34;
        I THINK DEPRECATED, BUT KEEPING FOR KEEPING SAKE
        Updates the GUI to reflect a change in the Micromanager config
        Set the value of the dropdown to the current MM value

        Args:
            config_id (int): The ID of the config box to change
            newValue (str): The new value of the config property

        Returns:
            None
        &#34;&#34;&#34;
        if self.config_groups[config_id].isDropDown():
            self.dropDownBoxes[config_id].setCurrentText(newValue)
        elif self.config_groups[config_id].isSlider():
            #Finally we get the current value of the slider
            currentSliderValue = float(newValue)
                
            #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
            sliderPrecision = self.sliderPrecision
            #Get the min and max value of the slider:
            lowerLimit = self.config_groups[config_id].lowerLimit()
            upperLimit = self.config_groups[config_id].upperLimit()
            sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
            
            self.sliders[config_id].setValue(sliderValInSliderPrecision)
            
        elif self.config_groups[config_id].isInputField():
            pass
    
    def configLayoutEnableChange(self,config_id):
        &#34;&#34;&#34;
        Enables or disables the GUI elements in the layout of the given config box

        Args:
            config_id (int): The ID of the config box to change
        &#34;&#34;&#34;
        if self.showCheckboxes:
            #Disable all children recursively
            def enableDisableLayout(self, layout,config_id,trueFalse):
                &#34;&#34;&#34;
                Enables or disables widgets in a layout based on the provided configuration ID.
                
                Args:
                    layout: The layout containing the widgets to be enabled or disabled.
                    config_id: The configuration ID used to identify the checkbox that should not be disabled.
                    trueFalse: A boolean value indicating whether the widgets should be enabled (True) or disabled (False).
                
                Returns:
                    None
                &#34;&#34;&#34;
                for i in range(layout.count()):
                    item = layout.itemAt(i)

                    if item.widget():
                        #Don&#39;t disable if it&#39;s the checkbox itself
                        if not item.widget() == self.configCheckboxes[config_id]:
                            item.widget().setEnabled(trueFalse)
                    elif item.layout():
                        self.disableLayout(item.layout())
                        
            if self.configCheckboxes[config_id].isChecked():
                enableDisableLayout(self, self.configEntries[config_id],config_id,True)
            else:
                enableDisableLayout(self, self.configEntries[config_id],config_id,False)
        return
    
    def updateConfigsFromMM(self):
        &#34;&#34;&#34;
        Updates all configs from the Micro-Manager backend.
        
        This function iterates over all configs and updates their values in the GUI
        based on the current values in the Micro-Manager backend.
        &#34;&#34;&#34;
        #Update all values from MM:
        for config_id in range(len(self.config_groups)):
            self.updateValuefromMM(config_id)
        pass
    #endregion

    #region deprecated
    def get_device_properties(self):
        &#34;&#34;&#34;
        Get device properties.
        
        Args:
            self: The object itself.
            
        Returns:
            List: A list of dictionaries containing device properties.
        &#34;&#34;&#34;
        
        core = self.core
        devices = core.get_loaded_devices() #type:ignore
        devices = [devices.get(i) for i in range(devices.size())]
        device_items = []
        for device in devices:
            logging.debug(&#39;Device: &#39;+device)
            names = core.get_device_property_names(device) #type:ignore
            props = [names.get(i) for i in range(names.size())]
            property_items = []
            for prop in props:
                logging.debug(&#39;Property&#39;,prop)
                value = core.get_property(device, prop) #type:ignore
                is_read_only = core.is_property_read_only(device, prop) #type:ignore
                if core.has_property_limits(device, prop): #type:ignore
                    lower = core.get_property_lower_limit(device, prop) #type:ignore
                    upper = core.get_property_upper_limit(device, prop) #type:ignore
                    allowed = {
                    &#34;type&#34;: &#34;range&#34;,
                    &#34;min&#34;: lower,
                    &#34;max&#34;: upper,
                    &#34;readOnly&#34;: is_read_only,
                    }
                else:
                    allowed = core.get_allowed_property_values(device, prop) #type:ignore
                    allowed = {
                    &#34;type&#34;: &#34;enum&#34;,
                    &#34;options&#34;: [allowed.get(i) for i in range(allowed.size())],&#34;readOnly&#34;: is_read_only,
                    }
                    property_items.append(
                    {&#34;device&#34;: device, &#34;name&#34;: prop, &#34;value&#34;: value, &#34;allowed&#34;: allowed}
                    )
                    logging.debug(&#39;===&gt;&#39;, device, prop, value, allowed)
            if len(property_items) &gt; 0:
                device_items.append(
                {
                &#34;name&#34;: device,
                &#34;value&#34;: &#34;{} properties&#34;.format(len(props)),
                &#34;items&#34;: property_items,
                }
                )
        return device_items

    def Vseparator_line(self):
        &#34;&#34;&#34;
        Creates a vertical separator line widget.
        
        Args:
            None
        
        Returns:
            QFrame: A vertical separator line widget with frame shape set to QFrame.VLine, frame shadow set to QFrame.Sunken, and background color set to #FFFFFF with a minimum width of 1px.
        &#34;&#34;&#34;
        
        separator_line = QFrame()
        separator_line.setFrameShape(QFrame.VLine)
        separator_line.setFrameShadow(QFrame.Sunken)
        separator_line.setStyleSheet(&#34;background-color: #FFFFFF; min-width: 1px;&#34;)
        return separator_line
    #endregion</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="utils.CustomMainWindow" href="utils.html#utils.CustomMainWindow">CustomMainWindow</a></li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MMcontrols.MMConfigUI.LoadAllMMFromJSON"><code class="name flex">
<span>def <span class="ident">LoadAllMMFromJSON</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update all the info that can be loaded from the JSON file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LoadAllMMFromJSON(self):
    &#34;&#34;&#34;
    Update all the info that can be loaded from the JSON file.
    &#34;&#34;&#34;
    #Load from APPData, if it exists
    appdata_folder = os.getenv(&#39;APPDATA&#39;)
    if appdata_folder is None:
        raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
    app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
    
    if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
        #Load the file
        with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
            gladosInfo = json.load(file)
            MMControlsInfo = gladosInfo[&#39;MMControls&#39;]
    
        #Hand-set the values that I want:
        if &#39;exposureTimeInputField&#39; in MMControlsInfo:
            if hasattr(self, &#39;exposureTimeInputField&#39;):
                self.exposureTimeInputField.setText(MMControlsInfo[&#39;exposureTimeInputField&#39;][&#39;text&#39;])
        if &#39;oneDstageDropdown&#39; in MMControlsInfo:
            if hasattr(self, &#39;oneDstageDropdown&#39;):
                self.oneDstageDropdown.setCurrentText(MMControlsInfo[&#39;oneDstageDropdown&#39;][&#39;text&#39;])
        
        if hasattr(self, &#39;XYMoveEditField&#39;):
            for key, object in self.XYMoveEditField.items():
                if key in MMControlsInfo:
                    object.setText(MMControlsInfo[key][&#39;text&#39;])
        if hasattr(self, &#39;oneDMoveEditField&#39;):
            for key,object in self.oneDMoveEditField.items():
                for objectLineEditKey in object:
                    objectLineEdit = object[objectLineEditKey]
                    if objectLineEditKey in MMControlsInfo:
                        objectLineEdit.setText(MMControlsInfo[objectLineEditKey][&#39;text&#39;])</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.ROIoptionsLayout"><code class="name flex">
<span>def <span class="ident">ROIoptionsLayout</span></span>(<span>self, orientation='horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a layout with buttons for ROI options</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ROIoptionsLayout</code></strong> :&ensp;<code>QGridLayout</code></dt>
<dd>A layout with buttons for ROI options</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ROIoptionsLayout(self,orientation=&#39;horizontal&#39;):
    &#34;&#34;&#34;
    Create a layout with buttons for ROI options

    Returns
    -------
    ROIoptionsLayout : QGridLayout
        A layout with buttons for ROI options
    &#34;&#34;&#34;
    #Create a Grid layout:
    ROIoptionsLayout = QGridLayout()
    self.ROIoptionsButtons = {}
    #Following options should be added:
    #Reset ROI to max size
    self.ROIoptionsButtons[&#39;Reset&#39;] = QPushButton(&#34;Reset ROI&#34;)
    self.ROIoptionsButtons[&#39;Reset&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_reset.png&#39;))
    self.ROIoptionsButtons[&#39;Reset&#39;].clicked.connect(lambda index: self.resetROI())
    #Zoom in once to center
    self.ROIoptionsButtons[&#39;ZoomIn&#39;] = QPushButton(&#34;Zoom In&#34;)
    self.ROIoptionsButtons[&#39;ZoomIn&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_zoomIn.png&#39;))
    self.ROIoptionsButtons[&#39;ZoomIn&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomIn&#39;))
    #Zoom out once from center
    self.ROIoptionsButtons[&#39;ZoomOut&#39;] = QPushButton(&#34;Zoom Out&#34;)
    self.ROIoptionsButtons[&#39;ZoomOut&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_zoomOut.png&#39;))
    self.ROIoptionsButtons[&#39;ZoomOut&#39;].clicked.connect(lambda index: self.zoomROI(&#39;ZoomOut&#39;))
    #Draw a ROI
    self.ROIoptionsButtons[&#39;drawROI&#39;] = QPushButton(&#34;Draw ROI&#34;)
    self.ROIoptionsButtons[&#39;drawROI&#39;].setIcon(QIcon(self.iconFolder+os.sep+&#39;ROI_select.png&#39;))
    self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.drawROI())
    if orientation == &#39;vertical&#39;:
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],1,0)
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],2,0)
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;drawROI&#39;],3,0)
    else:
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;Reset&#39;],0,0)
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomIn&#39;],0,1)
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;ZoomOut&#39;],0,2)
        ROIoptionsLayout.addWidget(self.ROIoptionsButtons[&#39;drawROI&#39;],0,3)
    return ROIoptionsLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.Vseparator_line"><code class="name flex">
<span>def <span class="ident">Vseparator_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a vertical separator line widget.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>QFrame</code></dt>
<dd>A vertical separator line widget with frame shape set to QFrame.VLine, frame shadow set to QFrame.Sunken, and background color set to #FFFFFF with a minimum width of 1px.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Vseparator_line(self):
    &#34;&#34;&#34;
    Creates a vertical separator line widget.
    
    Args:
        None
    
    Returns:
        QFrame: A vertical separator line widget with frame shape set to QFrame.VLine, frame shadow set to QFrame.Sunken, and background color set to #FFFFFF with a minimum width of 1px.
    &#34;&#34;&#34;
    
    separator_line = QFrame()
    separator_line.setFrameShape(QFrame.VLine)
    separator_line.setFrameShadow(QFrame.Sunken)
    separator_line.setStyleSheet(&#34;background-color: #FFFFFF; min-width: 1px;&#34;)
    return separator_line</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.XYstageLayout"><code class="name flex">
<span>def <span class="ident">XYstageLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a layout with the XY stage widgets.</p>
<p>This layout includes a label with the current position,
three arrow buttons to move in the XY stage relative to the current position,
and text fields to set the size of the arrow buttons movement</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def XYstageLayout(self):
    &#34;&#34;&#34;
    Returns a layout with the XY stage widgets.

    This layout includes a label with the current position,
    three arrow buttons to move in the XY stage relative to the current position,
    and text fields to set the size of the arrow buttons movement
    &#34;&#34;&#34;
    #Obtain the stage info from MM:
    XYStageName = self.core.get_xy_stage_device() #type: ignore
    #Get the stage position
    XYStagePos = self.core.get_xy_stage_position(XYStageName)#type: ignore
    
    #Get current pixel size via self.core.get_pixel_size_um()
    #Then move 0.1, 0.5, or 1 field with the arrows
    field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]#type: ignore
    field_move_fraction = [1,.5,.1]
    
    #Widget itself is a grid layout with 7x7 entries
    XYStageLayout = QGridLayout()
    XYStageLayout.setAlignment(Qt.AlignmentFlag.AlignCenter)
    
    #XY move buttons
    self.XYmoveButtons = {}
    for m in range(1,4):
        #Initialize buttons
        self.XYmoveButtons[f&#39;Up_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
        self.XYmoveButtons[f&#39;Up_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,float(self.XYMoveEditField[f&#34;Y_{4-m}&#34;].text())))
        self.XYmoveButtons[f&#39;Down_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
        self.XYmoveButtons[f&#39;Down_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(0,float(self.XYMoveEditField[f&#34;Y_{4-m}&#34;].text())*-1))
        self.XYmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
        self.XYmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(float(self.XYMoveEditField[f&#34;X_{4-m}&#34;].text())*-1,0))
        self.XYmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;&#34;*(4-m))
        self.XYmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveXYStage(float(self.XYMoveEditField[f&#34;X_{4-m}&#34;].text()),0))
        
        #Add buttons to layout
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Up_{m}&#39;],m-1,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Down_{m}&#39;],8-m,4,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Left_{m}&#39;],4,m-1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        XYStageLayout.addWidget(self.XYmoveButtons[f&#39;Right_{m}&#39;],4,8-m,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
    
    XYStageSetMovementLayout = QGridLayout()
    XYStageSetMovementLayout.addWidget(QLabel(&#39;X&#39;),0,1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
    XYStageSetMovementLayout.addWidget(QLabel(&#39;Y&#39;),0,2,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
    self.XYMoveEditField = {}
    pushButtonLabelArr = [&#34;0.1 field&#34;,&#34;1 field&#34;,&#34;3 fields&#34;]
    for m in range(1,4):
        XYStageSetMovementLayout.addWidget(QLabel(&#34;&#34;*(m)),m,0,1,1, alignment=Qt.AlignmentFlag.AlignRight)
        self.XYMoveEditField[f&#34;X_{m}&#34;] = QLineEdit()
        XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;X_{m}&#34;],m,1,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        self.XYMoveEditField[f&#34;X_{m}&#34;].editingFinished.connect(lambda: self.storeAllControlValues())
        self.XYMoveEditField[f&#34;Y_{m}&#34;] = QLineEdit()
        XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;Y_{m}&#34;],m,2,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        self.XYMoveEditField[f&#34;Y_{m}&#34;].editingFinished.connect(lambda: self.storeAllControlValues())
        XYStageSetMovementLayout.addWidget(QLabel(&#34;m&#34;),m,3,1,1, alignment=Qt.AlignmentFlag.AlignLeft)
        self.XYMoveEditField[f&#34;Button_{m}&#34;] = QPushButton(pushButtonLabelArr[m-1])
        
        self.XYMoveEditField[f&#34;Button_{m}&#34;].clicked.connect(lambda index, m=m: self.setXYStageMovementValue(m-1,self.XYMoveEditField[f&#34;X_{m}&#34;],self.XYMoveEditField[f&#34;Y_{m}&#34;]))
        
        XYStageSetMovementLayout.addWidget(self.XYMoveEditField[f&#34;Button_{m}&#34;],m,4,1,1, alignment=Qt.AlignmentFlag.AlignLeft)
        
    #Add the setmovementlayout to the XY stage layout
    XYStageLayout.addLayout(XYStageSetMovementLayout,8,0,1,8, alignment=Qt.AlignmentFlag.AlignCenter)
            
    #Add a central label for info
    #this label contains the XY stage name, then an enter, then the current position:
    self.XYStageInfoWidget = QLabel()
    XYStageLayout.addWidget(self.XYStageInfoWidget,4,4)
    #Update the text of it
    self.updateXYStageInfoWidget()
    
    return XYStageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addDropDown"><code class="name flex">
<span>def <span class="ident">addDropDown</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a drop-down menu to the given rowLayout
with the options provided in the MM config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addDropDown(self,rowLayout,config_id):
    &#34;&#34;&#34;
    Add a drop-down menu to the given rowLayout
    with the options provided in the MM config.

    &#34;&#34;&#34;
    #Create a drop-down menu:
    self.dropDownBoxes[config_id] = QComboBox()
    #Add an empty option:
    self.dropDownBoxes[config_id].addItem(&#39;&#39;)
    #Populate with the options:
    for i in range(self.config_groups[config_id].nrConfigs()):
        self.dropDownBoxes[config_id].addItem(self.config_groups[config_id].configName(i))
    #Update the value to the current MM value:
    # self.updateValuefromMM(config_id)
    #Add a callback when it is changed:
    self.dropDownBoxes[config_id].currentIndexChanged.connect(lambda index, config_id = config_id: self.on_dropDownChanged(config_id))
    
    #Add dropdown to rowLayout:
    rowLayout.addWidget(self.dropDownBoxes[config_id])</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addImageToAlbum"><code class="name flex">
<span>def <span class="ident">addImageToAlbum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an image to the Album layer in napari</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addImageToAlbum(self):
    &#34;&#34;&#34;
    Add an image to the Album layer in napari
    &#34;&#34;&#34; 
    #Set the correct exposure time
    shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
    #Snap an image
    shared_data.core.snap_image()
    #Get the just-snapped image
    newImage = shared_data.core.get_tagged_image()
    
    #And add to the &#39;Album&#39; layer
    addToExistingOrNewLayer(napariViewer,&#39;Album&#39;,np.reshape(newImage.pix, newshape=[newImage.tags[&#34;Height&#34;], newImage.tags[&#34;Width&#34;]]),shared_data_throughput = shared_data)
    return</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addInputField"><code class="name flex">
<span>def <span class="ident">addInputField</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a editfield to a rowLayout for a given MMConfigItem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addInputField(self,rowLayout,config_id):
    &#34;&#34;&#34; 
    Add a editfield to a rowLayout for a given MMConfigItem.

    &#34;&#34;&#34;
    #Get the config group name
    configGroupName = self.config_groups[config_id].configGroupName()

    self.editFields[config_id] = QLineEdit()
    #Add a callback when it is changed:
    self.editFields[config_id].editingFinished.connect(lambda config_id = config_id: self.onEditFieldChanged(config_id))
    # Add the editFields to the rowLayout:
    rowLayout.addWidget(self.editFields[config_id])</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addLabel"><code class="name flex">
<span>def <span class="ident">addLabel</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a label to the given rowLayout with the label text provided in the MM config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addLabel(self,rowLayout,config_id):
    &#34;&#34;&#34;
    Add a label to the given rowLayout with the label text provided in the MM config.

    &#34;&#34;&#34;
    if self.showCheckboxes:
        #Add a checkbox
        self.configCheckboxes[config_id] = QCheckBox()
        self.configCheckboxes[config_id].setChecked(False)
        #Add callback:
        self.configCheckboxes[config_id].stateChanged.connect(lambda _, self=self, config_id = config_id: self.configLayoutEnableChange(config_id))
        rowLayout.addWidget(self.configCheckboxes[config_id])
    #add a label to the row:
    label = QLabel()
    label.setText(self.config_groups[config_id].configGroupName())
    rowLayout.addWidget(label)
    #Add the dropdown/slider/inputfield:
    if self.config_groups[config_id].isDropDown():
        self.addDropDown(rowLayout,config_id)
    if self.config_groups[config_id].isSlider():
        self.addSlider(rowLayout,config_id)
    if self.config_groups[config_id].isInputField():
        self.addInputField(rowLayout,config_id)
    return rowLayout
    # pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addRow"><code class="name flex">
<span>def <span class="ident">addRow</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addRow(self,config_id):
    &#34;&#34;&#34;
    Add a new row in the configLayout which will be populated with a label-dropdown/slider/inputField combination
    &#34;&#34;&#34;
    rowLayout = QHBoxLayout()
    #Add the label to it
    self.addLabel(rowLayout,config_id)
    #Add the widget to the QVBoxlayout
    self.configLayout.addLayout(rowLayout,divmod(config_id,self.number_columns)[1],divmod(config_id,self.number_columns)[0])
    
    return rowLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.addSlider"><code class="name flex">
<span>def <span class="ident">addSlider</span></span>(<span>self, rowLayout, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a slider to a rowLayout for a given MMConfigItem.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rowLayout</code></strong> :&ensp;<code>QHBoxLayout</code></dt>
<dd>The rowLayout to add the slider to.</dd>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the MMConfigItem to add a slider for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addSlider(self,rowLayout,config_id):
    &#34;&#34;&#34;
    Add a slider to a rowLayout for a given MMConfigItem.

    Args:
        rowLayout (QHBoxLayout): The rowLayout to add the slider to.
        config_id (int): The ID of the MMConfigItem to add a slider for.

    Returns:
        None
    &#34;&#34;&#34;
    #Get the config group name
    configGroupName = self.config_groups[config_id].configGroupName()
    
    #Get the min and max value of the slider:
    lowerLimit = self.config_groups[config_id].lowerLimit()
    upperLimit = self.config_groups[config_id].upperLimit()
    
    #A slider config by definition (?) only has a single property underneath, so get that:
    underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
    configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
    device_label = configdata.get_setting(0).get_device_label()
    property_name = configdata.get_setting(0).get_property_name()
    
    #Finally we get the current value of the slider
    currentSliderValue = float(self.config_groups[config_id].core.get_property(device_label,property_name))
    
    #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
    sliderPrecision = self.sliderPrecision
    sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
    
    
    #First add an editfield that has the value numerically:
    self.editFields[config_id] = QLineEdit()
    self.editFields[config_id].setText(str(currentSliderValue))
    #Only allow numbers/float values
    self.editFields[config_id].setValidator(QDoubleValidator())
    rowLayout.addWidget(self.editFields[config_id])
    self.editFields[config_id].editingFinished.connect(lambda config_id = config_id: self.on_sliderChanged(config_id,fromText=True,fromSlider=False))


    #Create the slider:
    self.sliders[config_id] = QSlider(Qt.Horizontal) #type: ignore
    #Give it a minimum size:
    self.sliders[config_id].setMinimumWidth(50)
    self.sliders[config_id].setRange(0,sliderPrecision)
    self.sliders[config_id].setValue(sliderValInSliderPrecision)
    self.sliders[config_id].slider_conversion_array = [lowerLimit,upperLimit,sliderPrecision]
    #Add a callback when it is changed:
    self.sliders[config_id].valueChanged.connect(lambda value, config_id = config_id: self.on_sliderChanged(config_id,fromSlider=True,fromText=False))
    # #Add the slider to the rowLayout:
    rowLayout.addWidget(self.sliders[config_id])
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.changeLiveMode"><code class="name flex">
<span>def <span class="ident">changeLiveMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that should be called when live mode is changed. Sets the shared_data.liveMode to True or False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeLiveMode(self):
    &#34;&#34;&#34;
    Function that should be called when live mode is changed. Sets the shared_data.liveMode to True or False.
    &#34;&#34;&#34;
    if shared_data.liveMode == False:
        #update the button text of the live mode:
        self.LiveModeButton.setText(&#34;Stop Live Mode&#34;)
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Stop.png&#39;)
        # icon: Flaticon.com
        self.LiveModeButton.setIcon(icon)
        #set exposure time first:
        shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
        #Then start live mode:
        shared_data.liveMode = True
    else:
        #update the button text of the live mode:
        self.LiveModeButton.setText(&#34;Start Live Mode&#34;)
        icon = QIcon(self.iconFolder+os.sep+&#39;General_Start.png&#39;)
        # icon: Flaticon.com
        self.LiveModeButton.setIcon(icon)
        #update live mode:
        shared_data.liveMode = False</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.configLayoutEnableChange"><code class="name flex">
<span>def <span class="ident">configLayoutEnableChange</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables or disables the GUI elements in the layout of the given config box</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the config box to change</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configLayoutEnableChange(self,config_id):
    &#34;&#34;&#34;
    Enables or disables the GUI elements in the layout of the given config box

    Args:
        config_id (int): The ID of the config box to change
    &#34;&#34;&#34;
    if self.showCheckboxes:
        #Disable all children recursively
        def enableDisableLayout(self, layout,config_id,trueFalse):
            &#34;&#34;&#34;
            Enables or disables widgets in a layout based on the provided configuration ID.
            
            Args:
                layout: The layout containing the widgets to be enabled or disabled.
                config_id: The configuration ID used to identify the checkbox that should not be disabled.
                trueFalse: A boolean value indicating whether the widgets should be enabled (True) or disabled (False).
            
            Returns:
                None
            &#34;&#34;&#34;
            for i in range(layout.count()):
                item = layout.itemAt(i)

                if item.widget():
                    #Don&#39;t disable if it&#39;s the checkbox itself
                    if not item.widget() == self.configCheckboxes[config_id]:
                        item.widget().setEnabled(trueFalse)
                elif item.layout():
                    self.disableLayout(item.layout())
                    
        if self.configCheckboxes[config_id].isChecked():
            enableDisableLayout(self, self.configEntries[config_id],config_id,True)
        else:
            enableDisableLayout(self, self.configEntries[config_id],config_id,False)
    return</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.currentConfigUISingleValue"><code class="name flex">
<span>def <span class="ident">currentConfigUISingleValue</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the value of a single config as currently determined by the UI.</p>
<p>param config_id: The ID of the config_group to get the value for.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def currentConfigUISingleValue(self,config_id):
    &#34;&#34;&#34;
    Get the value of a single config as currently determined by the UI.

    param config_id: The ID of the config_group to get the value for.
    &#34;&#34;&#34;
    #Get the value of a single config as currently determined by the UI
    if self.config_groups[config_id].isDropDown():
        currentUIvalue = self.dropDownBoxes[config_id].currentText()
    elif self.config_groups[config_id].isSlider():
        #Get the value from the slider:
        sliderValue = self.sliders[config_id].value()
        #Get the true value from the conversion:
        currentUIvalue = sliderValue/self.sliders[config_id].slider_conversion_array[2]*(self.sliders[config_id].slider_conversion_array[1]-self.sliders[config_id].slider_conversion_array[0])+self.sliders[config_id].slider_conversion_array[0]
    elif self.config_groups[config_id].isInputField():
        currentUIvalue = self.editFields[config_id].text()
    else:
        currentUIvalue = None
    return currentUIvalue</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.drawROI"><code class="name flex">
<span>def <span class="ident">drawROI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a ROI. Idea is to create a new layer, let the user draw a rectangle, and ask if they like it or not. Then a small popup window with 'OK', 'Let me draw again', 'Stop this futile attempt'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawROI(self):
    &#34;&#34;&#34;
    Draw a ROI. Idea is to create a new layer, let the user draw a rectangle, and ask if they like it or not. Then a small popup window with &#39;OK&#39;, &#39;Let me draw again&#39;, &#39;Stop this futile attempt&#39;
    &#34;&#34;&#34;
    
        
    # Create a shapes layer
    self.drawROIlayer = shared_data.napariViewer.add_shapes(name=&#39;Draw ROI&#39;)
    self.drawROIlayer.events.set_data.connect(self.shape_drawn_callback)


    # Set the shapes layer mode to &#39;add_rectangle&#39;
    self.drawROIlayer.mode = &#39;add_rectangle&#39;
    
    #Changes the button to a different method, which should be pressed once the rectangle is drawn:
    # self.ROIoptionsButtons[&#39;drawROI&#39;].setText(&#39;ROI drawn&#39;)
    # self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.disconnect()
    # self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.setROItoDrawn())</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.generalImagingLayout"><code class="name flex">
<span>def <span class="ident">generalImagingLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the layout for the general imaging mode options.
This includes an input field for the exposure time in ms.
Basically, should be exposure time (ms), snap, addToAlbum, live start/stop</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>QGridLayout</code></dt>
<dd>The layout for the live mode options.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generalImagingLayout(self):
    &#34;&#34;&#34;
    Creates the layout for the general imaging mode options.
    This includes an input field for the exposure time in ms.
    Basically, should be exposure time (ms), snap, addToAlbum, live start/stop

    Returns:
        QGridLayout: The layout for the live mode options.
    &#34;&#34;&#34;
    #Create a Grid layout:
    liveModeLayout = QGridLayout()
    liveModeLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
    #Add a &#39;exposure time&#39; label:
    exposureTimeLabel = QLabel(&#34;Exposure time (ms):&#34;)
    liveModeLayout.addWidget(exposureTimeLabel,0,0)
    #Add a &#39;exposure time&#39; input field:
    self.exposureTimeInputField = QLineEdit()
    self.exposureTimeInputField.setText(str(100))
    self.exposureTimeInputField.editingFinished.connect(lambda: self.storeAllControlValues())
    liveModeLayout.addWidget(self.exposureTimeInputField,0,1)
    
    self.livesnapalbumbuttons = QHBoxLayout()
    
    self.LiveModeButton = QPushButton(&#34;Start Live Mode&#34;)
    icon = QIcon(self.iconFolder+os.sep+&#39;General_Start.png&#39;)
    # icon: Flaticon.com
    self.LiveModeButton.setIcon(icon)
    
    #add a connection to the button:
    self.LiveModeButton.clicked.connect(lambda index: self.changeLiveMode())
    #Add the button to the layout:
    self.livesnapalbumbuttons.addWidget(self.LiveModeButton)
    
    self.SnapButton = QPushButton(&#34;Snap&#34;)
    icon = QIcon(self.iconFolder+os.sep+&#39;General_Snap.png&#39;)
    # icon: Flaticon.com
    self.SnapButton.setIcon(icon)
    #add a connection to the button:
    self.SnapButton.clicked.connect(lambda index: self.snapImage())
    #Add the button to the layout:
    self.livesnapalbumbuttons.addWidget(self.SnapButton)
    
    self.AlbumButton = QPushButton(&#34;Add to Album&#34;)
    #add a connection to the button:
    self.AlbumButton.clicked.connect(lambda index: self.addImageToAlbum())
    icon = QIcon(self.iconFolder+os.sep+&#39;General_Album.png&#39;)
    # icon: Flaticon.com
    self.AlbumButton.setIcon(icon)
    #Add the button to the layout:
    self.livesnapalbumbuttons.addWidget(self.AlbumButton)
    
    liveModeLayout.addLayout(self.livesnapalbumbuttons,1,0,1,2)
    
    if self.showShutterOptions:
        self.shutterOptionsGroupBox = QGroupBox(&#34;Shutter&#34;)
        self.shutterOptionsGroupBox.setLayout(self.shutterOptionsLayout(orientation=&#39;horizontal&#39;))
        liveModeLayout.addWidget(self.shutterOptionsGroupBox, 4,0,1,2)
        
    
    if self.showROIoptions:
        #Now add the ROI options widget
        self.roiOptionsGroupBox = QGroupBox(&#34;ROI Options&#34;)
        self.roiOptionsGroupBox.setLayout(self.ROIoptionsLayout(orientation=&#39;horizontal&#39;))
        liveModeLayout.addWidget(self.roiOptionsGroupBox, 5,0,1,2)
    
    #Add one of those spacers at the bottom:
    verticalSpacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
    liveModeLayout.addItem(verticalSpacer)
    
    #Add a button to update all MM info
    
    #Create a &#39;debug-ish&#39; button list:
    debugHbox = QHBoxLayout()
    self.updateAllMMinfoButton = QPushButton(&#34;Update all MM info&#34;)
    self.updateAllMMinfoButton.clicked.connect(self.updateAllMMinfo)
    #all the way at the bottom of the layout
    debugHbox.addWidget(self.updateAllMMinfoButton)
    #Add a button to close all layers
    self.closeAllLayersButton = QPushButton(&#34;Close all Layers&#34;)
    self.closeAllLayersButton.clicked.connect(lambda index, shared_data=shared_data: utils.closeAllLayers(shared_data))
    
    #all the way at the bottom of the layout
    debugHbox.addWidget(self.closeAllLayersButton)
    
    self.forceResetButton = QPushButton(&#34;Force-reset&#34;)
    self.forceResetButton.clicked.connect(lambda index, shared_data=shared_data: utils.forceReset(shared_data))
    debugHbox.addWidget(self.forceResetButton)
    
    
    self.advSettingsButton = QPushButton(&#34;Adv. settings&#34;)
    self.advSettingsButton.clicked.connect(lambda index, shared_data=shared_data: utils.openAdvancedSettings(shared_data))
    debugHbox.addWidget(self.advSettingsButton)
    
    liveModeLayout.addLayout(debugHbox,99,0,1,2)
    
    #Return the layout
    return liveModeLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.getDevicesOfDeviceType"><code class="name flex">
<span>def <span class="ident">getDevicesOfDeviceType</span></span>(<span>self, devicetype)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="find-all-devices-that-have-a-specific-devicetype">Find all devices that have a specific devicetype</h1>
<h1 id="look-at-httpsjavadocscijavaorgmicro-manager-coremmcorejdevicetypehtml">Look at <a href="https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html">https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html</a></h1>
<h1 id="for-all-devicetypes">for all devicetypes</h1></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDevicesOfDeviceType(self,devicetype):
    &#34;&#34;&#34;
    #Find all devices that have a specific devicetype
    #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
    #for all devicetypes
    &#34;&#34;&#34;
    #Get devices
    devices = self.core.get_loaded_devices() #type:ignore
    devices = [devices.get(i) for i in range(devices.size())]
    devicesOfType = []
    #Loop over devices
    for device in devices:
        if self.core.get_device_type(device).to_string() == devicetype: #type:ignore
            logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
            devicesOfType.append(device)
    return devicesOfType</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.getUIConfigInfo"><code class="name flex">
<span>def <span class="ident">getUIConfigInfo</span></span>(<span>self, onlyChecked=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all config information as set by the UI.</p>
<p>param onlyChecked: If True, only return information for checked configs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUIConfigInfo(self,onlyChecked=False):
    &#34;&#34;&#34;
    Get all config information as set by the UI.

    param onlyChecked: If True, only return information for checked configs.
    &#34;&#34;&#34;
    configInfo = {}
    for config_id in range(len(self.config_groups)):
        if onlyChecked and not self.configCheckboxes[config_id].isChecked():
            continue
        configInfo[self.config_groups[config_id].configGroupName()] = self.currentConfigUISingleValue(config_id)
    return configInfo</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.get_device_properties"><code class="name flex">
<span>def <span class="ident">get_device_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get device properties.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The object itself.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>A list of dictionaries containing device properties.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_properties(self):
    &#34;&#34;&#34;
    Get device properties.
    
    Args:
        self: The object itself.
        
    Returns:
        List: A list of dictionaries containing device properties.
    &#34;&#34;&#34;
    
    core = self.core
    devices = core.get_loaded_devices() #type:ignore
    devices = [devices.get(i) for i in range(devices.size())]
    device_items = []
    for device in devices:
        logging.debug(&#39;Device: &#39;+device)
        names = core.get_device_property_names(device) #type:ignore
        props = [names.get(i) for i in range(names.size())]
        property_items = []
        for prop in props:
            logging.debug(&#39;Property&#39;,prop)
            value = core.get_property(device, prop) #type:ignore
            is_read_only = core.is_property_read_only(device, prop) #type:ignore
            if core.has_property_limits(device, prop): #type:ignore
                lower = core.get_property_lower_limit(device, prop) #type:ignore
                upper = core.get_property_upper_limit(device, prop) #type:ignore
                allowed = {
                &#34;type&#34;: &#34;range&#34;,
                &#34;min&#34;: lower,
                &#34;max&#34;: upper,
                &#34;readOnly&#34;: is_read_only,
                }
            else:
                allowed = core.get_allowed_property_values(device, prop) #type:ignore
                allowed = {
                &#34;type&#34;: &#34;enum&#34;,
                &#34;options&#34;: [allowed.get(i) for i in range(allowed.size())],&#34;readOnly&#34;: is_read_only,
                }
                property_items.append(
                {&#34;device&#34;: device, &#34;name&#34;: prop, &#34;value&#34;: value, &#34;allowed&#34;: allowed}
                )
                logging.debug(&#39;===&gt;&#39;, device, prop, value, allowed)
        if len(property_items) &gt; 0:
            device_items.append(
            {
            &#34;name&#34;: device,
            &#34;value&#34;: &#34;{} properties&#34;.format(len(props)),
            &#34;items&#34;: property_items,
            }
            )
    return device_items</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.moveOneDStage"><code class="name flex">
<span>def <span class="ident">moveOneDStage</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the selected one-D stage by the specified amount</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int: 1</code> or <code>2, 'small step'</code> or <code>'big step'</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveOneDStage(self,amount):
    &#34;&#34;&#34;
    Moves the selected one-D stage by the specified amount

    Parameters
    ----------
    amount: int: 1 or 2, &#39;small step&#39; or &#39;big step&#39;
    &#34;&#34;&#34;
    #Get the currently selected one-D stage:
    selectedStage = self.oneDstageDropdown.currentText()
    
    #Get the value currently in the LineEdit
    self.moveoneDstagesmallAmount = float(self.oneDMoveEditField[selectedStage][f&#39;oneDStackedWidget_{selectedStage}_1&#39;].text())
    self.moveoneDstagelargeAmount = float(self.oneDMoveEditField[selectedStage][f&#39;oneDStackedWidget_{selectedStage}_2&#39;].text())
    
    logging.debug(&#34;moving &#34; + selectedStage + &#34; by &#34; + str(amount))
    
    #Move the stage relatively
    if abs(amount) == 2:
        self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagesmallAmount).astype(float)) #type:ignore
    elif abs(amount) == 1:
        self.core.set_relative_position(selectedStage,(np.sign(amount)*self.moveoneDstagelargeAmount).astype(float)) #type:ignore
    self.updateOneDstageLayout()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.moveXYStage"><code class="name flex">
<span>def <span class="ident">moveXYStage</span></span>(<span>self, relX, relY)</span>
</code></dt>
<dd>
<div class="desc"><p>Move XY stage with um positions in relx, rely:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveXYStage(self,relX,relY):
    &#34;&#34;&#34;
    Move XY stage with um positions in relx, rely:
    &#34;&#34;&#34;
    self.core.set_relative_xy_position(relX,relY) #type:ignore
    #Update the XYStageInfoWidget (if it exists)
    self.updateXYStageInfoWidget()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.onEditFieldChanged"><code class="name flex">
<span>def <span class="ident">onEditFieldChanged</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes a micromanager config when an editfield has changed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the editfield box that triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onEditFieldChanged(self,config_id):
    &#34;&#34;&#34;
    Changes a micromanager config when an editfield has changed
    Args:
        config_id (int): The ID of the editfield box that triggered the event.
    Returns:
        None
    &#34;&#34;&#34;

    CurrentText = self.editFields[config_id].text()
    #Get the config group name:
    configGroupName = self.config_groups[config_id].configGroupName()

    #An Editfield config by definition (?) only has a single property underneath, so get that:
    underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
    configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
    device_label = configdata.get_setting(0).get_device_label()
    property_name = configdata.get_setting(0).get_property_name()

    #Set this property:
    self.config_groups[config_id].core.set_property(device_label,property_name,CurrentText)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.on_dropDownChanged"><code class="name flex">
<span>def <span class="ident">on_dropDownChanged</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes a micromanager config when a dropdown has changed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the dropdown box that triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_dropDownChanged(self,config_id):
    &#34;&#34;&#34;
    Changes a micromanager config when a dropdown has changed

    Args:
        config_id (int): The ID of the dropdown box that triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    if self.showCheckboxes:
        #Check the corresponding checkbox
        self.configCheckboxes[config_id].setChecked(True)
    if self.changes_update_MM:
        #Get the new value from the dropdown:
        newValue = self.dropDownBoxes[config_id].currentText()
        #Change the value if it&#39;s a true value
        if newValue != &#34;&#34; and newValue != &#34; &#34;:
            #Get the config group name:
            configGroupName = self.config_groups[config_id].configGroupName()
            #Set in MM:
            self.config_groups[config_id].core.set_config(configGroupName,newValue)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.on_shutterAutoCheckboxChanged"><code class="name flex">
<span>def <span class="ident">on_shutterAutoCheckboxChanged</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the auto-shutter to whether the checkbox is selected or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_shutterAutoCheckboxChanged(self,state):
    &#34;&#34;&#34;
    Set the auto-shutter to whether the checkbox is selected or not
    &#34;&#34;&#34;
    if state == 2:
        self.shutterOpenCloseButton.setEnabled(False)
        self.core.set_auto_shutter(True) #type:ignore
    else:
        self.shutterOpenCloseButton.setEnabled(True)
        self.core.set_auto_shutter(False) #type:ignore</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.on_shutterChoiceChanged"><code class="name flex">
<span>def <span class="ident">on_shutterChoiceChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the shutter to the new choice if the dropdown is changed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_shutterChoiceChanged(self):
    &#34;&#34;&#34;
    Set the shutter to the new choice if the dropdown is changed
    &#34;&#34;&#34; 
    selected_item = self.shutterChoiceDropdown.currentText()
    self.core.set_shutter_device(selected_item) #type:ignore</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.on_shutterOpenCloseButtonPressed"><code class="name flex">
<span>def <span class="ident">on_shutterOpenCloseButtonPressed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>"
Method that's called when the Open/Close shutter button is pressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_shutterOpenCloseButtonPressed(self):
    &#34;&#34;&#34;&#34; 
    Method that&#39;s called when the Open/Close shutter button is pressed.
    &#34;&#34;&#34;
    current_text = self.shutterOpenCloseButton.text()
    if current_text == &#39;Open&#39;:
        self.core.set_shutter_open(True) #type:ignore
        self.shutterOpenCloseButton.setText(&#39;Close&#39;)
        self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterClosed.png&#39;))
    elif current_text == &#39;Close&#39;:
        self.core.set_shutter_open(False) #type:ignore
        self.shutterOpenCloseButton.setText(&#39;Open&#39;)
        self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterOpen.png&#39;))</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.on_sliderChanged"><code class="name flex">
<span>def <span class="ident">on_sliderChanged</span></span>(<span>self, config_id, fromText=False, fromSlider=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Changes a micromanager config when a slider has changed</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the slider box that triggered the event.</dd>
<dt><strong><code>slider_conversion_array</code></strong> :&ensp;<code>array</code></dt>
<dd>[lowerLimit,upperLimit,sliderPrecision]</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_sliderChanged(self,config_id,fromText=False,fromSlider=True):
    &#34;&#34;&#34;
    Changes a micromanager config when a slider has changed

    Args:
        config_id (int): The ID of the slider box that triggered the event.
        slider_conversion_array (array): [lowerLimit,upperLimit,sliderPrecision]

    Returns:
        None
    &#34;&#34;&#34;
    if self.showCheckboxes:
        #Check the corresponding checkbox:
        self.configCheckboxes[config_id].setChecked(True)
        
    #Get the new value from the slider:
    if fromSlider:
        newValue = self.sliders[config_id].value()
        #Get the true value from the conversion:
        trueValue = newValue/self.sliders[config_id].slider_conversion_array[2]*(self.sliders[config_id].slider_conversion_array[1]-self.sliders[config_id].slider_conversion_array[0])+self.sliders[config_id].slider_conversion_array[0]
    elif fromText:
        if self.editFields[config_id].text() != &#34;&#34;:
            trueValue = float(self.editFields[config_id].text())
        else:
            trueValue = &#34;&#34;
    else:
        trueValue = &#34;&#34; #error out later on purpose
        
    if self.changes_update_MM:
        #Change the value if it&#39;s a true value
        if trueValue != &#34;&#34; and trueValue != &#34; &#34;:
            #Get the config group name:
            configGroupName = self.config_groups[config_id].configGroupName()
            #Set in MM:
            #A slider config by definition (?) only has a single property underneath, so get that:
            underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
            configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
            device_label = configdata.get_setting(0).get_device_label()
            property_name = configdata.get_setting(0).get_property_name()

            #Set this property:
            self.config_groups[config_id].core.set_property(device_label,property_name,trueValue)
            
    if trueValue != &#34;&#34; and trueValue != &#34; &#34;:
        trueValue = round(trueValue,3)
        #Set the slider/text if the other is changed
        if fromSlider:
            self.editFields[config_id].setText(str(trueValue))
        elif fromText:
            newValue = self.sliders[config_id].slider_conversion_array[2] * (trueValue - self.sliders[config_id].slider_conversion_array[0]) / (self.sliders[config_id].slider_conversion_array[1] - self.sliders[config_id].slider_conversion_array[0])
            self.sliders[config_id].setValue(int(newValue))</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.oneDstageLayout"><code class="name flex">
<span>def <span class="ident">oneDstageLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see XYstageLayout()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oneDstageLayout(self):
    &#34;&#34;&#34;
    Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see XYstageLayout()
    &#34;&#34;&#34;
    #Create a layout
    self.oneDStageLayout = QGridLayout()
    
    #Creates a UI layout to move all found 1D stages
    #Find all 1D stages
    allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
    
    #Create a drop-down menu that has these stages as options
    self.oneDstageDropdown = QComboBox()
    for stage in allStages:
        self.oneDstageDropdown.addItem(stage)
    #If it changes, call the update routine
    self.oneDstageDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageLayout())
    #Also store the JSON if changed:
    self.oneDstageDropdown.currentTextChanged.connect(lambda: self.storeAllControlValues())
    #Set default value to default z stage of MM
    try:
        self.oneDstageDropdown.setCurrentText(self.core.get_focus_device()) #type:ignore
    except:
        pass
    #Add the dropdown to the layout:
    self.oneDStageLayout.addWidget(self.oneDstageDropdown,0,0)
    
    #Add left/right buttons and a label for the position
    self.oneDmoveButtons = {}
    for m in range(1,3):
        #Initialize buttons
        self.oneDmoveButtons[f&#39;Left_{m}&#39;] = QPushButton(&#34;&#34;*(3-m))
        self.oneDmoveButtons[f&#39;Left_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(m))
        self.oneDmoveButtons[f&#39;Right_{m}&#39;] = QPushButton(&#34;&#34;*(3-m))
        self.oneDmoveButtons[f&#39;Right_{m}&#39;].clicked.connect(lambda index, m=m: self.moveOneDStage(-m))
        
        #Add buttons to layout
        self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Left_{m}&#39;],m-1+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
        self.oneDStageLayout.addWidget(self.oneDmoveButtons[f&#39;Right_{m}&#39;],5-m+2,0,1,1, alignment=Qt.AlignmentFlag.AlignCenter)
    
    #Create a QGridBox for the movement sizes for each stage:
    self.oneDMoveEditFieldGridLayouts={}
    self.oneDMoveEditField={}
    self.oneDStackedWidget = QStackedWidget()
    for stage in allStages:
        self.oneDMoveEditFieldGridLayouts[stage] = QWidget()
        self.oneDMoveEditFieldGridLayouts[stage].setObjectName(stage)
        internalLayout = QGridLayout()
        self.oneDMoveEditFieldGridLayouts[stage].setLayout(internalLayout)
        self.oneDMoveEditField[stage] = {}
        for m in range(1,3):
            internalLayout.addWidget(QLabel(&#34;&#34;*(m)),m,0)
            self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;] = QLineEdit()
            internalLayout.addWidget(self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;],m,1)
            self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;].setText(&#34;10&#34;)
            self.oneDMoveEditField[stage][f&#39;oneDStackedWidget_{stage}_{m}&#39;].editingFinished.connect(lambda: self.storeAllControlValues())
        
        self.oneDStackedWidget.addWidget(self.oneDMoveEditFieldGridLayouts[stage])
    
    self.oneDStageLayout.addWidget(self.oneDStackedWidget,8,0)
    
    #Get current info of the widget
    self.oneDinfoWidget = QLabel()
    self.oneDStageLayout.addWidget(self.oneDinfoWidget,1,0)
    #update the text
    self.updateOneDstageLayout()
    
    #Store the values
    self.storeAllControlValues()
    
    return self.oneDStageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.oneDstageRelLayout"><code class="name flex">
<span>def <span class="ident">oneDstageRelLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see oneDstageLayout()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oneDstageRelLayout(self):
    &#34;&#34;&#34;
    Creates a UI layout to place all found one-D stages in a QStackedWidget and add the LineEdits etc. Also see oneDstageLayout()
    &#34;&#34;&#34;
    #Create a layout
    self.oneDStageRelLayout = QGridLayout()
    
    #Creates a UI layout to move all found 1D stages
    #Find all 1D stages
    allStages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
    
    #Create a drop-down menu that has these stages as options
    self.oneDstageRelDropdown = QComboBox()
    for stage in allStages:
        self.oneDstageRelDropdown.addItem(stage)
    #If it changes, call the update routine
    self.oneDstageRelDropdown.currentTextChanged.connect(lambda index: self.updateOneDstageRelLayout())
    #Also store the JSON if changed:
    self.oneDstageRelDropdown.currentTextChanged.connect(lambda: self.storeAllControlValues())
    #Set default value to default z stage of MM
    try:
        self.oneDstageRelDropdown.setCurrentText(self.core.get_focus_device()) #type:ignore
    except:
        pass
    #Add the dropdown to the layout:
    self.oneDStageRelLayout.addWidget(self.oneDstageRelDropdown,0,0)
    
    #Create a QGridBox for the movement sizes for each stage:
    self.oneDMoveRelEditFieldGridLayouts={}
    self.oneDMoveRelEditField={}
    self.oneDRelStackedWidget = QStackedWidget()
    for stage in allStages:
        self.oneDMoveRelEditFieldGridLayouts[stage] = QWidget()
        self.oneDMoveRelEditFieldGridLayouts[stage].setObjectName(stage)
        internalLayout = QGridLayout()
        self.oneDMoveRelEditFieldGridLayouts[stage].setLayout(internalLayout)
        self.oneDMoveRelEditField[stage] = {}
        
        internalLayout.addWidget(QLabel(&#34;Move&#34;),0,0)
        self.oneDMoveRelEditField[stage] = QLineEdit()
        internalLayout.addWidget(self.oneDMoveRelEditField[stage],1,0)
        self.oneDMoveRelEditField[stage].setText(&#34;10&#34;)
        self.oneDMoveRelEditField[stage].editingFinished.connect(lambda: self.storeAllControlValues())
        
        self.oneDRelStackedWidget.addWidget(self.oneDMoveRelEditFieldGridLayouts[stage])
    
    self.oneDStageRelLayout.addWidget(self.oneDRelStackedWidget,1,0)
    
    #Get current info of the widget
    self.oneDinfoRelWidget = QLabel()
    self.oneDStageRelLayout.addWidget(self.oneDinfoRelWidget,2,0)
    #update the text
    # self.updateOneDstageRelLayout()
    
    #Store the values
    # self.storeAllControlValues()
    
    return self.oneDStageRelLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.relativeStagesLayout"><code class="name flex">
<span>def <span class="ident">relativeStagesLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the layout with the XY stage widgets in relative mode.</p>
<p>This layout is used when the user is in relative mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relativeStagesLayout(self):
    &#34;&#34;&#34;
    Returns the layout with the XY stage widgets in relative mode.

    This layout is used when the user is in relative mode.
    &#34;&#34;&#34;
    stageLayout = QHBoxLayout()
    # stageLayout.addLayout(self.XYstageLayout())
    stageLayout.addLayout(self.oneDstageRelLayout())
    return stageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.resetROI"><code class="name flex">
<span>def <span class="ident">resetROI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the ROI to its maximum size</p>
<p>This function resets the ROI to its maximum size, which is the size of the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetROI(self):
    &#34;&#34;&#34;
    Reset the ROI to its maximum size

    This function resets the ROI to its maximum size, which is the size of the image
    &#34;&#34;&#34;
    self.core.clear_roi() #type:ignore</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.setROI"><code class="name flex">
<span>def <span class="ident">setROI</span></span>(<span>self, ROIpos)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the ROI to the specified position and size.</p>
<p>The ROIpos should be a list of [x,y,width,height]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setROI(self,ROIpos):
    &#34;&#34;&#34;
    Set the ROI to the specified position and size.
    
    The ROIpos should be a list of [x,y,width,height]
    &#34;&#34;&#34;
    #ROIpos should be a list of [x,y,width,height]
    logging.debug(&#39;Zooming ROI to &#39; + str(ROIpos))
    try:
        if shared_data.liveMode == False:
            self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3]) #type:ignore
            self.core.wait_for_system() #type:ignore
        else:
            shared_data.liveMode = False
            self.core.set_roi(ROIpos[0],ROIpos[1],ROIpos[2],ROIpos[3]) #type:ignore
            time.sleep(0.5)
            shared_data.liveMode = True
    except:
        logging.error(&#39;ZOOMING DIDN\&#39;T WORK!&#39;)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.setROItoDrawn"><code class="name flex">
<span>def <span class="ident">setROItoDrawn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The setROItoDrawn function is used to set the ROI of the microscope to a drawn shape.
The function first checks if there are any shapes in self.drawROIlayer, and if so, it gets the vertices of the last added shape (which should be a rectangle). It then sets the ROI using these vertices as top left and bottom right corners.
It also removes self.drawROIlayer from shared_data.napariViewer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setROItoDrawn(self):
    &#34;&#34;&#34;
    The setROItoDrawn function is used to set the ROI of the microscope to a drawn shape.
    The function first checks if there are any shapes in self.drawROIlayer, and if so, it gets the vertices of the last added shape (which should be a rectangle). It then sets the ROI using these vertices as top left and bottom right corners.
    It also removes self.drawROIlayer from shared_data.napariViewer
    &#34;&#34;&#34;
    # Get the type of the last added shape
    if len(self.drawROIlayer.data) &gt; 0:
        shape_type = self.drawROIlayer.shape_type[-1]
        if shape_type == &#39;rectangle&#39;:
            vertices = self.drawROIlayer.data[-1]  # Get the vertices of the last added shape
            #Get the topleft, bottomright position from the drawn rectangle
            topleftxy = np.floor(vertices[0][::-1])
            bottomrightxy = np.ceil(vertices[2][::-1])
            #Set the boundaries based on the camera
            mintopleft = [0,0]
            maxbottomright = [shared_data.core.get_roi().width, shared_data.core.get_roi().height]
            #Find the bounded positions
            topleftpos = np.maximum(topleftxy,mintopleft)
            bottomrightpos = np.minimum(bottomrightxy,maxbottomright)
            #Set the ROI correclty
            shared_data.core.set_roi(int(topleftpos[0]),int(topleftpos[1]),int(bottomrightpos[0]-topleftpos[0]),int(bottomrightpos[1]-topleftpos[1]))
            logging.info(f&#34;Set ROI to {topleftpos[0]},{topleftpos[1]},{bottomrightpos[0]},{bottomrightpos[1]} px&#34;)
    else:
        logging.warning(&#39;Attempted to set ROI to drawn, but no shape was added&#39;)
    
    #remove the self.drawROIlayer:
    try:
        shared_data.napariViewer.layers.remove(self.drawROIlayer)
    except:
        logging.error(&#39;Failed to remove the drawROIlayer&#39;)
    
    #Reset the Draw ROI button
    self.ROIoptionsButtons[&#39;drawROI&#39;].setText(&#39;Draw ROI&#39;)
    self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.disconnect()
    self.ROIoptionsButtons[&#39;drawROI&#39;].clicked.connect(lambda index: self.drawROI())</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.setXYStageMovementValue"><code class="name flex">
<span>def <span class="ident">setXYStageMovementValue</span></span>(<span>self, m, xEditField, yEditField)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the XY stageLineEdits to specific values based on the Buttons next to the fields.
This function is called when the user presses the "Set" buttons next to the XY EditFields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setXYStageMovementValue(self,m,xEditField,yEditField):
    &#34;&#34;&#34;
    Set the XY stageLineEdits to specific values based on the Buttons next to the fields.
    This function is called when the user presses the &#34;Set&#34; buttons next to the XY EditFields
    &#34;&#34;&#34;
    #Set the values in the XY EditFields based on the buttons
    fieldUnits = [0.1,1,3]
    fieldUnit = fieldUnits[m]
    field_size_um = [self.core.get_pixel_size_um()*self.core.get_roi().width,self.core.get_pixel_size_um()*self.core.get_roi().height]#type: ignore
    
    x_value_um = field_size_um[0]*fieldUnit
    y_value_um = field_size_um[1]*fieldUnit
    xEditField.setText(str(x_value_um))
    yEditField.setText(str(y_value_um))
    self.storeAllControlValues()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.set_font_and_margins_recursive"><code class="name flex">
<span>def <span class="ident">set_font_and_margins_recursive</span></span>(<span>self, widget, font=&lt;PyQt5.QtGui.QFont object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
    &#34;&#34;&#34;
    Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
    Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.

    &#34;&#34;&#34;
    # if widget is None:
    #     return
    #Testing a few things
    # try:
    #     widget.setSizePolicy(
    #         QSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
    #     )
    # except:
    #     pass
    # try:
    #     widget.setMimimumSize(10, 10)
    # except:
    #     pass
    
    # if not isinstance(widget, (QPushButton,QComboBox)):
    #     try:
    #         widget.setSizePolicy(
    #             QSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
    #         )
    #     except:
    #         pass
    
    if isinstance(widget, (QPushButton)):
        widget.setFont(font)
        # widget.setContentsMargins(0, 0, 0, 0)
        # widget.setMinimumSize(20, 20)
    if isinstance(widget, (QLabel, QComboBox)):
        widget.setFont(font)
        # widget.setContentsMargins(0, 0, 0, 0)
        # widget.setMinimumSize(20, 20)

    if isinstance(widget, QGroupBox):
        widget.setSizePolicy(
            QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        )
        # Ensure QGroupBox respects the size of its contents
        widget.setMinimumSize(widget.minimumSizeHint())  # Set the minimum size of QGroupBox based on its size hint

    if hasattr(widget, &#39;layout&#39;):
        layout = widget.layout()
        if layout:
            # layout.setContentsMargins(0, 0, 0, 0)
            # layout.setSpacing(0)  # Optionally, remove spacing between widgets
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if hasattr(item, &#39;widget&#39;):
                    self.set_font_and_margins_recursive(item.widget(), font=font)
                if hasattr(item, &#39;layout&#39;):
                    self.set_font_and_margins_recursive(item.layout(), font=font)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.shape_drawn_callback"><code class="name flex">
<span>def <span class="ident">shape_drawn_callback</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shape_drawn_callback(self, event):
    if len(self.drawROIlayer.data) &gt; 0:
        if not event.source._is_moving and not event.source._is_selecting and not event.source._is_creating and len(event.source._mouse_drag_gen) &gt; 0 and event.source.name != &#39;Draw ROI_&#39;:
            logging.debug(&#39;Finished drawing an area for the ROI size!&#39;)
            
            def acceptFun(dialogV):
                self.setROItoDrawn()
                #Close the dialog:
                dialogV.done(QDialog.Accepted)
            
            
            
            def reDoFun(dialogV,layer):
                #Remove the layer
                shared_data.napariViewer.layers.remove(layer)
                #Restart the drawROI:
                self.drawROI()
                #Close the dialog:
                dialogV.done(QDialog.Rejected)
            
            def cancelFun(dialogV,layer):
                #Remove the layer
                shared_data.napariViewer.layers.remove(layer)
                #Close the dialog:
                dialogV.done(QDialog.Rejected)
            
            #Change the layer name so this won&#39;t pop up again after dialog is closed.
            event.source.name = &#39;Draw ROI_&#39;
            #Pop up a dialog box to ask if they like it or not:
            #Create a dialog box
            from PyQt5.QtWidgets import QDialog, QDialogButtonBox, QVBoxLayout, QLabel
            dialog =  QDialog()
            dialog.setWindowTitle(&#39;Draw ROI&#39;)
            #Add 3 buttons: 
            QButtonOk = QPushButton(&#39;OK&#39;)
            QButtonRedraw = QPushButton(&#39;Redraw&#39;)
            QButtonCancel = QPushButton(&#39;Cancel&#39;)
            #add the box to dialog:
            layout = QVBoxLayout()
            layout.addWidget(
                QLabel(&#39;ROI drawn correctly?&#39;)
            )
            buttonBox = QHBoxLayout()
            buttonBox.addWidget(QButtonOk)
            buttonBox.addWidget(QButtonRedraw)
            buttonBox.addWidget(QButtonCancel)
            layout.addLayout(buttonBox)
            dialog.setLayout(layout)
            #Connect the buttons to the dialog:
            QButtonOk.clicked.connect(lambda: acceptFun(dialog))
            QButtonRedraw.clicked.connect(lambda: reDoFun(dialog,event.source))
            QButtonCancel.clicked.connect(lambda: cancelFun(dialog,event.source))
            #Show the dialog:
            dialog.exec_()</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.shutterOptionsLayout"><code class="name flex">
<span>def <span class="ident">shutterOptionsLayout</span></span>(<span>self, orientation='horizontal')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a layout with buttons for Shutter options</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ShutterOptionsLayout</code></strong> :&ensp;<code>QGridLayout</code></dt>
<dd>A layout with buttons for Shutter options</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutterOptionsLayout(self,orientation=&#39;horizontal&#39;):
    &#34;&#34;&#34;
    Create a layout with buttons for Shutter options

    Returns
    -------
    ShutterOptionsLayout : QGridLayout
        A layout with buttons for Shutter options
    &#34;&#34;&#34;
    #Create a Grid layout:
    shutterOptionsLayout = QGridLayout()
    #Add a dropdown:
    self.shutterChoiceDropdown = QComboBox()
    shutterDevices = self.getDevicesOfDeviceType(&#39;ShutterDevice&#39;)
    for shutterDevice in shutterDevices:
        self.shutterChoiceDropdown.addItem(shutterDevice)
    self.shutterChoiceDropdown.currentIndexChanged.connect(self.on_shutterChoiceChanged)
    
    self.shutterAutoCheckbox = QCheckBox(&#34;Auto&#34;)
    self.shutterAutoCheckbox.stateChanged.connect(self.on_shutterAutoCheckboxChanged)
    
    self.shutterOpenCloseButton = QPushButton(&#34;Open&#34;)
    self.shutterOpenCloseButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;ShutterOpen.png&#39;))
    self.shutterOpenCloseButton.clicked.connect(self.on_shutterOpenCloseButtonPressed)
    
    shutterOptionsLayout.addWidget(self.shutterChoiceDropdown,0,0,1,2)
    shutterOptionsLayout.addWidget(self.shutterAutoCheckbox,1,0)
    shutterOptionsLayout.addWidget(self.shutterOpenCloseButton,1,1)
    
    return shutterOptionsLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.snapImage"><code class="name flex">
<span>def <span class="ident">snapImage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that's called when an image is snapped (i.e. get a single image), uses the float(self.exposureTimeInputField.text()) as time in ms</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snapImage(self):
    &#34;&#34;&#34;
    Function that&#39;s called when an image is snapped (i.e. get a single image), uses the float(self.exposureTimeInputField.text()) as time in ms
    &#34;&#34;&#34;
    #Set the correct exposure time
    shared_data.core.set_exposure(float(self.exposureTimeInputField.text()))
    #Snap an image
    shared_data.core.snap_image()
    #Get the just-snapped image
    newImage = shared_data.core.get_tagged_image()
    snapLayer = checkIfLayerExistsOrCreate(napariViewer,&#39;Snap&#39;,shared_data_throughput = shared_data, required_size = (newImage.tags[&#34;Height&#34;],newImage.tags[&#34;Width&#34;]))
    snapLayer.data = np.reshape(newImage.pix, newshape=[newImage.tags[&#34;Height&#34;], newImage.tags[&#34;Width&#34;]])
    #Move the layer to top
    moveLayerToTop(napariViewer,&#39;Snap&#39;)
    return</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.stagesLayout"><code class="name flex">
<span>def <span class="ident">stagesLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the layout with the XY and 1D stage widgets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stagesLayout(self):
    &#34;&#34;&#34;
    Returns the layout with the XY and 1D stage widgets.
    &#34;&#34;&#34;
    stageLayout = QHBoxLayout()
    # self.XYstageLayout()
    xyStageLayout = self.XYstageLayout()
    oneDstageLayout = self.oneDstageLayout()
    stageLayout.addLayout(xyStageLayout)
    stageLayout.addLayout(oneDstageLayout)
    #Add a horizontal spacer:
    stageLayout.addStretch(1)
    stageLayout.setSizeConstraint(QHBoxLayout.SetMinimumSize) #type:ignore
    # print(stageLayout.children())
    xyLayoutWidth = 0
    for i in range(xyStageLayout.columnCount()):
        xyLayoutWidth += xyStageLayout.columnMinimumWidth(i)
    oneDstageLayoutWidth = 0
    for i in range(oneDstageLayout.columnCount()):
        oneDstageLayoutWidth += oneDstageLayout.columnMinimumWidth(i)
    
    containerWidget = QWidget()
    containerWidget.setLayout(stageLayout)
    containerWidget.setFixedWidth(xyLayoutWidth+oneDstageLayoutWidth)
    
    stageOvercapLayout = QHBoxLayout()
    stageOvercapLayout.addWidget(containerWidget)
    
    return stageLayout</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.storeAllControlValues"><code class="name flex">
<span>def <span class="ident">storeAllControlValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Store all the control values in a dictionary, which can be used to save state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storeAllControlValues(self):
    &#34;&#34;&#34;
    Store all the control values in a dictionary, which can be used to save state.
    &#34;&#34;&#34;
    if self.autoSaveLoad:
        if self.fullyLoaded:
            logging.debug(&#39;Storing glados state.json&#39;)
            
            #Store in appdata
            appdata_folder = os.getenv(&#39;APPDATA&#39;)
            if appdata_folder is None:
                raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
            app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
            os.makedirs(app_specific_folder, exist_ok=True)
            self.save_state_MMControls(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
            pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateAllMMinfo"><code class="name flex">
<span>def <span class="ident">updateAllMMinfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update all the info that can be updated from the microscope.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateAllMMinfo(self):
    &#34;&#34;&#34;
    Update all the info that can be updated from the microscope.
    &#34;&#34;&#34;
    logging.debug(&#39;Updating all MM info&#39;)
    if self.showConfigs:
        self.updateConfigsFromMM()
    if self.showStages:
        self.updateXYStageInfoWidget()
        self.updateOneDstageLayout()
    if self.showShutterOptions:
        self.updateShutterOptions()
    
    #Then store it in JSON for good measure
    if self.autoSaveLoad:
        if self.fullyLoaded:
            #Store in appdata
            appdata_folder = os.getenv(&#39;APPDATA&#39;)
            if appdata_folder is None:
                raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
            app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
            os.makedirs(app_specific_folder, exist_ok=True)
            self.save_state_MMControls(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
            
    #         #Store in appdata
    #         appdata_folder = os.getenv(&#39;APPDATA&#39;)
    #         if appdata_folder is None:
    #             raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
    #         app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
    #         os.makedirs(app_specific_folder, exist_ok=True)
            
            
    #         if os.path.exists(os.path.join(app_specific_folder, &#39;glados_state.json&#39;)):
    #             with open(os.path.join(app_specific_folder, &#39;glados_state.json&#39;), &#39;r&#39;) as file:
    #                 gladosInfo = json.load(file)
    #                 MMControlsInfo = gladosInfo[&#39;MMControls&#39;]
            
    #             #Hand-set the values that I want:
    #             if &#39;exposureTimeInputField&#39; in MMControlsInfo:
    #                 self.exposureTimeInputField.setText(MMControlsInfo[&#39;exposureTimeInputField&#39;][&#39;text&#39;])
    #             for key, object in self.XYMoveEditField.items():
    #                 if key in MMControlsInfo:
    #                     object.setText(MMControlsInfo[key][&#39;text&#39;])
    #             for key,object in self.oneDMoveEditField.items():
    #                 for objectLineEditKey in object:
    #                     objectLineEdit = object[objectLineEditKey]
    #                     if objectLineEditKey in MMControlsInfo:
    #                         objectLineEdit.setText(MMControlsInfo[objectLineEditKey][&#39;text&#39;])</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateConfigsFromMM"><code class="name flex">
<span>def <span class="ident">updateConfigsFromMM</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates all configs from the Micro-Manager backend.</p>
<p>This function iterates over all configs and updates their values in the GUI
based on the current values in the Micro-Manager backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateConfigsFromMM(self):
    &#34;&#34;&#34;
    Updates all configs from the Micro-Manager backend.
    
    This function iterates over all configs and updates their values in the GUI
    based on the current values in the Micro-Manager backend.
    &#34;&#34;&#34;
    #Update all values from MM:
    for config_id in range(len(self.config_groups)):
        self.updateValuefromMM(config_id)
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateOneDstageLayout"><code class="name flex">
<span>def <span class="ident">updateOneDstageLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateOneDstageLayout(self):
    &#34;&#34;&#34;
    Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage
    &#34;&#34;&#34;
    self.oneDinfoWidget.setText(f&#34;{self.oneDstageDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageDropdown.currentText()):.1f}&#34;) #type:ignore
    
    for widget_id in range(0,self.oneDStackedWidget.count()):
        widget = self.oneDStackedWidget.widget(widget_id)
        if widget.objectName() == self.oneDstageDropdown.currentText():
            self.oneDStackedWidget.setCurrentIndex(widget_id)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateOneDstageRelLayout"><code class="name flex">
<span>def <span class="ident">updateOneDstageRelLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateOneDstageRelLayout(self):
    &#34;&#34;&#34;
    Updates the OneD stage layout text with the current values of the stage dropdown and the current position of the stage
    &#34;&#34;&#34;
    logging.debug(&#34;Updating OneD stage layout&#34;)
    self.oneDinfoRelWidget.setText(f&#34;{self.oneDstageRelDropdown.currentText()}\r\n {self.core.get_position(self.oneDstageRelDropdown.currentText()):.1f}&#34;) #type:ignore
    
    for widget_id in range(0,self.oneDRelStackedWidget.count()):
        widget = self.oneDRelStackedWidget.widget(widget_id)
        if widget.objectName() == self.oneDstageRelDropdown.currentText():
            self.oneDRelStackedWidget.setCurrentIndex(widget_id)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateShutterOptions"><code class="name flex">
<span>def <span class="ident">updateShutterOptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>"
Update the shutter GUI options based on what's what in MM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateShutterOptions(self):
    &#34;&#34;&#34;&#34; 
    Update the shutter GUI options based on what&#39;s what in MM
    &#34;&#34;&#34;
    #Set the current shutter device to the one in MM
    currentShutterDevice = self.core.get_shutter_device() #type:ignore
    self.shutterChoiceDropdown.currentText = currentShutterDevice
    #Set the auto-method to the one in MM:
    currentShutterAuto = self.core.get_auto_shutter() #type:ignore
    self.shutterAutoCheckbox.setChecked(currentShutterAuto)
    if currentShutterAuto == False:
        self.shutterOpenCloseButton.setEnabled(True)
    #Set the button text
    currentShutterOpen = self.core.get_shutter_open() #type:ignore
    if currentShutterOpen == True:
        self.shutterOpenCloseButton.setText(&#39;Close&#39;)
    else:
        self.shutterOpenCloseButton.setText(&#39;Open&#39;)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateValueInGUI"><code class="name flex">
<span>def <span class="ident">updateValueInGUI</span></span>(<span>self, config_id, newValue)</span>
</code></dt>
<dd>
<div class="desc"><p>I THINK DEPRECATED, BUT KEEPING FOR KEEPING SAKE
Updates the GUI to reflect a change in the Micromanager config
Set the value of the dropdown to the current MM value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the config box to change</dd>
<dt><strong><code>newValue</code></strong> :&ensp;<code>str</code></dt>
<dd>The new value of the config property</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateValueInGUI(self,config_id, newValue):
    &#34;&#34;&#34;
    I THINK DEPRECATED, BUT KEEPING FOR KEEPING SAKE
    Updates the GUI to reflect a change in the Micromanager config
    Set the value of the dropdown to the current MM value

    Args:
        config_id (int): The ID of the config box to change
        newValue (str): The new value of the config property

    Returns:
        None
    &#34;&#34;&#34;
    if self.config_groups[config_id].isDropDown():
        self.dropDownBoxes[config_id].setCurrentText(newValue)
    elif self.config_groups[config_id].isSlider():
        #Finally we get the current value of the slider
        currentSliderValue = float(newValue)
            
        #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
        sliderPrecision = self.sliderPrecision
        #Get the min and max value of the slider:
        lowerLimit = self.config_groups[config_id].lowerLimit()
        upperLimit = self.config_groups[config_id].upperLimit()
        sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
        
        self.sliders[config_id].setValue(sliderValInSliderPrecision)
        
    elif self.config_groups[config_id].isInputField():
        pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateValuefromMM"><code class="name flex">
<span>def <span class="ident">updateValuefromMM</span></span>(<span>self, config_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the value in the GUI for a single config_id based on the current value in MM</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config_id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the config_group to update</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateValuefromMM(self,config_id):
    &#34;&#34;&#34;
    Updates the value in the GUI for a single config_id based on the current value in MM

    Args:
        config_id (int): The ID of the config_group to update

    Returns:
        None
    &#34;&#34;&#34;
    logging.debug(&#34;Updating value from &#34; + self.config_groups[config_id].configGroupName())
    #Get the value of the config_id from micromanager:
    currentValue = self.config_groups[config_id].getCurrentMMValue()
    
    #Set the value of the dropdown to the current MM value
    if self.config_groups[config_id].isDropDown():
        self.dropDownBoxes[config_id].setCurrentText(currentValue)
    elif self.config_groups[config_id].isSlider():
        #A slider config by definition (?) only has a single property underneath, so get that:
        configGroupName = self.config_groups[config_id].configGroupName()
        underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
        configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()
        
        #Finally we get the current value of the slider
        currentSliderValue = float(self.config_groups[config_id].core.get_property(device_label,property_name))
            
        #Sliders only work in integers, so we need to set some artificial precision and translate to this precision
        sliderPrecision = self.sliderPrecision
        #Get the min and max value of the slider:
        lowerLimit = self.config_groups[config_id].lowerLimit()
        upperLimit = self.config_groups[config_id].upperLimit()
        sliderValInSliderPrecision = int(((currentSliderValue-lowerLimit)/(upperLimit-lowerLimit))*sliderPrecision)
        # #Update the slider:
        self.sliders[config_id].setRange(0,sliderPrecision)
        self.sliders[config_id].setValue(sliderValInSliderPrecision)
        #Also update the corresponding editField
        self.editFields[config_id].setText(str(currentSliderValue))
        
    elif self.config_groups[config_id].isInputField():
        #A editfield config by definition (?) only has a single property underneath, so get that:
        configGroupName = self.config_groups[config_id].configGroupName()
        underlyingProperty = self.config_groups[config_id].core.get_available_configs(configGroupName).get(0)
        configdata = self.config_groups[config_id].core.get_config_data(configGroupName,underlyingProperty)
        device_label = configdata.get_setting(0).get_device_label()
        property_name = configdata.get_setting(0).get_property_name()

        #Finally we get the current value of the editfield
        currentValue = (self.config_groups[config_id].core.get_property(device_label,property_name))

        self.editFields[config_id].setText(currentValue)
    
    #Make inactive if the checkbox is inactive
    self.configLayoutEnableChange(config_id)
    pass</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.updateXYStageInfoWidget"><code class="name flex">
<span>def <span class="ident">updateXYStageInfoWidget</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the XY stage info widget with the current position of the stage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateXYStageInfoWidget(self):
    &#34;&#34;&#34;
    Updates the XY stage info widget with the current position of the stage

    &#34;&#34;&#34;
    #Obtain the stage info from MM:
    XYStageName = self.core.get_xy_stage_device() #type:ignore
    #Get the stage position
    XYStagePos = self.core.get_xy_stage_position(XYStageName) #type:ignore
    self.XYStageInfoWidget.setText(f&#34;{XYStageName}\r\n {XYStagePos.x:.0f}/{XYStagePos.y:.0f}&#34;)</code></pre>
</details>
</dd>
<dt id="MMcontrols.MMConfigUI.zoomROI"><code class="name flex">
<span>def <span class="ident">zoomROI</span></span>(<span>self, option)</span>
</code></dt>
<dd>
<div class="desc"><p>Zoom the ROI in or out from the center</p>
<p>This function zooms the ROI in or out from the center.
It zooms the ROI by a factor of 2.
If the option is "ZoomIn", the ROI is zoomed in twice.
If the option is "ZoomOut", the ROI is zoomed out twice</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zoomROI(self,option):
    &#34;&#34;&#34;
    Zoom the ROI in or out from the center
    
    This function zooms the ROI in or out from the center.
    It zooms the ROI by a factor of 2.
    If the option is &#34;ZoomIn&#34;, the ROI is zoomed in twice.
    If the option is &#34;ZoomOut&#34;, the ROI is zoomed out twice
    &#34;&#34;&#34;
    #Get the current ROI info
    #[x,y,width,height]
    roiv = [self.core.get_roi().x,self.core.get_roi().y,self.core.get_roi().width,self.core.get_roi().height] #type:ignore
    logging.debug(&#39;ROI zoom requested, current size: &#39;+str(roiv))
    if option == &#39;ZoomIn&#39;:
        #zoom in twice
        try:
            #Get current widht/height and new width/height
            curTotWidth = roiv[2]
            curTotHeight = roiv[3]
            newTotWidth = int(curTotWidth/2)
            newTotHeight = int(curTotHeight/2)
            newX = int(roiv[0]+(curTotWidth-newTotWidth)/2)
            newY = int(roiv[1]+(curTotHeight-newTotHeight)/2)
            #Set the new ROI size
            self.setROI([newX,newY,newTotWidth,newTotHeight])
        except:
            logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)
    elif option == &#39;ZoomOut&#39;:
        #zoom in twice
        try:
            #Get current widht/height and new width/height
            curTotWidth = roiv[2]
            curTotHeight = roiv[3]
            newTotWidth = int(curTotWidth*2)
            newTotHeight = int(curTotHeight*2)
            newX = int(roiv[0]-(newTotWidth-curTotWidth)/2)
            newY = int(roiv[1]-(newTotHeight-curTotHeight)/2)
            #Set the new ROI size
            self.setROI([newX,newY,newTotWidth,newTotHeight])
        except:
            logging.error(&#39;ZOOMING IN DIDN\&#39;T WORK!&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MMcontrols.microManagerControlsUI" href="#MMcontrols.microManagerControlsUI">microManagerControlsUI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MMcontrols.ConfigInfo" href="#MMcontrols.ConfigInfo">ConfigInfo</a></code></h4>
<ul class="">
<li><code><a title="MMcontrols.ConfigInfo.configGroupName" href="#MMcontrols.ConfigInfo.configGroupName">configGroupName</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.configName" href="#MMcontrols.ConfigInfo.configName">configName</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.deviceNameProperty_fromVerbose" href="#MMcontrols.ConfigInfo.deviceNameProperty_fromVerbose">deviceNameProperty_fromVerbose</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.getCurrentMMValue" href="#MMcontrols.ConfigInfo.getCurrentMMValue">getCurrentMMValue</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.getStorableValue" href="#MMcontrols.ConfigInfo.getStorableValue">getStorableValue</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.hasPropertyLimits" href="#MMcontrols.ConfigInfo.hasPropertyLimits">hasPropertyLimits</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.helpStringInfo" href="#MMcontrols.ConfigInfo.helpStringInfo">helpStringInfo</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.isDropDown" href="#MMcontrols.ConfigInfo.isDropDown">isDropDown</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.isInputField" href="#MMcontrols.ConfigInfo.isInputField">isInputField</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.isSlider" href="#MMcontrols.ConfigInfo.isSlider">isSlider</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.lowerLimit" href="#MMcontrols.ConfigInfo.lowerLimit">lowerLimit</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.nrConfigs" href="#MMcontrols.ConfigInfo.nrConfigs">nrConfigs</a></code></li>
<li><code><a title="MMcontrols.ConfigInfo.upperLimit" href="#MMcontrols.ConfigInfo.upperLimit">upperLimit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MMcontrols.MMConfigUI" href="#MMcontrols.MMConfigUI">MMConfigUI</a></code></h4>
<ul class="">
<li><code><a title="MMcontrols.MMConfigUI.LoadAllMMFromJSON" href="#MMcontrols.MMConfigUI.LoadAllMMFromJSON">LoadAllMMFromJSON</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.ROIoptionsLayout" href="#MMcontrols.MMConfigUI.ROIoptionsLayout">ROIoptionsLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.Vseparator_line" href="#MMcontrols.MMConfigUI.Vseparator_line">Vseparator_line</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.XYstageLayout" href="#MMcontrols.MMConfigUI.XYstageLayout">XYstageLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addDropDown" href="#MMcontrols.MMConfigUI.addDropDown">addDropDown</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addImageToAlbum" href="#MMcontrols.MMConfigUI.addImageToAlbum">addImageToAlbum</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addInputField" href="#MMcontrols.MMConfigUI.addInputField">addInputField</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addLabel" href="#MMcontrols.MMConfigUI.addLabel">addLabel</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addRow" href="#MMcontrols.MMConfigUI.addRow">addRow</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.addSlider" href="#MMcontrols.MMConfigUI.addSlider">addSlider</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.changeLiveMode" href="#MMcontrols.MMConfigUI.changeLiveMode">changeLiveMode</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.configLayoutEnableChange" href="#MMcontrols.MMConfigUI.configLayoutEnableChange">configLayoutEnableChange</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.currentConfigUISingleValue" href="#MMcontrols.MMConfigUI.currentConfigUISingleValue">currentConfigUISingleValue</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.drawROI" href="#MMcontrols.MMConfigUI.drawROI">drawROI</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.generalImagingLayout" href="#MMcontrols.MMConfigUI.generalImagingLayout">generalImagingLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.getDevicesOfDeviceType" href="#MMcontrols.MMConfigUI.getDevicesOfDeviceType">getDevicesOfDeviceType</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.getUIConfigInfo" href="#MMcontrols.MMConfigUI.getUIConfigInfo">getUIConfigInfo</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.get_device_properties" href="#MMcontrols.MMConfigUI.get_device_properties">get_device_properties</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.moveOneDStage" href="#MMcontrols.MMConfigUI.moveOneDStage">moveOneDStage</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.moveXYStage" href="#MMcontrols.MMConfigUI.moveXYStage">moveXYStage</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.onEditFieldChanged" href="#MMcontrols.MMConfigUI.onEditFieldChanged">onEditFieldChanged</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.on_dropDownChanged" href="#MMcontrols.MMConfigUI.on_dropDownChanged">on_dropDownChanged</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.on_shutterAutoCheckboxChanged" href="#MMcontrols.MMConfigUI.on_shutterAutoCheckboxChanged">on_shutterAutoCheckboxChanged</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.on_shutterChoiceChanged" href="#MMcontrols.MMConfigUI.on_shutterChoiceChanged">on_shutterChoiceChanged</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.on_shutterOpenCloseButtonPressed" href="#MMcontrols.MMConfigUI.on_shutterOpenCloseButtonPressed">on_shutterOpenCloseButtonPressed</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.on_sliderChanged" href="#MMcontrols.MMConfigUI.on_sliderChanged">on_sliderChanged</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.oneDstageLayout" href="#MMcontrols.MMConfigUI.oneDstageLayout">oneDstageLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.oneDstageRelLayout" href="#MMcontrols.MMConfigUI.oneDstageRelLayout">oneDstageRelLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.relativeStagesLayout" href="#MMcontrols.MMConfigUI.relativeStagesLayout">relativeStagesLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.resetROI" href="#MMcontrols.MMConfigUI.resetROI">resetROI</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.setROI" href="#MMcontrols.MMConfigUI.setROI">setROI</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.setROItoDrawn" href="#MMcontrols.MMConfigUI.setROItoDrawn">setROItoDrawn</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.setXYStageMovementValue" href="#MMcontrols.MMConfigUI.setXYStageMovementValue">setXYStageMovementValue</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.set_font_and_margins_recursive" href="#MMcontrols.MMConfigUI.set_font_and_margins_recursive">set_font_and_margins_recursive</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.shape_drawn_callback" href="#MMcontrols.MMConfigUI.shape_drawn_callback">shape_drawn_callback</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.shutterOptionsLayout" href="#MMcontrols.MMConfigUI.shutterOptionsLayout">shutterOptionsLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.snapImage" href="#MMcontrols.MMConfigUI.snapImage">snapImage</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.stagesLayout" href="#MMcontrols.MMConfigUI.stagesLayout">stagesLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.storeAllControlValues" href="#MMcontrols.MMConfigUI.storeAllControlValues">storeAllControlValues</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateAllMMinfo" href="#MMcontrols.MMConfigUI.updateAllMMinfo">updateAllMMinfo</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateConfigsFromMM" href="#MMcontrols.MMConfigUI.updateConfigsFromMM">updateConfigsFromMM</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateOneDstageLayout" href="#MMcontrols.MMConfigUI.updateOneDstageLayout">updateOneDstageLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateOneDstageRelLayout" href="#MMcontrols.MMConfigUI.updateOneDstageRelLayout">updateOneDstageRelLayout</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateShutterOptions" href="#MMcontrols.MMConfigUI.updateShutterOptions">updateShutterOptions</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateValueInGUI" href="#MMcontrols.MMConfigUI.updateValueInGUI">updateValueInGUI</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateValuefromMM" href="#MMcontrols.MMConfigUI.updateValuefromMM">updateValuefromMM</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.updateXYStageInfoWidget" href="#MMcontrols.MMConfigUI.updateXYStageInfoWidget">updateXYStageInfoWidget</a></code></li>
<li><code><a title="MMcontrols.MMConfigUI.zoomROI" href="#MMcontrols.MMConfigUI.zoomROI">zoomROI</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>