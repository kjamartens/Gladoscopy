<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MDAGlados API documentation</title>
<meta name="description" content="Main function of the multi-dimensional acquisitions in glados-pycromanager â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MDAGlados</code></h1>
</header>
<section id="section-intro">
<p>Main function of the multi-dimensional acquisitions in glados-pycromanager.</p>
<p>Handles the GUI as well as the logic of the multi-dimensional acquisitions.
Includes classes for Interactive Lists such as the Channels, XY positions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Main function of the multi-dimensional acquisitions in glados-pycromanager.

Handles the GUI as well as the logic of the multi-dimensional acquisitions.
Includes classes for Interactive Lists such as the Channels, XY positions.
&#34;&#34;&#34;

import sys
import time
from PyQt5.QtWidgets import QLineEdit, QFrame, QGridLayout, QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QComboBox, QSpacerItem, QSizePolicy, QSlider, QCheckBox, QGroupBox, QVBoxLayout, QFileDialog, QRadioButton
from PyQt5.QtCore import Qt, pyqtSignal, QObject, QThread, QCoreApplication
from PyQt5.QtGui import QResizeEvent, QIcon, QPixmap, QFont, QDoubleValidator, QIntValidator
from PyQt5 import uic
import os
# import PyQt5.QtWidgets
import json
from pycromanager import Core, multi_d_acquisition_events, Acquisition
import numpy as np
import asyncio
import pyqtgraph as pg
import matplotlib.pyplot as plt
from matplotlib import colormaps # type: ignore
#For drawing
import matplotlib
matplotlib.use(&#39;Qt5Agg&#39;)
# from PyQt5 import QtCore, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure
import tifffile
import time
from PyQt5.QtCore import QTimer,QDateTime, pyqtSignal
import logging
from typing import List, Iterable
import itertools
import queue
from PyQt5.QtWidgets import QTableWidget, QWidget, QInputDialog, QTableWidgetItem

def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__

if is_pip_installed():
    import glados_pycromanager.GUI.utils
    from glados_pycromanager.GUI.utils import CustomMainWindow
    from glados_pycromanager.GUI.napariHelperFunctions import getLayerIdFromName, InitateNapariUI
    from glados_pycromanager.GUI.AnalysisClass import *
    from glados_pycromanager.GUI.AnalysisClass import create_real_time_analysis_thread
    import glados_pycromanager.GUI.utils as utils
    from glados_pycromanager.GUI.MMcontrols import ConfigInfo
else:
    import utils as utils
    from utils import CustomMainWindow
    from napariHelperFunctions import getLayerIdFromName, InitateNapariUI
    from AnalysisClass import *
    from AnalysisClass import create_real_time_analysis_thread
    from MMcontrols import ConfigInfo


#region List Widgets
class InteractiveListWidget(QTableWidget):
    &#34;&#34;&#34;
    Creation of an interactive list widget, initially created for a nice XY list (similar to POS list in micromanager)
    &#34;&#34;&#34;
    def __init__(self,fontsize=6,columnCount=2,parent=None):
        &#34;&#34;&#34;
        Initializes an InteractiveListWidget.
        
        Args:
            fontsize (int): The font size to be set for the widget. Default is 6.
            columnCount (int): The number of columns to be displayed in the widget. Default is 2.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        logging.debug(&#39;init InteractiveListWidget&#39;)
        self.parent = parent #type: ignore
        super().__init__(rowCount=0, columnCount=columnCount) #type: ignore
        # self.horizontalHeader().setStretchLastSection(True)
        
        colWidth = 100
        # Set the minimum size for the table widget
        self.setColumnWidth(0, int(colWidth*.9)) #Slightly smaller to prevent scrollbar to appear
        self.setMinimumWidth(colWidth*columnCount) 
        # Set the size policy to ensure the widget can expand but not shrink below the minimum size
        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        
        font = QFont()
        font.setPointSize(fontsize)
        self.setFont(font)
        # Reduce padding within cells
        self.setStyleSheet(&#34;QTableWidget::item { padding: 1px; }&#34;)
        
        self.parentWidget=None #type:ignore
            
    def setColumNames(self, names):
        &#34;&#34;&#34;
        Set column names for the interactive list table.
        
        Args:
            names (list): A list of column names to be set.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.setColumnCount(len(names))
        self.setHorizontalHeaderLabels(names)
        
    def deleteSelected(self):
        &#34;&#34;&#34;
        Deletes selected rows from the table.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        selectedRows = sorted(set(index.row() for index in self.selectedIndexes()), reverse=True)
        for row in selectedRows:
            self.removeRow(row)

    def deleteAll(self):
        &#34;&#34;&#34;
        Deletes all rows in the table.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for row in range(self.rowCount() - 1, -1, -1):
            self.removeRow(row)

    def moveUp(self):
        &#34;&#34;&#34;
        Moves the current row up by swapping it with the row above.
        
            Args:
                None
        
            Returns:
                None
        &#34;&#34;&#34;
        row = self.currentRow()
        if row &gt; 0:
            self.swapRows(row, row - 1)
            
    def moveDown(self):
        &#34;&#34;&#34;
        Moves the current row down by swapping it with the row below.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        row = self.currentRow()
        if row &lt; self.rowCount() - 1 and row != -1:
            self.swapRows(row, row + 1)

    def moveToPos(self):
        &#34;&#34;&#34; 
        Move to the position specified by the current selected entry gridA
        &#34;&#34;&#34;
        currRow = self.currentRow()
        #get the info of the curRow:
        xpos_goto = float(self.item(currRow,2).text())
        ypos_goto = float(self.item(currRow,3).text())
        #Move the stage to this position
        logging.debug(f&#34;Moving stage {self.XYstageName()} to pos {xpos_goto},{ypos_goto}&#34;)
        self.parent.core.set_xy_position(self.XYstageName(),xpos_goto,ypos_goto)

    def getIDValues(self):
        &#34;&#34;&#34;
        Get the ID values from the second column of the table.
        
        Args:
            None
        
        Returns:
            list: A list of float values extracted from the second column of the table.
        &#34;&#34;&#34;
        id_values = []
        for row in range(self.rowCount()):
            item_id = self.takeItem(row, 1)
            if item_id:
                id_values.append(float(item_id.text()))
        return id_values

    def disconnectFunGUIConnection(self):
        self.itemChanged.disconnect()
    
    def reconnectFunGUIConnection(self,runOnce=True):
        self.itemChanged.connect(lambda: self.parent.get_MDA_events_from_GUI())
        if runOnce:
            self.parent.get_MDA_events_from_GUI()

class ChannelList(InteractiveListWidget):
    &#34;&#34;&#34;
    Creation of an interactive list widget, initially created for a nice channel list
    Extends InteractiveListWidget
    &#34;&#34;&#34;
    def __init__(self,parent=None):
        &#34;&#34;&#34;
        Initializes the channellist class within the given parent widget.
        
        Args:
            parent: The parent widget to set for the current instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(columnCount=3)
        self.channelName = &#39;&#39;
        self.parentWidget=parent #type:ignore
        
    def setChannelName(self, channelName):
        &#34;&#34;&#34;
        Set the name of the channel.
        
        Args:
            channelName: A string representing the name of the channel.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.channelName = channelName
        
    def swapRows(self, row1, row2):
        &#34;&#34;&#34;
        Swap rows in the table.
        
        Args:
            row1 (int): The index of the first row to swap.
            row2 (int): The index of the second row to swap.
        
        Returns:
            None
        &#34;&#34;&#34;
        for col in range(self.columnCount()):
            if col == 0:
                combobox1 = self.cellWidget(row1, col)
                combobox2 = self.cellWidget(row2, col)
                
                chosenEntry1 = combobox1.currentText()
                chosenEntry2 = combobox2.currentText()
                
                combobox1.setCurrentText(chosenEntry2)
                combobox2.setCurrentText(chosenEntry1)
            else:
                item1 = self.takeItem(row1, col)
                item2 = self.takeItem(row2, col)
                self.setItem(row1, col, item2)
                self.setItem(row2, col, item1)
        self.setCurrentCell(row2, 1)
        
    def addNewEntry(self,channelEntry=None,exposureEntry=None):
        &#34;&#34;&#34;
        Add a new entry to the table.
        
        Args:
            channelEntry (str): The channel entry to be added to the table.
            exposureEntry (str): The exposure entry to be added to the table.
        
        Returns:
            None
        &#34;&#34;&#34;
        #Add the current exposure time as text as textentry:
        if &#39;channelDropdown&#39; in dir(self.parentWidget):
            rowPosition = self.rowCount()
            self.insertRow(rowPosition)
            #Create a dropbox with two options:
            newdropbox = QComboBox()
            #Currently selected channel: self.parentWidget.channelDropdown.currentText()
            #Find the corresponding options:
            currentChannel = self.parentWidget.channelDropdown.currentText()
            nrConfigs = self.parentWidget.core.get_available_configs(currentChannel).size()
            for i in range(nrConfigs):
                newdropbox.addItem(self.parentWidget.core.get_available_configs(currentChannel).get(i))
            if channelEntry is not None:
                try:
                    newdropbox.setCurrentText(channelEntry)
                except:
                    logging.warning(&#39;Wrong mix of channel and entries&#39;)
                    pass
            self.setCellWidget(rowPosition, 0, newdropbox)
            # self.setItem(rowPosition, 1, QTableWidgetItem(textEntry))
            if exposureEntry == None:
                currentexposure = self.parentWidget.core.get_exposure()
                self.setItem(rowPosition, 1, QTableWidgetItem(str(currentexposure)))
            else:
                self.setItem(rowPosition, 1, QTableWidgetItem(exposureEntry))

class XYStageList(InteractiveListWidget):
    &#34;&#34;&#34;
    Creation of an interactive list widget, initially created for a nice XY list (similar to POS list in micromanager)
    Extends InteractiveListWidget
    &#34;&#34;&#34;
    def __init__(self,parent=None):
        &#34;&#34;&#34;
        Initializes the XY stage, only setting the name to empty
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent=parent,columnCount=4)
        self.XYstageName = &#39;&#39;
        
    def setXYStageName(self, XYstageName):
        &#34;&#34;&#34;
        Set the name of the XY stage.
        
        Args:
            XYstageName (str): The name of the XY stage to be set.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.XYstageName = XYstageName
    
    def getPositionsArray(self):
        &#34;&#34;&#34;
        Return an array of the positions for pycromanager to work with
        &#34;&#34;&#34;
        if self.rowCount() == 0:
            return None
        elif self.rowCount() &gt; 0:
            posArray = []
            for row in range(self.rowCount()):
                posArray.append([float(self.item(row, 2).text()),float(self.item(row, 3).text())])
            return posArray
    
    def getSaveInfoPositionsArray(self):
        &#34;&#34;&#34;
        Return an array of the positions for pycromanager to work with, with all info (i.e. name, id)
        &#34;&#34;&#34;
        if self.rowCount() == 0:
            return None
        elif self.rowCount() &gt; 0:
            infoArray = []
            for row in range(self.rowCount()):
                infoArray.append([self.item(row, 0).text(),self.item(row, 1).text(),self.item(row, 2).text(),self.item(row, 3).text()])
            return infoArray
    
    def swapRows(self, row1, row2):
        &#34;&#34;&#34;
        Swap rows in the table widget.
        
        Args:
            row1 (int): The index of the first row to swap.
            row2 (int): The index of the second row to swap.
        
        Returns:
            None
        &#34;&#34;&#34;
        for col in range(self.columnCount()):
            item1 = self.takeItem(row1, col)
            item2 = self.takeItem(row2, col)
            self.setItem(row1, col, item2)
            self.setItem(row2, col, item1)
        self.setCurrentCell(row2, 0)
        
    def addNewEntry(self,textEntry=&#34;New Entry&#34;,id=None,setxy:str|Iterable=&#34;Pos&#34;):
        &#34;&#34;&#34;
        Add a new entry to the table.
        
        Args:
            textEntry (str): The text entry to be added. Default is &#34;New Entry&#34;.
            id (int): The ID of the new entry. If not provided, it will be automatically generated based on existing IDs.
        
        Returns:
            None
        &#34;&#34;&#34;
        if id is None:
            if self.rowCount() == 0:
                id = 1
            else:
                try:
                    #add the new ID to be the max existing ID + 1
                    existing_ids = [int(self.item(row, 1).text()) for row in range(self.rowCount())]
                    id = max(existing_ids) + 1
                except:
                    id = self.rowCount() + 1
        rowPosition = self.rowCount()
        self.insertRow(rowPosition)
        self.setItem(rowPosition, 0, QTableWidgetItem(textEntry))
        self.setItem(rowPosition, 1, QTableWidgetItem(str(id)))
        if setxy == &#34;Pos&#34;:
            self.setItem(rowPosition, 2, QTableWidgetItem(str(self.parent.core.get_xy_stage_position().x)))
            self.setItem(rowPosition, 3, QTableWidgetItem(str(self.parent.core.get_xy_stage_position().y)))
        elif len(setxy) == 2: #type:ignore
            self.setItem(rowPosition, 2, QTableWidgetItem(str(setxy[0]))) #type:ignore
            self.setItem(rowPosition, 3, QTableWidgetItem(str(setxy[1]))) #type:ignore
#endregion

class MDAGlados(CustomMainWindow):
    &#34;&#34;&#34; 
    Class that handles the multi-Dimensional acquisition of Pycromanager
    &#34;&#34;&#34;
    #Pysignal should be outside the functions for proper init
    MDA_completed = pyqtSignal(bool)
    def __init__(self,core,MM_JSON,layout,
                shared_data,
                hasGUI=False,
                num_time_points: int | None = 10, 
                time_interval_s: float | List[float] = 0, 
                time_interval_s_or_ms: str = &#39;ms&#39;,
                z_start: float | None = 0, 
                z_end: float | None = 1, 
                z_step: float | None = None, 
                z_stage_sel : str | None = None,
                z_nr_steps: float | None = 2,
                z_step_distance: float | None = None,
                z_nrsteps_radio_sel: bool | None = None,
                z_stepdistance_radio_sel: bool | None = None,
                channel_group: str | None = None, 
                channels: list | None = None, 
                channel_exposures_ms: list | None = None, 
                xy_positions: Iterable | None = None, 
                xyz_positions: Iterable | None = None, 
                position_labels: List[str] | None = None, 
                order: str = &#39;tpcz&#39;, 
                exposure_ms: float | None = 90, 
                exposure_s_or_ms: str = &#39;ms&#39;,
                storage_folder: str | None = None,
                storage_file_name: str | None = None,
                GUI_show_exposure = True, 
                GUI_show_xy = True, 
                GUI_show_z = True, 
                GUI_show_channel = True, 
                GUI_show_time = True, 
                GUI_show_order = True, 
                GUI_show_storage = True, 
                GUI_acquire_button = True,
                GUI_xy_pos_fullInfo: Iterable | None = None,
                autoSaveLoad = False,
                parent=None,
                node = None):
        &#34;&#34;&#34;
        Initializes the MDAGlados class with the provided parameters.
        
        Args:
            core: Core object for communication with the microscope.
            MM_JSON: JSON object containing metadata.
            layout: Layout object for GUI layout.
            shared_data: Shared data object for communication between modules.
            hasGUI: Boolean indicating whether GUI should be displayed (default is False).
            num_time_points: Number of time points (default is 10).
            time_interval_s: Time interval in seconds between acquisitions (default is 0).
            z_start: Starting position of the Z-stack (default is None).
            z_end: Ending position of the Z-stack (default is None).
            z_step: Step size for Z-stack acquisition (default is None).
            z_stage_sel: Selected Z-stage for acquisition (default is None).
            z_nr_steps: Number of steps in the Z-stack (default is None).
            z_step_distance: Distance between Z-stack steps (default is None).
            z_nrsteps_radio_sel: Boolean indicating whether number of steps is selected (default is None).
            z_stepdistance_radio_sel: Boolean indicating whether step distance is selected (default is None).
            channel_group: Group of channels to acquire (default is None).
            channels: List of channels to acquire (default is None).
            channel_exposures_ms: List of exposure times for each channel in milliseconds (default is None).
            xy_positions: Iterable of XY positions to acquire (default is None).
            xyz_positions: Iterable of XYZ positions to acquire (default is None).
            position_labels: List of labels for positions (default is None).
            order: Order of acquisition (default is &#39;tpcz&#39;).
            exposure_ms: Exposure time in milliseconds (default is 90).
            storage_folder: Folder path for storing data (default is None).
            storage_file_name: Name of the storage file (default is None).
            GUI_show_exposure: Boolean indicating whether to show exposure settings in GUI (default is True).
            GUI_show_xy: Boolean indicating whether to show XY settings in GUI (default is True).
            GUI_show_z: Boolean indicating whether to show Z settings in GUI (default is True).
            GUI_show_channel: Boolean indicating whether to show channel settings in GUI (default is True).
            GUI_show_time: Boolean indicating whether to show time settings in GUI (default is True).
            GUI_show_order: Boolean indicating whether to show order settings in GUI (default is True).
            GUI_show_storage: Boolean indicating whether to show storage settings in GUI (default is True).
            GUI_acquire_button: Boolean indicating whether to show the acquisition button in GUI (default is True).
            GUI_xy_pos_fullInfo: Full info (including naming, id) of the XY position list
            autoSaveLoad: Boolean indicating whether to automatically save and load settings (default is False).
        
        Returns:
            None
        &#34;&#34;&#34;
        
        super().__init__()
        
        #If run as plugin, we need to specify the globals like this:
        if parent is not None:
            global livestate, napariViewer
            livestate = parent.livestate
            napariViewer = parent.napariViewer
        
        self.nodeInfo = node
        self.num_time_points = num_time_points
        self.time_interval_s = time_interval_s
        self.time_interval_s_or_ms = time_interval_s_or_ms
        self.z_start = z_start
        self.z_end = z_end
        self.z_step = z_step
        self.z_stage_sel = z_stage_sel
        self.z_nr_steps = z_nr_steps
        self.z_step_distance = z_step_distance
        self.z_nrsteps_radio_sel = z_nrsteps_radio_sel
        self.z_stepdistance_radio_sel = z_stepdistance_radio_sel
        self.channel_group = channel_group
        self.channels = channels
        self.channel_exposures_ms = channel_exposures_ms
        self.storage_folder = storage_folder
        self.storage_file_name = storage_file_name
        self.xy_positions = xy_positions
        self.xyz_positions = xyz_positions
        self.position_labels = position_labels
        self.order = order
        self.exposure_ms = exposure_ms
        self.exposure_s_or_ms = exposure_s_or_ms
        self.GUI_show_exposure = GUI_show_exposure
        self.GUI_show_xy = GUI_show_xy
        self.GUI_show_z = GUI_show_z
        self.GUI_show_channel = GUI_show_channel
        self.GUI_show_time = GUI_show_time
        self.GUI_show_order = GUI_show_order
        self.GUI_show_storage = GUI_show_storage
        self.GUI_xy_pos_fullInfo = GUI_xy_pos_fullInfo
        self.autoSaveLoad = autoSaveLoad
        
        self.GUI_exposure_enabled = GUI_show_exposure
        self.GUI_xy_enabled = GUI_show_xy
        self.GUI_z_enabled = GUI_show_z
        self.GUI_channel_enabled = GUI_show_channel
        self.GUI_time_enabled = GUI_show_time
        self.GUI_order_enabled = GUI_show_order
        self.GUI_storage_enabled = GUI_show_storage
        
        self.GUI_acquire_button = GUI_acquire_button
        self.has_GUI = False
        self.core = core
        self.mda_analysis_thread = None
        self.MM_JSON = MM_JSON
        self.layout = layout
        self.shared_data = shared_data
        self.gui = {}
        self.lastTimeUpdateSize = time.time()
        self._GUI_grid_width = None
        self.data = None
        
        self.fully_started = False
        
        #Initiate GUI if wanted
        if hasGUI:
            self.initGUI(GUI_show_exposure=self.GUI_show_exposure,GUI_show_xy=self.GUI_show_xy, GUI_show_z=self.GUI_show_z, GUI_show_channel=self.GUI_show_channel, GUI_show_time=self.GUI_show_time, GUI_show_order=self.GUI_show_order, GUI_show_storage=self.GUI_show_storage, GUI_acquire_button=self.GUI_acquire_button)
            self.has_GUI = True
        
        #initiate with an empty mda, or mda based on GUI:
        self.mda = multi_d_acquisition_events(num_time_points=self.num_time_points, time_interval_s=self.time_interval_s,z_start=self.z_start,z_end=self.z_end,z_step=self.z_step,channel_group=self.channel_group,channels=self.channels,channel_exposures_ms=self.channel_exposures_ms,xy_positions=self.xy_positions,xyz_positions=self.xyz_positions,position_labels=self.position_labels,order=self.order) #type:ignore
        
        self.fully_started = True
        #check if mda_state.json exists:
        # if os.path.isfile(&#39;mda_state.json&#39;):
        #     if self.autoSaveLoad:
        #         self.load_state(&#39;mda_state.json&#39;)
    
    #region properties
    @property
    def GUI_grid_width(self):
        &#34;&#34;&#34;
        Get the width of the GUI grid.
        
        Returns:
            int: The width of the GUI grid.
        &#34;&#34;&#34;
        
        return self._GUI_grid_width
    
    @GUI_grid_width.setter
    def GUI_grid_width(self, value):
        &#34;&#34;&#34;
        Updates the width of the GUI grid.
        
        Args:
            value: An integer representing the new width of the GUI grid.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        if value != self._GUI_grid_width:
            self._GUI_grid_width = value
            if self.has_GUI and self.fully_started:
                try:
                    logging.debug(f&#34;updating gui with nr of columns: {self._GUI_grid_width}&#34;)
                    self.showOptionChanged()
                except:
                    pass
    #endregion
    
    #region GUI
    def initGUI(self, GUI_show_exposure=True, GUI_show_xy = True, GUI_show_z=True, GUI_show_channel=True, GUI_show_time=True, GUI_show_order=True, GUI_show_storage=True, GUI_showOptions=True,GUI_acquire_button=True):
        &#34;&#34;&#34;
        Initiate the GUI.
        
        Args:
            GUI_show_exposure (bool): Whether to show the exposure widget. Default is True.
            GUI_show_xy (bool): Whether to show the XY widget. Default is True.
            GUI_show_z (bool): Whether to show the Z widget. Default is True.
            GUI_show_channel (bool): Whether to show the Channel widget. Default is True.
            GUI_show_time (bool): Whether to show the Time widget. Default is True.
            GUI_show_order (bool): Whether to show the Order widget. Default is True.
            GUI_show_storage (bool): Whether to show the Storage widget. Default is True.
            GUI_showOptions (bool): Whether to show the Options widget. Default is True.
            GUI_acquire_button (bool): Whether to show the Acquire button. Default is True.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        #initiate the GUI
        #Create a Vertical+horizontal layout:
        self.gui = QGridLayout()
        self.GUI_grid_width = 7
        
        # Add groupboxes for xy, z, channel, time, order, storage
        self.exposureGroupBox = QGroupBox(&#34;Exposure&#34;)
        self.xyGroupBox = QGroupBox(&#34;XY&#34;)
        self.zGroupBox = QGroupBox(&#34;Z&#34;)
        self.channelGroupBox = QGroupBox(&#34;Channel&#34;)
        self.timeGroupBox = QGroupBox(&#34;Time&#34;)
        self.storageGroupBox = QGroupBox(&#34;Storage&#34;)
        self.showOptionsGroupBox = QGroupBox(&#34;Options&#34;)

        # Create layouts for each groupbox
        exposureLayout=QHBoxLayout()
        xyLayout = QGridLayout()
        zLayout = QGridLayout()
        channelLayout = QGridLayout()
        timeLayout = QGridLayout()
        orderLayout = QVBoxLayout()
        storageLayout = QGridLayout()
        showOptionsLayout = QGridLayout()

        # Add widgets to each layout
        # --------------- Exposure widget -----------------------------------------------
        #Exposure: add a label, an entry field, and a dropdown between &#39;ms&#39; and &#39;s&#39;:
        self.exposureLabel = QLabel(&#34;Exposure:&#34;)
        self.exposureEntry = QLineEdit()
        if self.exposure_ms is not None:
            if self.exposure_s_or_ms == &#39;ms&#39;:
                self.exposureEntry.setText(str(self.exposure_ms))
            elif self.exposure_s_or_ms == &#39;s&#39;:
                self.exposureEntry.setText(str(self.exposure_ms/1000))
        #ensure thatexposureEntry can only be a float:
        self.exposureEntry.setValidator(QDoubleValidator())
        self.exposureDropdown = QComboBox()
        self.exposureDropdown.addItem(&#34;ms&#34;)
        self.exposureDropdown.addItem(&#34;s&#34;)
        self.exposureDropdown.setCurrentText(self.exposure_s_or_ms)
        exposureLayout.addWidget(self.exposureLabel)
        exposureLayout.addWidget(self.exposureEntry)
        exposureLayout.addWidget(self.exposureDropdown)
        #run get_MDA_events_from_GUI when the text or dropdown is changed:
        self.exposureEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.exposureDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- Time widget -----------------------------------------------
        #Time: add labels for time points and time intervals, and integer-based entry fields:
        self.timePointLabel = QLabel(&#34;Number time points:&#34;)
        self.timePointEntry = QLineEdit()
        if self.num_time_points is not None:
            self.timePointEntry.setText(str(self.num_time_points))
        self.timePointEntry.setValidator(QIntValidator())
        self.timeIntervalLabel = QLabel(&#34;Time interval:&#34;)
        self.timeIntervalEntry = QLineEdit()
        if self.time_interval_s is not None:
            if self.time_interval_s_or_ms == &#39;s&#39;:
                self.timeIntervalEntry.setText(str(self.time_interval_s))
            elif self.time_interval_s_or_ms == &#39;ms&#39;:
                self.timeIntervalEntry.setText(str(self.time_interval_s*1000))
        self.timeIntervalEntry.setValidator(QDoubleValidator())
        self.timeIntervalDropdown = QComboBox()
        self.timeIntervalDropdown.addItem(&#34;ms&#34;)
        self.timeIntervalDropdown.addItem(&#34;s&#34;)
        self.timeIntervalDropdown.setCurrentText(self.time_interval_s_or_ms)
        #Adding widgets to layout
        timeLayout.addWidget(self.timePointLabel,0,0)
        timeLayout.addWidget(self.timePointEntry,0,1)
        timeLayout.addWidget(self.timeIntervalLabel,1,0)
        timeLayout.addWidget(self.timeIntervalEntry,1,1)
        timeLayout.addWidget(self.timeIntervalDropdown,1,2)
        #run get_MDA_events_from_GUI when the text or dropdown is changed:
        self.timePointEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.timeIntervalEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.timeIntervalDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- storage widget -----------------------------------------------
        #storage: first, add a label, entry field, and button with &#39;...&#39; to select a folder of choice:
        self.storageFolderLabel = QLabel(&#34;Storage:&#34;)
        self.storageFolderEntry = QLineEdit()
        if self.storage_folder is not None:
            self.storageFolderEntry.setText(self.storage_folder)
        self.storageFolderButton = QPushButton(&#39;...&#39;)
        #add a lambda function when this is pressed to search for a folder:
        self.storageFolderButton.clicked.connect(lambda: self.storageFolderEntry.setText(QFileDialog.getExistingDirectory()))
        #Then add a label and entry field for the file name:
        self.storageFileNameLabel = QLabel(&#34;File name:&#34;)
        self.storageFileNameEntry = QLineEdit()
        if self.storage_file_name is not None:
            self.storageFileNameEntry.setText(self.storage_file_name)
        #Adding widgets to layout
        storageLayout.addWidget(self.storageFolderLabel,0,0)
        storageLayout.addWidget(self.storageFolderEntry,0,1)
        storageLayout.addWidget(self.storageFolderButton,0,2)
        storageLayout.addWidget(self.storageFileNameLabel,1,0)
        storageLayout.addWidget(self.storageFileNameEntry,1,1)
        self.storageFolderEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.storageFileNameEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- XY widget widget -----------------------------------------------
        #First a dropdown to select the xy stage:
        
        #Adding a list widget to add a list of xy positions
        self.xypositionListWidget = XYStageList(parent=self)
        self.xypositionListWidget.setColumNames([&#34;Name&#34;, &#34;ID&#34;,&#34;xPos&#34;,&#34;yPos&#34;])
        self.xypositionListWidget.setColumnWidth(0, 60)
        self.xypositionListWidget.setColumnWidth(1, 40)
        
        self.xy_stagesDropdownLabel = QLabel(&#34;XY Stage:&#34;)
        self.xy_stagesDropdown = QComboBox()
        XYstages = self.getDevicesOfDeviceType(&#39;XYStageDevice&#39;)
        #add the options to the dropdown:
        for stage in XYstages:
            self.xy_stagesDropdown.addItem(stage)
        #Add a callback if we change this dropdown:
        self.xy_stagesDropdown.currentIndexChanged.connect(lambda: self.xypositionListWidget.setXYStageName(self.xy_stagesDropdown.currentText()))
        
        #Initisalise the XY position list
        self.xypositionListWidget.setXYStageName(self.xy_stagesDropdown.currentText)
        #Buttons for the xy position list
        self.xypositionListWidget_deleteButton = QPushButton(&#39;Delete Selected&#39;)
        self.xypositionListWidget_deleteAllButton = QPushButton(&#39;Delete All&#39;)
        self.xypositionListWidget_moveUpButton = QPushButton(&#39;Move Up&#39;)
        self.xypositionListWidget_moveDownButton = QPushButton(&#39;Move Down&#39;)
        self.xypositionListWidget_moveToButton = QPushButton(&#39;Move to Pos&#39;)
        self.xypositionListWidget_addButton = QPushButton(&#39;Add New Entry&#39;)
        #Intialise a gridManager
        self.xypositionListWidget_XYGridManager = utils.XYGridManager(core=self.core,parent=self)
        self.xypositionListWidget_createGridButton = QPushButton(&#39;Create Grid&#39;)
        #Adding callbacks to the xy position list buttons
        self.xypositionListWidget_deleteButton.clicked.connect(self.xypositionListWidget.deleteSelected)
        self.xypositionListWidget_deleteAllButton.clicked.connect(self.xypositionListWidget.deleteAll)
        self.xypositionListWidget_moveUpButton.clicked.connect(self.xypositionListWidget.moveUp)
        self.xypositionListWidget_moveDownButton.clicked.connect(self.xypositionListWidget.moveDown)
        self.xypositionListWidget_moveToButton.clicked.connect(self.xypositionListWidget.moveToPos)
        self.xypositionListWidget_addButton.clicked.connect(lambda: self.xypositionListWidget.addNewEntry(textEntry=&#34;Your Text Entry&#34;))
        
        #Open the GridManager GUI
        self.xypositionListWidget_createGridButton.clicked.connect(lambda: self.xypositionListWidget_XYGridManager.openGUI())

        #Adding widgets to layout
        xyLayout.addWidget(self.xy_stagesDropdownLabel,0,0)
        xyLayout.addWidget(self.xy_stagesDropdown,0,1)
        xyLayout.addWidget(self.xypositionListWidget,1,0,12,1)
        xyLayout.addWidget(self.xypositionListWidget_deleteButton,2,1)
        xyLayout.addWidget(self.xypositionListWidget_deleteAllButton,3,1)
        xyLayout.addWidget(self.xypositionListWidget_moveUpButton,4,1)
        xyLayout.addWidget(self.xypositionListWidget_moveDownButton,5,1)
        xyLayout.addWidget(self.xypositionListWidget_moveToButton,6,1)
        xyLayout.addWidget(self.xypositionListWidget_addButton,7,1)
        xyLayout.addWidget(self.xypositionListWidget_createGridButton,8,1)
        
        #Pre-load entries if they exist:
        if self.GUI_xy_pos_fullInfo != None:
            for entry in self.GUI_xy_pos_fullInfo:
                self.xypositionListWidget.addNewEntry(textEntry=entry[0],id=int(entry[1]),setxy=[float(entry[2]),float(entry[3])])
        
        #Add a callback lambda
        self.xypositionListWidget.itemChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- Z widget widget -----------------------------------------------
        #First a dropdown to select the 1d stage:
        self.z_oneDstageDropdownLabel = QLabel(&#34;Z Stage:&#34;)
        self.z_oneDstageDropdown = QComboBox()
        oneDstages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        #add the options to the dropdown:
        for stage in oneDstages:
            self.z_oneDstageDropdown.addItem(stage)
        if self.z_stage_sel is not None:
            if self.z_stage_sel in oneDstages:
                self.z_oneDstageDropdown.setCurrentText(self.z_stage_sel)
        #Create all other buttons/lineedits
        self.z_startLabel = QLabel(&#34;Start:&#34;)
        self.z_startEntry = QLineEdit()
        if self.z_start is not None:
            self.z_startEntry.setText(str(self.z_start))
        self.z_startEntry.setValidator(QDoubleValidator())
        self.z_startSetButton = QPushButton(&#39;Set&#39;)
        self.z_startSetButton.clicked.connect(lambda: self.setZStart())
        self.z_endLabel = QLabel(&#34;End:&#34;)
        self.z_endEntry = QLineEdit()
        if self.z_end is not None:
            self.z_endEntry.setText(str(self.z_end))
        self.z_endEntry.setValidator(QDoubleValidator())
        self.z_endSetButton = QPushButton(&#39;Set&#39;)
        self.z_endSetButton.clicked.connect(lambda: self.setZEnd())
        
        #add radio buttons:
        self.z_nrsteps_radio= QRadioButton(&#34;Number of steps: &#34;)
        self.z_stepdistance_radio= QRadioButton(&#34;Step distance: &#34;)
        #preselect the nr of steps one:
        if self.z_nrsteps_radio_sel == True:
            self.z_nrsteps_radio.setChecked(True)
        elif self.z_stepdistance_radio_sel == True:
            self.z_stepdistance_radio.setChecked(True)
        else:
            self.z_nrsteps_radio.setChecked(True)
        #add edit boxes for number of steps and step distance:
        self.z_nrsteps_entry = QLineEdit()
        if self.z_nr_steps is not None:
            self.z_nrsteps_entry.setText(str(self.z_nr_steps))
        self.z_nrsteps_entry.setValidator(QIntValidator())
        self.z_stepdistance_entry = QLineEdit()
        if self.z_step_distance is not None:
            self.z_stepdistance_entry.setText(str(self.z_step_distance))
        self.z_stepdistance_entry.setValidator(QDoubleValidator())
        
        #Add all widgets to layout
        zLayout.addWidget(self.z_oneDstageDropdownLabel,0,0)
        zLayout.addWidget(self.z_oneDstageDropdown,0,1)
        zLayout.addWidget(self.z_startLabel,1,0)
        zLayout.addWidget(self.z_startEntry,1,1)
        zLayout.addWidget(self.z_startSetButton,1,2)
        zLayout.addWidget(self.z_endLabel,2,0)
        zLayout.addWidget(self.z_endEntry,2,1)
        zLayout.addWidget(self.z_endSetButton,2,2)
        zLayout.addWidget(self.z_nrsteps_radio,3,0)
        zLayout.addWidget(self.z_nrsteps_entry,3,1)
        zLayout.addWidget(self.z_stepdistance_radio,4,0)
        zLayout.addWidget(self.z_stepdistance_entry,4,1)
        
        #run get_MDA_events_from_GUI when the text or dropdown is changed:
        self.z_oneDstageDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_startEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_endEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_nrsteps_radio.toggled.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_stepdistance_radio.toggled.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_nrsteps_entry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_stepdistance_entry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())

        # --- Ordering widget ---
        #Note: only used in updateGUIwidgets
        
        #--------------- Channel widget -----------------------------------------------
        #Adding a list widget to add a list of channels
        self.channelListWidget = ChannelList(parent=self)
        self.channelListWidget.setColumNames([&#34;Channel Setting&#34;, &#34;Exposure&#34;])
        
        #Add possible channels
        self.channelDropdownLabel = QLabel(&#34;Channel:&#34;)
        self.channelDropdown = QComboBox()
        
        #Figure out from all config groups which ones are &#34;dropdown&#34;
        nrconfiggroups = self.core.get_available_config_groups().size()
        allConfigGroups={}
        for config_group_id in range(nrconfiggroups):
            allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
        comboboxindexes = []
        for config_group_id in range(nrconfiggroups):
            if allConfigGroups[config_group_id].isDropDown():
                comboboxindexes.append(config_group_id)
        ComboBoxes = {key: allConfigGroups[key] for key in comboboxindexes}
        ComboBoxNames = {allConfigGroups[key].configGroupName() for key in comboboxindexes}
        
        #add the options to the dropdown:
        for combobox in ComboBoxes:
            self.channelDropdown.addItem(allConfigGroups[combobox].configGroupName())
        #Add a callback if we change this dropdown:
        self.channelDropdown.currentIndexChanged.connect(lambda: self.channelListWidget.setChannelName(self.channelDropdown.currentText()))
        #Also delete all the current entries
        self.channelDropdown.currentIndexChanged.connect(lambda: self.channelListWidget.deleteAll())
        
        #Initisalise the channel  list
        self.channelListWidget.setChannelName(self.channelDropdown.currentText)
        
        
        #Buttons for the channel position list
        self.channelListWidget_deleteButton = QPushButton(&#39;Delete Selected&#39;)
        self.channelListWidget_moveUpButton = QPushButton(&#39;Move Up&#39;)
        self.channelListWidget_moveDownButton = QPushButton(&#39;Move Down&#39;)
        self.channelListWidget_addButton = QPushButton(&#39;Add New Entry&#39;)
        self.channelListWidget_deleteAllButton = QPushButton(&#39;Delete All&#39;)
        #Adding callbacks to the channel list buttons
        self.channelListWidget_deleteButton.clicked.connect(self.channelListWidget.deleteSelected)
        self.channelListWidget_deleteAllButton.clicked.connect(self.channelListWidget.deleteAll)
        self.channelListWidget_moveUpButton.clicked.connect(self.channelListWidget.moveUp)
        self.channelListWidget_moveDownButton.clicked.connect(self.channelListWidget.moveDown)
        self.channelListWidget_addButton.clicked.connect(lambda: self.channelListWidget.addNewEntry())

        #Adding widgets to layout
        channelLayout.addWidget(self.channelDropdownLabel,0,0)
        channelLayout.addWidget(self.channelDropdown,0,1)
        channelLayout.addWidget(self.channelListWidget,1,0,6,1)
        channelLayout.addWidget(self.channelListWidget_deleteButton,2,1)
        channelLayout.addWidget(self.channelListWidget_moveUpButton,3,1)
        channelLayout.addWidget(self.channelListWidget_moveDownButton,4,1)
        channelLayout.addWidget(self.channelListWidget_addButton,5,1)
        channelLayout.addWidget(self.channelListWidget_deleteAllButton,6,1)

        #Add the pre-set channels:
        if self.channel_group in ComboBoxNames:
            if self.channel_group is not None:
                self.channelDropdown.setCurrentText(self.channel_group)
        if self.channels is not None and self.channel_exposures_ms is not None:
            for entry in range(len(self.channels)):
                self.channelListWidget.addNewEntry(channelEntry=self.channels[entry],exposureEntry=str(self.channel_exposures_ms[entry]))
                
        #Change MDA events when adapted
        self.channelListWidget.itemChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- Show options widget -----------------------------------------------
        #This should have checkboxes for exposure, xy, z, channel, time, order, storage. If these checkboxes are clicked, the GUI should be updated accordingly:
        self.GUI_show_exposure_chkbox = QCheckBox(&#34;Exposure&#34;) #Note: created but never rendered
        self.GUI_show_xy_chkbox = QCheckBox(&#34;XY&#34;)
        self.GUI_show_z_chkbox = QCheckBox(&#34;Z&#34;)
        self.GUI_show_channel_chkbox = QCheckBox(&#34;Channel&#34;)
        self.GUI_show_time_chkbox = QCheckBox(&#34;Time&#34;)
        self.GUI_show_storage_chkbox = QCheckBox(&#34;Storage&#34;)
        #initialise the checkboxes based on the values in this GUI:
        self.GUI_show_exposure_chkbox.setChecked(self.GUI_show_exposure) #Note: created but never rendered
        self.GUI_show_xy_chkbox.setChecked(self.GUI_show_xy)
        self.GUI_show_z_chkbox.setChecked(self.GUI_show_z)
        self.GUI_show_channel_chkbox.setChecked(self.GUI_show_channel)
        self.GUI_show_time_chkbox.setChecked(self.GUI_show_time)
        self.GUI_show_storage_chkbox.setChecked(self.GUI_show_storage)
        #Add lambda functions to all of them that all run the same function: showOptionChanged():
        # self.GUI_show_exposure_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_xy_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_z_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_channel_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_time_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_storage_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        
        font = QFont()
        font.setPointSize(7)  # Set the desired font size

        [checkbox.setFont(font) for checkbox in [self.GUI_show_exposure_chkbox, self.GUI_show_xy_chkbox, self.GUI_show_z_chkbox, self.GUI_show_channel_chkbox, self.GUI_show_time_chkbox, self.GUI_show_storage_chkbox]]

        #Add all checkboxes to the options-layout
        # showOptionsLayout.addWidget(self.GUI_show_exposure_chkbox,0,0)
        showOptionsLayout.addWidget(self.GUI_show_time_chkbox,0,0)
        showOptionsLayout.addWidget(self.GUI_show_xy_chkbox,0,1)
        showOptionsLayout.addWidget(self.GUI_show_z_chkbox,0,2)
        showOptionsLayout.addWidget(self.GUI_show_channel_chkbox,1,0)
        showOptionsLayout.addWidget(self.GUI_show_storage_chkbox,1,1)
        
        # ---------- Combining all to the main layout -----------------------------------------
        # Set layouts for each groupbox
        self.exposureGroupBox.setLayout(exposureLayout)
        self.xyGroupBox.setLayout(xyLayout)
        self.zGroupBox.setLayout(zLayout)
        self.channelGroupBox.setLayout(channelLayout)
        self.timeGroupBox.setLayout(timeLayout)
        self.storageGroupBox.setLayout(storageLayout)
        self.showOptionsGroupBox.setLayout(showOptionsLayout)

        # Add groupboxes to the main layout, only if they should be shown. The position of the gridbox is based on whether the previous ones are added or not:
        self.updateGUIwidgets(GUI_show_exposure=GUI_show_exposure,GUI_show_xy=GUI_show_xy, GUI_show_z=GUI_show_z, GUI_show_channel=GUI_show_channel, GUI_show_time=GUI_show_time, GUI_show_storage=GUI_show_storage,GUI_showOptions=GUI_showOptions,GUI_acquire_button=GUI_acquire_button)
        
        #Change the font of everything in the layout
        self.set_font_and_margins_recursive(self.gui, font=QFont(&#34;Arial&#34;, 7))
        #Twice because it relies on dependancies inside qgridlayouts
        self.set_font_and_margins_recursive(self.gui, font=QFont(&#34;Arial&#34;, 7))
        
        if self.layout is not None:
            #Add the layout to the main layout
            try:
                self.layout.addLayout(self.gui,0,0)
            except:
                self.setLayout(self.gui)
                self.mainLayout = self.gui
            
            # Changing font and padding of all widgets
            font = QFont(&#34;Arial&#34;, 7)
            for i in range(self.gui.count()):
                try:
                    item = self.gui.itemAt(i)
                    if item.widget():
                        item.widget().setFont(font)
                        item.widget().setStyleSheet(&#34;padding: 2px; margin: 1px; spacing: 1px;&#34;)  # Change padding as needed
                except:
                    pass
    
    def handleSizeChange(self, size):
        &#34;&#34;&#34;
        Handle a change in size by adjusting the number of columns in the GUI grid.
        
        Args:
            size: The new size of the GUI window.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        newNrColumns = max(1,min(10, size.width() // 150))
        self.GUI_grid_width = newNrColumns
    
    def getDevicesOfDeviceType(self,devicetype):
        &#34;&#34;&#34;
        Find all devices that have a specific devicetype.
        
        Args:
            devicetype (str): The type of device to search for. Refer to https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html for all devicetypes.
        
        Returns:
            list: A list of devices that match the specified devicetype.
        &#34;&#34;&#34;
        
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        #Get devices
        devices = self.core.get_loaded_devices()
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.core.get_device_type(device).to_string() == devicetype:
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType
    
    def createOrderLayout(self,GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice = None):
        &#34;&#34;&#34;
        Create an order (&#39;t&#39;,&#39;tc&#39;, etc) layout based on the provided parameters.
        
        Args:
            GUI_show_channel (bool): Whether to include channel in the layout.
            GUI_show_time (bool): Whether to include time in the layout.
            GUI_show_xy (bool): Whether to include xy in the layout.
            GUI_show_z (bool): Whether to include z in the layout.
            orderChoice (str, optional): The default order choice. Defaults to None.
        
        Returns:
            QVBoxLayout: The layout containing the order dropdown and label.
        &#34;&#34;&#34;
        
        orderLayout = QVBoxLayout()
        letters_to_include = &#39;&#39;
        if GUI_show_channel:
            letters_to_include += &#39;c&#39;
        if GUI_show_time:
            letters_to_include += &#39;t&#39;
        if GUI_show_xy:
            letters_to_include += &#39;p&#39;
        if GUI_show_z:
            letters_to_include += &#39;z&#39;
        #Now we create an array with all possible combinations of these letters:
        permuatations = [&#39;&#39;.join(comb) for comb in itertools.permutations(letters_to_include, len(letters_to_include))]
        self.orderDropdown = QComboBox()
        self.orderDropdown.currentTextChanged.connect(lambda: self.get_MDA_events_from_GUI())
        #add the options to the dropdown:
        for option in permuatations:
            self.orderDropdown.addItem(option)
        #Create a label:
        self.orderLabel = QLabel(&#34;Order:&#34;)
        
        #Show the widgets.
        orderLayout.addWidget(self.orderLabel)
        orderLayout.addWidget(self.orderDropdown)
        
        if orderChoice in permuatations:
            if orderChoice is not None:
                self.orderDropdown.setCurrentText(orderChoice)
        
        return orderLayout
        
    def showOptionChanged(self):
        &#34;&#34;&#34;
        Updates the GUI widgets based on the checkbox values.
        
        This function will be called when the checkboxes are clicked. It will update the GUI accordingly.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.setAllCheckBoxEnableValues()
        #This function will be called when the checkboxes are clicked. It will update the GUI accordingly:
        self.updateGUIwidgets(GUI_show_exposure=self.GUI_show_exposure_chkbox.isChecked(), GUI_show_xy = self.GUI_show_xy_chkbox.isChecked(), GUI_show_z=self.GUI_show_z_chkbox.isChecked(), GUI_show_channel=self.GUI_show_channel_chkbox.isChecked(), GUI_show_time=self.GUI_show_time_chkbox.isChecked(), GUI_show_storage=self.GUI_show_storage_chkbox.isChecked(),GUI_showOptions=True,GUI_acquire_button=self.GUI_acquire_button)
        self.get_MDA_events_from_GUI()
    
    def setAllCheckBoxEnableValues(self):
        &#34;&#34;&#34;
        Set the enable values for all the checkboxes.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.GUI_exposure_enabled = self.GUI_show_exposure_chkbox.isChecked()
        self.GUI_xy_enabled = self.GUI_show_xy_chkbox.isChecked()
        self.GUI_z_enabled = self.GUI_show_z_chkbox.isChecked()
        self.GUI_channel_enabled = self.GUI_show_channel_chkbox.isChecked()
        self.GUI_time_enabled = self.GUI_show_time_chkbox.isChecked()
        self.GUI_storage_enabled = self.GUI_show_storage_chkbox.isChecked()
        self.GUI_show_exposure = self.GUI_show_exposure_chkbox.isChecked()
        self.GUI_show_xy = self.GUI_show_xy_chkbox.isChecked()
        self.GUI_show_z = self.GUI_show_z_chkbox.isChecked()
        self.GUI_show_channel = self.GUI_show_channel_chkbox.isChecked()
        self.GUI_show_time = self.GUI_show_time_chkbox.isChecked()
        self.GUI_show_storage = self.GUI_show_storage_chkbox.isChecked()
    
    def updateGUIwidgets(self,GUI_show_exposure=True, GUI_show_xy = False, GUI_show_z=True, GUI_show_channel=False, GUI_show_time=True, GUI_show_storage=True,GUI_showOptions=True,gridWidth=4,GUI_acquire_button=True):
        &#34;&#34;&#34;
        Updates the GUI widgets based on the specified parameters.
        
        Args:
            GUI_show_exposure (bool): Whether to show the exposure widget. Default is True.
            GUI_show_xy (bool): Whether to show the XY widget. Default is False.
            GUI_show_z (bool): Whether to show the Z widget. Default is True.
            GUI_show_channel (bool): Whether to show the channel widget. Default is False.
            GUI_show_time (bool): Whether to show the time widget. Default is True.
            GUI_show_storage (bool): Whether to show the storage widget. Default is True.
            GUI_showOptions (bool): Whether to show the options widget. Default is True.
            gridWidth (int): The width of the grid. Default is 4.
            GUI_acquire_button (bool): Whether to show the acquire button. Default is True.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        gridWidth = self.GUI_grid_width
        # Remove the widgets from their parent
        self.exposureGroupBox.setParent(None) # type: ignore
        self.xyGroupBox.setParent(None) # type: ignore
        self.zGroupBox.setParent(None) # type: ignore
        self.channelGroupBox.setParent(None) # type: ignore
        self.timeGroupBox.setParent(None) # type: ignore
        # # self.orderGroupBox.setParent(None) # type: ignore
        self.storageGroupBox.setParent(None) # type: ignore
        self.showOptionsGroupBox.setParent(None)  # type: ignore


        # Clear the layout - this is required
        while self.gui.count(): # type: ignore
            item = self.gui.takeAt(0) # type: ignore
            widget = item.widget()
            if widget:
                widget.deleteLater()
        #redraw the self.gui:
        self.gui.update()
        QCoreApplication.processEvents()
        
        # At the beginning add an options groupbox, which has all the checkboxes and storage/acquire
        optionsBGroupBox = QWidget()
        optionsBLayout = QVBoxLayout()
        optionsBGroupBox.setLayout(optionsBLayout)
        optionsBLayout.addWidget(self.showOptionsGroupBox) # type: ignore
        self.showOptionsGroupBox.setEnabled(True)
        optionsBLayout.addWidget(self.storageGroupBox) # type: ignore
        if GUI_show_storage: 
            self.storageGroupBox.setEnabled(True)
        else:
            self.storageGroupBox.setEnabled(False)
        self.GUI_acquire_button = QPushButton(&#34;Acquire&#34;)
        self.GUI_acquire_button.clicked.connect(lambda index: self.MDA_acq_from_GUI(mdaLayerName=&#39;MDA&#39;))
        optionsBLayout.addWidget(self.GUI_acquire_button) # type: ignore
        if GUI_acquire_button:
            self.GUI_acquire_button.setEnabled(True)
        else:
            self.GUI_acquire_button.setEnabled(False)
        
        self.gui.addWidget(optionsBGroupBox, 0, 0) # type: ignore
        
        #Add order/exposure/time as single groupbox
        orderexposuretimegroupbox = QWidget()
        orderexposuretimelayout = QVBoxLayout()
        orderexposuretimegroupbox.setLayout(orderexposuretimelayout)
        
        if GUI_show_exposure:
            self.exposureGroupBox.setEnabled(True)
        else:
            self.exposureGroupBox.setEnabled(False)
            
        self.orderGroupBox = QGroupBox(&#34;Order&#34;)
        orderlayout = self.createOrderLayout(GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice=self.order)
        self.orderGroupBox.setLayout(orderlayout)
        
        orderexposuretimelayout.addWidget(self.orderGroupBox) # type: ignore
        orderexposuretimelayout.addWidget(self.exposureGroupBox) # type: ignore
        orderexposuretimelayout.addWidget(self.timeGroupBox) # type: ignore
        if GUI_show_time:
            self.timeGroupBox.setEnabled(True)
        else:
            self.timeGroupBox.setEnabled(False)
        #     # QCoreApplication.processEvents()
        self.gui.addWidget(orderexposuretimegroupbox, 1//gridWidth, 1%gridWidth) # type: ignore
        
        #Add XY, Z, Channel, groupboxes as individual groupboxes
        curindex = 2
        self.gui.addWidget(self.xyGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
        curindex+=1
        if GUI_show_xy:
            self.xyGroupBox.setEnabled(True)
        else:
            self.xyGroupBox.setEnabled(False)
            # QCoreApplication.processEvents()
        self.gui.addWidget(self.zGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
        curindex+=1
        if GUI_show_z:
            self.zGroupBox.setEnabled(True)
        else:
            self.zGroupBox.setEnabled(False)
            # QCoreApplication.processEvents()
        self.gui.addWidget(self.channelGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
        curindex+=1
        if GUI_show_channel:
            self.channelGroupBox.setEnabled(True)
        else:
            self.channelGroupBox.setEnabled(False)
            # QCoreApplication.processEvents()
        
        
        self.gui.setColumnStretch(99,gridWidth+1) # type: ignore
        self.gui.setRowStretch(99,gridWidth+1) # type: ignore
        
        #try to trigger a dock widget resize event at this point.
        mdawidget_object = self.gui.parent() #type:ignore
        try:
            logging.debug(&#39;attempting to update parent&#39;)
            from PyQt5.QtCore import QEvent
            current_size = mdawidget_object.size() #type:ignore
            resize_event = QEvent(QEvent.Resize) #type:ignore
            resize_event.oldSize = lambda: current_size #type:ignore
            resize_event.size = lambda: current_size #type:ignore
            QApplication.sendEvent(mdawidget_object, resize_event)
        except:
            logging.debug(&#39;did not attempt to update parent&#39;)
        
        
        QCoreApplication.processEvents()
        
        #redraw the self.gui:
        self.gui.update()
    
    def printText(self):
        &#34;&#34;&#34;
        Prints the events obtained from the getEvents method.
        
        Args:
            self: The object instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.info(self.getEvents())
    
    def getEvents(self):
        &#34;&#34;&#34;
        Get the MDA events from the object.
        
        Returns:
            The MDA events stored in the object.
        &#34;&#34;&#34;
        return self.mda
    
    def getGui(self):
        &#34;&#34;&#34;
        Returns the GUI object.
        
        Args:
            None
        
        Returns:
            The GUI object.
        &#34;&#34;&#34;
        return self
    
    def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
        &#34;&#34;&#34;
        Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
        Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.

        &#34;&#34;&#34;
        
        if isinstance(widget, (QPushButton)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)
        if isinstance(widget, (QLabel, QComboBox)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)

        if isinstance(widget, QGroupBox):
            widget.setSizePolicy(
                QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            )
            # Ensure QGroupBox respects the size of its contents
            widget.setMinimumSize(widget.minimumSizeHint())  # Set the minimum size of QGroupBox based on its size hint

        try:
            minsize = widget.minimumSizeHint()
            if minsize[0] &gt; -1 and minsize[1] &gt; -1:
                widget.setMinimumSize(widget.minimumSizeHint())
        except:
            pass

        if hasattr(widget, &#39;layout&#39;):
            layout = widget.layout()
            if layout:
                # layout.setContentsMargins(0, 0, 0, 0)
                # layout.setSpacing(0)  # Optionally, remove spacing between widgets
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if hasattr(item, &#39;widget&#39;):
                        self.set_font_and_margins_recursive(item.widget(), font=font)
                    if hasattr(item, &#39;layout&#39;):
                        self.set_font_and_margins_recursive(item.layout(), font=font)
    
    #endregion
    
    #region Multi-D acquisition logic
    def MDA_acq_finished(self):
        &#34;&#34;&#34;
        Signal that MDA acquisition has finished.
        
        Disconnects the signal, stores the acquired data, and updates the status of connected nodes in the nodz-coupled visualization and real-time analysis.
        
        Args:
            self: The object instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.shared_data.mda_acq_done_signal.disconnect(self.MDA_acq_finished)
        self.data = self.shared_data.mdaDatasets[-1]
        
        logging.info(&#39;MDA acq data finished and data stored!&#39;)
        self.shared_data._mdaMode = False
        
        #Remove any existing nodz-coupled real-time analyses:
        if &#39;nodz_analysis_threads&#39; in vars(self):
            for analysis_thread in self.nodz_analysis_threads:
                analysis_thread.stop()
        
        #Set the status of the nodz-coupled vis and real-time to finished, and add nodz-based variables:
        if &#39;nodeInfo&#39; in vars(self) and self.nodeInfo is not None:
            logging.debug(&#39;This MDA acq data was connected to node: &#39; + self.nodeInfo.name)
            self.updateNodzVariables()
            self.nodeInfo.status=&#39;finished&#39;
            self.nodeInfo.flowChart.update()

        #Look at the &#39;Visual&#39; bottom attribute:
            visualAttr = self.nodeInfo.bottomAttrs[&#39;Visual&#39;]
            if len(visualAttr.connections) &gt; 0:
                visual_connected_node_name = visualAttr.connections[0].socketNode
                for node in self.nodeInfo.flowChart.nodes:
                    if node.name == visual_connected_node_name:
                        visual_connected_node = node
                        visual_connected_node.status = &#39;finished&#39;
            
            #Look at the &#39;Real-time&#39; bottom attribute:
            RealTimeAttr = self.nodeInfo.bottomAttrs[&#39;Real-time&#39;]
            if len(RealTimeAttr.connections) &gt; 0:
                self.nodz_analysis_threads = []
                rt_analysis_connected_node_name = RealTimeAttr.connections[0].socketNode
                for node in self.nodeInfo.flowChart.nodes:
                    if node.name == rt_analysis_connected_node_name:
                        rt_analysis_connected_node = node
                        rt_analysis_connected_node.status = &#39;finished&#39;
        
        #reset the MDA button in the GUI
        self.resetMDAbutton(mdaLayerName=&#39;MDA&#39;)
        logging.debug(&#39;about to emit MDA_completed&#39;)
        self.MDA_completed.emit(True)
    
    def MDA_acq_from_Node(self, nodeInfo):
        &#34;&#34;&#34;MDA_acq_from_Node(self, nodeInfo)
        
        Basically the same as MDA_from_GUI, but with the NodeInfo.
        
        Args:
            self: The object itself.
            nodeInfo: Information about the node.
        
        Returns:
            None
        
        Raises:
            None
        
        This function acquires data from a node and performs various operations based on the node information provided.
        &#34;&#34;&#34;
        logging.debug(&#39;At MDA_acq_from_node&#39;)
        nodeName = nodeInfo.name
        
        self.nodeInfo = nodeInfo
        
        #Look at the &#39;Visual&#39; bottom attribute:
        visualAttr = nodeInfo.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            for connection in visualAttr.connections:
                if connection.plugAttr is not None and connection.socketAttr is not None and connection.plugItem is not None and connection.socketItem is not None and connection.plugNode is not None and connection.socketNode is not None:
                    visual_connected_node_name = connection.socketNode
                    for node in nodeInfo.flowChart.nodes:
                        if node.name == visual_connected_node_name:
                            visual_connected_node = node
                            if &#39;layerName&#39; in visual_connected_node.visualisation_currentData and visual_connected_node.visualisation_currentData[&#39;layerName&#39;] is not None:
                                layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                            else:
                                visual_connected_node.visualisation_currentData[&#39;layerName&#39;] = nodeName
                                layerName = nodeName
                                
                            if &#39;colormap&#39; in visual_connected_node.visualisation_currentData and visual_connected_node.visualisation_currentData[&#39;colormap&#39;] is not None:
                                colormap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                            else:
                                visual_connected_node.visualisation_currentData[&#39;colormap&#39;] = &#39;gray&#39;
                                colormap = &#39;gray&#39;
                            
                            visual_connected_node.status = &#39;running&#39;
                            break
                
                    logging.debug(&#39;Starting Nodz-MDA visualisation&#39;)
                    #Prepare layerName for shared_data to order the layers later.
                    #Import here to prevent circular import
                    if is_pip_installed():
                        from glados_pycromanager.GUI.napariGlados import startMDAVisualisation
                    else:
                        from napariGlados import startMDAVisualisation
                    self.shared_data.newestLayerName = layerName
                    startMDAVisualisation(self.shared_data,layerName=layerName,layerColorMap=colormap)
        
        #And try to get real-time analysis attributes at bottom:
        
        #Look at the &#39;Real-time&#39; bottom attribute:
        RealTimeAttr = nodeInfo.bottomAttrs[&#39;Real-time&#39;]
        if len(RealTimeAttr.connections) &gt; 0:
            self.nodz_analysis_threads = []
            rt_analysis_connected_node_name = RealTimeAttr.connections[0].socketNode
            for node in nodeInfo.flowChart.nodes:
                if node.name == rt_analysis_connected_node_name:
                    rt_analysis_connected_node = node
                    rt_analysis_info = rt_analysis_connected_node.real_time_analysis_currentData
                    
                    new_analysis_thread = create_real_time_analysis_thread(self.shared_data,analysisInfo = rt_analysis_info,delay=None,nodzInfo=nodeInfo.flowChart)
                    self.nodz_analysis_threads.append(new_analysis_thread)
                    rt_analysis_connected_node.status = &#39;running&#39;
                    
                    
        self.shared_data._mdaMode = False
        
        #Set the exposure time:
        self.core.set_exposure(self.exposure_ms)
        
        #Set the location where to save the mda
        Evaled_storage_file_name = utils.attemptToEvaluateVariables(self.storage_file_name,nodeInfo.flowChart)
        Evaled_storage_folder = utils.attemptToEvaluateVariables(self.storage_folder,nodeInfo.flowChart)
        
        self.shared_data._mdaModeSaveLoc = [Evaled_storage_folder,Evaled_storage_file_name]
        #Set whether the napariviewer should (also) try to connect to the mda
        # self.shared_data._mdaModeNapariViewer = self.shared_data.napariViewer
        #Set the mda parameters
        self.shared_data._mdaModeParams = self.mda
        #Set this MDA object as the active MDA object in the shared_data
        self.shared_data.activeMDAobject = self
        self.shared_data.mda_acq_done_signal.connect(self.MDA_acq_finished)
        #And set the mdamode to be true
        self.shared_data.mdaMode = True
        logging.debug(&#39;ended setting mdamode params&#39;)
        
        pass
    
    def MDA_acq_from_GUI(self, mdaLayerName=None):
        &#34;&#34;&#34;
        The MDA_acq_from_GUI function is called when the user presses the &#39;Start MDA&#39; button in the GUI.
        It sets all of the parameters for an MDA acquisition, and then starts it by calling startMDAacq()
        
        Args:
            self: Refer to the instance of the class
            mdaLayerName: Set the name of the napari layer that will be created for this mda
        
        Returns:
            Nothing
        
        Doc Author:
            Trelent
        &#34;&#34;&#34;
        logging.debug(&#39;At MDA_acq_from_GUI&#39;)
        self.shared_data._mdaMode = False
        
        #Set the exposure time:
        self.core.set_exposure(self.exposure_ms)
        
        #Set the location where to save the mda
        if self.GUI_storage_enabled:
            self.shared_data._mdaModeSaveLoc = [self.storage_folder,self.storage_file_name]
        else:
            self.shared_data._mdaModeSaveLoc = [&#39;&#39;,&#39;&#39;]
        #Set whether the napariviewer should (also) try to connect to the mda
        # self.shared_data._mdaModeNapariViewer = self.shared_data.napariViewer
        #Set the mda parameters
        
        self.shared_data._mdaModeParams = self.mda
        #Set this MDA object as the active MDA object in the shared_data
        self.shared_data.activeMDAobject = self
        self.shared_data.mda_acq_done_signal.connect(self.MDA_acq_finished)
        #And set the mdamode to be true
        self.shared_data.mdaMode = True
        #And start visualization
        if mdaLayerName is not None:
            #Import here to prevent circular import
            if is_pip_installed():
                from glados_pycromanager.GUI.napariGlados import startMDAVisualisation
            else:
                from napariGlados import startMDAVisualisation
            startMDAVisualisation(self.shared_data,layerName=mdaLayerName)
        logging.debug(&#39;ended setting mdamode params&#39;)
        
        #Set the Acquire button to say &#39;stop&#39;
        self.GUI_acquire_button.setText(&#39;Stop Acquisition&#39;) #type:ignore
        #Remove active clicked-connect-calls:
        self.GUI_acquire_button.clicked.disconnect() #type:ignore
        self.GUI_acquire_button.clicked.connect(lambda index: self.stopMDA(mdaLayerName=&#39;MDA&#39;)) #type:ignore
        pass
    
    def resetMDAbutton(self,mdaLayerName=&#39;MDA&#39;):
        &#34;&#34;&#34;
        Function that resets the Acquire button (i.e. if acq is running, it shows &#39;stop acquisition&#39;, this should go back to &#39;acquire&#39; and the connected call)
        &#34;&#34;&#34;
        #ATM, first just update the button back and show that we can access this:
        if self.GUI_acquire_button is not None:
            try:
                self.GUI_acquire_button.setText(&#39;Acquire&#39;) #type:ignore
                #Remove active clicked-connect-calls:
                self.GUI_acquire_button.clicked.disconnect() #type:ignore
                self.GUI_acquire_button.clicked.connect(lambda index: self.MDA_acq_from_GUI(mdaLayerName=mdaLayerName)) #type:ignore
            except RuntimeError:
                pass #C/C++ object has been deleted if called from Nodz.
    
    def stopMDA(self,mdaLayerName=&#39;MDA&#39;):
        &#34;&#34;&#34;
        The stopMDA function is called when the user presses the &#39;Stop Acquisition&#39; button in the GUI.
        It stops the MDA acquisition.
        &#34;&#34;&#34;
        
        logging.info(&#39;Attempting to stop MDA&#39;)
        #Reset the button
        self.resetMDAbutton(mdaLayerName=mdaLayerName)
        #Abort the mda mode
        self.shared_data._mdaModeAcqData.abort()
    
    def get_MDA_events_from_GUI(self):
        &#34;&#34;&#34;
        The get_MDA_events_from_GUI function is called every time the user changes any option in the GUI.
        It will then update all variables that are used to create an MDA object, which can be used to run a multi-dimensional acquisition.
        
        
        Args:
            self: Refer to the object itself
        &#34;&#34;&#34;
        logging.debug(&#39;starting get_MDA_events_from_GUI&#39;)
        #Make this somewhat readable:
        if self.exposureGroupBox.isEnabled():
            try:
                self.exposure_ms = float(self.exposureEntry.text())
                self.exposure_s_or_ms = &#39;ms&#39;
                if self.exposureDropdown.currentText() == &#39;s&#39;:
                    self.exposure_ms *= 1000
                    self.exposure_s_or_ms = &#39;s&#39;
            except:
                self.exposure_ms = None
                self.exposure_s_or_ms = &#39;ms&#39;
        
        if self.timeGroupBox.isEnabled():
            try:
                self.num_time_points = int(self.timePointEntry.text())
                self.time_interval_s = float(self.timeIntervalEntry.text())
                self.time_interval_s_or_ms = &#39;s&#39;
                if self.timeIntervalDropdown.currentText() == &#39;ms&#39;:
                    self.time_interval_s_or_ms = &#39;ms&#39;
                    self.time_interval_s /= 1000
            except:
                self.num_time_points = None
                self.time_interval_s = None
                self.time_interval_s_or_ms = &#39;ms&#39;
                
        # if self.orderGroupBox.isEnabled():
        self.order = self.orderDropdown.currentText()
        
        if self.storageGroupBox.isEnabled():
            self.storage_folder = self.storageFolderEntry.text()
            self.storage_file_name = self.storageFileNameEntry.text()
        
        if self.zGroupBox.isEnabled():
            try:
                #We also need to set the shared_data focus device for proper z-functioning
                self.shared_data.core.set_focus_device(self.z_oneDstageDropdown.currentText())
            except:
                self.shared_data.core.set_focus_device(self.shared_data._defaultFocusDevice)
                
            self.z_stage_sel = self.z_oneDstageDropdown.currentText()
            
            if self.z_startEntry.text() != &#39;&#39;:
                self.z_start = (float(self.z_startEntry.text()))
            else:
                self.z_start = None
                
            if self.z_endEntry.text() != &#39;&#39;:
                self.z_end = (float(self.z_endEntry.text()))
            else:
                self.z_end = None
                
            if self.z_nrsteps_radio.isChecked():
                if (self.z_nrsteps_entry.text() != &#39;&#39;) and self.z_start is not None and self.z_end is not None:
                    self.z_step = float((self.z_end-self.z_start)/int(self.z_nrsteps_entry.text()))
                    self.z_step_distance = None
                    self.z_nr_steps = int(self.z_nrsteps_entry.text())
                else:
                    self.z_step = None
                    self.z_step_distance = None
                    self.z_nr_steps = None
            elif self.z_stepdistance_radio.isChecked():
                if self.z_stepdistance_entry.text() != &#39;&#39; and self.z_start is not None and self.z_end is not None:
                    self.z_step = float(self.z_stepdistance_entry.text())
                    self.z_step_distance = float(self.z_stepdistance_entry.text())
                    self.z_nr_steps = None
                    if self.z_start &lt; self.z_end:
                        if self.z_step &lt; 0:
                            self.z_step*=-1
                    elif self.z_start &gt; self.z_end:
                        if self.z_step &gt; 0:
                            self.z_step*=-1
                else:
                    self.z_step = None
                    self.z_step_distance = None
                    self.z_nr_steps = None
            self.z_nrsteps_radio_sel = self.z_nrsteps_radio.isChecked()
            self.z_stepdistance_radio_sel = self.z_stepdistance_radio.isChecked()
        else:
            self.shared_data.core.set_focus_device(self.shared_data._defaultFocusDevice)
        
        #Get the xy positions
        if self.xyGroupBox.isEnabled():
            try:
                self.xy_positions = self.xypositionListWidget.getPositionsArray()
                self.xy_positions_saveInfo = self.xypositionListWidget.getSaveInfoPositionsArray()
            except:
                self.xy_positions = None
                self.xy_positions_saveInfo = None
        else:
            self.xy_positions = None
            self.xy_positions_saveInfo = None
        
        if self.channelGroupBox.isEnabled():
            try:
                
                self.channel_group = self.channelDropdown.currentText()
                
                self.channels = []
                self.channel_exposures_ms = []
                for row in range(self.channelListWidget.rowCount()):
                    for column in range(self.channelListWidget.columnCount()):
                        if column == 0:
                            self.channels.append(self.channelListWidget.cellWidget(row,0).currentText())
                        elif column == 1:
                            item = self.channelListWidget.item(row, column)
                            try: #Check if it will be float-value:
                                if item is not None:
                                    self.channel_exposures_ms.append(float(item.text()))
                                else:
                                    self.channel_exposures_ms.append(&#34;&#34;)  # Add an empty string for empty cells
                            except ValueError:  # Add an empty string for non-float
                                self.channel_exposures_ms.append(&#34;&#34;)

            except:
                self.channel_group = None
                self.channels = None
                self.channel_exposures_ms = None
        
        #Do a small catch in case z_start, z_step or z_end is None:
        if self.z_start is None or self.z_step is None or self.z_end is None:
            if self.zGroupBox.isEnabled() and self.GUI_show_z:
                #Only a warning if we actually want Z, if we don&#39;t, it&#39;s just a debug info.
                logging.info(&#34;z_start, z_step or z_end is None. These are adapted to 0/1/1.&#34;)
            else:
                logging.debug(&#34;z_start, z_step or z_end is None. These are adapted to 0/1/1.&#34;)
            self.z_start = 0
            self.z_step = 1
            self.z_end = 1
        
        #Also update the nodz variables info:
        self.updateNodzVariables()
        
        self.mda = multi_d_acquisition_events(num_time_points=self.num_time_points, time_interval_s=self.time_interval_s,z_start=self.z_start,z_end=self.z_end,z_step=self.z_step,channel_group=self.channel_group,channels=self.channels,channel_exposures_ms=self.channel_exposures_ms,xy_positions=self.xy_positions,xyz_positions=self.xyz_positions,position_labels=self.position_labels,order=self.order) #type:ignore
        
        logging.debug(f&#34;mda: {self.mda}&#34;)
        if self.fully_started:
            if self.autoSaveLoad:
                #Store in appdata
                appdata_folder = os.getenv(&#39;APPDATA&#39;)
                if appdata_folder is None:
                    raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
                app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
                os.makedirs(app_specific_folder, exist_ok=True)
                self.save_state_MDA(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
        logging.debug(&#39;ended get_MDA_events_from_GUI&#39;)
        
        pass
    
    def setZStart(self):
        &#34;&#34;&#34;
        Set the starting Z position based on the selected zstage.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        zstage = self.z_oneDstageDropdown.currentText()
        #zstage value limited to 2 decimal places:
        zstagePos = round(float(self.core.get_position(zstage)),2)
        self.z_startEntry.setText(str(zstagePos))
    
    def setZEnd(self):
        &#34;&#34;&#34;
        Set the end position of the Z stage.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        zstage = self.z_oneDstageDropdown.currentText()
        #zstage value limited to 2 decimal places:
        zstagePos = round(float(self.core.get_position(zstage)),2)
        self.z_endEntry.setText(str(zstagePos))
        
    def setMDAparams(self,mdaparams):
        &#34;&#34;&#34;
        Set the MDA parameters.
        
        Args:
            mdaparams: The MDA parameters to be set.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.mda = mdaparams
    #endregion
    
    #region Nodz-based
    def updateNodzVariables(self):
        &#34;&#34;&#34;
        Update Nodz variables (variablesNodz) with current data.
        &#34;&#34;&#34;
        if &#39;nodeInfo&#39; in vars(self) and self.nodeInfo is not None:
            utils.updateNodzVariablesTime(self.nodeInfo)
            self.nodeInfo.variablesNodz[&#39;data&#39;][&#39;data&#39;] = self.data
            self.nodeInfo.variablesNodz[&#39;order&#39;][&#39;data&#39;] = self.order
            self.nodeInfo.variablesNodz[&#39;exposure_ms&#39;][&#39;data&#39;] = self.exposure_ms
            self.nodeInfo.variablesNodz[&#39;n_timepoints&#39;][&#39;data&#39;] = self.num_time_points
            self.nodeInfo.variablesNodz[&#39;time_interval_ms&#39;][&#39;data&#39;] = self.time_interval_s*1000 #type: ignore
            if self.GUI_show_xy == True and self.xy_positions is not None:
                self.nodeInfo.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = self.xy_positions
                self.nodeInfo.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = len(self.xy_positions) #type: ignore
            else:
                self.nodeInfo.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = None
            if self.GUI_show_z == True:
                self.nodeInfo.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = [self.z_start, self.z_step, self.z_end]
                self.nodeInfo.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = self.z_nr_steps
            else:
                self.nodeInfo.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = None
            if self.GUI_show_channel == True:
                self.nodeInfo.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = self.channel_group
                self.nodeInfo.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = self.channels
                self.nodeInfo.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = len(self.channels) #type: ignore
            else:
                self.nodeInfo.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = None
            if self.GUI_storage_enabled == True:
                try:
                    #Update to the actually-stored-path.
                    self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = self.data.path #type: ignore
                except AttributeError:
                    #Update to the expectedpath.
                    self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = self.storage_folder+os.sep+self.storage_file_name+&#39;_1//&#39; #type: ignore
            else:
                self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = None
    #endregion</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MDAGlados.ChannelList"><code class="flex name class">
<span>class <span class="ident">ChannelList</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creation of an interactive list widget, initially created for a nice channel list
Extends InteractiveListWidget</p>
<p>Initializes the channellist class within the given parent widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget to set for the current instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelList(InteractiveListWidget):
    &#34;&#34;&#34;
    Creation of an interactive list widget, initially created for a nice channel list
    Extends InteractiveListWidget
    &#34;&#34;&#34;
    def __init__(self,parent=None):
        &#34;&#34;&#34;
        Initializes the channellist class within the given parent widget.
        
        Args:
            parent: The parent widget to set for the current instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(columnCount=3)
        self.channelName = &#39;&#39;
        self.parentWidget=parent #type:ignore
        
    def setChannelName(self, channelName):
        &#34;&#34;&#34;
        Set the name of the channel.
        
        Args:
            channelName: A string representing the name of the channel.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.channelName = channelName
        
    def swapRows(self, row1, row2):
        &#34;&#34;&#34;
        Swap rows in the table.
        
        Args:
            row1 (int): The index of the first row to swap.
            row2 (int): The index of the second row to swap.
        
        Returns:
            None
        &#34;&#34;&#34;
        for col in range(self.columnCount()):
            if col == 0:
                combobox1 = self.cellWidget(row1, col)
                combobox2 = self.cellWidget(row2, col)
                
                chosenEntry1 = combobox1.currentText()
                chosenEntry2 = combobox2.currentText()
                
                combobox1.setCurrentText(chosenEntry2)
                combobox2.setCurrentText(chosenEntry1)
            else:
                item1 = self.takeItem(row1, col)
                item2 = self.takeItem(row2, col)
                self.setItem(row1, col, item2)
                self.setItem(row2, col, item1)
        self.setCurrentCell(row2, 1)
        
    def addNewEntry(self,channelEntry=None,exposureEntry=None):
        &#34;&#34;&#34;
        Add a new entry to the table.
        
        Args:
            channelEntry (str): The channel entry to be added to the table.
            exposureEntry (str): The exposure entry to be added to the table.
        
        Returns:
            None
        &#34;&#34;&#34;
        #Add the current exposure time as text as textentry:
        if &#39;channelDropdown&#39; in dir(self.parentWidget):
            rowPosition = self.rowCount()
            self.insertRow(rowPosition)
            #Create a dropbox with two options:
            newdropbox = QComboBox()
            #Currently selected channel: self.parentWidget.channelDropdown.currentText()
            #Find the corresponding options:
            currentChannel = self.parentWidget.channelDropdown.currentText()
            nrConfigs = self.parentWidget.core.get_available_configs(currentChannel).size()
            for i in range(nrConfigs):
                newdropbox.addItem(self.parentWidget.core.get_available_configs(currentChannel).get(i))
            if channelEntry is not None:
                try:
                    newdropbox.setCurrentText(channelEntry)
                except:
                    logging.warning(&#39;Wrong mix of channel and entries&#39;)
                    pass
            self.setCellWidget(rowPosition, 0, newdropbox)
            # self.setItem(rowPosition, 1, QTableWidgetItem(textEntry))
            if exposureEntry == None:
                currentexposure = self.parentWidget.core.get_exposure()
                self.setItem(rowPosition, 1, QTableWidgetItem(str(currentexposure)))
            else:
                self.setItem(rowPosition, 1, QTableWidgetItem(exposureEntry))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MDAGlados.InteractiveListWidget" href="#MDAGlados.InteractiveListWidget">InteractiveListWidget</a></li>
<li>PyQt5.QtWidgets.QTableWidget</li>
<li>PyQt5.QtWidgets.QTableView</li>
<li>PyQt5.QtWidgets.QAbstractItemView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MDAGlados.ChannelList.addNewEntry"><code class="name flex">
<span>def <span class="ident">addNewEntry</span></span>(<span>self, channelEntry=None, exposureEntry=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new entry to the table.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channelEntry</code></strong> :&ensp;<code>str</code></dt>
<dd>The channel entry to be added to the table.</dd>
<dt><strong><code>exposureEntry</code></strong> :&ensp;<code>str</code></dt>
<dd>The exposure entry to be added to the table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addNewEntry(self,channelEntry=None,exposureEntry=None):
    &#34;&#34;&#34;
    Add a new entry to the table.
    
    Args:
        channelEntry (str): The channel entry to be added to the table.
        exposureEntry (str): The exposure entry to be added to the table.
    
    Returns:
        None
    &#34;&#34;&#34;
    #Add the current exposure time as text as textentry:
    if &#39;channelDropdown&#39; in dir(self.parentWidget):
        rowPosition = self.rowCount()
        self.insertRow(rowPosition)
        #Create a dropbox with two options:
        newdropbox = QComboBox()
        #Currently selected channel: self.parentWidget.channelDropdown.currentText()
        #Find the corresponding options:
        currentChannel = self.parentWidget.channelDropdown.currentText()
        nrConfigs = self.parentWidget.core.get_available_configs(currentChannel).size()
        for i in range(nrConfigs):
            newdropbox.addItem(self.parentWidget.core.get_available_configs(currentChannel).get(i))
        if channelEntry is not None:
            try:
                newdropbox.setCurrentText(channelEntry)
            except:
                logging.warning(&#39;Wrong mix of channel and entries&#39;)
                pass
        self.setCellWidget(rowPosition, 0, newdropbox)
        # self.setItem(rowPosition, 1, QTableWidgetItem(textEntry))
        if exposureEntry == None:
            currentexposure = self.parentWidget.core.get_exposure()
            self.setItem(rowPosition, 1, QTableWidgetItem(str(currentexposure)))
        else:
            self.setItem(rowPosition, 1, QTableWidgetItem(exposureEntry))</code></pre>
</details>
</dd>
<dt id="MDAGlados.ChannelList.setChannelName"><code class="name flex">
<span>def <span class="ident">setChannelName</span></span>(<span>self, channelName)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the name of the channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channelName</code></strong></dt>
<dd>A string representing the name of the channel.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setChannelName(self, channelName):
    &#34;&#34;&#34;
    Set the name of the channel.
    
    Args:
        channelName: A string representing the name of the channel.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.channelName = channelName</code></pre>
</details>
</dd>
<dt id="MDAGlados.ChannelList.swapRows"><code class="name flex">
<span>def <span class="ident">swapRows</span></span>(<span>self, row1, row2)</span>
</code></dt>
<dd>
<div class="desc"><p>Swap rows in the table.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row1</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the first row to swap.</dd>
<dt><strong><code>row2</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the second row to swap.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swapRows(self, row1, row2):
    &#34;&#34;&#34;
    Swap rows in the table.
    
    Args:
        row1 (int): The index of the first row to swap.
        row2 (int): The index of the second row to swap.
    
    Returns:
        None
    &#34;&#34;&#34;
    for col in range(self.columnCount()):
        if col == 0:
            combobox1 = self.cellWidget(row1, col)
            combobox2 = self.cellWidget(row2, col)
            
            chosenEntry1 = combobox1.currentText()
            chosenEntry2 = combobox2.currentText()
            
            combobox1.setCurrentText(chosenEntry2)
            combobox2.setCurrentText(chosenEntry1)
        else:
            item1 = self.takeItem(row1, col)
            item2 = self.takeItem(row2, col)
            self.setItem(row1, col, item2)
            self.setItem(row2, col, item1)
    self.setCurrentCell(row2, 1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MDAGlados.InteractiveListWidget" href="#MDAGlados.InteractiveListWidget">InteractiveListWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="MDAGlados.InteractiveListWidget.deleteAll" href="#MDAGlados.InteractiveListWidget.deleteAll">deleteAll</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.deleteSelected" href="#MDAGlados.InteractiveListWidget.deleteSelected">deleteSelected</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.getIDValues" href="#MDAGlados.InteractiveListWidget.getIDValues">getIDValues</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveDown" href="#MDAGlados.InteractiveListWidget.moveDown">moveDown</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveToPos" href="#MDAGlados.InteractiveListWidget.moveToPos">moveToPos</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveUp" href="#MDAGlados.InteractiveListWidget.moveUp">moveUp</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.setColumNames" href="#MDAGlados.InteractiveListWidget.setColumNames">setColumNames</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MDAGlados.InteractiveListWidget"><code class="flex name class">
<span>class <span class="ident">InteractiveListWidget</span></span>
<span>(</span><span>fontsize=6, columnCount=2, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creation of an interactive list widget, initially created for a nice XY list (similar to POS list in micromanager)</p>
<p>Initializes an InteractiveListWidget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code></dt>
<dd>The font size to be set for the widget. Default is 6.</dd>
<dt><strong><code>columnCount</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of columns to be displayed in the widget. Default is 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InteractiveListWidget(QTableWidget):
    &#34;&#34;&#34;
    Creation of an interactive list widget, initially created for a nice XY list (similar to POS list in micromanager)
    &#34;&#34;&#34;
    def __init__(self,fontsize=6,columnCount=2,parent=None):
        &#34;&#34;&#34;
        Initializes an InteractiveListWidget.
        
        Args:
            fontsize (int): The font size to be set for the widget. Default is 6.
            columnCount (int): The number of columns to be displayed in the widget. Default is 2.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        logging.debug(&#39;init InteractiveListWidget&#39;)
        self.parent = parent #type: ignore
        super().__init__(rowCount=0, columnCount=columnCount) #type: ignore
        # self.horizontalHeader().setStretchLastSection(True)
        
        colWidth = 100
        # Set the minimum size for the table widget
        self.setColumnWidth(0, int(colWidth*.9)) #Slightly smaller to prevent scrollbar to appear
        self.setMinimumWidth(colWidth*columnCount) 
        # Set the size policy to ensure the widget can expand but not shrink below the minimum size
        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        
        font = QFont()
        font.setPointSize(fontsize)
        self.setFont(font)
        # Reduce padding within cells
        self.setStyleSheet(&#34;QTableWidget::item { padding: 1px; }&#34;)
        
        self.parentWidget=None #type:ignore
            
    def setColumNames(self, names):
        &#34;&#34;&#34;
        Set column names for the interactive list table.
        
        Args:
            names (list): A list of column names to be set.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.setColumnCount(len(names))
        self.setHorizontalHeaderLabels(names)
        
    def deleteSelected(self):
        &#34;&#34;&#34;
        Deletes selected rows from the table.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        selectedRows = sorted(set(index.row() for index in self.selectedIndexes()), reverse=True)
        for row in selectedRows:
            self.removeRow(row)

    def deleteAll(self):
        &#34;&#34;&#34;
        Deletes all rows in the table.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for row in range(self.rowCount() - 1, -1, -1):
            self.removeRow(row)

    def moveUp(self):
        &#34;&#34;&#34;
        Moves the current row up by swapping it with the row above.
        
            Args:
                None
        
            Returns:
                None
        &#34;&#34;&#34;
        row = self.currentRow()
        if row &gt; 0:
            self.swapRows(row, row - 1)
            
    def moveDown(self):
        &#34;&#34;&#34;
        Moves the current row down by swapping it with the row below.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        row = self.currentRow()
        if row &lt; self.rowCount() - 1 and row != -1:
            self.swapRows(row, row + 1)

    def moveToPos(self):
        &#34;&#34;&#34; 
        Move to the position specified by the current selected entry gridA
        &#34;&#34;&#34;
        currRow = self.currentRow()
        #get the info of the curRow:
        xpos_goto = float(self.item(currRow,2).text())
        ypos_goto = float(self.item(currRow,3).text())
        #Move the stage to this position
        logging.debug(f&#34;Moving stage {self.XYstageName()} to pos {xpos_goto},{ypos_goto}&#34;)
        self.parent.core.set_xy_position(self.XYstageName(),xpos_goto,ypos_goto)

    def getIDValues(self):
        &#34;&#34;&#34;
        Get the ID values from the second column of the table.
        
        Args:
            None
        
        Returns:
            list: A list of float values extracted from the second column of the table.
        &#34;&#34;&#34;
        id_values = []
        for row in range(self.rowCount()):
            item_id = self.takeItem(row, 1)
            if item_id:
                id_values.append(float(item_id.text()))
        return id_values

    def disconnectFunGUIConnection(self):
        self.itemChanged.disconnect()
    
    def reconnectFunGUIConnection(self,runOnce=True):
        self.itemChanged.connect(lambda: self.parent.get_MDA_events_from_GUI())
        if runOnce:
            self.parent.get_MDA_events_from_GUI()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QTableWidget</li>
<li>PyQt5.QtWidgets.QTableView</li>
<li>PyQt5.QtWidgets.QAbstractItemView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MDAGlados.ChannelList" href="#MDAGlados.ChannelList">ChannelList</a></li>
<li><a title="MDAGlados.XYStageList" href="#MDAGlados.XYStageList">XYStageList</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MDAGlados.InteractiveListWidget.deleteAll"><code class="name flex">
<span>def <span class="ident">deleteAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes all rows in the table.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteAll(self):
    &#34;&#34;&#34;
    Deletes all rows in the table.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    for row in range(self.rowCount() - 1, -1, -1):
        self.removeRow(row)</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.deleteSelected"><code class="name flex">
<span>def <span class="ident">deleteSelected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes selected rows from the table.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteSelected(self):
    &#34;&#34;&#34;
    Deletes selected rows from the table.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    
    selectedRows = sorted(set(index.row() for index in self.selectedIndexes()), reverse=True)
    for row in selectedRows:
        self.removeRow(row)</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.disconnectFunGUIConnection"><code class="name flex">
<span>def <span class="ident">disconnectFunGUIConnection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnectFunGUIConnection(self):
    self.itemChanged.disconnect()</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.getIDValues"><code class="name flex">
<span>def <span class="ident">getIDValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the ID values from the second column of the table.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of float values extracted from the second column of the table.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getIDValues(self):
    &#34;&#34;&#34;
    Get the ID values from the second column of the table.
    
    Args:
        None
    
    Returns:
        list: A list of float values extracted from the second column of the table.
    &#34;&#34;&#34;
    id_values = []
    for row in range(self.rowCount()):
        item_id = self.takeItem(row, 1)
        if item_id:
            id_values.append(float(item_id.text()))
    return id_values</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.moveDown"><code class="name flex">
<span>def <span class="ident">moveDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the current row down by swapping it with the row below.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveDown(self):
    &#34;&#34;&#34;
    Moves the current row down by swapping it with the row below.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    row = self.currentRow()
    if row &lt; self.rowCount() - 1 and row != -1:
        self.swapRows(row, row + 1)</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.moveToPos"><code class="name flex">
<span>def <span class="ident">moveToPos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move to the position specified by the current selected entry gridA</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveToPos(self):
    &#34;&#34;&#34; 
    Move to the position specified by the current selected entry gridA
    &#34;&#34;&#34;
    currRow = self.currentRow()
    #get the info of the curRow:
    xpos_goto = float(self.item(currRow,2).text())
    ypos_goto = float(self.item(currRow,3).text())
    #Move the stage to this position
    logging.debug(f&#34;Moving stage {self.XYstageName()} to pos {xpos_goto},{ypos_goto}&#34;)
    self.parent.core.set_xy_position(self.XYstageName(),xpos_goto,ypos_goto)</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.moveUp"><code class="name flex">
<span>def <span class="ident">moveUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the current row up by swapping it with the row above.</p>
<pre><code>Args:
    None

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveUp(self):
    &#34;&#34;&#34;
    Moves the current row up by swapping it with the row above.
    
        Args:
            None
    
        Returns:
            None
    &#34;&#34;&#34;
    row = self.currentRow()
    if row &gt; 0:
        self.swapRows(row, row - 1)</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.reconnectFunGUIConnection"><code class="name flex">
<span>def <span class="ident">reconnectFunGUIConnection</span></span>(<span>self, runOnce=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconnectFunGUIConnection(self,runOnce=True):
    self.itemChanged.connect(lambda: self.parent.get_MDA_events_from_GUI())
    if runOnce:
        self.parent.get_MDA_events_from_GUI()</code></pre>
</details>
</dd>
<dt id="MDAGlados.InteractiveListWidget.setColumNames"><code class="name flex">
<span>def <span class="ident">setColumNames</span></span>(<span>self, names)</span>
</code></dt>
<dd>
<div class="desc"><p>Set column names for the interactive list table.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of column names to be set.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setColumNames(self, names):
    &#34;&#34;&#34;
    Set column names for the interactive list table.
    
    Args:
        names (list): A list of column names to be set.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    self.setColumnCount(len(names))
    self.setHorizontalHeaderLabels(names)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MDAGlados.MDAGlados"><code class="flex name class">
<span>class <span class="ident">MDAGlados</span></span>
<span>(</span><span>core, MM_JSON, layout, shared_data, hasGUI=False, num_time_points:Â intÂ |Â NoneÂ =Â 10, time_interval_s:Â Union[float,Â List[float]]Â =Â 0, time_interval_s_or_ms:Â strÂ =Â 'ms', z_start:Â floatÂ |Â NoneÂ =Â 0, z_end:Â floatÂ |Â NoneÂ =Â 1, z_step:Â floatÂ |Â NoneÂ =Â None, z_stage_sel:Â Optional[str]Â =Â None, z_nr_steps:Â floatÂ |Â NoneÂ =Â 2, z_step_distance:Â floatÂ |Â NoneÂ =Â None, z_nrsteps_radio_sel:Â boolÂ |Â NoneÂ =Â None, z_stepdistance_radio_sel:Â boolÂ |Â NoneÂ =Â None, channel_group:Â Optional[str]Â =Â None, channels:Â listÂ |Â NoneÂ =Â None, channel_exposures_ms:Â listÂ |Â NoneÂ =Â None, xy_positions:Â Optional[Iterable]Â =Â None, xyz_positions:Â Optional[Iterable]Â =Â None, position_labels:Â Optional[List[str]]Â =Â None, order:Â strÂ =Â 'tpcz', exposure_ms:Â floatÂ |Â NoneÂ =Â 90, exposure_s_or_ms:Â strÂ =Â 'ms', storage_folder:Â Optional[str]Â =Â None, storage_file_name:Â Optional[str]Â =Â None, GUI_show_exposure=True, GUI_show_xy=True, GUI_show_z=True, GUI_show_channel=True, GUI_show_time=True, GUI_show_order=True, GUI_show_storage=True, GUI_acquire_button=True, GUI_xy_pos_fullInfo:Â Optional[Iterable]Â =Â None, autoSaveLoad=False, parent=None, node=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that handles the multi-Dimensional acquisition of Pycromanager</p>
<p>Initializes the MDAGlados class with the provided parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>core</code></strong></dt>
<dd>Core object for communication with the microscope.</dd>
<dt><strong><code>MM_JSON</code></strong></dt>
<dd>JSON object containing metadata.</dd>
<dt><strong><code>layout</code></strong></dt>
<dd>Layout object for GUI layout.</dd>
<dt><strong><code>shared_data</code></strong></dt>
<dd>Shared data object for communication between modules.</dd>
<dt><strong><code>hasGUI</code></strong></dt>
<dd>Boolean indicating whether GUI should be displayed (default is False).</dd>
<dt><strong><code>num_time_points</code></strong></dt>
<dd>Number of time points (default is 10).</dd>
<dt><strong><code>time_interval_s</code></strong></dt>
<dd>Time interval in seconds between acquisitions (default is 0).</dd>
<dt><strong><code>z_start</code></strong></dt>
<dd>Starting position of the Z-stack (default is None).</dd>
<dt><strong><code>z_end</code></strong></dt>
<dd>Ending position of the Z-stack (default is None).</dd>
<dt><strong><code>z_step</code></strong></dt>
<dd>Step size for Z-stack acquisition (default is None).</dd>
<dt><strong><code>z_stage_sel</code></strong></dt>
<dd>Selected Z-stage for acquisition (default is None).</dd>
<dt><strong><code>z_nr_steps</code></strong></dt>
<dd>Number of steps in the Z-stack (default is None).</dd>
<dt><strong><code>z_step_distance</code></strong></dt>
<dd>Distance between Z-stack steps (default is None).</dd>
<dt><strong><code>z_nrsteps_radio_sel</code></strong></dt>
<dd>Boolean indicating whether number of steps is selected (default is None).</dd>
<dt><strong><code>z_stepdistance_radio_sel</code></strong></dt>
<dd>Boolean indicating whether step distance is selected (default is None).</dd>
<dt><strong><code>channel_group</code></strong></dt>
<dd>Group of channels to acquire (default is None).</dd>
<dt><strong><code>channels</code></strong></dt>
<dd>List of channels to acquire (default is None).</dd>
<dt><strong><code>channel_exposures_ms</code></strong></dt>
<dd>List of exposure times for each channel in milliseconds (default is None).</dd>
<dt><strong><code>xy_positions</code></strong></dt>
<dd>Iterable of XY positions to acquire (default is None).</dd>
<dt><strong><code>xyz_positions</code></strong></dt>
<dd>Iterable of XYZ positions to acquire (default is None).</dd>
<dt><strong><code>position_labels</code></strong></dt>
<dd>List of labels for positions (default is None).</dd>
<dt><strong><code>order</code></strong></dt>
<dd>Order of acquisition (default is 'tpcz').</dd>
<dt><strong><code>exposure_ms</code></strong></dt>
<dd>Exposure time in milliseconds (default is 90).</dd>
<dt><strong><code>storage_folder</code></strong></dt>
<dd>Folder path for storing data (default is None).</dd>
<dt><strong><code>storage_file_name</code></strong></dt>
<dd>Name of the storage file (default is None).</dd>
<dt><strong><code>GUI_show_exposure</code></strong></dt>
<dd>Boolean indicating whether to show exposure settings in GUI (default is True).</dd>
<dt><strong><code>GUI_show_xy</code></strong></dt>
<dd>Boolean indicating whether to show XY settings in GUI (default is True).</dd>
<dt><strong><code>GUI_show_z</code></strong></dt>
<dd>Boolean indicating whether to show Z settings in GUI (default is True).</dd>
<dt><strong><code>GUI_show_channel</code></strong></dt>
<dd>Boolean indicating whether to show channel settings in GUI (default is True).</dd>
<dt><strong><code>GUI_show_time</code></strong></dt>
<dd>Boolean indicating whether to show time settings in GUI (default is True).</dd>
<dt><strong><code>GUI_show_order</code></strong></dt>
<dd>Boolean indicating whether to show order settings in GUI (default is True).</dd>
<dt><strong><code>GUI_show_storage</code></strong></dt>
<dd>Boolean indicating whether to show storage settings in GUI (default is True).</dd>
<dt><strong><code>GUI_acquire_button</code></strong></dt>
<dd>Boolean indicating whether to show the acquisition button in GUI (default is True).</dd>
<dt><strong><code>GUI_xy_pos_fullInfo</code></strong></dt>
<dd>Full info (including naming, id) of the XY position list</dd>
<dt><strong><code>autoSaveLoad</code></strong></dt>
<dd>Boolean indicating whether to automatically save and load settings (default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MDAGlados(CustomMainWindow):
    &#34;&#34;&#34; 
    Class that handles the multi-Dimensional acquisition of Pycromanager
    &#34;&#34;&#34;
    #Pysignal should be outside the functions for proper init
    MDA_completed = pyqtSignal(bool)
    def __init__(self,core,MM_JSON,layout,
                shared_data,
                hasGUI=False,
                num_time_points: int | None = 10, 
                time_interval_s: float | List[float] = 0, 
                time_interval_s_or_ms: str = &#39;ms&#39;,
                z_start: float | None = 0, 
                z_end: float | None = 1, 
                z_step: float | None = None, 
                z_stage_sel : str | None = None,
                z_nr_steps: float | None = 2,
                z_step_distance: float | None = None,
                z_nrsteps_radio_sel: bool | None = None,
                z_stepdistance_radio_sel: bool | None = None,
                channel_group: str | None = None, 
                channels: list | None = None, 
                channel_exposures_ms: list | None = None, 
                xy_positions: Iterable | None = None, 
                xyz_positions: Iterable | None = None, 
                position_labels: List[str] | None = None, 
                order: str = &#39;tpcz&#39;, 
                exposure_ms: float | None = 90, 
                exposure_s_or_ms: str = &#39;ms&#39;,
                storage_folder: str | None = None,
                storage_file_name: str | None = None,
                GUI_show_exposure = True, 
                GUI_show_xy = True, 
                GUI_show_z = True, 
                GUI_show_channel = True, 
                GUI_show_time = True, 
                GUI_show_order = True, 
                GUI_show_storage = True, 
                GUI_acquire_button = True,
                GUI_xy_pos_fullInfo: Iterable | None = None,
                autoSaveLoad = False,
                parent=None,
                node = None):
        &#34;&#34;&#34;
        Initializes the MDAGlados class with the provided parameters.
        
        Args:
            core: Core object for communication with the microscope.
            MM_JSON: JSON object containing metadata.
            layout: Layout object for GUI layout.
            shared_data: Shared data object for communication between modules.
            hasGUI: Boolean indicating whether GUI should be displayed (default is False).
            num_time_points: Number of time points (default is 10).
            time_interval_s: Time interval in seconds between acquisitions (default is 0).
            z_start: Starting position of the Z-stack (default is None).
            z_end: Ending position of the Z-stack (default is None).
            z_step: Step size for Z-stack acquisition (default is None).
            z_stage_sel: Selected Z-stage for acquisition (default is None).
            z_nr_steps: Number of steps in the Z-stack (default is None).
            z_step_distance: Distance between Z-stack steps (default is None).
            z_nrsteps_radio_sel: Boolean indicating whether number of steps is selected (default is None).
            z_stepdistance_radio_sel: Boolean indicating whether step distance is selected (default is None).
            channel_group: Group of channels to acquire (default is None).
            channels: List of channels to acquire (default is None).
            channel_exposures_ms: List of exposure times for each channel in milliseconds (default is None).
            xy_positions: Iterable of XY positions to acquire (default is None).
            xyz_positions: Iterable of XYZ positions to acquire (default is None).
            position_labels: List of labels for positions (default is None).
            order: Order of acquisition (default is &#39;tpcz&#39;).
            exposure_ms: Exposure time in milliseconds (default is 90).
            storage_folder: Folder path for storing data (default is None).
            storage_file_name: Name of the storage file (default is None).
            GUI_show_exposure: Boolean indicating whether to show exposure settings in GUI (default is True).
            GUI_show_xy: Boolean indicating whether to show XY settings in GUI (default is True).
            GUI_show_z: Boolean indicating whether to show Z settings in GUI (default is True).
            GUI_show_channel: Boolean indicating whether to show channel settings in GUI (default is True).
            GUI_show_time: Boolean indicating whether to show time settings in GUI (default is True).
            GUI_show_order: Boolean indicating whether to show order settings in GUI (default is True).
            GUI_show_storage: Boolean indicating whether to show storage settings in GUI (default is True).
            GUI_acquire_button: Boolean indicating whether to show the acquisition button in GUI (default is True).
            GUI_xy_pos_fullInfo: Full info (including naming, id) of the XY position list
            autoSaveLoad: Boolean indicating whether to automatically save and load settings (default is False).
        
        Returns:
            None
        &#34;&#34;&#34;
        
        super().__init__()
        
        #If run as plugin, we need to specify the globals like this:
        if parent is not None:
            global livestate, napariViewer
            livestate = parent.livestate
            napariViewer = parent.napariViewer
        
        self.nodeInfo = node
        self.num_time_points = num_time_points
        self.time_interval_s = time_interval_s
        self.time_interval_s_or_ms = time_interval_s_or_ms
        self.z_start = z_start
        self.z_end = z_end
        self.z_step = z_step
        self.z_stage_sel = z_stage_sel
        self.z_nr_steps = z_nr_steps
        self.z_step_distance = z_step_distance
        self.z_nrsteps_radio_sel = z_nrsteps_radio_sel
        self.z_stepdistance_radio_sel = z_stepdistance_radio_sel
        self.channel_group = channel_group
        self.channels = channels
        self.channel_exposures_ms = channel_exposures_ms
        self.storage_folder = storage_folder
        self.storage_file_name = storage_file_name
        self.xy_positions = xy_positions
        self.xyz_positions = xyz_positions
        self.position_labels = position_labels
        self.order = order
        self.exposure_ms = exposure_ms
        self.exposure_s_or_ms = exposure_s_or_ms
        self.GUI_show_exposure = GUI_show_exposure
        self.GUI_show_xy = GUI_show_xy
        self.GUI_show_z = GUI_show_z
        self.GUI_show_channel = GUI_show_channel
        self.GUI_show_time = GUI_show_time
        self.GUI_show_order = GUI_show_order
        self.GUI_show_storage = GUI_show_storage
        self.GUI_xy_pos_fullInfo = GUI_xy_pos_fullInfo
        self.autoSaveLoad = autoSaveLoad
        
        self.GUI_exposure_enabled = GUI_show_exposure
        self.GUI_xy_enabled = GUI_show_xy
        self.GUI_z_enabled = GUI_show_z
        self.GUI_channel_enabled = GUI_show_channel
        self.GUI_time_enabled = GUI_show_time
        self.GUI_order_enabled = GUI_show_order
        self.GUI_storage_enabled = GUI_show_storage
        
        self.GUI_acquire_button = GUI_acquire_button
        self.has_GUI = False
        self.core = core
        self.mda_analysis_thread = None
        self.MM_JSON = MM_JSON
        self.layout = layout
        self.shared_data = shared_data
        self.gui = {}
        self.lastTimeUpdateSize = time.time()
        self._GUI_grid_width = None
        self.data = None
        
        self.fully_started = False
        
        #Initiate GUI if wanted
        if hasGUI:
            self.initGUI(GUI_show_exposure=self.GUI_show_exposure,GUI_show_xy=self.GUI_show_xy, GUI_show_z=self.GUI_show_z, GUI_show_channel=self.GUI_show_channel, GUI_show_time=self.GUI_show_time, GUI_show_order=self.GUI_show_order, GUI_show_storage=self.GUI_show_storage, GUI_acquire_button=self.GUI_acquire_button)
            self.has_GUI = True
        
        #initiate with an empty mda, or mda based on GUI:
        self.mda = multi_d_acquisition_events(num_time_points=self.num_time_points, time_interval_s=self.time_interval_s,z_start=self.z_start,z_end=self.z_end,z_step=self.z_step,channel_group=self.channel_group,channels=self.channels,channel_exposures_ms=self.channel_exposures_ms,xy_positions=self.xy_positions,xyz_positions=self.xyz_positions,position_labels=self.position_labels,order=self.order) #type:ignore
        
        self.fully_started = True
        #check if mda_state.json exists:
        # if os.path.isfile(&#39;mda_state.json&#39;):
        #     if self.autoSaveLoad:
        #         self.load_state(&#39;mda_state.json&#39;)
    
    #region properties
    @property
    def GUI_grid_width(self):
        &#34;&#34;&#34;
        Get the width of the GUI grid.
        
        Returns:
            int: The width of the GUI grid.
        &#34;&#34;&#34;
        
        return self._GUI_grid_width
    
    @GUI_grid_width.setter
    def GUI_grid_width(self, value):
        &#34;&#34;&#34;
        Updates the width of the GUI grid.
        
        Args:
            value: An integer representing the new width of the GUI grid.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        if value != self._GUI_grid_width:
            self._GUI_grid_width = value
            if self.has_GUI and self.fully_started:
                try:
                    logging.debug(f&#34;updating gui with nr of columns: {self._GUI_grid_width}&#34;)
                    self.showOptionChanged()
                except:
                    pass
    #endregion
    
    #region GUI
    def initGUI(self, GUI_show_exposure=True, GUI_show_xy = True, GUI_show_z=True, GUI_show_channel=True, GUI_show_time=True, GUI_show_order=True, GUI_show_storage=True, GUI_showOptions=True,GUI_acquire_button=True):
        &#34;&#34;&#34;
        Initiate the GUI.
        
        Args:
            GUI_show_exposure (bool): Whether to show the exposure widget. Default is True.
            GUI_show_xy (bool): Whether to show the XY widget. Default is True.
            GUI_show_z (bool): Whether to show the Z widget. Default is True.
            GUI_show_channel (bool): Whether to show the Channel widget. Default is True.
            GUI_show_time (bool): Whether to show the Time widget. Default is True.
            GUI_show_order (bool): Whether to show the Order widget. Default is True.
            GUI_show_storage (bool): Whether to show the Storage widget. Default is True.
            GUI_showOptions (bool): Whether to show the Options widget. Default is True.
            GUI_acquire_button (bool): Whether to show the Acquire button. Default is True.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        #initiate the GUI
        #Create a Vertical+horizontal layout:
        self.gui = QGridLayout()
        self.GUI_grid_width = 7
        
        # Add groupboxes for xy, z, channel, time, order, storage
        self.exposureGroupBox = QGroupBox(&#34;Exposure&#34;)
        self.xyGroupBox = QGroupBox(&#34;XY&#34;)
        self.zGroupBox = QGroupBox(&#34;Z&#34;)
        self.channelGroupBox = QGroupBox(&#34;Channel&#34;)
        self.timeGroupBox = QGroupBox(&#34;Time&#34;)
        self.storageGroupBox = QGroupBox(&#34;Storage&#34;)
        self.showOptionsGroupBox = QGroupBox(&#34;Options&#34;)

        # Create layouts for each groupbox
        exposureLayout=QHBoxLayout()
        xyLayout = QGridLayout()
        zLayout = QGridLayout()
        channelLayout = QGridLayout()
        timeLayout = QGridLayout()
        orderLayout = QVBoxLayout()
        storageLayout = QGridLayout()
        showOptionsLayout = QGridLayout()

        # Add widgets to each layout
        # --------------- Exposure widget -----------------------------------------------
        #Exposure: add a label, an entry field, and a dropdown between &#39;ms&#39; and &#39;s&#39;:
        self.exposureLabel = QLabel(&#34;Exposure:&#34;)
        self.exposureEntry = QLineEdit()
        if self.exposure_ms is not None:
            if self.exposure_s_or_ms == &#39;ms&#39;:
                self.exposureEntry.setText(str(self.exposure_ms))
            elif self.exposure_s_or_ms == &#39;s&#39;:
                self.exposureEntry.setText(str(self.exposure_ms/1000))
        #ensure thatexposureEntry can only be a float:
        self.exposureEntry.setValidator(QDoubleValidator())
        self.exposureDropdown = QComboBox()
        self.exposureDropdown.addItem(&#34;ms&#34;)
        self.exposureDropdown.addItem(&#34;s&#34;)
        self.exposureDropdown.setCurrentText(self.exposure_s_or_ms)
        exposureLayout.addWidget(self.exposureLabel)
        exposureLayout.addWidget(self.exposureEntry)
        exposureLayout.addWidget(self.exposureDropdown)
        #run get_MDA_events_from_GUI when the text or dropdown is changed:
        self.exposureEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.exposureDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- Time widget -----------------------------------------------
        #Time: add labels for time points and time intervals, and integer-based entry fields:
        self.timePointLabel = QLabel(&#34;Number time points:&#34;)
        self.timePointEntry = QLineEdit()
        if self.num_time_points is not None:
            self.timePointEntry.setText(str(self.num_time_points))
        self.timePointEntry.setValidator(QIntValidator())
        self.timeIntervalLabel = QLabel(&#34;Time interval:&#34;)
        self.timeIntervalEntry = QLineEdit()
        if self.time_interval_s is not None:
            if self.time_interval_s_or_ms == &#39;s&#39;:
                self.timeIntervalEntry.setText(str(self.time_interval_s))
            elif self.time_interval_s_or_ms == &#39;ms&#39;:
                self.timeIntervalEntry.setText(str(self.time_interval_s*1000))
        self.timeIntervalEntry.setValidator(QDoubleValidator())
        self.timeIntervalDropdown = QComboBox()
        self.timeIntervalDropdown.addItem(&#34;ms&#34;)
        self.timeIntervalDropdown.addItem(&#34;s&#34;)
        self.timeIntervalDropdown.setCurrentText(self.time_interval_s_or_ms)
        #Adding widgets to layout
        timeLayout.addWidget(self.timePointLabel,0,0)
        timeLayout.addWidget(self.timePointEntry,0,1)
        timeLayout.addWidget(self.timeIntervalLabel,1,0)
        timeLayout.addWidget(self.timeIntervalEntry,1,1)
        timeLayout.addWidget(self.timeIntervalDropdown,1,2)
        #run get_MDA_events_from_GUI when the text or dropdown is changed:
        self.timePointEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.timeIntervalEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.timeIntervalDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- storage widget -----------------------------------------------
        #storage: first, add a label, entry field, and button with &#39;...&#39; to select a folder of choice:
        self.storageFolderLabel = QLabel(&#34;Storage:&#34;)
        self.storageFolderEntry = QLineEdit()
        if self.storage_folder is not None:
            self.storageFolderEntry.setText(self.storage_folder)
        self.storageFolderButton = QPushButton(&#39;...&#39;)
        #add a lambda function when this is pressed to search for a folder:
        self.storageFolderButton.clicked.connect(lambda: self.storageFolderEntry.setText(QFileDialog.getExistingDirectory()))
        #Then add a label and entry field for the file name:
        self.storageFileNameLabel = QLabel(&#34;File name:&#34;)
        self.storageFileNameEntry = QLineEdit()
        if self.storage_file_name is not None:
            self.storageFileNameEntry.setText(self.storage_file_name)
        #Adding widgets to layout
        storageLayout.addWidget(self.storageFolderLabel,0,0)
        storageLayout.addWidget(self.storageFolderEntry,0,1)
        storageLayout.addWidget(self.storageFolderButton,0,2)
        storageLayout.addWidget(self.storageFileNameLabel,1,0)
        storageLayout.addWidget(self.storageFileNameEntry,1,1)
        self.storageFolderEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.storageFileNameEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- XY widget widget -----------------------------------------------
        #First a dropdown to select the xy stage:
        
        #Adding a list widget to add a list of xy positions
        self.xypositionListWidget = XYStageList(parent=self)
        self.xypositionListWidget.setColumNames([&#34;Name&#34;, &#34;ID&#34;,&#34;xPos&#34;,&#34;yPos&#34;])
        self.xypositionListWidget.setColumnWidth(0, 60)
        self.xypositionListWidget.setColumnWidth(1, 40)
        
        self.xy_stagesDropdownLabel = QLabel(&#34;XY Stage:&#34;)
        self.xy_stagesDropdown = QComboBox()
        XYstages = self.getDevicesOfDeviceType(&#39;XYStageDevice&#39;)
        #add the options to the dropdown:
        for stage in XYstages:
            self.xy_stagesDropdown.addItem(stage)
        #Add a callback if we change this dropdown:
        self.xy_stagesDropdown.currentIndexChanged.connect(lambda: self.xypositionListWidget.setXYStageName(self.xy_stagesDropdown.currentText()))
        
        #Initisalise the XY position list
        self.xypositionListWidget.setXYStageName(self.xy_stagesDropdown.currentText)
        #Buttons for the xy position list
        self.xypositionListWidget_deleteButton = QPushButton(&#39;Delete Selected&#39;)
        self.xypositionListWidget_deleteAllButton = QPushButton(&#39;Delete All&#39;)
        self.xypositionListWidget_moveUpButton = QPushButton(&#39;Move Up&#39;)
        self.xypositionListWidget_moveDownButton = QPushButton(&#39;Move Down&#39;)
        self.xypositionListWidget_moveToButton = QPushButton(&#39;Move to Pos&#39;)
        self.xypositionListWidget_addButton = QPushButton(&#39;Add New Entry&#39;)
        #Intialise a gridManager
        self.xypositionListWidget_XYGridManager = utils.XYGridManager(core=self.core,parent=self)
        self.xypositionListWidget_createGridButton = QPushButton(&#39;Create Grid&#39;)
        #Adding callbacks to the xy position list buttons
        self.xypositionListWidget_deleteButton.clicked.connect(self.xypositionListWidget.deleteSelected)
        self.xypositionListWidget_deleteAllButton.clicked.connect(self.xypositionListWidget.deleteAll)
        self.xypositionListWidget_moveUpButton.clicked.connect(self.xypositionListWidget.moveUp)
        self.xypositionListWidget_moveDownButton.clicked.connect(self.xypositionListWidget.moveDown)
        self.xypositionListWidget_moveToButton.clicked.connect(self.xypositionListWidget.moveToPos)
        self.xypositionListWidget_addButton.clicked.connect(lambda: self.xypositionListWidget.addNewEntry(textEntry=&#34;Your Text Entry&#34;))
        
        #Open the GridManager GUI
        self.xypositionListWidget_createGridButton.clicked.connect(lambda: self.xypositionListWidget_XYGridManager.openGUI())

        #Adding widgets to layout
        xyLayout.addWidget(self.xy_stagesDropdownLabel,0,0)
        xyLayout.addWidget(self.xy_stagesDropdown,0,1)
        xyLayout.addWidget(self.xypositionListWidget,1,0,12,1)
        xyLayout.addWidget(self.xypositionListWidget_deleteButton,2,1)
        xyLayout.addWidget(self.xypositionListWidget_deleteAllButton,3,1)
        xyLayout.addWidget(self.xypositionListWidget_moveUpButton,4,1)
        xyLayout.addWidget(self.xypositionListWidget_moveDownButton,5,1)
        xyLayout.addWidget(self.xypositionListWidget_moveToButton,6,1)
        xyLayout.addWidget(self.xypositionListWidget_addButton,7,1)
        xyLayout.addWidget(self.xypositionListWidget_createGridButton,8,1)
        
        #Pre-load entries if they exist:
        if self.GUI_xy_pos_fullInfo != None:
            for entry in self.GUI_xy_pos_fullInfo:
                self.xypositionListWidget.addNewEntry(textEntry=entry[0],id=int(entry[1]),setxy=[float(entry[2]),float(entry[3])])
        
        #Add a callback lambda
        self.xypositionListWidget.itemChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- Z widget widget -----------------------------------------------
        #First a dropdown to select the 1d stage:
        self.z_oneDstageDropdownLabel = QLabel(&#34;Z Stage:&#34;)
        self.z_oneDstageDropdown = QComboBox()
        oneDstages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
        #add the options to the dropdown:
        for stage in oneDstages:
            self.z_oneDstageDropdown.addItem(stage)
        if self.z_stage_sel is not None:
            if self.z_stage_sel in oneDstages:
                self.z_oneDstageDropdown.setCurrentText(self.z_stage_sel)
        #Create all other buttons/lineedits
        self.z_startLabel = QLabel(&#34;Start:&#34;)
        self.z_startEntry = QLineEdit()
        if self.z_start is not None:
            self.z_startEntry.setText(str(self.z_start))
        self.z_startEntry.setValidator(QDoubleValidator())
        self.z_startSetButton = QPushButton(&#39;Set&#39;)
        self.z_startSetButton.clicked.connect(lambda: self.setZStart())
        self.z_endLabel = QLabel(&#34;End:&#34;)
        self.z_endEntry = QLineEdit()
        if self.z_end is not None:
            self.z_endEntry.setText(str(self.z_end))
        self.z_endEntry.setValidator(QDoubleValidator())
        self.z_endSetButton = QPushButton(&#39;Set&#39;)
        self.z_endSetButton.clicked.connect(lambda: self.setZEnd())
        
        #add radio buttons:
        self.z_nrsteps_radio= QRadioButton(&#34;Number of steps: &#34;)
        self.z_stepdistance_radio= QRadioButton(&#34;Step distance: &#34;)
        #preselect the nr of steps one:
        if self.z_nrsteps_radio_sel == True:
            self.z_nrsteps_radio.setChecked(True)
        elif self.z_stepdistance_radio_sel == True:
            self.z_stepdistance_radio.setChecked(True)
        else:
            self.z_nrsteps_radio.setChecked(True)
        #add edit boxes for number of steps and step distance:
        self.z_nrsteps_entry = QLineEdit()
        if self.z_nr_steps is not None:
            self.z_nrsteps_entry.setText(str(self.z_nr_steps))
        self.z_nrsteps_entry.setValidator(QIntValidator())
        self.z_stepdistance_entry = QLineEdit()
        if self.z_step_distance is not None:
            self.z_stepdistance_entry.setText(str(self.z_step_distance))
        self.z_stepdistance_entry.setValidator(QDoubleValidator())
        
        #Add all widgets to layout
        zLayout.addWidget(self.z_oneDstageDropdownLabel,0,0)
        zLayout.addWidget(self.z_oneDstageDropdown,0,1)
        zLayout.addWidget(self.z_startLabel,1,0)
        zLayout.addWidget(self.z_startEntry,1,1)
        zLayout.addWidget(self.z_startSetButton,1,2)
        zLayout.addWidget(self.z_endLabel,2,0)
        zLayout.addWidget(self.z_endEntry,2,1)
        zLayout.addWidget(self.z_endSetButton,2,2)
        zLayout.addWidget(self.z_nrsteps_radio,3,0)
        zLayout.addWidget(self.z_nrsteps_entry,3,1)
        zLayout.addWidget(self.z_stepdistance_radio,4,0)
        zLayout.addWidget(self.z_stepdistance_entry,4,1)
        
        #run get_MDA_events_from_GUI when the text or dropdown is changed:
        self.z_oneDstageDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_startEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_endEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_nrsteps_radio.toggled.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_stepdistance_radio.toggled.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_nrsteps_entry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
        self.z_stepdistance_entry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())

        # --- Ordering widget ---
        #Note: only used in updateGUIwidgets
        
        #--------------- Channel widget -----------------------------------------------
        #Adding a list widget to add a list of channels
        self.channelListWidget = ChannelList(parent=self)
        self.channelListWidget.setColumNames([&#34;Channel Setting&#34;, &#34;Exposure&#34;])
        
        #Add possible channels
        self.channelDropdownLabel = QLabel(&#34;Channel:&#34;)
        self.channelDropdown = QComboBox()
        
        #Figure out from all config groups which ones are &#34;dropdown&#34;
        nrconfiggroups = self.core.get_available_config_groups().size()
        allConfigGroups={}
        for config_group_id in range(nrconfiggroups):
            allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
        comboboxindexes = []
        for config_group_id in range(nrconfiggroups):
            if allConfigGroups[config_group_id].isDropDown():
                comboboxindexes.append(config_group_id)
        ComboBoxes = {key: allConfigGroups[key] for key in comboboxindexes}
        ComboBoxNames = {allConfigGroups[key].configGroupName() for key in comboboxindexes}
        
        #add the options to the dropdown:
        for combobox in ComboBoxes:
            self.channelDropdown.addItem(allConfigGroups[combobox].configGroupName())
        #Add a callback if we change this dropdown:
        self.channelDropdown.currentIndexChanged.connect(lambda: self.channelListWidget.setChannelName(self.channelDropdown.currentText()))
        #Also delete all the current entries
        self.channelDropdown.currentIndexChanged.connect(lambda: self.channelListWidget.deleteAll())
        
        #Initisalise the channel  list
        self.channelListWidget.setChannelName(self.channelDropdown.currentText)
        
        
        #Buttons for the channel position list
        self.channelListWidget_deleteButton = QPushButton(&#39;Delete Selected&#39;)
        self.channelListWidget_moveUpButton = QPushButton(&#39;Move Up&#39;)
        self.channelListWidget_moveDownButton = QPushButton(&#39;Move Down&#39;)
        self.channelListWidget_addButton = QPushButton(&#39;Add New Entry&#39;)
        self.channelListWidget_deleteAllButton = QPushButton(&#39;Delete All&#39;)
        #Adding callbacks to the channel list buttons
        self.channelListWidget_deleteButton.clicked.connect(self.channelListWidget.deleteSelected)
        self.channelListWidget_deleteAllButton.clicked.connect(self.channelListWidget.deleteAll)
        self.channelListWidget_moveUpButton.clicked.connect(self.channelListWidget.moveUp)
        self.channelListWidget_moveDownButton.clicked.connect(self.channelListWidget.moveDown)
        self.channelListWidget_addButton.clicked.connect(lambda: self.channelListWidget.addNewEntry())

        #Adding widgets to layout
        channelLayout.addWidget(self.channelDropdownLabel,0,0)
        channelLayout.addWidget(self.channelDropdown,0,1)
        channelLayout.addWidget(self.channelListWidget,1,0,6,1)
        channelLayout.addWidget(self.channelListWidget_deleteButton,2,1)
        channelLayout.addWidget(self.channelListWidget_moveUpButton,3,1)
        channelLayout.addWidget(self.channelListWidget_moveDownButton,4,1)
        channelLayout.addWidget(self.channelListWidget_addButton,5,1)
        channelLayout.addWidget(self.channelListWidget_deleteAllButton,6,1)

        #Add the pre-set channels:
        if self.channel_group in ComboBoxNames:
            if self.channel_group is not None:
                self.channelDropdown.setCurrentText(self.channel_group)
        if self.channels is not None and self.channel_exposures_ms is not None:
            for entry in range(len(self.channels)):
                self.channelListWidget.addNewEntry(channelEntry=self.channels[entry],exposureEntry=str(self.channel_exposures_ms[entry]))
                
        #Change MDA events when adapted
        self.channelListWidget.itemChanged.connect(lambda: self.get_MDA_events_from_GUI())
        
        #--------------- Show options widget -----------------------------------------------
        #This should have checkboxes for exposure, xy, z, channel, time, order, storage. If these checkboxes are clicked, the GUI should be updated accordingly:
        self.GUI_show_exposure_chkbox = QCheckBox(&#34;Exposure&#34;) #Note: created but never rendered
        self.GUI_show_xy_chkbox = QCheckBox(&#34;XY&#34;)
        self.GUI_show_z_chkbox = QCheckBox(&#34;Z&#34;)
        self.GUI_show_channel_chkbox = QCheckBox(&#34;Channel&#34;)
        self.GUI_show_time_chkbox = QCheckBox(&#34;Time&#34;)
        self.GUI_show_storage_chkbox = QCheckBox(&#34;Storage&#34;)
        #initialise the checkboxes based on the values in this GUI:
        self.GUI_show_exposure_chkbox.setChecked(self.GUI_show_exposure) #Note: created but never rendered
        self.GUI_show_xy_chkbox.setChecked(self.GUI_show_xy)
        self.GUI_show_z_chkbox.setChecked(self.GUI_show_z)
        self.GUI_show_channel_chkbox.setChecked(self.GUI_show_channel)
        self.GUI_show_time_chkbox.setChecked(self.GUI_show_time)
        self.GUI_show_storage_chkbox.setChecked(self.GUI_show_storage)
        #Add lambda functions to all of them that all run the same function: showOptionChanged():
        # self.GUI_show_exposure_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_xy_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_z_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_channel_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_time_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        self.GUI_show_storage_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
        
        font = QFont()
        font.setPointSize(7)  # Set the desired font size

        [checkbox.setFont(font) for checkbox in [self.GUI_show_exposure_chkbox, self.GUI_show_xy_chkbox, self.GUI_show_z_chkbox, self.GUI_show_channel_chkbox, self.GUI_show_time_chkbox, self.GUI_show_storage_chkbox]]

        #Add all checkboxes to the options-layout
        # showOptionsLayout.addWidget(self.GUI_show_exposure_chkbox,0,0)
        showOptionsLayout.addWidget(self.GUI_show_time_chkbox,0,0)
        showOptionsLayout.addWidget(self.GUI_show_xy_chkbox,0,1)
        showOptionsLayout.addWidget(self.GUI_show_z_chkbox,0,2)
        showOptionsLayout.addWidget(self.GUI_show_channel_chkbox,1,0)
        showOptionsLayout.addWidget(self.GUI_show_storage_chkbox,1,1)
        
        # ---------- Combining all to the main layout -----------------------------------------
        # Set layouts for each groupbox
        self.exposureGroupBox.setLayout(exposureLayout)
        self.xyGroupBox.setLayout(xyLayout)
        self.zGroupBox.setLayout(zLayout)
        self.channelGroupBox.setLayout(channelLayout)
        self.timeGroupBox.setLayout(timeLayout)
        self.storageGroupBox.setLayout(storageLayout)
        self.showOptionsGroupBox.setLayout(showOptionsLayout)

        # Add groupboxes to the main layout, only if they should be shown. The position of the gridbox is based on whether the previous ones are added or not:
        self.updateGUIwidgets(GUI_show_exposure=GUI_show_exposure,GUI_show_xy=GUI_show_xy, GUI_show_z=GUI_show_z, GUI_show_channel=GUI_show_channel, GUI_show_time=GUI_show_time, GUI_show_storage=GUI_show_storage,GUI_showOptions=GUI_showOptions,GUI_acquire_button=GUI_acquire_button)
        
        #Change the font of everything in the layout
        self.set_font_and_margins_recursive(self.gui, font=QFont(&#34;Arial&#34;, 7))
        #Twice because it relies on dependancies inside qgridlayouts
        self.set_font_and_margins_recursive(self.gui, font=QFont(&#34;Arial&#34;, 7))
        
        if self.layout is not None:
            #Add the layout to the main layout
            try:
                self.layout.addLayout(self.gui,0,0)
            except:
                self.setLayout(self.gui)
                self.mainLayout = self.gui
            
            # Changing font and padding of all widgets
            font = QFont(&#34;Arial&#34;, 7)
            for i in range(self.gui.count()):
                try:
                    item = self.gui.itemAt(i)
                    if item.widget():
                        item.widget().setFont(font)
                        item.widget().setStyleSheet(&#34;padding: 2px; margin: 1px; spacing: 1px;&#34;)  # Change padding as needed
                except:
                    pass
    
    def handleSizeChange(self, size):
        &#34;&#34;&#34;
        Handle a change in size by adjusting the number of columns in the GUI grid.
        
        Args:
            size: The new size of the GUI window.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        newNrColumns = max(1,min(10, size.width() // 150))
        self.GUI_grid_width = newNrColumns
    
    def getDevicesOfDeviceType(self,devicetype):
        &#34;&#34;&#34;
        Find all devices that have a specific devicetype.
        
        Args:
            devicetype (str): The type of device to search for. Refer to https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html for all devicetypes.
        
        Returns:
            list: A list of devices that match the specified devicetype.
        &#34;&#34;&#34;
        
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        #Get devices
        devices = self.core.get_loaded_devices()
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.core.get_device_type(device).to_string() == devicetype:
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType
    
    def createOrderLayout(self,GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice = None):
        &#34;&#34;&#34;
        Create an order (&#39;t&#39;,&#39;tc&#39;, etc) layout based on the provided parameters.
        
        Args:
            GUI_show_channel (bool): Whether to include channel in the layout.
            GUI_show_time (bool): Whether to include time in the layout.
            GUI_show_xy (bool): Whether to include xy in the layout.
            GUI_show_z (bool): Whether to include z in the layout.
            orderChoice (str, optional): The default order choice. Defaults to None.
        
        Returns:
            QVBoxLayout: The layout containing the order dropdown and label.
        &#34;&#34;&#34;
        
        orderLayout = QVBoxLayout()
        letters_to_include = &#39;&#39;
        if GUI_show_channel:
            letters_to_include += &#39;c&#39;
        if GUI_show_time:
            letters_to_include += &#39;t&#39;
        if GUI_show_xy:
            letters_to_include += &#39;p&#39;
        if GUI_show_z:
            letters_to_include += &#39;z&#39;
        #Now we create an array with all possible combinations of these letters:
        permuatations = [&#39;&#39;.join(comb) for comb in itertools.permutations(letters_to_include, len(letters_to_include))]
        self.orderDropdown = QComboBox()
        self.orderDropdown.currentTextChanged.connect(lambda: self.get_MDA_events_from_GUI())
        #add the options to the dropdown:
        for option in permuatations:
            self.orderDropdown.addItem(option)
        #Create a label:
        self.orderLabel = QLabel(&#34;Order:&#34;)
        
        #Show the widgets.
        orderLayout.addWidget(self.orderLabel)
        orderLayout.addWidget(self.orderDropdown)
        
        if orderChoice in permuatations:
            if orderChoice is not None:
                self.orderDropdown.setCurrentText(orderChoice)
        
        return orderLayout
        
    def showOptionChanged(self):
        &#34;&#34;&#34;
        Updates the GUI widgets based on the checkbox values.
        
        This function will be called when the checkboxes are clicked. It will update the GUI accordingly.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.setAllCheckBoxEnableValues()
        #This function will be called when the checkboxes are clicked. It will update the GUI accordingly:
        self.updateGUIwidgets(GUI_show_exposure=self.GUI_show_exposure_chkbox.isChecked(), GUI_show_xy = self.GUI_show_xy_chkbox.isChecked(), GUI_show_z=self.GUI_show_z_chkbox.isChecked(), GUI_show_channel=self.GUI_show_channel_chkbox.isChecked(), GUI_show_time=self.GUI_show_time_chkbox.isChecked(), GUI_show_storage=self.GUI_show_storage_chkbox.isChecked(),GUI_showOptions=True,GUI_acquire_button=self.GUI_acquire_button)
        self.get_MDA_events_from_GUI()
    
    def setAllCheckBoxEnableValues(self):
        &#34;&#34;&#34;
        Set the enable values for all the checkboxes.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.GUI_exposure_enabled = self.GUI_show_exposure_chkbox.isChecked()
        self.GUI_xy_enabled = self.GUI_show_xy_chkbox.isChecked()
        self.GUI_z_enabled = self.GUI_show_z_chkbox.isChecked()
        self.GUI_channel_enabled = self.GUI_show_channel_chkbox.isChecked()
        self.GUI_time_enabled = self.GUI_show_time_chkbox.isChecked()
        self.GUI_storage_enabled = self.GUI_show_storage_chkbox.isChecked()
        self.GUI_show_exposure = self.GUI_show_exposure_chkbox.isChecked()
        self.GUI_show_xy = self.GUI_show_xy_chkbox.isChecked()
        self.GUI_show_z = self.GUI_show_z_chkbox.isChecked()
        self.GUI_show_channel = self.GUI_show_channel_chkbox.isChecked()
        self.GUI_show_time = self.GUI_show_time_chkbox.isChecked()
        self.GUI_show_storage = self.GUI_show_storage_chkbox.isChecked()
    
    def updateGUIwidgets(self,GUI_show_exposure=True, GUI_show_xy = False, GUI_show_z=True, GUI_show_channel=False, GUI_show_time=True, GUI_show_storage=True,GUI_showOptions=True,gridWidth=4,GUI_acquire_button=True):
        &#34;&#34;&#34;
        Updates the GUI widgets based on the specified parameters.
        
        Args:
            GUI_show_exposure (bool): Whether to show the exposure widget. Default is True.
            GUI_show_xy (bool): Whether to show the XY widget. Default is False.
            GUI_show_z (bool): Whether to show the Z widget. Default is True.
            GUI_show_channel (bool): Whether to show the channel widget. Default is False.
            GUI_show_time (bool): Whether to show the time widget. Default is True.
            GUI_show_storage (bool): Whether to show the storage widget. Default is True.
            GUI_showOptions (bool): Whether to show the options widget. Default is True.
            gridWidth (int): The width of the grid. Default is 4.
            GUI_acquire_button (bool): Whether to show the acquire button. Default is True.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        gridWidth = self.GUI_grid_width
        # Remove the widgets from their parent
        self.exposureGroupBox.setParent(None) # type: ignore
        self.xyGroupBox.setParent(None) # type: ignore
        self.zGroupBox.setParent(None) # type: ignore
        self.channelGroupBox.setParent(None) # type: ignore
        self.timeGroupBox.setParent(None) # type: ignore
        # # self.orderGroupBox.setParent(None) # type: ignore
        self.storageGroupBox.setParent(None) # type: ignore
        self.showOptionsGroupBox.setParent(None)  # type: ignore


        # Clear the layout - this is required
        while self.gui.count(): # type: ignore
            item = self.gui.takeAt(0) # type: ignore
            widget = item.widget()
            if widget:
                widget.deleteLater()
        #redraw the self.gui:
        self.gui.update()
        QCoreApplication.processEvents()
        
        # At the beginning add an options groupbox, which has all the checkboxes and storage/acquire
        optionsBGroupBox = QWidget()
        optionsBLayout = QVBoxLayout()
        optionsBGroupBox.setLayout(optionsBLayout)
        optionsBLayout.addWidget(self.showOptionsGroupBox) # type: ignore
        self.showOptionsGroupBox.setEnabled(True)
        optionsBLayout.addWidget(self.storageGroupBox) # type: ignore
        if GUI_show_storage: 
            self.storageGroupBox.setEnabled(True)
        else:
            self.storageGroupBox.setEnabled(False)
        self.GUI_acquire_button = QPushButton(&#34;Acquire&#34;)
        self.GUI_acquire_button.clicked.connect(lambda index: self.MDA_acq_from_GUI(mdaLayerName=&#39;MDA&#39;))
        optionsBLayout.addWidget(self.GUI_acquire_button) # type: ignore
        if GUI_acquire_button:
            self.GUI_acquire_button.setEnabled(True)
        else:
            self.GUI_acquire_button.setEnabled(False)
        
        self.gui.addWidget(optionsBGroupBox, 0, 0) # type: ignore
        
        #Add order/exposure/time as single groupbox
        orderexposuretimegroupbox = QWidget()
        orderexposuretimelayout = QVBoxLayout()
        orderexposuretimegroupbox.setLayout(orderexposuretimelayout)
        
        if GUI_show_exposure:
            self.exposureGroupBox.setEnabled(True)
        else:
            self.exposureGroupBox.setEnabled(False)
            
        self.orderGroupBox = QGroupBox(&#34;Order&#34;)
        orderlayout = self.createOrderLayout(GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice=self.order)
        self.orderGroupBox.setLayout(orderlayout)
        
        orderexposuretimelayout.addWidget(self.orderGroupBox) # type: ignore
        orderexposuretimelayout.addWidget(self.exposureGroupBox) # type: ignore
        orderexposuretimelayout.addWidget(self.timeGroupBox) # type: ignore
        if GUI_show_time:
            self.timeGroupBox.setEnabled(True)
        else:
            self.timeGroupBox.setEnabled(False)
        #     # QCoreApplication.processEvents()
        self.gui.addWidget(orderexposuretimegroupbox, 1//gridWidth, 1%gridWidth) # type: ignore
        
        #Add XY, Z, Channel, groupboxes as individual groupboxes
        curindex = 2
        self.gui.addWidget(self.xyGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
        curindex+=1
        if GUI_show_xy:
            self.xyGroupBox.setEnabled(True)
        else:
            self.xyGroupBox.setEnabled(False)
            # QCoreApplication.processEvents()
        self.gui.addWidget(self.zGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
        curindex+=1
        if GUI_show_z:
            self.zGroupBox.setEnabled(True)
        else:
            self.zGroupBox.setEnabled(False)
            # QCoreApplication.processEvents()
        self.gui.addWidget(self.channelGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
        curindex+=1
        if GUI_show_channel:
            self.channelGroupBox.setEnabled(True)
        else:
            self.channelGroupBox.setEnabled(False)
            # QCoreApplication.processEvents()
        
        
        self.gui.setColumnStretch(99,gridWidth+1) # type: ignore
        self.gui.setRowStretch(99,gridWidth+1) # type: ignore
        
        #try to trigger a dock widget resize event at this point.
        mdawidget_object = self.gui.parent() #type:ignore
        try:
            logging.debug(&#39;attempting to update parent&#39;)
            from PyQt5.QtCore import QEvent
            current_size = mdawidget_object.size() #type:ignore
            resize_event = QEvent(QEvent.Resize) #type:ignore
            resize_event.oldSize = lambda: current_size #type:ignore
            resize_event.size = lambda: current_size #type:ignore
            QApplication.sendEvent(mdawidget_object, resize_event)
        except:
            logging.debug(&#39;did not attempt to update parent&#39;)
        
        
        QCoreApplication.processEvents()
        
        #redraw the self.gui:
        self.gui.update()
    
    def printText(self):
        &#34;&#34;&#34;
        Prints the events obtained from the getEvents method.
        
        Args:
            self: The object instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.info(self.getEvents())
    
    def getEvents(self):
        &#34;&#34;&#34;
        Get the MDA events from the object.
        
        Returns:
            The MDA events stored in the object.
        &#34;&#34;&#34;
        return self.mda
    
    def getGui(self):
        &#34;&#34;&#34;
        Returns the GUI object.
        
        Args:
            None
        
        Returns:
            The GUI object.
        &#34;&#34;&#34;
        return self
    
    def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
        &#34;&#34;&#34;
        Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
        Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.

        &#34;&#34;&#34;
        
        if isinstance(widget, (QPushButton)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)
        if isinstance(widget, (QLabel, QComboBox)):
            widget.setFont(font)
            # widget.setContentsMargins(0, 0, 0, 0)
            # widget.setMinimumSize(20, 20)

        if isinstance(widget, QGroupBox):
            widget.setSizePolicy(
                QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            )
            # Ensure QGroupBox respects the size of its contents
            widget.setMinimumSize(widget.minimumSizeHint())  # Set the minimum size of QGroupBox based on its size hint

        try:
            minsize = widget.minimumSizeHint()
            if minsize[0] &gt; -1 and minsize[1] &gt; -1:
                widget.setMinimumSize(widget.minimumSizeHint())
        except:
            pass

        if hasattr(widget, &#39;layout&#39;):
            layout = widget.layout()
            if layout:
                # layout.setContentsMargins(0, 0, 0, 0)
                # layout.setSpacing(0)  # Optionally, remove spacing between widgets
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if hasattr(item, &#39;widget&#39;):
                        self.set_font_and_margins_recursive(item.widget(), font=font)
                    if hasattr(item, &#39;layout&#39;):
                        self.set_font_and_margins_recursive(item.layout(), font=font)
    
    #endregion
    
    #region Multi-D acquisition logic
    def MDA_acq_finished(self):
        &#34;&#34;&#34;
        Signal that MDA acquisition has finished.
        
        Disconnects the signal, stores the acquired data, and updates the status of connected nodes in the nodz-coupled visualization and real-time analysis.
        
        Args:
            self: The object instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        self.shared_data.mda_acq_done_signal.disconnect(self.MDA_acq_finished)
        self.data = self.shared_data.mdaDatasets[-1]
        
        logging.info(&#39;MDA acq data finished and data stored!&#39;)
        self.shared_data._mdaMode = False
        
        #Remove any existing nodz-coupled real-time analyses:
        if &#39;nodz_analysis_threads&#39; in vars(self):
            for analysis_thread in self.nodz_analysis_threads:
                analysis_thread.stop()
        
        #Set the status of the nodz-coupled vis and real-time to finished, and add nodz-based variables:
        if &#39;nodeInfo&#39; in vars(self) and self.nodeInfo is not None:
            logging.debug(&#39;This MDA acq data was connected to node: &#39; + self.nodeInfo.name)
            self.updateNodzVariables()
            self.nodeInfo.status=&#39;finished&#39;
            self.nodeInfo.flowChart.update()

        #Look at the &#39;Visual&#39; bottom attribute:
            visualAttr = self.nodeInfo.bottomAttrs[&#39;Visual&#39;]
            if len(visualAttr.connections) &gt; 0:
                visual_connected_node_name = visualAttr.connections[0].socketNode
                for node in self.nodeInfo.flowChart.nodes:
                    if node.name == visual_connected_node_name:
                        visual_connected_node = node
                        visual_connected_node.status = &#39;finished&#39;
            
            #Look at the &#39;Real-time&#39; bottom attribute:
            RealTimeAttr = self.nodeInfo.bottomAttrs[&#39;Real-time&#39;]
            if len(RealTimeAttr.connections) &gt; 0:
                self.nodz_analysis_threads = []
                rt_analysis_connected_node_name = RealTimeAttr.connections[0].socketNode
                for node in self.nodeInfo.flowChart.nodes:
                    if node.name == rt_analysis_connected_node_name:
                        rt_analysis_connected_node = node
                        rt_analysis_connected_node.status = &#39;finished&#39;
        
        #reset the MDA button in the GUI
        self.resetMDAbutton(mdaLayerName=&#39;MDA&#39;)
        logging.debug(&#39;about to emit MDA_completed&#39;)
        self.MDA_completed.emit(True)
    
    def MDA_acq_from_Node(self, nodeInfo):
        &#34;&#34;&#34;MDA_acq_from_Node(self, nodeInfo)
        
        Basically the same as MDA_from_GUI, but with the NodeInfo.
        
        Args:
            self: The object itself.
            nodeInfo: Information about the node.
        
        Returns:
            None
        
        Raises:
            None
        
        This function acquires data from a node and performs various operations based on the node information provided.
        &#34;&#34;&#34;
        logging.debug(&#39;At MDA_acq_from_node&#39;)
        nodeName = nodeInfo.name
        
        self.nodeInfo = nodeInfo
        
        #Look at the &#39;Visual&#39; bottom attribute:
        visualAttr = nodeInfo.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            for connection in visualAttr.connections:
                if connection.plugAttr is not None and connection.socketAttr is not None and connection.plugItem is not None and connection.socketItem is not None and connection.plugNode is not None and connection.socketNode is not None:
                    visual_connected_node_name = connection.socketNode
                    for node in nodeInfo.flowChart.nodes:
                        if node.name == visual_connected_node_name:
                            visual_connected_node = node
                            if &#39;layerName&#39; in visual_connected_node.visualisation_currentData and visual_connected_node.visualisation_currentData[&#39;layerName&#39;] is not None:
                                layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                            else:
                                visual_connected_node.visualisation_currentData[&#39;layerName&#39;] = nodeName
                                layerName = nodeName
                                
                            if &#39;colormap&#39; in visual_connected_node.visualisation_currentData and visual_connected_node.visualisation_currentData[&#39;colormap&#39;] is not None:
                                colormap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                            else:
                                visual_connected_node.visualisation_currentData[&#39;colormap&#39;] = &#39;gray&#39;
                                colormap = &#39;gray&#39;
                            
                            visual_connected_node.status = &#39;running&#39;
                            break
                
                    logging.debug(&#39;Starting Nodz-MDA visualisation&#39;)
                    #Prepare layerName for shared_data to order the layers later.
                    #Import here to prevent circular import
                    if is_pip_installed():
                        from glados_pycromanager.GUI.napariGlados import startMDAVisualisation
                    else:
                        from napariGlados import startMDAVisualisation
                    self.shared_data.newestLayerName = layerName
                    startMDAVisualisation(self.shared_data,layerName=layerName,layerColorMap=colormap)
        
        #And try to get real-time analysis attributes at bottom:
        
        #Look at the &#39;Real-time&#39; bottom attribute:
        RealTimeAttr = nodeInfo.bottomAttrs[&#39;Real-time&#39;]
        if len(RealTimeAttr.connections) &gt; 0:
            self.nodz_analysis_threads = []
            rt_analysis_connected_node_name = RealTimeAttr.connections[0].socketNode
            for node in nodeInfo.flowChart.nodes:
                if node.name == rt_analysis_connected_node_name:
                    rt_analysis_connected_node = node
                    rt_analysis_info = rt_analysis_connected_node.real_time_analysis_currentData
                    
                    new_analysis_thread = create_real_time_analysis_thread(self.shared_data,analysisInfo = rt_analysis_info,delay=None,nodzInfo=nodeInfo.flowChart)
                    self.nodz_analysis_threads.append(new_analysis_thread)
                    rt_analysis_connected_node.status = &#39;running&#39;
                    
                    
        self.shared_data._mdaMode = False
        
        #Set the exposure time:
        self.core.set_exposure(self.exposure_ms)
        
        #Set the location where to save the mda
        Evaled_storage_file_name = utils.attemptToEvaluateVariables(self.storage_file_name,nodeInfo.flowChart)
        Evaled_storage_folder = utils.attemptToEvaluateVariables(self.storage_folder,nodeInfo.flowChart)
        
        self.shared_data._mdaModeSaveLoc = [Evaled_storage_folder,Evaled_storage_file_name]
        #Set whether the napariviewer should (also) try to connect to the mda
        # self.shared_data._mdaModeNapariViewer = self.shared_data.napariViewer
        #Set the mda parameters
        self.shared_data._mdaModeParams = self.mda
        #Set this MDA object as the active MDA object in the shared_data
        self.shared_data.activeMDAobject = self
        self.shared_data.mda_acq_done_signal.connect(self.MDA_acq_finished)
        #And set the mdamode to be true
        self.shared_data.mdaMode = True
        logging.debug(&#39;ended setting mdamode params&#39;)
        
        pass
    
    def MDA_acq_from_GUI(self, mdaLayerName=None):
        &#34;&#34;&#34;
        The MDA_acq_from_GUI function is called when the user presses the &#39;Start MDA&#39; button in the GUI.
        It sets all of the parameters for an MDA acquisition, and then starts it by calling startMDAacq()
        
        Args:
            self: Refer to the instance of the class
            mdaLayerName: Set the name of the napari layer that will be created for this mda
        
        Returns:
            Nothing
        
        Doc Author:
            Trelent
        &#34;&#34;&#34;
        logging.debug(&#39;At MDA_acq_from_GUI&#39;)
        self.shared_data._mdaMode = False
        
        #Set the exposure time:
        self.core.set_exposure(self.exposure_ms)
        
        #Set the location where to save the mda
        if self.GUI_storage_enabled:
            self.shared_data._mdaModeSaveLoc = [self.storage_folder,self.storage_file_name]
        else:
            self.shared_data._mdaModeSaveLoc = [&#39;&#39;,&#39;&#39;]
        #Set whether the napariviewer should (also) try to connect to the mda
        # self.shared_data._mdaModeNapariViewer = self.shared_data.napariViewer
        #Set the mda parameters
        
        self.shared_data._mdaModeParams = self.mda
        #Set this MDA object as the active MDA object in the shared_data
        self.shared_data.activeMDAobject = self
        self.shared_data.mda_acq_done_signal.connect(self.MDA_acq_finished)
        #And set the mdamode to be true
        self.shared_data.mdaMode = True
        #And start visualization
        if mdaLayerName is not None:
            #Import here to prevent circular import
            if is_pip_installed():
                from glados_pycromanager.GUI.napariGlados import startMDAVisualisation
            else:
                from napariGlados import startMDAVisualisation
            startMDAVisualisation(self.shared_data,layerName=mdaLayerName)
        logging.debug(&#39;ended setting mdamode params&#39;)
        
        #Set the Acquire button to say &#39;stop&#39;
        self.GUI_acquire_button.setText(&#39;Stop Acquisition&#39;) #type:ignore
        #Remove active clicked-connect-calls:
        self.GUI_acquire_button.clicked.disconnect() #type:ignore
        self.GUI_acquire_button.clicked.connect(lambda index: self.stopMDA(mdaLayerName=&#39;MDA&#39;)) #type:ignore
        pass
    
    def resetMDAbutton(self,mdaLayerName=&#39;MDA&#39;):
        &#34;&#34;&#34;
        Function that resets the Acquire button (i.e. if acq is running, it shows &#39;stop acquisition&#39;, this should go back to &#39;acquire&#39; and the connected call)
        &#34;&#34;&#34;
        #ATM, first just update the button back and show that we can access this:
        if self.GUI_acquire_button is not None:
            try:
                self.GUI_acquire_button.setText(&#39;Acquire&#39;) #type:ignore
                #Remove active clicked-connect-calls:
                self.GUI_acquire_button.clicked.disconnect() #type:ignore
                self.GUI_acquire_button.clicked.connect(lambda index: self.MDA_acq_from_GUI(mdaLayerName=mdaLayerName)) #type:ignore
            except RuntimeError:
                pass #C/C++ object has been deleted if called from Nodz.
    
    def stopMDA(self,mdaLayerName=&#39;MDA&#39;):
        &#34;&#34;&#34;
        The stopMDA function is called when the user presses the &#39;Stop Acquisition&#39; button in the GUI.
        It stops the MDA acquisition.
        &#34;&#34;&#34;
        
        logging.info(&#39;Attempting to stop MDA&#39;)
        #Reset the button
        self.resetMDAbutton(mdaLayerName=mdaLayerName)
        #Abort the mda mode
        self.shared_data._mdaModeAcqData.abort()
    
    def get_MDA_events_from_GUI(self):
        &#34;&#34;&#34;
        The get_MDA_events_from_GUI function is called every time the user changes any option in the GUI.
        It will then update all variables that are used to create an MDA object, which can be used to run a multi-dimensional acquisition.
        
        
        Args:
            self: Refer to the object itself
        &#34;&#34;&#34;
        logging.debug(&#39;starting get_MDA_events_from_GUI&#39;)
        #Make this somewhat readable:
        if self.exposureGroupBox.isEnabled():
            try:
                self.exposure_ms = float(self.exposureEntry.text())
                self.exposure_s_or_ms = &#39;ms&#39;
                if self.exposureDropdown.currentText() == &#39;s&#39;:
                    self.exposure_ms *= 1000
                    self.exposure_s_or_ms = &#39;s&#39;
            except:
                self.exposure_ms = None
                self.exposure_s_or_ms = &#39;ms&#39;
        
        if self.timeGroupBox.isEnabled():
            try:
                self.num_time_points = int(self.timePointEntry.text())
                self.time_interval_s = float(self.timeIntervalEntry.text())
                self.time_interval_s_or_ms = &#39;s&#39;
                if self.timeIntervalDropdown.currentText() == &#39;ms&#39;:
                    self.time_interval_s_or_ms = &#39;ms&#39;
                    self.time_interval_s /= 1000
            except:
                self.num_time_points = None
                self.time_interval_s = None
                self.time_interval_s_or_ms = &#39;ms&#39;
                
        # if self.orderGroupBox.isEnabled():
        self.order = self.orderDropdown.currentText()
        
        if self.storageGroupBox.isEnabled():
            self.storage_folder = self.storageFolderEntry.text()
            self.storage_file_name = self.storageFileNameEntry.text()
        
        if self.zGroupBox.isEnabled():
            try:
                #We also need to set the shared_data focus device for proper z-functioning
                self.shared_data.core.set_focus_device(self.z_oneDstageDropdown.currentText())
            except:
                self.shared_data.core.set_focus_device(self.shared_data._defaultFocusDevice)
                
            self.z_stage_sel = self.z_oneDstageDropdown.currentText()
            
            if self.z_startEntry.text() != &#39;&#39;:
                self.z_start = (float(self.z_startEntry.text()))
            else:
                self.z_start = None
                
            if self.z_endEntry.text() != &#39;&#39;:
                self.z_end = (float(self.z_endEntry.text()))
            else:
                self.z_end = None
                
            if self.z_nrsteps_radio.isChecked():
                if (self.z_nrsteps_entry.text() != &#39;&#39;) and self.z_start is not None and self.z_end is not None:
                    self.z_step = float((self.z_end-self.z_start)/int(self.z_nrsteps_entry.text()))
                    self.z_step_distance = None
                    self.z_nr_steps = int(self.z_nrsteps_entry.text())
                else:
                    self.z_step = None
                    self.z_step_distance = None
                    self.z_nr_steps = None
            elif self.z_stepdistance_radio.isChecked():
                if self.z_stepdistance_entry.text() != &#39;&#39; and self.z_start is not None and self.z_end is not None:
                    self.z_step = float(self.z_stepdistance_entry.text())
                    self.z_step_distance = float(self.z_stepdistance_entry.text())
                    self.z_nr_steps = None
                    if self.z_start &lt; self.z_end:
                        if self.z_step &lt; 0:
                            self.z_step*=-1
                    elif self.z_start &gt; self.z_end:
                        if self.z_step &gt; 0:
                            self.z_step*=-1
                else:
                    self.z_step = None
                    self.z_step_distance = None
                    self.z_nr_steps = None
            self.z_nrsteps_radio_sel = self.z_nrsteps_radio.isChecked()
            self.z_stepdistance_radio_sel = self.z_stepdistance_radio.isChecked()
        else:
            self.shared_data.core.set_focus_device(self.shared_data._defaultFocusDevice)
        
        #Get the xy positions
        if self.xyGroupBox.isEnabled():
            try:
                self.xy_positions = self.xypositionListWidget.getPositionsArray()
                self.xy_positions_saveInfo = self.xypositionListWidget.getSaveInfoPositionsArray()
            except:
                self.xy_positions = None
                self.xy_positions_saveInfo = None
        else:
            self.xy_positions = None
            self.xy_positions_saveInfo = None
        
        if self.channelGroupBox.isEnabled():
            try:
                
                self.channel_group = self.channelDropdown.currentText()
                
                self.channels = []
                self.channel_exposures_ms = []
                for row in range(self.channelListWidget.rowCount()):
                    for column in range(self.channelListWidget.columnCount()):
                        if column == 0:
                            self.channels.append(self.channelListWidget.cellWidget(row,0).currentText())
                        elif column == 1:
                            item = self.channelListWidget.item(row, column)
                            try: #Check if it will be float-value:
                                if item is not None:
                                    self.channel_exposures_ms.append(float(item.text()))
                                else:
                                    self.channel_exposures_ms.append(&#34;&#34;)  # Add an empty string for empty cells
                            except ValueError:  # Add an empty string for non-float
                                self.channel_exposures_ms.append(&#34;&#34;)

            except:
                self.channel_group = None
                self.channels = None
                self.channel_exposures_ms = None
        
        #Do a small catch in case z_start, z_step or z_end is None:
        if self.z_start is None or self.z_step is None or self.z_end is None:
            if self.zGroupBox.isEnabled() and self.GUI_show_z:
                #Only a warning if we actually want Z, if we don&#39;t, it&#39;s just a debug info.
                logging.info(&#34;z_start, z_step or z_end is None. These are adapted to 0/1/1.&#34;)
            else:
                logging.debug(&#34;z_start, z_step or z_end is None. These are adapted to 0/1/1.&#34;)
            self.z_start = 0
            self.z_step = 1
            self.z_end = 1
        
        #Also update the nodz variables info:
        self.updateNodzVariables()
        
        self.mda = multi_d_acquisition_events(num_time_points=self.num_time_points, time_interval_s=self.time_interval_s,z_start=self.z_start,z_end=self.z_end,z_step=self.z_step,channel_group=self.channel_group,channels=self.channels,channel_exposures_ms=self.channel_exposures_ms,xy_positions=self.xy_positions,xyz_positions=self.xyz_positions,position_labels=self.position_labels,order=self.order) #type:ignore
        
        logging.debug(f&#34;mda: {self.mda}&#34;)
        if self.fully_started:
            if self.autoSaveLoad:
                #Store in appdata
                appdata_folder = os.getenv(&#39;APPDATA&#39;)
                if appdata_folder is None:
                    raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
                app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
                os.makedirs(app_specific_folder, exist_ok=True)
                self.save_state_MDA(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
        logging.debug(&#39;ended get_MDA_events_from_GUI&#39;)
        
        pass
    
    def setZStart(self):
        &#34;&#34;&#34;
        Set the starting Z position based on the selected zstage.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        zstage = self.z_oneDstageDropdown.currentText()
        #zstage value limited to 2 decimal places:
        zstagePos = round(float(self.core.get_position(zstage)),2)
        self.z_startEntry.setText(str(zstagePos))
    
    def setZEnd(self):
        &#34;&#34;&#34;
        Set the end position of the Z stage.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        zstage = self.z_oneDstageDropdown.currentText()
        #zstage value limited to 2 decimal places:
        zstagePos = round(float(self.core.get_position(zstage)),2)
        self.z_endEntry.setText(str(zstagePos))
        
    def setMDAparams(self,mdaparams):
        &#34;&#34;&#34;
        Set the MDA parameters.
        
        Args:
            mdaparams: The MDA parameters to be set.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.mda = mdaparams
    #endregion
    
    #region Nodz-based
    def updateNodzVariables(self):
        &#34;&#34;&#34;
        Update Nodz variables (variablesNodz) with current data.
        &#34;&#34;&#34;
        if &#39;nodeInfo&#39; in vars(self) and self.nodeInfo is not None:
            utils.updateNodzVariablesTime(self.nodeInfo)
            self.nodeInfo.variablesNodz[&#39;data&#39;][&#39;data&#39;] = self.data
            self.nodeInfo.variablesNodz[&#39;order&#39;][&#39;data&#39;] = self.order
            self.nodeInfo.variablesNodz[&#39;exposure_ms&#39;][&#39;data&#39;] = self.exposure_ms
            self.nodeInfo.variablesNodz[&#39;n_timepoints&#39;][&#39;data&#39;] = self.num_time_points
            self.nodeInfo.variablesNodz[&#39;time_interval_ms&#39;][&#39;data&#39;] = self.time_interval_s*1000 #type: ignore
            if self.GUI_show_xy == True and self.xy_positions is not None:
                self.nodeInfo.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = self.xy_positions
                self.nodeInfo.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = len(self.xy_positions) #type: ignore
            else:
                self.nodeInfo.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = None
            if self.GUI_show_z == True:
                self.nodeInfo.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = [self.z_start, self.z_step, self.z_end]
                self.nodeInfo.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = self.z_nr_steps
            else:
                self.nodeInfo.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = None
            if self.GUI_show_channel == True:
                self.nodeInfo.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = self.channel_group
                self.nodeInfo.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = self.channels
                self.nodeInfo.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = len(self.channels) #type: ignore
            else:
                self.nodeInfo.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = None
                self.nodeInfo.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = None
            if self.GUI_storage_enabled == True:
                try:
                    #Update to the actually-stored-path.
                    self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = self.data.path #type: ignore
                except AttributeError:
                    #Update to the expectedpath.
                    self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = self.storage_folder+os.sep+self.storage_file_name+&#39;_1//&#39; #type: ignore
            else:
                self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = None
    #endregion</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="utils.CustomMainWindow" href="utils.html#utils.CustomMainWindow">CustomMainWindow</a></li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="MDAGlados.MDAGlados.GUI_grid_width"><code class="name">var <span class="ident">GUI_grid_width</span></code></dt>
<dd>
<div class="desc"><p>Get the width of the GUI grid.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The width of the GUI grid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def GUI_grid_width(self):
    &#34;&#34;&#34;
    Get the width of the GUI grid.
    
    Returns:
        int: The width of the GUI grid.
    &#34;&#34;&#34;
    
    return self._GUI_grid_width</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MDAGlados.MDAGlados.MDA_acq_finished"><code class="name flex">
<span>def <span class="ident">MDA_acq_finished</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal that MDA acquisition has finished.</p>
<p>Disconnects the signal, stores the acquired data, and updates the status of connected nodes in the nodz-coupled visualization and real-time analysis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The object instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MDA_acq_finished(self):
    &#34;&#34;&#34;
    Signal that MDA acquisition has finished.
    
    Disconnects the signal, stores the acquired data, and updates the status of connected nodes in the nodz-coupled visualization and real-time analysis.
    
    Args:
        self: The object instance.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    self.shared_data.mda_acq_done_signal.disconnect(self.MDA_acq_finished)
    self.data = self.shared_data.mdaDatasets[-1]
    
    logging.info(&#39;MDA acq data finished and data stored!&#39;)
    self.shared_data._mdaMode = False
    
    #Remove any existing nodz-coupled real-time analyses:
    if &#39;nodz_analysis_threads&#39; in vars(self):
        for analysis_thread in self.nodz_analysis_threads:
            analysis_thread.stop()
    
    #Set the status of the nodz-coupled vis and real-time to finished, and add nodz-based variables:
    if &#39;nodeInfo&#39; in vars(self) and self.nodeInfo is not None:
        logging.debug(&#39;This MDA acq data was connected to node: &#39; + self.nodeInfo.name)
        self.updateNodzVariables()
        self.nodeInfo.status=&#39;finished&#39;
        self.nodeInfo.flowChart.update()

    #Look at the &#39;Visual&#39; bottom attribute:
        visualAttr = self.nodeInfo.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            visual_connected_node_name = visualAttr.connections[0].socketNode
            for node in self.nodeInfo.flowChart.nodes:
                if node.name == visual_connected_node_name:
                    visual_connected_node = node
                    visual_connected_node.status = &#39;finished&#39;
        
        #Look at the &#39;Real-time&#39; bottom attribute:
        RealTimeAttr = self.nodeInfo.bottomAttrs[&#39;Real-time&#39;]
        if len(RealTimeAttr.connections) &gt; 0:
            self.nodz_analysis_threads = []
            rt_analysis_connected_node_name = RealTimeAttr.connections[0].socketNode
            for node in self.nodeInfo.flowChart.nodes:
                if node.name == rt_analysis_connected_node_name:
                    rt_analysis_connected_node = node
                    rt_analysis_connected_node.status = &#39;finished&#39;
    
    #reset the MDA button in the GUI
    self.resetMDAbutton(mdaLayerName=&#39;MDA&#39;)
    logging.debug(&#39;about to emit MDA_completed&#39;)
    self.MDA_completed.emit(True)</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.MDA_acq_from_GUI"><code class="name flex">
<span>def <span class="ident">MDA_acq_from_GUI</span></span>(<span>self, mdaLayerName=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The MDA_acq_from_GUI function is called when the user presses the 'Start MDA' button in the GUI.
It sets all of the parameters for an MDA acquisition, and then starts it by calling startMDAacq()</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>Refer to the instance of the class</dd>
<dt><strong><code>mdaLayerName</code></strong></dt>
<dd>Set the name of the napari layer that will be created for this mda</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing
Doc Author:
Trelent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MDA_acq_from_GUI(self, mdaLayerName=None):
    &#34;&#34;&#34;
    The MDA_acq_from_GUI function is called when the user presses the &#39;Start MDA&#39; button in the GUI.
    It sets all of the parameters for an MDA acquisition, and then starts it by calling startMDAacq()
    
    Args:
        self: Refer to the instance of the class
        mdaLayerName: Set the name of the napari layer that will be created for this mda
    
    Returns:
        Nothing
    
    Doc Author:
        Trelent
    &#34;&#34;&#34;
    logging.debug(&#39;At MDA_acq_from_GUI&#39;)
    self.shared_data._mdaMode = False
    
    #Set the exposure time:
    self.core.set_exposure(self.exposure_ms)
    
    #Set the location where to save the mda
    if self.GUI_storage_enabled:
        self.shared_data._mdaModeSaveLoc = [self.storage_folder,self.storage_file_name]
    else:
        self.shared_data._mdaModeSaveLoc = [&#39;&#39;,&#39;&#39;]
    #Set whether the napariviewer should (also) try to connect to the mda
    # self.shared_data._mdaModeNapariViewer = self.shared_data.napariViewer
    #Set the mda parameters
    
    self.shared_data._mdaModeParams = self.mda
    #Set this MDA object as the active MDA object in the shared_data
    self.shared_data.activeMDAobject = self
    self.shared_data.mda_acq_done_signal.connect(self.MDA_acq_finished)
    #And set the mdamode to be true
    self.shared_data.mdaMode = True
    #And start visualization
    if mdaLayerName is not None:
        #Import here to prevent circular import
        if is_pip_installed():
            from glados_pycromanager.GUI.napariGlados import startMDAVisualisation
        else:
            from napariGlados import startMDAVisualisation
        startMDAVisualisation(self.shared_data,layerName=mdaLayerName)
    logging.debug(&#39;ended setting mdamode params&#39;)
    
    #Set the Acquire button to say &#39;stop&#39;
    self.GUI_acquire_button.setText(&#39;Stop Acquisition&#39;) #type:ignore
    #Remove active clicked-connect-calls:
    self.GUI_acquire_button.clicked.disconnect() #type:ignore
    self.GUI_acquire_button.clicked.connect(lambda index: self.stopMDA(mdaLayerName=&#39;MDA&#39;)) #type:ignore
    pass</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.MDA_acq_from_Node"><code class="name flex">
<span>def <span class="ident">MDA_acq_from_Node</span></span>(<span>self, nodeInfo)</span>
</code></dt>
<dd>
<div class="desc"><p>MDA_acq_from_Node(self, nodeInfo)</p>
<p>Basically the same as MDA_from_GUI, but with the NodeInfo.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The object itself.</dd>
<dt><strong><code>nodeInfo</code></strong></dt>
<dd>Information about the node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>None
This function acquires data from a node and performs various operations based on the node information provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MDA_acq_from_Node(self, nodeInfo):
    &#34;&#34;&#34;MDA_acq_from_Node(self, nodeInfo)
    
    Basically the same as MDA_from_GUI, but with the NodeInfo.
    
    Args:
        self: The object itself.
        nodeInfo: Information about the node.
    
    Returns:
        None
    
    Raises:
        None
    
    This function acquires data from a node and performs various operations based on the node information provided.
    &#34;&#34;&#34;
    logging.debug(&#39;At MDA_acq_from_node&#39;)
    nodeName = nodeInfo.name
    
    self.nodeInfo = nodeInfo
    
    #Look at the &#39;Visual&#39; bottom attribute:
    visualAttr = nodeInfo.bottomAttrs[&#39;Visual&#39;]
    if len(visualAttr.connections) &gt; 0:
        for connection in visualAttr.connections:
            if connection.plugAttr is not None and connection.socketAttr is not None and connection.plugItem is not None and connection.socketItem is not None and connection.plugNode is not None and connection.socketNode is not None:
                visual_connected_node_name = connection.socketNode
                for node in nodeInfo.flowChart.nodes:
                    if node.name == visual_connected_node_name:
                        visual_connected_node = node
                        if &#39;layerName&#39; in visual_connected_node.visualisation_currentData and visual_connected_node.visualisation_currentData[&#39;layerName&#39;] is not None:
                            layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                        else:
                            visual_connected_node.visualisation_currentData[&#39;layerName&#39;] = nodeName
                            layerName = nodeName
                            
                        if &#39;colormap&#39; in visual_connected_node.visualisation_currentData and visual_connected_node.visualisation_currentData[&#39;colormap&#39;] is not None:
                            colormap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                        else:
                            visual_connected_node.visualisation_currentData[&#39;colormap&#39;] = &#39;gray&#39;
                            colormap = &#39;gray&#39;
                        
                        visual_connected_node.status = &#39;running&#39;
                        break
            
                logging.debug(&#39;Starting Nodz-MDA visualisation&#39;)
                #Prepare layerName for shared_data to order the layers later.
                #Import here to prevent circular import
                if is_pip_installed():
                    from glados_pycromanager.GUI.napariGlados import startMDAVisualisation
                else:
                    from napariGlados import startMDAVisualisation
                self.shared_data.newestLayerName = layerName
                startMDAVisualisation(self.shared_data,layerName=layerName,layerColorMap=colormap)
    
    #And try to get real-time analysis attributes at bottom:
    
    #Look at the &#39;Real-time&#39; bottom attribute:
    RealTimeAttr = nodeInfo.bottomAttrs[&#39;Real-time&#39;]
    if len(RealTimeAttr.connections) &gt; 0:
        self.nodz_analysis_threads = []
        rt_analysis_connected_node_name = RealTimeAttr.connections[0].socketNode
        for node in nodeInfo.flowChart.nodes:
            if node.name == rt_analysis_connected_node_name:
                rt_analysis_connected_node = node
                rt_analysis_info = rt_analysis_connected_node.real_time_analysis_currentData
                
                new_analysis_thread = create_real_time_analysis_thread(self.shared_data,analysisInfo = rt_analysis_info,delay=None,nodzInfo=nodeInfo.flowChart)
                self.nodz_analysis_threads.append(new_analysis_thread)
                rt_analysis_connected_node.status = &#39;running&#39;
                
                
    self.shared_data._mdaMode = False
    
    #Set the exposure time:
    self.core.set_exposure(self.exposure_ms)
    
    #Set the location where to save the mda
    Evaled_storage_file_name = utils.attemptToEvaluateVariables(self.storage_file_name,nodeInfo.flowChart)
    Evaled_storage_folder = utils.attemptToEvaluateVariables(self.storage_folder,nodeInfo.flowChart)
    
    self.shared_data._mdaModeSaveLoc = [Evaled_storage_folder,Evaled_storage_file_name]
    #Set whether the napariviewer should (also) try to connect to the mda
    # self.shared_data._mdaModeNapariViewer = self.shared_data.napariViewer
    #Set the mda parameters
    self.shared_data._mdaModeParams = self.mda
    #Set this MDA object as the active MDA object in the shared_data
    self.shared_data.activeMDAobject = self
    self.shared_data.mda_acq_done_signal.connect(self.MDA_acq_finished)
    #And set the mdamode to be true
    self.shared_data.mdaMode = True
    logging.debug(&#39;ended setting mdamode params&#39;)
    
    pass</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.MDA_completed"><code class="name flex">
<span>def <span class="ident">MDA_completed</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="MDAGlados.MDAGlados.createOrderLayout"><code class="name flex">
<span>def <span class="ident">createOrderLayout</span></span>(<span>self, GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an order ('t','tc', etc) layout based on the provided parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>GUI_show_channel</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include channel in the layout.</dd>
<dt><strong><code>GUI_show_time</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include time in the layout.</dd>
<dt><strong><code>GUI_show_xy</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include xy in the layout.</dd>
<dt><strong><code>GUI_show_z</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to include z in the layout.</dd>
<dt><strong><code>orderChoice</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The default order choice. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>QVBoxLayout</code></dt>
<dd>The layout containing the order dropdown and label.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createOrderLayout(self,GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice = None):
    &#34;&#34;&#34;
    Create an order (&#39;t&#39;,&#39;tc&#39;, etc) layout based on the provided parameters.
    
    Args:
        GUI_show_channel (bool): Whether to include channel in the layout.
        GUI_show_time (bool): Whether to include time in the layout.
        GUI_show_xy (bool): Whether to include xy in the layout.
        GUI_show_z (bool): Whether to include z in the layout.
        orderChoice (str, optional): The default order choice. Defaults to None.
    
    Returns:
        QVBoxLayout: The layout containing the order dropdown and label.
    &#34;&#34;&#34;
    
    orderLayout = QVBoxLayout()
    letters_to_include = &#39;&#39;
    if GUI_show_channel:
        letters_to_include += &#39;c&#39;
    if GUI_show_time:
        letters_to_include += &#39;t&#39;
    if GUI_show_xy:
        letters_to_include += &#39;p&#39;
    if GUI_show_z:
        letters_to_include += &#39;z&#39;
    #Now we create an array with all possible combinations of these letters:
    permuatations = [&#39;&#39;.join(comb) for comb in itertools.permutations(letters_to_include, len(letters_to_include))]
    self.orderDropdown = QComboBox()
    self.orderDropdown.currentTextChanged.connect(lambda: self.get_MDA_events_from_GUI())
    #add the options to the dropdown:
    for option in permuatations:
        self.orderDropdown.addItem(option)
    #Create a label:
    self.orderLabel = QLabel(&#34;Order:&#34;)
    
    #Show the widgets.
    orderLayout.addWidget(self.orderLabel)
    orderLayout.addWidget(self.orderDropdown)
    
    if orderChoice in permuatations:
        if orderChoice is not None:
            self.orderDropdown.setCurrentText(orderChoice)
    
    return orderLayout</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.getDevicesOfDeviceType"><code class="name flex">
<span>def <span class="ident">getDevicesOfDeviceType</span></span>(<span>self, devicetype)</span>
</code></dt>
<dd>
<div class="desc"><p>Find all devices that have a specific devicetype.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>devicetype</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of device to search for. Refer to <a href="https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html">https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html</a> for all devicetypes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of devices that match the specified devicetype.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDevicesOfDeviceType(self,devicetype):
    &#34;&#34;&#34;
    Find all devices that have a specific devicetype.
    
    Args:
        devicetype (str): The type of device to search for. Refer to https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html for all devicetypes.
    
    Returns:
        list: A list of devices that match the specified devicetype.
    &#34;&#34;&#34;
    
    #Find all devices that have a specific devicetype
    #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
    #for all devicetypes
    #Get devices
    devices = self.core.get_loaded_devices()
    devices = [devices.get(i) for i in range(devices.size())]
    devicesOfType = []
    #Loop over devices
    for device in devices:
        if self.core.get_device_type(device).to_string() == devicetype:
            logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
            devicesOfType.append(device)
    return devicesOfType</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.getEvents"><code class="name flex">
<span>def <span class="ident">getEvents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the MDA events from the object.</p>
<h2 id="returns">Returns</h2>
<p>The MDA events stored in the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getEvents(self):
    &#34;&#34;&#34;
    Get the MDA events from the object.
    
    Returns:
        The MDA events stored in the object.
    &#34;&#34;&#34;
    return self.mda</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.getGui"><code class="name flex">
<span>def <span class="ident">getGui</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the GUI object.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>The GUI object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGui(self):
    &#34;&#34;&#34;
    Returns the GUI object.
    
    Args:
        None
    
    Returns:
        The GUI object.
    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.get_MDA_events_from_GUI"><code class="name flex">
<span>def <span class="ident">get_MDA_events_from_GUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The get_MDA_events_from_GUI function is called every time the user changes any option in the GUI.
It will then update all variables that are used to create an MDA object, which can be used to run a multi-dimensional acquisition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>Refer to the object itself</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_MDA_events_from_GUI(self):
    &#34;&#34;&#34;
    The get_MDA_events_from_GUI function is called every time the user changes any option in the GUI.
    It will then update all variables that are used to create an MDA object, which can be used to run a multi-dimensional acquisition.
    
    
    Args:
        self: Refer to the object itself
    &#34;&#34;&#34;
    logging.debug(&#39;starting get_MDA_events_from_GUI&#39;)
    #Make this somewhat readable:
    if self.exposureGroupBox.isEnabled():
        try:
            self.exposure_ms = float(self.exposureEntry.text())
            self.exposure_s_or_ms = &#39;ms&#39;
            if self.exposureDropdown.currentText() == &#39;s&#39;:
                self.exposure_ms *= 1000
                self.exposure_s_or_ms = &#39;s&#39;
        except:
            self.exposure_ms = None
            self.exposure_s_or_ms = &#39;ms&#39;
    
    if self.timeGroupBox.isEnabled():
        try:
            self.num_time_points = int(self.timePointEntry.text())
            self.time_interval_s = float(self.timeIntervalEntry.text())
            self.time_interval_s_or_ms = &#39;s&#39;
            if self.timeIntervalDropdown.currentText() == &#39;ms&#39;:
                self.time_interval_s_or_ms = &#39;ms&#39;
                self.time_interval_s /= 1000
        except:
            self.num_time_points = None
            self.time_interval_s = None
            self.time_interval_s_or_ms = &#39;ms&#39;
            
    # if self.orderGroupBox.isEnabled():
    self.order = self.orderDropdown.currentText()
    
    if self.storageGroupBox.isEnabled():
        self.storage_folder = self.storageFolderEntry.text()
        self.storage_file_name = self.storageFileNameEntry.text()
    
    if self.zGroupBox.isEnabled():
        try:
            #We also need to set the shared_data focus device for proper z-functioning
            self.shared_data.core.set_focus_device(self.z_oneDstageDropdown.currentText())
        except:
            self.shared_data.core.set_focus_device(self.shared_data._defaultFocusDevice)
            
        self.z_stage_sel = self.z_oneDstageDropdown.currentText()
        
        if self.z_startEntry.text() != &#39;&#39;:
            self.z_start = (float(self.z_startEntry.text()))
        else:
            self.z_start = None
            
        if self.z_endEntry.text() != &#39;&#39;:
            self.z_end = (float(self.z_endEntry.text()))
        else:
            self.z_end = None
            
        if self.z_nrsteps_radio.isChecked():
            if (self.z_nrsteps_entry.text() != &#39;&#39;) and self.z_start is not None and self.z_end is not None:
                self.z_step = float((self.z_end-self.z_start)/int(self.z_nrsteps_entry.text()))
                self.z_step_distance = None
                self.z_nr_steps = int(self.z_nrsteps_entry.text())
            else:
                self.z_step = None
                self.z_step_distance = None
                self.z_nr_steps = None
        elif self.z_stepdistance_radio.isChecked():
            if self.z_stepdistance_entry.text() != &#39;&#39; and self.z_start is not None and self.z_end is not None:
                self.z_step = float(self.z_stepdistance_entry.text())
                self.z_step_distance = float(self.z_stepdistance_entry.text())
                self.z_nr_steps = None
                if self.z_start &lt; self.z_end:
                    if self.z_step &lt; 0:
                        self.z_step*=-1
                elif self.z_start &gt; self.z_end:
                    if self.z_step &gt; 0:
                        self.z_step*=-1
            else:
                self.z_step = None
                self.z_step_distance = None
                self.z_nr_steps = None
        self.z_nrsteps_radio_sel = self.z_nrsteps_radio.isChecked()
        self.z_stepdistance_radio_sel = self.z_stepdistance_radio.isChecked()
    else:
        self.shared_data.core.set_focus_device(self.shared_data._defaultFocusDevice)
    
    #Get the xy positions
    if self.xyGroupBox.isEnabled():
        try:
            self.xy_positions = self.xypositionListWidget.getPositionsArray()
            self.xy_positions_saveInfo = self.xypositionListWidget.getSaveInfoPositionsArray()
        except:
            self.xy_positions = None
            self.xy_positions_saveInfo = None
    else:
        self.xy_positions = None
        self.xy_positions_saveInfo = None
    
    if self.channelGroupBox.isEnabled():
        try:
            
            self.channel_group = self.channelDropdown.currentText()
            
            self.channels = []
            self.channel_exposures_ms = []
            for row in range(self.channelListWidget.rowCount()):
                for column in range(self.channelListWidget.columnCount()):
                    if column == 0:
                        self.channels.append(self.channelListWidget.cellWidget(row,0).currentText())
                    elif column == 1:
                        item = self.channelListWidget.item(row, column)
                        try: #Check if it will be float-value:
                            if item is not None:
                                self.channel_exposures_ms.append(float(item.text()))
                            else:
                                self.channel_exposures_ms.append(&#34;&#34;)  # Add an empty string for empty cells
                        except ValueError:  # Add an empty string for non-float
                            self.channel_exposures_ms.append(&#34;&#34;)

        except:
            self.channel_group = None
            self.channels = None
            self.channel_exposures_ms = None
    
    #Do a small catch in case z_start, z_step or z_end is None:
    if self.z_start is None or self.z_step is None or self.z_end is None:
        if self.zGroupBox.isEnabled() and self.GUI_show_z:
            #Only a warning if we actually want Z, if we don&#39;t, it&#39;s just a debug info.
            logging.info(&#34;z_start, z_step or z_end is None. These are adapted to 0/1/1.&#34;)
        else:
            logging.debug(&#34;z_start, z_step or z_end is None. These are adapted to 0/1/1.&#34;)
        self.z_start = 0
        self.z_step = 1
        self.z_end = 1
    
    #Also update the nodz variables info:
    self.updateNodzVariables()
    
    self.mda = multi_d_acquisition_events(num_time_points=self.num_time_points, time_interval_s=self.time_interval_s,z_start=self.z_start,z_end=self.z_end,z_step=self.z_step,channel_group=self.channel_group,channels=self.channels,channel_exposures_ms=self.channel_exposures_ms,xy_positions=self.xy_positions,xyz_positions=self.xyz_positions,position_labels=self.position_labels,order=self.order) #type:ignore
    
    logging.debug(f&#34;mda: {self.mda}&#34;)
    if self.fully_started:
        if self.autoSaveLoad:
            #Store in appdata
            appdata_folder = os.getenv(&#39;APPDATA&#39;)
            if appdata_folder is None:
                raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
            app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
            os.makedirs(app_specific_folder, exist_ok=True)
            self.save_state_MDA(os.path.join(app_specific_folder, &#39;glados_state.json&#39;))
    logging.debug(&#39;ended get_MDA_events_from_GUI&#39;)
    
    pass</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.handleSizeChange"><code class="name flex">
<span>def <span class="ident">handleSizeChange</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a change in size by adjusting the number of columns in the GUI grid.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>The new size of the GUI window.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handleSizeChange(self, size):
    &#34;&#34;&#34;
    Handle a change in size by adjusting the number of columns in the GUI grid.
    
    Args:
        size: The new size of the GUI window.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    newNrColumns = max(1,min(10, size.width() // 150))
    self.GUI_grid_width = newNrColumns</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.initGUI"><code class="name flex">
<span>def <span class="ident">initGUI</span></span>(<span>self, GUI_show_exposure=True, GUI_show_xy=True, GUI_show_z=True, GUI_show_channel=True, GUI_show_time=True, GUI_show_order=True, GUI_show_storage=True, GUI_showOptions=True, GUI_acquire_button=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Initiate the GUI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>GUI_show_exposure</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the exposure widget. Default is True.</dd>
<dt><strong><code>GUI_show_xy</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the XY widget. Default is True.</dd>
<dt><strong><code>GUI_show_z</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Z widget. Default is True.</dd>
<dt><strong><code>GUI_show_channel</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Channel widget. Default is True.</dd>
<dt><strong><code>GUI_show_time</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Time widget. Default is True.</dd>
<dt><strong><code>GUI_show_order</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Order widget. Default is True.</dd>
<dt><strong><code>GUI_show_storage</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Storage widget. Default is True.</dd>
<dt><strong><code>GUI_showOptions</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Options widget. Default is True.</dd>
<dt><strong><code>GUI_acquire_button</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Acquire button. Default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initGUI(self, GUI_show_exposure=True, GUI_show_xy = True, GUI_show_z=True, GUI_show_channel=True, GUI_show_time=True, GUI_show_order=True, GUI_show_storage=True, GUI_showOptions=True,GUI_acquire_button=True):
    &#34;&#34;&#34;
    Initiate the GUI.
    
    Args:
        GUI_show_exposure (bool): Whether to show the exposure widget. Default is True.
        GUI_show_xy (bool): Whether to show the XY widget. Default is True.
        GUI_show_z (bool): Whether to show the Z widget. Default is True.
        GUI_show_channel (bool): Whether to show the Channel widget. Default is True.
        GUI_show_time (bool): Whether to show the Time widget. Default is True.
        GUI_show_order (bool): Whether to show the Order widget. Default is True.
        GUI_show_storage (bool): Whether to show the Storage widget. Default is True.
        GUI_showOptions (bool): Whether to show the Options widget. Default is True.
        GUI_acquire_button (bool): Whether to show the Acquire button. Default is True.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    #initiate the GUI
    #Create a Vertical+horizontal layout:
    self.gui = QGridLayout()
    self.GUI_grid_width = 7
    
    # Add groupboxes for xy, z, channel, time, order, storage
    self.exposureGroupBox = QGroupBox(&#34;Exposure&#34;)
    self.xyGroupBox = QGroupBox(&#34;XY&#34;)
    self.zGroupBox = QGroupBox(&#34;Z&#34;)
    self.channelGroupBox = QGroupBox(&#34;Channel&#34;)
    self.timeGroupBox = QGroupBox(&#34;Time&#34;)
    self.storageGroupBox = QGroupBox(&#34;Storage&#34;)
    self.showOptionsGroupBox = QGroupBox(&#34;Options&#34;)

    # Create layouts for each groupbox
    exposureLayout=QHBoxLayout()
    xyLayout = QGridLayout()
    zLayout = QGridLayout()
    channelLayout = QGridLayout()
    timeLayout = QGridLayout()
    orderLayout = QVBoxLayout()
    storageLayout = QGridLayout()
    showOptionsLayout = QGridLayout()

    # Add widgets to each layout
    # --------------- Exposure widget -----------------------------------------------
    #Exposure: add a label, an entry field, and a dropdown between &#39;ms&#39; and &#39;s&#39;:
    self.exposureLabel = QLabel(&#34;Exposure:&#34;)
    self.exposureEntry = QLineEdit()
    if self.exposure_ms is not None:
        if self.exposure_s_or_ms == &#39;ms&#39;:
            self.exposureEntry.setText(str(self.exposure_ms))
        elif self.exposure_s_or_ms == &#39;s&#39;:
            self.exposureEntry.setText(str(self.exposure_ms/1000))
    #ensure thatexposureEntry can only be a float:
    self.exposureEntry.setValidator(QDoubleValidator())
    self.exposureDropdown = QComboBox()
    self.exposureDropdown.addItem(&#34;ms&#34;)
    self.exposureDropdown.addItem(&#34;s&#34;)
    self.exposureDropdown.setCurrentText(self.exposure_s_or_ms)
    exposureLayout.addWidget(self.exposureLabel)
    exposureLayout.addWidget(self.exposureEntry)
    exposureLayout.addWidget(self.exposureDropdown)
    #run get_MDA_events_from_GUI when the text or dropdown is changed:
    self.exposureEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.exposureDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
    
    #--------------- Time widget -----------------------------------------------
    #Time: add labels for time points and time intervals, and integer-based entry fields:
    self.timePointLabel = QLabel(&#34;Number time points:&#34;)
    self.timePointEntry = QLineEdit()
    if self.num_time_points is not None:
        self.timePointEntry.setText(str(self.num_time_points))
    self.timePointEntry.setValidator(QIntValidator())
    self.timeIntervalLabel = QLabel(&#34;Time interval:&#34;)
    self.timeIntervalEntry = QLineEdit()
    if self.time_interval_s is not None:
        if self.time_interval_s_or_ms == &#39;s&#39;:
            self.timeIntervalEntry.setText(str(self.time_interval_s))
        elif self.time_interval_s_or_ms == &#39;ms&#39;:
            self.timeIntervalEntry.setText(str(self.time_interval_s*1000))
    self.timeIntervalEntry.setValidator(QDoubleValidator())
    self.timeIntervalDropdown = QComboBox()
    self.timeIntervalDropdown.addItem(&#34;ms&#34;)
    self.timeIntervalDropdown.addItem(&#34;s&#34;)
    self.timeIntervalDropdown.setCurrentText(self.time_interval_s_or_ms)
    #Adding widgets to layout
    timeLayout.addWidget(self.timePointLabel,0,0)
    timeLayout.addWidget(self.timePointEntry,0,1)
    timeLayout.addWidget(self.timeIntervalLabel,1,0)
    timeLayout.addWidget(self.timeIntervalEntry,1,1)
    timeLayout.addWidget(self.timeIntervalDropdown,1,2)
    #run get_MDA_events_from_GUI when the text or dropdown is changed:
    self.timePointEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.timeIntervalEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.timeIntervalDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
    
    #--------------- storage widget -----------------------------------------------
    #storage: first, add a label, entry field, and button with &#39;...&#39; to select a folder of choice:
    self.storageFolderLabel = QLabel(&#34;Storage:&#34;)
    self.storageFolderEntry = QLineEdit()
    if self.storage_folder is not None:
        self.storageFolderEntry.setText(self.storage_folder)
    self.storageFolderButton = QPushButton(&#39;...&#39;)
    #add a lambda function when this is pressed to search for a folder:
    self.storageFolderButton.clicked.connect(lambda: self.storageFolderEntry.setText(QFileDialog.getExistingDirectory()))
    #Then add a label and entry field for the file name:
    self.storageFileNameLabel = QLabel(&#34;File name:&#34;)
    self.storageFileNameEntry = QLineEdit()
    if self.storage_file_name is not None:
        self.storageFileNameEntry.setText(self.storage_file_name)
    #Adding widgets to layout
    storageLayout.addWidget(self.storageFolderLabel,0,0)
    storageLayout.addWidget(self.storageFolderEntry,0,1)
    storageLayout.addWidget(self.storageFolderButton,0,2)
    storageLayout.addWidget(self.storageFileNameLabel,1,0)
    storageLayout.addWidget(self.storageFileNameEntry,1,1)
    self.storageFolderEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.storageFileNameEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    
    #--------------- XY widget widget -----------------------------------------------
    #First a dropdown to select the xy stage:
    
    #Adding a list widget to add a list of xy positions
    self.xypositionListWidget = XYStageList(parent=self)
    self.xypositionListWidget.setColumNames([&#34;Name&#34;, &#34;ID&#34;,&#34;xPos&#34;,&#34;yPos&#34;])
    self.xypositionListWidget.setColumnWidth(0, 60)
    self.xypositionListWidget.setColumnWidth(1, 40)
    
    self.xy_stagesDropdownLabel = QLabel(&#34;XY Stage:&#34;)
    self.xy_stagesDropdown = QComboBox()
    XYstages = self.getDevicesOfDeviceType(&#39;XYStageDevice&#39;)
    #add the options to the dropdown:
    for stage in XYstages:
        self.xy_stagesDropdown.addItem(stage)
    #Add a callback if we change this dropdown:
    self.xy_stagesDropdown.currentIndexChanged.connect(lambda: self.xypositionListWidget.setXYStageName(self.xy_stagesDropdown.currentText()))
    
    #Initisalise the XY position list
    self.xypositionListWidget.setXYStageName(self.xy_stagesDropdown.currentText)
    #Buttons for the xy position list
    self.xypositionListWidget_deleteButton = QPushButton(&#39;Delete Selected&#39;)
    self.xypositionListWidget_deleteAllButton = QPushButton(&#39;Delete All&#39;)
    self.xypositionListWidget_moveUpButton = QPushButton(&#39;Move Up&#39;)
    self.xypositionListWidget_moveDownButton = QPushButton(&#39;Move Down&#39;)
    self.xypositionListWidget_moveToButton = QPushButton(&#39;Move to Pos&#39;)
    self.xypositionListWidget_addButton = QPushButton(&#39;Add New Entry&#39;)
    #Intialise a gridManager
    self.xypositionListWidget_XYGridManager = utils.XYGridManager(core=self.core,parent=self)
    self.xypositionListWidget_createGridButton = QPushButton(&#39;Create Grid&#39;)
    #Adding callbacks to the xy position list buttons
    self.xypositionListWidget_deleteButton.clicked.connect(self.xypositionListWidget.deleteSelected)
    self.xypositionListWidget_deleteAllButton.clicked.connect(self.xypositionListWidget.deleteAll)
    self.xypositionListWidget_moveUpButton.clicked.connect(self.xypositionListWidget.moveUp)
    self.xypositionListWidget_moveDownButton.clicked.connect(self.xypositionListWidget.moveDown)
    self.xypositionListWidget_moveToButton.clicked.connect(self.xypositionListWidget.moveToPos)
    self.xypositionListWidget_addButton.clicked.connect(lambda: self.xypositionListWidget.addNewEntry(textEntry=&#34;Your Text Entry&#34;))
    
    #Open the GridManager GUI
    self.xypositionListWidget_createGridButton.clicked.connect(lambda: self.xypositionListWidget_XYGridManager.openGUI())

    #Adding widgets to layout
    xyLayout.addWidget(self.xy_stagesDropdownLabel,0,0)
    xyLayout.addWidget(self.xy_stagesDropdown,0,1)
    xyLayout.addWidget(self.xypositionListWidget,1,0,12,1)
    xyLayout.addWidget(self.xypositionListWidget_deleteButton,2,1)
    xyLayout.addWidget(self.xypositionListWidget_deleteAllButton,3,1)
    xyLayout.addWidget(self.xypositionListWidget_moveUpButton,4,1)
    xyLayout.addWidget(self.xypositionListWidget_moveDownButton,5,1)
    xyLayout.addWidget(self.xypositionListWidget_moveToButton,6,1)
    xyLayout.addWidget(self.xypositionListWidget_addButton,7,1)
    xyLayout.addWidget(self.xypositionListWidget_createGridButton,8,1)
    
    #Pre-load entries if they exist:
    if self.GUI_xy_pos_fullInfo != None:
        for entry in self.GUI_xy_pos_fullInfo:
            self.xypositionListWidget.addNewEntry(textEntry=entry[0],id=int(entry[1]),setxy=[float(entry[2]),float(entry[3])])
    
    #Add a callback lambda
    self.xypositionListWidget.itemChanged.connect(lambda: self.get_MDA_events_from_GUI())
    
    #--------------- Z widget widget -----------------------------------------------
    #First a dropdown to select the 1d stage:
    self.z_oneDstageDropdownLabel = QLabel(&#34;Z Stage:&#34;)
    self.z_oneDstageDropdown = QComboBox()
    oneDstages = self.getDevicesOfDeviceType(&#39;StageDevice&#39;)
    #add the options to the dropdown:
    for stage in oneDstages:
        self.z_oneDstageDropdown.addItem(stage)
    if self.z_stage_sel is not None:
        if self.z_stage_sel in oneDstages:
            self.z_oneDstageDropdown.setCurrentText(self.z_stage_sel)
    #Create all other buttons/lineedits
    self.z_startLabel = QLabel(&#34;Start:&#34;)
    self.z_startEntry = QLineEdit()
    if self.z_start is not None:
        self.z_startEntry.setText(str(self.z_start))
    self.z_startEntry.setValidator(QDoubleValidator())
    self.z_startSetButton = QPushButton(&#39;Set&#39;)
    self.z_startSetButton.clicked.connect(lambda: self.setZStart())
    self.z_endLabel = QLabel(&#34;End:&#34;)
    self.z_endEntry = QLineEdit()
    if self.z_end is not None:
        self.z_endEntry.setText(str(self.z_end))
    self.z_endEntry.setValidator(QDoubleValidator())
    self.z_endSetButton = QPushButton(&#39;Set&#39;)
    self.z_endSetButton.clicked.connect(lambda: self.setZEnd())
    
    #add radio buttons:
    self.z_nrsteps_radio= QRadioButton(&#34;Number of steps: &#34;)
    self.z_stepdistance_radio= QRadioButton(&#34;Step distance: &#34;)
    #preselect the nr of steps one:
    if self.z_nrsteps_radio_sel == True:
        self.z_nrsteps_radio.setChecked(True)
    elif self.z_stepdistance_radio_sel == True:
        self.z_stepdistance_radio.setChecked(True)
    else:
        self.z_nrsteps_radio.setChecked(True)
    #add edit boxes for number of steps and step distance:
    self.z_nrsteps_entry = QLineEdit()
    if self.z_nr_steps is not None:
        self.z_nrsteps_entry.setText(str(self.z_nr_steps))
    self.z_nrsteps_entry.setValidator(QIntValidator())
    self.z_stepdistance_entry = QLineEdit()
    if self.z_step_distance is not None:
        self.z_stepdistance_entry.setText(str(self.z_step_distance))
    self.z_stepdistance_entry.setValidator(QDoubleValidator())
    
    #Add all widgets to layout
    zLayout.addWidget(self.z_oneDstageDropdownLabel,0,0)
    zLayout.addWidget(self.z_oneDstageDropdown,0,1)
    zLayout.addWidget(self.z_startLabel,1,0)
    zLayout.addWidget(self.z_startEntry,1,1)
    zLayout.addWidget(self.z_startSetButton,1,2)
    zLayout.addWidget(self.z_endLabel,2,0)
    zLayout.addWidget(self.z_endEntry,2,1)
    zLayout.addWidget(self.z_endSetButton,2,2)
    zLayout.addWidget(self.z_nrsteps_radio,3,0)
    zLayout.addWidget(self.z_nrsteps_entry,3,1)
    zLayout.addWidget(self.z_stepdistance_radio,4,0)
    zLayout.addWidget(self.z_stepdistance_entry,4,1)
    
    #run get_MDA_events_from_GUI when the text or dropdown is changed:
    self.z_oneDstageDropdown.currentIndexChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.z_startEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.z_endEntry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.z_nrsteps_radio.toggled.connect(lambda: self.get_MDA_events_from_GUI())
    self.z_stepdistance_radio.toggled.connect(lambda: self.get_MDA_events_from_GUI())
    self.z_nrsteps_entry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())
    self.z_stepdistance_entry.textChanged.connect(lambda: self.get_MDA_events_from_GUI())

    # --- Ordering widget ---
    #Note: only used in updateGUIwidgets
    
    #--------------- Channel widget -----------------------------------------------
    #Adding a list widget to add a list of channels
    self.channelListWidget = ChannelList(parent=self)
    self.channelListWidget.setColumNames([&#34;Channel Setting&#34;, &#34;Exposure&#34;])
    
    #Add possible channels
    self.channelDropdownLabel = QLabel(&#34;Channel:&#34;)
    self.channelDropdown = QComboBox()
    
    #Figure out from all config groups which ones are &#34;dropdown&#34;
    nrconfiggroups = self.core.get_available_config_groups().size()
    allConfigGroups={}
    for config_group_id in range(nrconfiggroups):
        allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
    comboboxindexes = []
    for config_group_id in range(nrconfiggroups):
        if allConfigGroups[config_group_id].isDropDown():
            comboboxindexes.append(config_group_id)
    ComboBoxes = {key: allConfigGroups[key] for key in comboboxindexes}
    ComboBoxNames = {allConfigGroups[key].configGroupName() for key in comboboxindexes}
    
    #add the options to the dropdown:
    for combobox in ComboBoxes:
        self.channelDropdown.addItem(allConfigGroups[combobox].configGroupName())
    #Add a callback if we change this dropdown:
    self.channelDropdown.currentIndexChanged.connect(lambda: self.channelListWidget.setChannelName(self.channelDropdown.currentText()))
    #Also delete all the current entries
    self.channelDropdown.currentIndexChanged.connect(lambda: self.channelListWidget.deleteAll())
    
    #Initisalise the channel  list
    self.channelListWidget.setChannelName(self.channelDropdown.currentText)
    
    
    #Buttons for the channel position list
    self.channelListWidget_deleteButton = QPushButton(&#39;Delete Selected&#39;)
    self.channelListWidget_moveUpButton = QPushButton(&#39;Move Up&#39;)
    self.channelListWidget_moveDownButton = QPushButton(&#39;Move Down&#39;)
    self.channelListWidget_addButton = QPushButton(&#39;Add New Entry&#39;)
    self.channelListWidget_deleteAllButton = QPushButton(&#39;Delete All&#39;)
    #Adding callbacks to the channel list buttons
    self.channelListWidget_deleteButton.clicked.connect(self.channelListWidget.deleteSelected)
    self.channelListWidget_deleteAllButton.clicked.connect(self.channelListWidget.deleteAll)
    self.channelListWidget_moveUpButton.clicked.connect(self.channelListWidget.moveUp)
    self.channelListWidget_moveDownButton.clicked.connect(self.channelListWidget.moveDown)
    self.channelListWidget_addButton.clicked.connect(lambda: self.channelListWidget.addNewEntry())

    #Adding widgets to layout
    channelLayout.addWidget(self.channelDropdownLabel,0,0)
    channelLayout.addWidget(self.channelDropdown,0,1)
    channelLayout.addWidget(self.channelListWidget,1,0,6,1)
    channelLayout.addWidget(self.channelListWidget_deleteButton,2,1)
    channelLayout.addWidget(self.channelListWidget_moveUpButton,3,1)
    channelLayout.addWidget(self.channelListWidget_moveDownButton,4,1)
    channelLayout.addWidget(self.channelListWidget_addButton,5,1)
    channelLayout.addWidget(self.channelListWidget_deleteAllButton,6,1)

    #Add the pre-set channels:
    if self.channel_group in ComboBoxNames:
        if self.channel_group is not None:
            self.channelDropdown.setCurrentText(self.channel_group)
    if self.channels is not None and self.channel_exposures_ms is not None:
        for entry in range(len(self.channels)):
            self.channelListWidget.addNewEntry(channelEntry=self.channels[entry],exposureEntry=str(self.channel_exposures_ms[entry]))
            
    #Change MDA events when adapted
    self.channelListWidget.itemChanged.connect(lambda: self.get_MDA_events_from_GUI())
    
    #--------------- Show options widget -----------------------------------------------
    #This should have checkboxes for exposure, xy, z, channel, time, order, storage. If these checkboxes are clicked, the GUI should be updated accordingly:
    self.GUI_show_exposure_chkbox = QCheckBox(&#34;Exposure&#34;) #Note: created but never rendered
    self.GUI_show_xy_chkbox = QCheckBox(&#34;XY&#34;)
    self.GUI_show_z_chkbox = QCheckBox(&#34;Z&#34;)
    self.GUI_show_channel_chkbox = QCheckBox(&#34;Channel&#34;)
    self.GUI_show_time_chkbox = QCheckBox(&#34;Time&#34;)
    self.GUI_show_storage_chkbox = QCheckBox(&#34;Storage&#34;)
    #initialise the checkboxes based on the values in this GUI:
    self.GUI_show_exposure_chkbox.setChecked(self.GUI_show_exposure) #Note: created but never rendered
    self.GUI_show_xy_chkbox.setChecked(self.GUI_show_xy)
    self.GUI_show_z_chkbox.setChecked(self.GUI_show_z)
    self.GUI_show_channel_chkbox.setChecked(self.GUI_show_channel)
    self.GUI_show_time_chkbox.setChecked(self.GUI_show_time)
    self.GUI_show_storage_chkbox.setChecked(self.GUI_show_storage)
    #Add lambda functions to all of them that all run the same function: showOptionChanged():
    # self.GUI_show_exposure_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
    self.GUI_show_xy_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
    self.GUI_show_z_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
    self.GUI_show_channel_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
    self.GUI_show_time_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
    self.GUI_show_storage_chkbox.stateChanged.connect(lambda: self.showOptionChanged())
    
    font = QFont()
    font.setPointSize(7)  # Set the desired font size

    [checkbox.setFont(font) for checkbox in [self.GUI_show_exposure_chkbox, self.GUI_show_xy_chkbox, self.GUI_show_z_chkbox, self.GUI_show_channel_chkbox, self.GUI_show_time_chkbox, self.GUI_show_storage_chkbox]]

    #Add all checkboxes to the options-layout
    # showOptionsLayout.addWidget(self.GUI_show_exposure_chkbox,0,0)
    showOptionsLayout.addWidget(self.GUI_show_time_chkbox,0,0)
    showOptionsLayout.addWidget(self.GUI_show_xy_chkbox,0,1)
    showOptionsLayout.addWidget(self.GUI_show_z_chkbox,0,2)
    showOptionsLayout.addWidget(self.GUI_show_channel_chkbox,1,0)
    showOptionsLayout.addWidget(self.GUI_show_storage_chkbox,1,1)
    
    # ---------- Combining all to the main layout -----------------------------------------
    # Set layouts for each groupbox
    self.exposureGroupBox.setLayout(exposureLayout)
    self.xyGroupBox.setLayout(xyLayout)
    self.zGroupBox.setLayout(zLayout)
    self.channelGroupBox.setLayout(channelLayout)
    self.timeGroupBox.setLayout(timeLayout)
    self.storageGroupBox.setLayout(storageLayout)
    self.showOptionsGroupBox.setLayout(showOptionsLayout)

    # Add groupboxes to the main layout, only if they should be shown. The position of the gridbox is based on whether the previous ones are added or not:
    self.updateGUIwidgets(GUI_show_exposure=GUI_show_exposure,GUI_show_xy=GUI_show_xy, GUI_show_z=GUI_show_z, GUI_show_channel=GUI_show_channel, GUI_show_time=GUI_show_time, GUI_show_storage=GUI_show_storage,GUI_showOptions=GUI_showOptions,GUI_acquire_button=GUI_acquire_button)
    
    #Change the font of everything in the layout
    self.set_font_and_margins_recursive(self.gui, font=QFont(&#34;Arial&#34;, 7))
    #Twice because it relies on dependancies inside qgridlayouts
    self.set_font_and_margins_recursive(self.gui, font=QFont(&#34;Arial&#34;, 7))
    
    if self.layout is not None:
        #Add the layout to the main layout
        try:
            self.layout.addLayout(self.gui,0,0)
        except:
            self.setLayout(self.gui)
            self.mainLayout = self.gui
        
        # Changing font and padding of all widgets
        font = QFont(&#34;Arial&#34;, 7)
        for i in range(self.gui.count()):
            try:
                item = self.gui.itemAt(i)
                if item.widget():
                    item.widget().setFont(font)
                    item.widget().setStyleSheet(&#34;padding: 2px; margin: 1px; spacing: 1px;&#34;)  # Change padding as needed
            except:
                pass</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.printText"><code class="name flex">
<span>def <span class="ident">printText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the events obtained from the getEvents method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The object instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printText(self):
    &#34;&#34;&#34;
    Prints the events obtained from the getEvents method.
    
    Args:
        self: The object instance.
    
    Returns:
        None
    &#34;&#34;&#34;
    logging.info(self.getEvents())</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.resetMDAbutton"><code class="name flex">
<span>def <span class="ident">resetMDAbutton</span></span>(<span>self, mdaLayerName='MDA')</span>
</code></dt>
<dd>
<div class="desc"><p>Function that resets the Acquire button (i.e. if acq is running, it shows 'stop acquisition', this should go back to 'acquire' and the connected call)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetMDAbutton(self,mdaLayerName=&#39;MDA&#39;):
    &#34;&#34;&#34;
    Function that resets the Acquire button (i.e. if acq is running, it shows &#39;stop acquisition&#39;, this should go back to &#39;acquire&#39; and the connected call)
    &#34;&#34;&#34;
    #ATM, first just update the button back and show that we can access this:
    if self.GUI_acquire_button is not None:
        try:
            self.GUI_acquire_button.setText(&#39;Acquire&#39;) #type:ignore
            #Remove active clicked-connect-calls:
            self.GUI_acquire_button.clicked.disconnect() #type:ignore
            self.GUI_acquire_button.clicked.connect(lambda index: self.MDA_acq_from_GUI(mdaLayerName=mdaLayerName)) #type:ignore
        except RuntimeError:
            pass #C/C++ object has been deleted if called from Nodz.</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.setAllCheckBoxEnableValues"><code class="name flex">
<span>def <span class="ident">setAllCheckBoxEnableValues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the enable values for all the checkboxes.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setAllCheckBoxEnableValues(self):
    &#34;&#34;&#34;
    Set the enable values for all the checkboxes.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    
    self.GUI_exposure_enabled = self.GUI_show_exposure_chkbox.isChecked()
    self.GUI_xy_enabled = self.GUI_show_xy_chkbox.isChecked()
    self.GUI_z_enabled = self.GUI_show_z_chkbox.isChecked()
    self.GUI_channel_enabled = self.GUI_show_channel_chkbox.isChecked()
    self.GUI_time_enabled = self.GUI_show_time_chkbox.isChecked()
    self.GUI_storage_enabled = self.GUI_show_storage_chkbox.isChecked()
    self.GUI_show_exposure = self.GUI_show_exposure_chkbox.isChecked()
    self.GUI_show_xy = self.GUI_show_xy_chkbox.isChecked()
    self.GUI_show_z = self.GUI_show_z_chkbox.isChecked()
    self.GUI_show_channel = self.GUI_show_channel_chkbox.isChecked()
    self.GUI_show_time = self.GUI_show_time_chkbox.isChecked()
    self.GUI_show_storage = self.GUI_show_storage_chkbox.isChecked()</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.setMDAparams"><code class="name flex">
<span>def <span class="ident">setMDAparams</span></span>(<span>self, mdaparams)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the MDA parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mdaparams</code></strong></dt>
<dd>The MDA parameters to be set.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setMDAparams(self,mdaparams):
    &#34;&#34;&#34;
    Set the MDA parameters.
    
    Args:
        mdaparams: The MDA parameters to be set.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.mda = mdaparams</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.setZEnd"><code class="name flex">
<span>def <span class="ident">setZEnd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the end position of the Z stage.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setZEnd(self):
    &#34;&#34;&#34;
    Set the end position of the Z stage.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    
    zstage = self.z_oneDstageDropdown.currentText()
    #zstage value limited to 2 decimal places:
    zstagePos = round(float(self.core.get_position(zstage)),2)
    self.z_endEntry.setText(str(zstagePos))</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.setZStart"><code class="name flex">
<span>def <span class="ident">setZStart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the starting Z position based on the selected zstage.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setZStart(self):
    &#34;&#34;&#34;
    Set the starting Z position based on the selected zstage.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    
    zstage = self.z_oneDstageDropdown.currentText()
    #zstage value limited to 2 decimal places:
    zstagePos = round(float(self.core.get_position(zstage)),2)
    self.z_startEntry.setText(str(zstagePos))</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.set_font_and_margins_recursive"><code class="name flex">
<span>def <span class="ident">set_font_and_margins_recursive</span></span>(<span>self, widget, font=&lt;PyQt5.QtGui.QFont object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_and_margins_recursive(self,widget, font=QFont(&#34;Arial&#34;, 8)):
    &#34;&#34;&#34;
    Recursively sets the font of all buttons/labels in a layout to the specified font, and sets the contents margins to 0.
    Also sets the size policy of the widget to minimum, so it will only take up as much space as it needs.

    &#34;&#34;&#34;
    
    if isinstance(widget, (QPushButton)):
        widget.setFont(font)
        # widget.setContentsMargins(0, 0, 0, 0)
        # widget.setMinimumSize(20, 20)
    if isinstance(widget, (QLabel, QComboBox)):
        widget.setFont(font)
        # widget.setContentsMargins(0, 0, 0, 0)
        # widget.setMinimumSize(20, 20)

    if isinstance(widget, QGroupBox):
        widget.setSizePolicy(
            QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        )
        # Ensure QGroupBox respects the size of its contents
        widget.setMinimumSize(widget.minimumSizeHint())  # Set the minimum size of QGroupBox based on its size hint

    try:
        minsize = widget.minimumSizeHint()
        if minsize[0] &gt; -1 and minsize[1] &gt; -1:
            widget.setMinimumSize(widget.minimumSizeHint())
    except:
        pass

    if hasattr(widget, &#39;layout&#39;):
        layout = widget.layout()
        if layout:
            # layout.setContentsMargins(0, 0, 0, 0)
            # layout.setSpacing(0)  # Optionally, remove spacing between widgets
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if hasattr(item, &#39;widget&#39;):
                    self.set_font_and_margins_recursive(item.widget(), font=font)
                if hasattr(item, &#39;layout&#39;):
                    self.set_font_and_margins_recursive(item.layout(), font=font)</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.showOptionChanged"><code class="name flex">
<span>def <span class="ident">showOptionChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the GUI widgets based on the checkbox values.</p>
<p>This function will be called when the checkboxes are clicked. It will update the GUI accordingly.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showOptionChanged(self):
    &#34;&#34;&#34;
    Updates the GUI widgets based on the checkbox values.
    
    This function will be called when the checkboxes are clicked. It will update the GUI accordingly.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    
    self.setAllCheckBoxEnableValues()
    #This function will be called when the checkboxes are clicked. It will update the GUI accordingly:
    self.updateGUIwidgets(GUI_show_exposure=self.GUI_show_exposure_chkbox.isChecked(), GUI_show_xy = self.GUI_show_xy_chkbox.isChecked(), GUI_show_z=self.GUI_show_z_chkbox.isChecked(), GUI_show_channel=self.GUI_show_channel_chkbox.isChecked(), GUI_show_time=self.GUI_show_time_chkbox.isChecked(), GUI_show_storage=self.GUI_show_storage_chkbox.isChecked(),GUI_showOptions=True,GUI_acquire_button=self.GUI_acquire_button)
    self.get_MDA_events_from_GUI()</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.stopMDA"><code class="name flex">
<span>def <span class="ident">stopMDA</span></span>(<span>self, mdaLayerName='MDA')</span>
</code></dt>
<dd>
<div class="desc"><p>The stopMDA function is called when the user presses the 'Stop Acquisition' button in the GUI.
It stops the MDA acquisition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopMDA(self,mdaLayerName=&#39;MDA&#39;):
    &#34;&#34;&#34;
    The stopMDA function is called when the user presses the &#39;Stop Acquisition&#39; button in the GUI.
    It stops the MDA acquisition.
    &#34;&#34;&#34;
    
    logging.info(&#39;Attempting to stop MDA&#39;)
    #Reset the button
    self.resetMDAbutton(mdaLayerName=mdaLayerName)
    #Abort the mda mode
    self.shared_data._mdaModeAcqData.abort()</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.updateGUIwidgets"><code class="name flex">
<span>def <span class="ident">updateGUIwidgets</span></span>(<span>self, GUI_show_exposure=True, GUI_show_xy=False, GUI_show_z=True, GUI_show_channel=False, GUI_show_time=True, GUI_show_storage=True, GUI_showOptions=True, gridWidth=4, GUI_acquire_button=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the GUI widgets based on the specified parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>GUI_show_exposure</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the exposure widget. Default is True.</dd>
<dt><strong><code>GUI_show_xy</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the XY widget. Default is False.</dd>
<dt><strong><code>GUI_show_z</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the Z widget. Default is True.</dd>
<dt><strong><code>GUI_show_channel</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the channel widget. Default is False.</dd>
<dt><strong><code>GUI_show_time</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the time widget. Default is True.</dd>
<dt><strong><code>GUI_show_storage</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the storage widget. Default is True.</dd>
<dt><strong><code>GUI_showOptions</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the options widget. Default is True.</dd>
<dt><strong><code>gridWidth</code></strong> :&ensp;<code>int</code></dt>
<dd>The width of the grid. Default is 4.</dd>
<dt><strong><code>GUI_acquire_button</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the acquire button. Default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateGUIwidgets(self,GUI_show_exposure=True, GUI_show_xy = False, GUI_show_z=True, GUI_show_channel=False, GUI_show_time=True, GUI_show_storage=True,GUI_showOptions=True,gridWidth=4,GUI_acquire_button=True):
    &#34;&#34;&#34;
    Updates the GUI widgets based on the specified parameters.
    
    Args:
        GUI_show_exposure (bool): Whether to show the exposure widget. Default is True.
        GUI_show_xy (bool): Whether to show the XY widget. Default is False.
        GUI_show_z (bool): Whether to show the Z widget. Default is True.
        GUI_show_channel (bool): Whether to show the channel widget. Default is False.
        GUI_show_time (bool): Whether to show the time widget. Default is True.
        GUI_show_storage (bool): Whether to show the storage widget. Default is True.
        GUI_showOptions (bool): Whether to show the options widget. Default is True.
        gridWidth (int): The width of the grid. Default is 4.
        GUI_acquire_button (bool): Whether to show the acquire button. Default is True.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    gridWidth = self.GUI_grid_width
    # Remove the widgets from their parent
    self.exposureGroupBox.setParent(None) # type: ignore
    self.xyGroupBox.setParent(None) # type: ignore
    self.zGroupBox.setParent(None) # type: ignore
    self.channelGroupBox.setParent(None) # type: ignore
    self.timeGroupBox.setParent(None) # type: ignore
    # # self.orderGroupBox.setParent(None) # type: ignore
    self.storageGroupBox.setParent(None) # type: ignore
    self.showOptionsGroupBox.setParent(None)  # type: ignore


    # Clear the layout - this is required
    while self.gui.count(): # type: ignore
        item = self.gui.takeAt(0) # type: ignore
        widget = item.widget()
        if widget:
            widget.deleteLater()
    #redraw the self.gui:
    self.gui.update()
    QCoreApplication.processEvents()
    
    # At the beginning add an options groupbox, which has all the checkboxes and storage/acquire
    optionsBGroupBox = QWidget()
    optionsBLayout = QVBoxLayout()
    optionsBGroupBox.setLayout(optionsBLayout)
    optionsBLayout.addWidget(self.showOptionsGroupBox) # type: ignore
    self.showOptionsGroupBox.setEnabled(True)
    optionsBLayout.addWidget(self.storageGroupBox) # type: ignore
    if GUI_show_storage: 
        self.storageGroupBox.setEnabled(True)
    else:
        self.storageGroupBox.setEnabled(False)
    self.GUI_acquire_button = QPushButton(&#34;Acquire&#34;)
    self.GUI_acquire_button.clicked.connect(lambda index: self.MDA_acq_from_GUI(mdaLayerName=&#39;MDA&#39;))
    optionsBLayout.addWidget(self.GUI_acquire_button) # type: ignore
    if GUI_acquire_button:
        self.GUI_acquire_button.setEnabled(True)
    else:
        self.GUI_acquire_button.setEnabled(False)
    
    self.gui.addWidget(optionsBGroupBox, 0, 0) # type: ignore
    
    #Add order/exposure/time as single groupbox
    orderexposuretimegroupbox = QWidget()
    orderexposuretimelayout = QVBoxLayout()
    orderexposuretimegroupbox.setLayout(orderexposuretimelayout)
    
    if GUI_show_exposure:
        self.exposureGroupBox.setEnabled(True)
    else:
        self.exposureGroupBox.setEnabled(False)
        
    self.orderGroupBox = QGroupBox(&#34;Order&#34;)
    orderlayout = self.createOrderLayout(GUI_show_channel, GUI_show_time, GUI_show_xy, GUI_show_z, orderChoice=self.order)
    self.orderGroupBox.setLayout(orderlayout)
    
    orderexposuretimelayout.addWidget(self.orderGroupBox) # type: ignore
    orderexposuretimelayout.addWidget(self.exposureGroupBox) # type: ignore
    orderexposuretimelayout.addWidget(self.timeGroupBox) # type: ignore
    if GUI_show_time:
        self.timeGroupBox.setEnabled(True)
    else:
        self.timeGroupBox.setEnabled(False)
    #     # QCoreApplication.processEvents()
    self.gui.addWidget(orderexposuretimegroupbox, 1//gridWidth, 1%gridWidth) # type: ignore
    
    #Add XY, Z, Channel, groupboxes as individual groupboxes
    curindex = 2
    self.gui.addWidget(self.xyGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
    curindex+=1
    if GUI_show_xy:
        self.xyGroupBox.setEnabled(True)
    else:
        self.xyGroupBox.setEnabled(False)
        # QCoreApplication.processEvents()
    self.gui.addWidget(self.zGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
    curindex+=1
    if GUI_show_z:
        self.zGroupBox.setEnabled(True)
    else:
        self.zGroupBox.setEnabled(False)
        # QCoreApplication.processEvents()
    self.gui.addWidget(self.channelGroupBox, curindex//gridWidth, curindex%gridWidth) # type: ignore
    curindex+=1
    if GUI_show_channel:
        self.channelGroupBox.setEnabled(True)
    else:
        self.channelGroupBox.setEnabled(False)
        # QCoreApplication.processEvents()
    
    
    self.gui.setColumnStretch(99,gridWidth+1) # type: ignore
    self.gui.setRowStretch(99,gridWidth+1) # type: ignore
    
    #try to trigger a dock widget resize event at this point.
    mdawidget_object = self.gui.parent() #type:ignore
    try:
        logging.debug(&#39;attempting to update parent&#39;)
        from PyQt5.QtCore import QEvent
        current_size = mdawidget_object.size() #type:ignore
        resize_event = QEvent(QEvent.Resize) #type:ignore
        resize_event.oldSize = lambda: current_size #type:ignore
        resize_event.size = lambda: current_size #type:ignore
        QApplication.sendEvent(mdawidget_object, resize_event)
    except:
        logging.debug(&#39;did not attempt to update parent&#39;)
    
    
    QCoreApplication.processEvents()
    
    #redraw the self.gui:
    self.gui.update()</code></pre>
</details>
</dd>
<dt id="MDAGlados.MDAGlados.updateNodzVariables"><code class="name flex">
<span>def <span class="ident">updateNodzVariables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update Nodz variables (variablesNodz) with current data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateNodzVariables(self):
    &#34;&#34;&#34;
    Update Nodz variables (variablesNodz) with current data.
    &#34;&#34;&#34;
    if &#39;nodeInfo&#39; in vars(self) and self.nodeInfo is not None:
        utils.updateNodzVariablesTime(self.nodeInfo)
        self.nodeInfo.variablesNodz[&#39;data&#39;][&#39;data&#39;] = self.data
        self.nodeInfo.variablesNodz[&#39;order&#39;][&#39;data&#39;] = self.order
        self.nodeInfo.variablesNodz[&#39;exposure_ms&#39;][&#39;data&#39;] = self.exposure_ms
        self.nodeInfo.variablesNodz[&#39;n_timepoints&#39;][&#39;data&#39;] = self.num_time_points
        self.nodeInfo.variablesNodz[&#39;time_interval_ms&#39;][&#39;data&#39;] = self.time_interval_s*1000 #type: ignore
        if self.GUI_show_xy == True and self.xy_positions is not None:
            self.nodeInfo.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = self.xy_positions
            self.nodeInfo.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = len(self.xy_positions) #type: ignore
        else:
            self.nodeInfo.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = None
            self.nodeInfo.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = None
        if self.GUI_show_z == True:
            self.nodeInfo.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = [self.z_start, self.z_step, self.z_end]
            self.nodeInfo.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = self.z_nr_steps
        else:
            self.nodeInfo.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = None
            self.nodeInfo.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = None
        if self.GUI_show_channel == True:
            self.nodeInfo.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = self.channel_group
            self.nodeInfo.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = self.channels
            self.nodeInfo.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = len(self.channels) #type: ignore
        else:
            self.nodeInfo.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = None
            self.nodeInfo.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = None
            self.nodeInfo.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = None
        if self.GUI_storage_enabled == True:
            try:
                #Update to the actually-stored-path.
                self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = self.data.path #type: ignore
            except AttributeError:
                #Update to the expectedpath.
                self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = self.storage_folder+os.sep+self.storage_file_name+&#39;_1//&#39; #type: ignore
        else:
            self.nodeInfo.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MDAGlados.XYStageList"><code class="flex name class">
<span>class <span class="ident">XYStageList</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creation of an interactive list widget, initially created for a nice XY list (similar to POS list in micromanager)
Extends InteractiveListWidget</p>
<p>Initializes the XY stage, only setting the name to empty</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XYStageList(InteractiveListWidget):
    &#34;&#34;&#34;
    Creation of an interactive list widget, initially created for a nice XY list (similar to POS list in micromanager)
    Extends InteractiveListWidget
    &#34;&#34;&#34;
    def __init__(self,parent=None):
        &#34;&#34;&#34;
        Initializes the XY stage, only setting the name to empty
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent=parent,columnCount=4)
        self.XYstageName = &#39;&#39;
        
    def setXYStageName(self, XYstageName):
        &#34;&#34;&#34;
        Set the name of the XY stage.
        
        Args:
            XYstageName (str): The name of the XY stage to be set.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.XYstageName = XYstageName
    
    def getPositionsArray(self):
        &#34;&#34;&#34;
        Return an array of the positions for pycromanager to work with
        &#34;&#34;&#34;
        if self.rowCount() == 0:
            return None
        elif self.rowCount() &gt; 0:
            posArray = []
            for row in range(self.rowCount()):
                posArray.append([float(self.item(row, 2).text()),float(self.item(row, 3).text())])
            return posArray
    
    def getSaveInfoPositionsArray(self):
        &#34;&#34;&#34;
        Return an array of the positions for pycromanager to work with, with all info (i.e. name, id)
        &#34;&#34;&#34;
        if self.rowCount() == 0:
            return None
        elif self.rowCount() &gt; 0:
            infoArray = []
            for row in range(self.rowCount()):
                infoArray.append([self.item(row, 0).text(),self.item(row, 1).text(),self.item(row, 2).text(),self.item(row, 3).text()])
            return infoArray
    
    def swapRows(self, row1, row2):
        &#34;&#34;&#34;
        Swap rows in the table widget.
        
        Args:
            row1 (int): The index of the first row to swap.
            row2 (int): The index of the second row to swap.
        
        Returns:
            None
        &#34;&#34;&#34;
        for col in range(self.columnCount()):
            item1 = self.takeItem(row1, col)
            item2 = self.takeItem(row2, col)
            self.setItem(row1, col, item2)
            self.setItem(row2, col, item1)
        self.setCurrentCell(row2, 0)
        
    def addNewEntry(self,textEntry=&#34;New Entry&#34;,id=None,setxy:str|Iterable=&#34;Pos&#34;):
        &#34;&#34;&#34;
        Add a new entry to the table.
        
        Args:
            textEntry (str): The text entry to be added. Default is &#34;New Entry&#34;.
            id (int): The ID of the new entry. If not provided, it will be automatically generated based on existing IDs.
        
        Returns:
            None
        &#34;&#34;&#34;
        if id is None:
            if self.rowCount() == 0:
                id = 1
            else:
                try:
                    #add the new ID to be the max existing ID + 1
                    existing_ids = [int(self.item(row, 1).text()) for row in range(self.rowCount())]
                    id = max(existing_ids) + 1
                except:
                    id = self.rowCount() + 1
        rowPosition = self.rowCount()
        self.insertRow(rowPosition)
        self.setItem(rowPosition, 0, QTableWidgetItem(textEntry))
        self.setItem(rowPosition, 1, QTableWidgetItem(str(id)))
        if setxy == &#34;Pos&#34;:
            self.setItem(rowPosition, 2, QTableWidgetItem(str(self.parent.core.get_xy_stage_position().x)))
            self.setItem(rowPosition, 3, QTableWidgetItem(str(self.parent.core.get_xy_stage_position().y)))
        elif len(setxy) == 2: #type:ignore
            self.setItem(rowPosition, 2, QTableWidgetItem(str(setxy[0]))) #type:ignore
            self.setItem(rowPosition, 3, QTableWidgetItem(str(setxy[1]))) #type:ignore</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MDAGlados.InteractiveListWidget" href="#MDAGlados.InteractiveListWidget">InteractiveListWidget</a></li>
<li>PyQt5.QtWidgets.QTableWidget</li>
<li>PyQt5.QtWidgets.QTableView</li>
<li>PyQt5.QtWidgets.QAbstractItemView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MDAGlados.XYStageList.addNewEntry"><code class="name flex">
<span>def <span class="ident">addNewEntry</span></span>(<span>self, textEntry='New Entry', id=None, setxy:Â Union[str,Â Iterable]Â =Â 'Pos')</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new entry to the table.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>textEntry</code></strong> :&ensp;<code>str</code></dt>
<dd>The text entry to be added. Default is "New Entry".</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>int</code></dt>
<dd>The ID of the new entry. If not provided, it will be automatically generated based on existing IDs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addNewEntry(self,textEntry=&#34;New Entry&#34;,id=None,setxy:str|Iterable=&#34;Pos&#34;):
    &#34;&#34;&#34;
    Add a new entry to the table.
    
    Args:
        textEntry (str): The text entry to be added. Default is &#34;New Entry&#34;.
        id (int): The ID of the new entry. If not provided, it will be automatically generated based on existing IDs.
    
    Returns:
        None
    &#34;&#34;&#34;
    if id is None:
        if self.rowCount() == 0:
            id = 1
        else:
            try:
                #add the new ID to be the max existing ID + 1
                existing_ids = [int(self.item(row, 1).text()) for row in range(self.rowCount())]
                id = max(existing_ids) + 1
            except:
                id = self.rowCount() + 1
    rowPosition = self.rowCount()
    self.insertRow(rowPosition)
    self.setItem(rowPosition, 0, QTableWidgetItem(textEntry))
    self.setItem(rowPosition, 1, QTableWidgetItem(str(id)))
    if setxy == &#34;Pos&#34;:
        self.setItem(rowPosition, 2, QTableWidgetItem(str(self.parent.core.get_xy_stage_position().x)))
        self.setItem(rowPosition, 3, QTableWidgetItem(str(self.parent.core.get_xy_stage_position().y)))
    elif len(setxy) == 2: #type:ignore
        self.setItem(rowPosition, 2, QTableWidgetItem(str(setxy[0]))) #type:ignore
        self.setItem(rowPosition, 3, QTableWidgetItem(str(setxy[1]))) #type:ignore</code></pre>
</details>
</dd>
<dt id="MDAGlados.XYStageList.getPositionsArray"><code class="name flex">
<span>def <span class="ident">getPositionsArray</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an array of the positions for pycromanager to work with</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPositionsArray(self):
    &#34;&#34;&#34;
    Return an array of the positions for pycromanager to work with
    &#34;&#34;&#34;
    if self.rowCount() == 0:
        return None
    elif self.rowCount() &gt; 0:
        posArray = []
        for row in range(self.rowCount()):
            posArray.append([float(self.item(row, 2).text()),float(self.item(row, 3).text())])
        return posArray</code></pre>
</details>
</dd>
<dt id="MDAGlados.XYStageList.getSaveInfoPositionsArray"><code class="name flex">
<span>def <span class="ident">getSaveInfoPositionsArray</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an array of the positions for pycromanager to work with, with all info (i.e. name, id)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSaveInfoPositionsArray(self):
    &#34;&#34;&#34;
    Return an array of the positions for pycromanager to work with, with all info (i.e. name, id)
    &#34;&#34;&#34;
    if self.rowCount() == 0:
        return None
    elif self.rowCount() &gt; 0:
        infoArray = []
        for row in range(self.rowCount()):
            infoArray.append([self.item(row, 0).text(),self.item(row, 1).text(),self.item(row, 2).text(),self.item(row, 3).text()])
        return infoArray</code></pre>
</details>
</dd>
<dt id="MDAGlados.XYStageList.setXYStageName"><code class="name flex">
<span>def <span class="ident">setXYStageName</span></span>(<span>self, XYstageName)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the name of the XY stage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>XYstageName</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the XY stage to be set.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setXYStageName(self, XYstageName):
    &#34;&#34;&#34;
    Set the name of the XY stage.
    
    Args:
        XYstageName (str): The name of the XY stage to be set.
    
    Returns:
        None
    &#34;&#34;&#34;
    self.XYstageName = XYstageName</code></pre>
</details>
</dd>
<dt id="MDAGlados.XYStageList.swapRows"><code class="name flex">
<span>def <span class="ident">swapRows</span></span>(<span>self, row1, row2)</span>
</code></dt>
<dd>
<div class="desc"><p>Swap rows in the table widget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row1</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the first row to swap.</dd>
<dt><strong><code>row2</code></strong> :&ensp;<code>int</code></dt>
<dd>The index of the second row to swap.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swapRows(self, row1, row2):
    &#34;&#34;&#34;
    Swap rows in the table widget.
    
    Args:
        row1 (int): The index of the first row to swap.
        row2 (int): The index of the second row to swap.
    
    Returns:
        None
    &#34;&#34;&#34;
    for col in range(self.columnCount()):
        item1 = self.takeItem(row1, col)
        item2 = self.takeItem(row2, col)
        self.setItem(row1, col, item2)
        self.setItem(row2, col, item1)
    self.setCurrentCell(row2, 0)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MDAGlados.InteractiveListWidget" href="#MDAGlados.InteractiveListWidget">InteractiveListWidget</a></b></code>:
<ul class="hlist">
<li><code><a title="MDAGlados.InteractiveListWidget.deleteAll" href="#MDAGlados.InteractiveListWidget.deleteAll">deleteAll</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.deleteSelected" href="#MDAGlados.InteractiveListWidget.deleteSelected">deleteSelected</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.getIDValues" href="#MDAGlados.InteractiveListWidget.getIDValues">getIDValues</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveDown" href="#MDAGlados.InteractiveListWidget.moveDown">moveDown</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveToPos" href="#MDAGlados.InteractiveListWidget.moveToPos">moveToPos</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveUp" href="#MDAGlados.InteractiveListWidget.moveUp">moveUp</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.setColumNames" href="#MDAGlados.InteractiveListWidget.setColumNames">setColumNames</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MDAGlados.ChannelList" href="#MDAGlados.ChannelList">ChannelList</a></code></h4>
<ul class="">
<li><code><a title="MDAGlados.ChannelList.addNewEntry" href="#MDAGlados.ChannelList.addNewEntry">addNewEntry</a></code></li>
<li><code><a title="MDAGlados.ChannelList.setChannelName" href="#MDAGlados.ChannelList.setChannelName">setChannelName</a></code></li>
<li><code><a title="MDAGlados.ChannelList.swapRows" href="#MDAGlados.ChannelList.swapRows">swapRows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MDAGlados.InteractiveListWidget" href="#MDAGlados.InteractiveListWidget">InteractiveListWidget</a></code></h4>
<ul class="">
<li><code><a title="MDAGlados.InteractiveListWidget.deleteAll" href="#MDAGlados.InteractiveListWidget.deleteAll">deleteAll</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.deleteSelected" href="#MDAGlados.InteractiveListWidget.deleteSelected">deleteSelected</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.disconnectFunGUIConnection" href="#MDAGlados.InteractiveListWidget.disconnectFunGUIConnection">disconnectFunGUIConnection</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.getIDValues" href="#MDAGlados.InteractiveListWidget.getIDValues">getIDValues</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveDown" href="#MDAGlados.InteractiveListWidget.moveDown">moveDown</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveToPos" href="#MDAGlados.InteractiveListWidget.moveToPos">moveToPos</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.moveUp" href="#MDAGlados.InteractiveListWidget.moveUp">moveUp</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.reconnectFunGUIConnection" href="#MDAGlados.InteractiveListWidget.reconnectFunGUIConnection">reconnectFunGUIConnection</a></code></li>
<li><code><a title="MDAGlados.InteractiveListWidget.setColumNames" href="#MDAGlados.InteractiveListWidget.setColumNames">setColumNames</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MDAGlados.MDAGlados" href="#MDAGlados.MDAGlados">MDAGlados</a></code></h4>
<ul class="">
<li><code><a title="MDAGlados.MDAGlados.GUI_grid_width" href="#MDAGlados.MDAGlados.GUI_grid_width">GUI_grid_width</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.MDA_acq_finished" href="#MDAGlados.MDAGlados.MDA_acq_finished">MDA_acq_finished</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.MDA_acq_from_GUI" href="#MDAGlados.MDAGlados.MDA_acq_from_GUI">MDA_acq_from_GUI</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.MDA_acq_from_Node" href="#MDAGlados.MDAGlados.MDA_acq_from_Node">MDA_acq_from_Node</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.MDA_completed" href="#MDAGlados.MDAGlados.MDA_completed">MDA_completed</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.createOrderLayout" href="#MDAGlados.MDAGlados.createOrderLayout">createOrderLayout</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.getDevicesOfDeviceType" href="#MDAGlados.MDAGlados.getDevicesOfDeviceType">getDevicesOfDeviceType</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.getEvents" href="#MDAGlados.MDAGlados.getEvents">getEvents</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.getGui" href="#MDAGlados.MDAGlados.getGui">getGui</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.get_MDA_events_from_GUI" href="#MDAGlados.MDAGlados.get_MDA_events_from_GUI">get_MDA_events_from_GUI</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.handleSizeChange" href="#MDAGlados.MDAGlados.handleSizeChange">handleSizeChange</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.initGUI" href="#MDAGlados.MDAGlados.initGUI">initGUI</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.printText" href="#MDAGlados.MDAGlados.printText">printText</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.resetMDAbutton" href="#MDAGlados.MDAGlados.resetMDAbutton">resetMDAbutton</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.setAllCheckBoxEnableValues" href="#MDAGlados.MDAGlados.setAllCheckBoxEnableValues">setAllCheckBoxEnableValues</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.setMDAparams" href="#MDAGlados.MDAGlados.setMDAparams">setMDAparams</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.setZEnd" href="#MDAGlados.MDAGlados.setZEnd">setZEnd</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.setZStart" href="#MDAGlados.MDAGlados.setZStart">setZStart</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.set_font_and_margins_recursive" href="#MDAGlados.MDAGlados.set_font_and_margins_recursive">set_font_and_margins_recursive</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.showOptionChanged" href="#MDAGlados.MDAGlados.showOptionChanged">showOptionChanged</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.stopMDA" href="#MDAGlados.MDAGlados.stopMDA">stopMDA</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.updateGUIwidgets" href="#MDAGlados.MDAGlados.updateGUIwidgets">updateGUIwidgets</a></code></li>
<li><code><a title="MDAGlados.MDAGlados.updateNodzVariables" href="#MDAGlados.MDAGlados.updateNodzVariables">updateNodzVariables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MDAGlados.XYStageList" href="#MDAGlados.XYStageList">XYStageList</a></code></h4>
<ul class="">
<li><code><a title="MDAGlados.XYStageList.addNewEntry" href="#MDAGlados.XYStageList.addNewEntry">addNewEntry</a></code></li>
<li><code><a title="MDAGlados.XYStageList.getPositionsArray" href="#MDAGlados.XYStageList.getPositionsArray">getPositionsArray</a></code></li>
<li><code><a title="MDAGlados.XYStageList.getSaveInfoPositionsArray" href="#MDAGlados.XYStageList.getSaveInfoPositionsArray">getSaveInfoPositionsArray</a></code></li>
<li><code><a title="MDAGlados.XYStageList.setXYStageName" href="#MDAGlados.XYStageList.setXYStageName">setXYStageName</a></code></li>
<li><code><a title="MDAGlados.XYStageList.swapRows" href="#MDAGlados.XYStageList.swapRows">swapRows</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>