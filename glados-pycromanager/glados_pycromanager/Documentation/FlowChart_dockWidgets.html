<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>FlowChart_dockWidgets API documentation</title>
<meta name="description" content="Main functions belonging to the &#39;Autonomous Microscopy&#39; part of Glados-pycromanager â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>FlowChart_dockWidgets</code></h1>
</header>
<section id="section-intro">
<p>Main functions belonging to the 'Autonomous Microscopy' part of Glados-pycromanager.</p>
<p>Handles the analysis microscopy flowchart.
Contains all information on creating/displaying/deleting/handling nodes.
Contains the Scanning/Decision/Variables/Logger widgets encapsulated in the autonomous microscopy</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Main functions belonging to the &#39;Autonomous Microscopy&#39; part of Glados-pycromanager.

Handles the analysis microscopy flowchart.
Contains all information on creating/displaying/deleting/handling nodes.
Contains the Scanning/Decision/Variables/Logger widgets encapsulated in the autonomous microscopy
&#34;&#34;&#34;

#region imports
#Add inclusion of this folder:
import sys, os
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QGroupBox
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QTextCursor
sys.path.append(&#39;glados-pycromanager\\glados_pycromanager\\GUI\\nodz&#39;)
from PyQt5 import QtCore, QtWidgets
from PyQt5.QtCore import QObject, pyqtSignal
from PyQt5.QtWidgets import QApplication, QGraphicsScene, QMainWindow, QGraphicsView, QPushButton, QVBoxLayout, QTextEdit, QPlainTextEdit, QWidget, QTabWidget, QMenu, QAction, QColorDialog, QHBoxLayout, QCheckBox, QDoubleSpinBox
from PyQt5.QtCore import Qt, QSize
from PyQt5 import QtGui
from PyQt5.QtWidgets import QGridLayout, QPushButton
from PyQt5.QtWidgets import QLineEdit, QInputDialog, QDialog, QLineEdit, QComboBox, QVBoxLayout, QDialogButtonBox, QMenu, QAction
from PyQt5.QtGui import QFont, QColor, QTextDocument, QAbstractTextDocumentLayout
from PyQt5.QtCore import QRectF
from qtpy.QtWidgets import QFileDialog, QMessageBox
from qtpy.QtWidgets import QFileDialog
import numpy as np
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from PyQt5.QtWidgets import QApplication, QComboBox
from PyQt5.QtWidgets import QApplication, QSizePolicy, QSpacerItem, QVBoxLayout, QScrollArea, QMainWindow, QWidget, QSpinBox, QLabel
import logging

def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__

if is_pip_installed():
    from glados_pycromanager.AutonomousMicroscopy.Analysis_Images import * 
    from glados_pycromanager.AutonomousMicroscopy.Analysis_Measurements import *
    from glados_pycromanager.AutonomousMicroscopy.Analysis_Shapes import *
    from glados_pycromanager.AutonomousMicroscopy.Real_Time_Analysis import *
    from glados_pycromanager.AutonomousMicroscopy.CustomFunctions import *
    import glados_pycromanager.GUI.utils as utils
    from glados_pycromanager.GUI.nodz import nodz_utils
    import glados_pycromanager.GUI.nodz.nodz_main as NodzMain
    from glados_pycromanager.GUI.MMcontrols import MMConfigUI, ConfigInfo
    from glados_pycromanager.GUI.MDAGlados import MDAGlados
    import glados_pycromanager.GUI.nodz.nodz_utils as nodz_utils
else:
    #Import all scripts in the custom script folders
    from AutonomousMicroscopy.Analysis_Images import *
    from AutonomousMicroscopy.Analysis_Measurements import * #type: ignore
    from AutonomousMicroscopy.Analysis_Shapes import * #type: ignore
    from AutonomousMicroscopy.Real_Time_Analysis import * #type: ignore
    from AutonomousMicroscopy.CustomFunctions import * #type: ignore
    import utils
    from nodz import nodz_utils
    import nodz_main as NodzMain
    from MMcontrols import MMConfigUI, ConfigInfo
    from MDAGlados import MDAGlados
    import nodz.nodz_utils as nodz_utils
#endregion

#region Dialogs_Nodz
class AnalysisScoringVisualisationDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for analysis/scoring/visualisation methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology. Also used for real-time analysis dialog.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None, addVisualisationBox = False):
        &#34;&#34;&#34;
        Advanced input dialog.

        Args:
            parent (QWidget): Parent widget.
            currentNode (Nodz): Node data.
            addVisualisationBox: A boolean indicating whether to add a visualization CheckBox (default is False). 

        Returns:
            tuple: A tuple containing the line edit and combo box input from the user.
        &#34;&#34;&#34;
        super().__init__()
        
        self.currentData = {}
        
        # Create layout
        layout = QVBoxLayout()
        
        self.mainLayout = QGridLayout()
        layout.addLayout(self.mainLayout)
        
        bottomHbox = QHBoxLayout()
        
        if addVisualisationBox:
            self.visualisationBox = QCheckBox()
            visualisationLabel = QLabel(&#39;Visualise&#39;)
            visualiseHbox = QHBoxLayout()
            visualiseHbox.addWidget(self.visualisationBox)
            visualiseHbox.addWidget(visualisationLabel)
            bottomHbox.addLayout(visualiseHbox)
            
        #Add a OK/cancel button set:
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        bottomHbox.addWidget(button_box)
        #Add this to the bottom of the layout, stretching horizontally but centering in the center:
        layout.addLayout(bottomHbox)
        
        self.setLayout(layout)

class nodz_analysisDialog(AnalysisScoringVisualisationDialog):
    &#34;&#34;&#34;
    A Dialog that is created for analysis methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Initializes the Analysis Options window.
        
        Args:
            parent: Parent widget (default is None).
            currentNode: Current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent, currentNode)
        self.setWindowTitle(&#34;Analysis Options&#34;)
        self.setMinimumSize(400,100)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        #Let&#39;s try to get all possible analysis options
        analysisFunctions_Images = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Analysis_Images&#39;)
        analysisFunctions_Measurements = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Analysis_Measurements&#39;)
        analysisFunctions_Shapes = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Analysis_Shapes&#39;)
        #Also add them back to back
        all_analysisFunctions = analysisFunctions_Images + analysisFunctions_Measurements + analysisFunctions_Shapes
        
        allDisplayNames,displaynameMapping = utils.displayNamesFromFunctionNames(all_analysisFunctions,&#39;&#39;)
        #Store this mapping also in the node
        self.currentData[&#39;__displayNameFunctionNameMap__&#39;] = displaynameMapping
        
        #Add a dropbox with all the options
        self.comboBox_analysisFunctions = QComboBox(self)
        if len(analysisFunctions_Images) &gt; 0:
            for item in analysisFunctions_Images:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
            self.comboBox_analysisFunctions.insertSeparator(len(analysisFunctions_Images)-1)  
        if len(analysisFunctions_Measurements) &gt; 0:
            for item in analysisFunctions_Measurements:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
            self.comboBox_analysisFunctions.insertSeparator(len(analysisFunctions_Images)+len(analysisFunctions_Measurements)-1)
        if len(analysisFunctions_Shapes) &gt; 0:
            for item in analysisFunctions_Shapes:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
            self.comboBox_analysisFunctions.insertSeparator(len(analysisFunctions_Images)+len(analysisFunctions_Measurements)+len(analysisFunctions_Shapes)-1)          

        self.mainLayout.addWidget(self.comboBox_analysisFunctions, 0, 1)
        #give it an objectName:
        self.comboBox_analysisFunctions.setObjectName(&#39;comboBox_analysisFunctions_KEEP&#39;)
        #Give it a connect-callback if it&#39;s changed (then the layout should be changed)
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, layout=self.mainLayout, dropdown=self.comboBox_analysisFunctions,displaynameMapping=displaynameMapping: utils.layout_changedDropdown(layout,dropdown,displaynameMapping))
        #Also give it a connect-callback to store the currentinfo:
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, parentdata=self: utils.updateCurrentDataUponDropdownChange(parentdata))

        # pre-load all args/kwargs and their edit values - then hide all of them
        utils.layout_init(self.mainLayout,&#39;&#39;,displaynameMapping,current_dropdown = self.comboBox_analysisFunctions,nodzInfo=parent)
        
        # if currentNode.scoring_analysis_currentData == {}: #type:ignore
        #     utils.preLoadOptions_analysis(self.mainLayout,self.currentData)
        # else: 
            
        #Add an expanding spacer at the bottom:
        spacer_item = QSpacerItem(
            20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding
        )
        # Add the spacer item to the grid layout
        self.mainLayout.addItem(spacer_item, 99, 0)
        
        #Pre-load the options if they&#39;re in the current node info
        utils.preLoadOptions_analysis(self.mainLayout,currentNode.scoring_analysis_currentData) #type:ignore

class nodz_customFunctionDialog(AnalysisScoringVisualisationDialog):
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Initializes the Analysis Options window.
        
        Args:
            parent: Parent widget (default is None).
            currentNode: Current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent, currentNode)
        self.setWindowTitle(&#34;Custom Function Options&#34;)
        self.setMinimumSize(400,100)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        #Let&#39;s try to get all possible analysis options
        customFunctions = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\CustomFunctions&#39;)
        #Also add them back to back
        all_analysisFunctions = customFunctions
        
        allDisplayNames,displaynameMapping = utils.displayNamesFromFunctionNames(all_analysisFunctions,&#39;&#39;)
        #Store this mapping also in the node
        self.currentData[&#39;__displayNameFunctionNameMap__&#39;] = displaynameMapping
        
        #Add a dropbox with all the options
        self.comboBox_analysisFunctions = QComboBox(self)
        if len(customFunctions) &gt; 0:
            for item in customFunctions:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
                
        self.mainLayout.addWidget(self.comboBox_analysisFunctions, 0, 1)
        #give it an objectName:
        self.comboBox_analysisFunctions.setObjectName(&#39;comboBox_customFunctions_KEEP&#39;)
        #Give it a connect-callback if it&#39;s changed (then the layout should be changed)
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, layout=self.mainLayout, dropdown=self.comboBox_analysisFunctions,displaynameMapping=displaynameMapping: utils.layout_changedDropdown(layout,dropdown,displaynameMapping))
        #Also give it a connect-callback to store the currentinfo:
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, parentdata=self: utils.updateCurrentDataUponDropdownChange(parentdata))

        # pre-load all args/kwargs and their edit values - then hide all of them
        utils.layout_init(self.mainLayout,&#39;&#39;,displaynameMapping,current_dropdown = self.comboBox_analysisFunctions,nodzInfo=parent,skipInput=True)
        
        #Add an expanding spacer at the bottom:
        spacer_item = QSpacerItem(
            20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding
        )
        # Add the spacer item to the grid layout
        self.mainLayout.addItem(spacer_item, 99, 0)
        
        #Pre-load the options if they&#39;re in the current node info
        utils.preLoadOptions_analysis(self.mainLayout,currentNode.customFunction_currentData,functionName = &#39;comboBox_customFunctions&#39;) #type:ignore
        
        try:
            #Set the current dropdown to be correct
            correctFunction = currentNode.customFunction_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;] #type:ignore
            self.comboBox_analysisFunctions.setCurrentText(correctFunction)
        except KeyError:
            pass

class nodz_realTimeAnalysisDialog(AnalysisScoringVisualisationDialog):
    &#34;&#34;&#34;
    A Dialog that is created for real-time analysis methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None,addVisualisationBox=True):
        &#34;&#34;&#34;
        Initializes the Real-Time Analysis Options window.
        
        Args:
            parent: The parent widget (default is None).
            currentNode: The current node (default is None).
            addVisualisationBox: A boolean indicating whether to add a visualization CheckBox (default is True). 
        
        Returns:
            None
        &#34;&#34;&#34;
        
        super().__init__(parent, currentNode,addVisualisationBox)
        self.setWindowTitle(&#34;Real-Time Analysis Options&#34;)
        
        #Let&#39;s try to get all possible RT analysis options
        realTimeAnalysisFunctions = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Real_Time_Analysis&#39;)
        
        allDisplayNames,displaynameMapping = utils.displayNamesFromFunctionNames(realTimeAnalysisFunctions,&#39;&#39;)
        #Store this mapping also in the node
        self.currentData[&#39;__displayNameFunctionNameMap__&#39;] = displaynameMapping
        
        #Add a dropbox with all the options
        self.comboBox_RTanalysisFunctions = QComboBox(self)
        if len(realTimeAnalysisFunctions) &gt; 0:
            for item in realTimeAnalysisFunctions:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_RTanalysisFunctions.addItem(displayNameI[0]) 
        
        self.mainLayout.addWidget(self.comboBox_RTanalysisFunctions, 0, 1)
        #give it an objectName:
        self.comboBox_RTanalysisFunctions.setObjectName(&#39;comboBox_RTanalysisFunctions_KEEP&#39;)
        #Give it a connect-callback if it&#39;s changed (then the layout should be changed)
        self.comboBox_RTanalysisFunctions.currentIndexChanged.connect(lambda index, layout=self.mainLayout, dropdown=self.comboBox_RTanalysisFunctions,displaynameMapping=displaynameMapping: utils.layout_changedDropdown(layout,dropdown,displaynameMapping))
        #Also give it a connect-callback to store the currentinfo:
        self.comboBox_RTanalysisFunctions.currentIndexChanged.connect(lambda index, parentdata=self: utils.updateCurrentDataUponDropdownChange(parentdata))

        # pre-load all args/kwargs and their edit values - then hide all of them
        utils.layout_init(self.mainLayout,&#39;&#39;,displaynameMapping,current_dropdown = self.comboBox_RTanalysisFunctions,nodzInfo=parent,skipInput=True)
        
        #Pre-load the options if they&#39;re in the current node info
        if &#39;real_time_analysis_currentData&#39; in vars(currentNode):
            if &#39;__realTimeVisualisation__&#39; in currentNode.real_time_analysis_currentData and currentNode.real_time_analysis_currentData[&#39;__realTimeVisualisation__&#39;]: #type:ignore
                self.visualisationBox.setChecked(True)
            
            utils.preLoadOptions_realtime(self.mainLayout,currentNode.real_time_analysis_currentData) #type:ignore

class nodz_analysisMeasurementDialog(nodz_analysisDialog):
    &#34;&#34;&#34;
    A Dialog that is created for analysis methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Dummy init function.
        &#34;&#34;&#34;
        super().__init__(parent, currentNode)
        self.setWindowTitle(&#34;Analysis Measurement Options&#34;)

class nodz_openInlineScriptDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for timer in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the TimerDialog.
        
        Args:
            parentNode: The parent node of the TimerDialog. If provided, the timerInfo will be set to the timerInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(&#34;InlineScript Dialog&#34;)
        self.InlineScriptInfo  = &#39;&#39;
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            self.InlineScriptInfo  = parentNode.InlineScriptInfo

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Create the QVBoxLayout
        layout = QVBoxLayout()

        #add a big editable text box:
        scriptinfo = QTextEdit()
        scriptinfo.setPlainText(self.InlineScriptInfo)
        scriptinfo.textChanged.connect(lambda: setattr(self, &#39;InlineScriptInfo&#39;, scriptinfo.toPlainText()))

        # Add the QMainWindow to the QVBoxLayout
        layout.addWidget(scriptinfo)

        layout.addWidget(button_box)
        
        self.setLayout(layout)

class nodz_stickyNoteDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for sticky notes in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the StickyNoteDialog.
        
        Args:
            parentNode: The parent node of the StickyNoteDialog. If provided, the stickyNoteInfo will be set to the stickyNoteInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(&#34;Sticky Note Dialog&#34;)
        self.stickyNoteInfo  = &#39;&#39;
        if parentNode is not None:
            self.stickyNoteInfo = parentNode.stickyNoteInfo

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Create the QVBoxLayout
        layout = QVBoxLayout()

        #add a big editable text box:
        stickyNoteInfoTE = QTextEdit()
        stickyNoteInfoTE.setPlainText(self.stickyNoteInfo)
        stickyNoteInfoTE.textChanged.connect(lambda: setattr(self, &#39;stickyNoteInfo&#39;, stickyNoteInfoTE.toPlainText()))

        # Add the QMainWindow to the QVBoxLayout
        layout.addWidget(stickyNoteInfoTE)

        layout.addWidget(button_box)
        
        self.setLayout(layout)


class nodz_slackReportDialog(QDialog):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(&#34;Slack Report Dialog&#34;)
        self.slackReportInfo  = &#39;&#39;
        if parentNode is not None:
            self.slackReportInfo   = parentNode.slackReportInfo

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Create the QVBoxLayout
        layout = QVBoxLayout()

        #add a big editable text box:
        slackReportInfo = QTextEdit()
        slackReportInfo.setPlainText(self.slackReportInfo)
        slackReportInfo.textChanged.connect(lambda: setattr(self, &#39;slackReportInfo&#39;, slackReportInfo.toPlainText()))

        # Add the QMainWindow to the QVBoxLayout
        layout.addWidget(slackReportInfo)

        layout.addWidget(button_box)
        
        self.setLayout(layout)

#General class for dialogs with simple line-edits only:
# class nodz_generalAdvancedLineEditDialog(QDialog):

class nodz_generalAdvancedLineEditDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for changeGlobalVar in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None,title=&#34;Title&#34;,internalName=&#39;internalName&#39;,advLineEdits=[{&#39;LineEdit1:&#39;:[&#39;intLineEdit1&#39;,&#39;Value&#39;]},{&#39;LineEdit2:&#39;: [&#39;intLineEdit2&#39;,&#39;Variable&#39;]}],storeVarName=&#39;storeVarName&#39;):
        &#34;&#34;&#34;
        Initializes the changeGlobalVarDialog.
        
        Args:
            parentNode: The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(title)
        self.storeVarName = storeVarName
        
        setattr(self,storeVarName,0)
        # selfvar = getattr(self,storeVarName)
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            setattr(self,storeVarName,getattr(parentNode,storeVarName))
            # self.changeGlobalVarInfo  = parentNode.changeGlobalVarInfo 

        # Create the QVBoxLayout
        layout = QGridLayout()

        self.advLineEditLayouts={}
        GridCounter = 0
        #Create a lineEditWidget for each requested
        for lineEditWidget in advLineEdits:
            labelName = list(lineEditWidget.keys())[0]
            varName = list(lineEditWidget.values())[0][0]
            standardChoice = list(lineEditWidget.values())[0][1]
        
            connection = self.updateFields
            self.advLineEditLayouts[varName] = utils.multiLineEdit_valueVarAdv(internalName,varName,layout,parentNode.flowChart,ShowVariablesOptions=True,textChangeCallback = connection,valueVarAdv=standardChoice) #type:ignore
            
            layout.addWidget(QLabel(labelName),GridCounter,0)
            layout.addLayout(self.advLineEditLayouts[varName],GridCounter,1)
            GridCounter+=1
            
            #Pre-load the values if they exist
            for lineEditVal in [&#39;line_edit&#39;,&#39;line_edit_adv&#39;,&#39;line_edit_variable&#39;]:
                this_line_edit = getattr(self.advLineEditLayouts[varName], lineEditVal)
                if this_line_edit.objectName() in getattr(self,storeVarName): #type:ignore
                    this_line_edit.textChanged.disconnect(connection)
                    this_line_edit.setText(getattr(self,storeVarName)[this_line_edit.objectName()]) #type:ignore
                    this_line_edit.textChanged.connect(connection)
            #Pre-load the value of the comboboxswitch:
            try:
                self.advLineEditLayouts[varName].comboBox_switch.setCurrentText(getattr(self,storeVarName)[self.advLineEditLayouts[varName].comboBox_switch.objectName()]) #type:ignore
            except:
                pass
            
            #When loading, hide the non-relevants:
            customParentChildren = [self.advLineEditLayouts[varName].line_edit,self.advLineEditLayouts[varName].line_edit_adv,self.advLineEditLayouts[varName].line_edit_variable,self.advLineEditLayouts[varName].line_edit_Button_adv,self.advLineEditLayouts[varName].push_button_variable_adv]
            utils.hideAdvVariables(self.advLineEditLayouts[varName].comboBox_switch,customParentChildren=customParentChildren)
        
        
        #OK/Cancel buttonBox.
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box,99,0,1,2)
        
        self.setLayout(layout)

    def updateFields(self):
        
        
        for entry in self.advLineEditLayouts:
            lineEditLayout = self.advLineEditLayouts[entry]
        
            try:
                #Set the value of the lineedits to storage
                getattr(self,self.storeVarName)[lineEditLayout.line_edit.objectName()] = lineEditLayout.line_edit.text()
                getattr(self,self.storeVarName)[lineEditLayout.line_edit_adv.objectName()] = lineEditLayout.line_edit_adv.text()
                getattr(self,self.storeVarName)[lineEditLayout.line_edit_variable.objectName()] = lineEditLayout.line_edit_variable.text()
                #Store the value of the combobox
                getattr(self,self.storeVarName)[lineEditLayout.comboBox_switch.objectName()] = lineEditLayout.comboBox_switch.currentText()
                
            except:
                pass
        

class nodz_openChangeGlobalVarDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for changeGlobalVar in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the changeGlobalVarDialog.
        
        Args:
            parentNode: The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;changeGlobalVarInfo  Dialog&#34;,
                        internalName=&#39;globalVarChange&#39;,
                        advLineEdits=[{&#39;Variable to change:&#39;:[&#39;globalVarName&#39;,&#39;Variable&#39;]},{&#39;Change to value:&#39;:[&#39;globalVarValue&#39;,&#39;Advanced&#39;]}],
                        storeVarName=&#39;changeGlobalVarInfo&#39;)
        
class nodz_openNewGlobalVarDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for newGlobalVar in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the newGlobalVarDialog.
        
        Args:
            parentNode: The parent node of the newGlobalVarDialog. If provided, the newGlobalVarDialog will be set to the newGlobalVarDialog of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;newGlobalVarInfo Dialog&#34;,
                        internalName=&#39;newVarChange&#39;,
                        advLineEdits=[{&#39;Variable Name:&#39;:[&#39;globalVarName&#39;,&#39;Value&#39;]},{&#39;Initial Value:&#39;:[&#39;globalVarValue&#39;,&#39;Value&#39;]}],
                        storeVarName=&#39;newGlobalVarInfo&#39;)

class nodz_openIfStatementDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for ifStatement in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the ifStatementDialog.
        
        Args:
            parentNode: The parent node of the ifStatementDialog. If provided, the ifStatementDialog will be set to the ifStatementDialog of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;ifStatement Dialog&#34;,
                        internalName=&#39;ifStatementDialog&#39;,
                        advLineEdits=[{&#39;Value to check:&#39;:[&#39;valueToCheck&#39;,&#39;Variable&#39;]},{&#39;Comparator:&#39;:[&#39;comparator&#39;,&#39;Value&#39;]},{&#39;Check against:&#39;:[&#39;valueCheckAgainst&#39;,&#39;Value&#39;]}],
                        storeVarName=&#39;ifStatementInfo&#39;)

class nodz_openStoreDataDialog(nodz_generalAdvancedLineEditDialog):
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the StoreDataDialog.
        
        Args:
            parentNode: The parent node of the StoreDataDialog. If provided, the storeDataInfo will be set to the storeDataInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;Store Data&#34;,
                        internalName=&#39;storeDataDialog&#39;,
                        advLineEdits=[{&#39;Data:&#39;:[&#39;item_to_store&#39;,&#39;Variable&#39;]},{&#39;Location:&#39;:[&#39;store_location&#39;,&#39;Advanced&#39;]}],
                        storeVarName=&#39;storeDataInfo&#39;)

class nodz_openTimerDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for timer in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        super().__init__(parentNode=parentNode,
                        title=&#34;Timer&#34;,
                        internalName=&#39;timerDialog&#39;,
                        advLineEdits=[{&#39;Time to wait (s):&#39;:[&#39;wait_time&#39;,&#39;Value&#39;]}],
                        storeVarName=&#39;timerInfo&#39;)
    #     &#34;&#34;&#34;
    #     Initializes the TimerDialog.
        
    #     Args:
    #         parentNode: The parent node of the TimerDialog. If provided, the timerInfo will be set to the timerInfo of the parentNode.
        
    #     Returns:
    #         None
    #     &#34;&#34;&#34;
    #     super().__init__(None)
    #     self.setWindowTitle(&#34;Timer Dialog&#34;)
    #     self.timerInfo = 0
    #     if parentNode is not None:
    #         from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
    #         self.timerInfo = parentNode.timerInfo

    #     button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    #     button_box.accepted.connect(self.accept)
    #     button_box.rejected.connect(self.reject)
        
    #     # Create the QVBoxLayout
    #     layout = QVBoxLayout()

    #     # Create a QWidget to contain the QGridLayout
    #     entryVal = QDoubleSpinBox()
    #     entryVal.setDecimals(2)
    #     entryVal.setSingleStep(0.1)
    #     entryVal.setValue(self.timerInfo)
    #     entryVal.valueChanged.connect(lambda value: setattr(self, &#39;timerInfo&#39;, value))
    #     # Add the QMainWindow to the QVBoxLayout
    #     layout.addWidget(entryVal)

    #     layout.addWidget(button_box)
        
    #     self.setLayout(layout)


class nodz_openMMConfigDialog(QDialog):
    
    &#34;&#34;&#34;
    Opens a dialog to modify the MM configs of a node
    &#34;&#34;&#34;
    def __init__(self, parentNode=None, storedConfigsStrings=None, storedrelStagesString=None):
        &#34;&#34;&#34;
        Opens a dialog to modify the Micromanager configs of a node
        
        Args:
            parentNode (Node): The node to modify the configs of.
            storedConfigsStrings (list of tuples): A list of tuples with the name of the config and the value of the config.
            
        Returns:
            A tuple with the configs as a dictionary and the list of configs as strings.
        &#34;&#34;&#34;
        super().__init__(None)
        self.newConfigUI = type(MMConfigUI)
        
        self.setWindowTitle(&#34;MM config Dialog&#34;)
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            
            self.MMlayout = parentNode.MMconfigInfo.mainLayout
            
            #Create a new MMconfigUI with the same components as parentNode.MMconfigInfo:
            self.newConfigUI = MMConfigUI(parentNode.MMconfigInfo.config_groups, showConfigs=parentNode.MMconfigInfo.showConfigs,showShutterOptions=parentNode.MMconfigInfo.showShutterOptions, showLiveSnapExposureButtons=parentNode.MMconfigInfo.showLiveSnapExposureButtons, showROIoptions =parentNode.MMconfigInfo.showROIoptions, showStages=parentNode.MMconfigInfo.showStages, showCheckboxes=parentNode.MMconfigInfo.showCheckboxes,changes_update_MM=parentNode.MMconfigInfo.changes_update_MM,showRelativeStages=parentNode.MMconfigInfo.showRelativeStages,autoSaveLoad=False)
            
            if parentNode.MMconfigInfo.changes_update_MM:
                logging.warning(&#39;WARNING! Nodz is actually changing the configs real-time rather than only when they are ran!&#39;)
            
            #Change some configs that are stored from last time this node was openend:
            if storedConfigsStrings is not None and len(storedConfigsStrings)&gt;0:
                for storedConfigString in storedConfigsStrings:
                    #Find the config that has this name:
                    for config_id in self.newConfigUI.config_groups:
                        thisConfig = self.newConfigUI.config_groups[config_id]
                        if thisConfig.configGroupName() == storedConfigString[0]:
                            foundConfigId = config_id
                            #Set the checkbox to true:
                            self.newConfigUI.configCheckboxes[foundConfigId].setChecked(True)
                            #Set the value correctly in the GUI:
                            self.newConfigUI.updateValueInGUI(foundConfigId,storedConfigString[1])
                            break
            
            if storedrelStagesString is not None:
                allRelStages = self.newConfigUI.oneDRelStackedWidget.children()
                #Set the values of all the stages
                for relstage in allRelStages:
                    objName = relstage.objectName()
                    if objName != &#39;&#39;:
                        for storedrelstage in storedrelStagesString:
                            if objName == storedrelstage[0]:
                                relstage.children()[2].setText(str(storedrelstage[1])) # type: ignore
                
                #Set the currently-selected stage:
                for storedrelstage in storedrelStagesString:
                    if storedrelstage[0] == &#39;__chosenRelStage__&#39;:
                        self.newConfigUI.oneDstageRelDropdown.setCurrentText(storedrelstage[1])
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
            
            # Create the QVBoxLayout
            layout = QVBoxLayout()

            # Create a QWidget to contain the QGridLayout
            grid_widget = QWidget()
            grid_widget.setLayout(self.newConfigUI.mainLayout) #type:ignore
            # Add the QMainWindow to the QVBoxLayout
            layout.addWidget(grid_widget)

            layout.addWidget(button_box)
            
            self.setLayout(layout)
        
    def ConfigsToBeChanged(self):
        &#34;&#34;&#34;
        Returns the configs that have been changed in the MM config Dialog.
        
        Returns:
            A list of tuples with the name of the config and the value of the config that has been changed.
        &#34;&#34;&#34;
        #Get the new value of all configs that are/should/want to be changed:
        ConfigsToBeChanged = []
        for config_id in range(len(self.newConfigUI.config_groups)): #type:ignore
            if self.newConfigUI.configCheckboxes[config_id].isChecked(): #type:ignore
                #Add config name and new value
                ConfigsToBeChanged.append([self.newConfigUI.config_groups[config_id].configGroupName(),self.newConfigUI.currentConfigUISingleValue(config_id)]) #type:ignore
        
        #Not adding ,self.newConfigUI.config_groups[config_id] (all info) for pickling reasons
        
        return ConfigsToBeChanged
        
        return self.newConfigUI
    
    def RelStageInfo(self):
        relStageInfo = []
        allRelStages = self.newConfigUI.oneDRelStackedWidget.children()
        for relstage in allRelStages:
            objName = relstage.objectName()
            if objName != &#39;&#39;:
                relStageInfo.append([objName,float(relstage.children()[2].text())]) # type: ignore
        relStageInfo.append([&#39;__chosenRelStage__&#39;,self.newConfigUI.oneDstageRelDropdown.currentText()])

        return relStageInfo
    # def getExposureTime(self):
    #     return self.mdaconfig.exposure_ms

    # def getmdaData(self):
    #     return self.mdaconfig

class nodz_visualisationDialog(QDialog):
    &#34;&#34;&#34;
    Opens a dialog to modify the visualisation settings
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Opens a dialog to modify the visualisation settings
        
        Args:
            parentNode (Node): The node to modify the configs of.
            
        Returns:
            A tuple with the configs as a dictionary and the list of configs as strings.
        &#34;&#34;&#34;
        super().__init__(None)
        
        self.setWindowTitle(&#34;Visualisation Dialog&#34;)
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget, QFormLayout
            layout_sub = QFormLayout()
            if &#39;layerName&#39; not in parentNode.visualisation_currentData or parentNode.visualisation_currentData[&#39;layerName&#39;] is not None:
                connectedNodes = nodz_utils.getConnectedNodes(parentNode, &#39;topAttr&#39;)
                if len(connectedNodes)&gt;0:
                    connectedNode = connectedNodes[0]
                    defaultText = connectedNode.name
                else:
                    defaultText = &#39;newLayer&#39;
            else:
                defaultText = parentNode.visualisation_currentData[&#39;layerName&#39;]
            self.layerNameEdit = QLineEdit()
            self.layerNameEdit.setText(defaultText)
            layout_sub.addRow(&#34;Layer name:&#34;, self.layerNameEdit)
            
            import napari
            
            self.colormapComboBox = QComboBox()
            colormaps = napari.utils.colormaps.AVAILABLE_COLORMAPS #type:ignore
            for colormap in colormaps:
                self.colormapComboBox.addItem(colormap)
            
            if &#39;colormap&#39; not in parentNode.visualisation_currentData or parentNode.visualisation_currentData[&#39;colormap&#39;] is None:
                self.colormapComboBox.setCurrentText(&#39;gray&#39;)
            else:
                self.colormapComboBox.setCurrentText(parentNode.visualisation_currentData[&#39;colormap&#39;])
            
            self.colormapComboBox.addItem(&#34;Use new config&#34;)
            layout_sub.addRow(&#34;Colormap:&#34;, self.colormapComboBox)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
            
            # Create the QVBoxLayout
            layout = QVBoxLayout()

            # Add the QMainWindow to the QVBoxLayout
            layout.addLayout(layout_sub)

            layout.addWidget(button_box)
            
            self.setLayout(layout)

class nodz_openMDADialog(QDialog):
    &#34;&#34;&#34;
    Dialog for the MDA options within the Nodz environment.
    &#34;&#34;&#34;
    def __init__(self, parent=None, parentData=None, currentNode = None):
        &#34;&#34;&#34;
        Dialog for the MDA options.
        
        Args:
            parent (QtWidgets.QWidget): Parent widget of the dialog.
            parentData (FlowChartCore): Instance of the FlowChartCore class.
            currentNode (FlowChartNode): Instance of the FlowChartNode class.
            
        Returns:
            List: List of tuples, each containing the configuration name and its new value.
        &#34;&#34;&#34;
        super().__init__(parent)
        self.parent = parent #type:ignore
        self.parentData = parentData
        self.currentNode=  currentNode
        
        self.setWindowTitle(&#34;MDA Dialog&#34;)
        if parentData is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            testQWidget = QWidget()
            
            if currentNode is not None:
                #Create a new MDAGlados with all the same components as currentNode.mdaData:
                self.mdaconfig = MDAGlados(parentData.core,None,None,parentData.shared_data,
                    hasGUI=True,
                    GUI_show_channel=currentNode.mdaData.GUI_show_channel,
                    GUI_show_exposure=currentNode.mdaData.GUI_show_exposure,
                    GUI_show_order=currentNode.mdaData.GUI_show_order,
                    GUI_show_storage=currentNode.mdaData.GUI_show_storage,
                    GUI_show_time=currentNode.mdaData.GUI_show_time,
                    GUI_show_xy=currentNode.mdaData.GUI_show_xy,
                    GUI_show_z=currentNode.mdaData.GUI_show_z,
                    GUI_acquire_button=False,
                    order = currentNode.mdaData.order,
                    num_time_points=currentNode.mdaData.num_time_points,
                    time_interval_s=currentNode.mdaData.time_interval_s,
                    z_start=currentNode.mdaData.z_start,
                    z_end=currentNode.mdaData.z_end,
                    z_step=currentNode.mdaData.z_step,
                    z_stage_sel = currentNode.mdaData.z_stage_sel,
                    z_nr_steps = currentNode.mdaData.z_nr_steps,
                    z_step_distance = currentNode.mdaData.z_step_distance,
                    z_nrsteps_radio_sel = currentNode.mdaData.z_nrsteps_radio_sel,
                    z_stepdistance_radio_sel= currentNode.mdaData.z_stepdistance_radio_sel,
                    channel_group=currentNode.mdaData.channel_group,
                    channels=currentNode.mdaData.channels,
                    channel_exposures_ms=currentNode.mdaData.channel_exposures_ms,
                    xy_positions=currentNode.mdaData.xy_positions,
                    xyz_positions=currentNode.mdaData.xyz_positions,
                    position_labels=currentNode.mdaData.position_labels,
                    exposure_ms=currentNode.mdaData.exposure_ms,
                    storage_folder=currentNode.mdaData.storage_folder,
                    storage_file_name=currentNode.mdaData.storage_file_name,
                    GUI_xy_pos_fullInfo=currentNode.mdaData.xy_positions_saveInfo,
                    node = currentNode)
            else: #This should never happen, but otherwise just open a new mdaglados instance
                self.mdaconfig = MDAGlados(parentData.core,None,None,parentData.shared_data,hasGUI=True)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.mdaconfig.showOptionChanged)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
            

            # Create the QVBoxLayout
            layout = QVBoxLayout()

            # Create a QWidget to contain the QGridLayout
            grid_widget = QWidget()
            grid_widget.setLayout(self.mdaconfig.gui) #type:ignore
            # Add the QMainWindow to the QVBoxLayout
            layout.addWidget(grid_widget)

            layout.addWidget(button_box)
            
            self.setLayout(layout)
        
    def getInputs(self):
        &#34;&#34;&#34;
        Get the inputs from the MDA configuration.
        
        Returns:
            The inputs from the MDA configuration.
        &#34;&#34;&#34;
        
        return self.mdaconfig.mda

    def getExposureTime(self):
        &#34;&#34;&#34;
        Get the exposure time in milliseconds.
        
        Returns:
            int: The exposure time in milliseconds.
        &#34;&#34;&#34;
        return self.mdaconfig.exposure_ms

    def getmdaData(self):
        &#34;&#34;&#34;
        Get the MDA data.
        
        Returns:
            The MDA configuration data.
        &#34;&#34;&#34;
        return self.mdaconfig

class nodz_openScoringEndDialog(QDialog):
    &#34;&#34;&#34;
    The ScoringEnd (i.e. the end of the scoring) dialog window.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Initialize the ScoringEnd (i.e. the end of the scoring) dialog window.
        
        Args:
            parent: The parent widget (default is None).
            currentNode: The current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        self.setWindowTitle(&#34;Scoring End&#34;)
        #Add an OK/Cancel box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Create the QVBoxLayout
        layout = QVBoxLayout()

        # Create a QWidget to contain the QGridLayout
        self.grid_widget = QGridLayout()
            
        self.nrVarsSpinbox = QSpinBox()
        self.nrVarsSpinbox.setMinimum(1)
        self.nrVarsSpinbox.valueChanged.connect(self.updateLayout)
        self.grid_widget.addWidget(self.nrVarsSpinbox,0,0)

        self.variableContainer = QGridLayout()
        # self.grid_widget.addLayout(self.variableContainer,1,0)
        
        self.variableContainerscrollArea = QScrollArea(self)
        self.variableContainerscrollArea.setWidgetResizable(True)
        self.variableContainerscrollAreaWidgetContents = QWidget()
        self.variableContainerscrollAreaWidgetContents.setLayout(self.variableContainer)
        self.variableContainerscrollArea.setWidget(self.variableContainerscrollAreaWidgetContents)
        self.grid_widget.addWidget(self.variableContainerscrollArea,1,0)
        
        # Set a fixed size for the QScrollArea
        self.variableContainerscrollArea.setFixedSize(QSize(300, 300))  # Adjust the size as needed
        # Add the QMainWindow to the QVBoxLayout
        layout.addLayout(self.grid_widget)

        layout.addWidget(button_box)
        
        self.setLayout(layout)
        
        #Add a spacer item at the bottom of the variableContainer so it&#39;s pushing it down down down
        spacerItem = QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding)
        self.variableContainer.addItem(spacerItem, 999, 0)

        #Pre-load labels/line-Edits with the current sockets:
        self.labels = []
        self.lineEdits = []
        if currentNode is not None:
            currentSockets = list(currentNode.sockets.items())
            for socket in currentSockets:
                label = QLabel(f&#34;Score {len(self.labels)+1}:&#34;)
                lineEdit = QLineEdit()
                lineEdit.setText(socket[0])
                self.variableContainer.addWidget(label,len(self.labels),0)
                self.variableContainer.addWidget(lineEdit,len(self.labels),1)
                self.labels.append(label)
                self.lineEdits.append(lineEdit)
        
        self.nrVarsSpinbox.setValue(len(self.labels)) 
        #And update the layout at the start:
        # self.updateLayout()
        
    def updateLayout(self):
        &#34;&#34;&#34;
        Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.
        
            Args:
                None
        
            Returns:
                None
        &#34;&#34;&#34;
        nrVars = self.nrVarsSpinbox.value()
        if nrVars == len(self.labels)-1: #If we want to remove the last one
            tobeRemovedLabel = self.labels[-1]
            tobeRemovedLineEdit = self.lineEdits[-1]
            self.layout().removeWidget(tobeRemovedLabel)
            tobeRemovedLabel.deleteLater()
            self.layout().removeWidget(tobeRemovedLineEdit)
            tobeRemovedLineEdit.deleteLater()
            self.labels.pop()
            self.lineEdits.pop()
        elif nrVars == len(self.labels)+1: #if we want to add one...
            label = QLabel(f&#34;Score {len(self.labels)+1}:&#34;)
            lineEdit = QLineEdit()
            self.variableContainer.addWidget(label,len(self.labels),0)
            self.variableContainer.addWidget(lineEdit,len(self.labels),1)
            self.labels.append(label)
            self.lineEdits.append(lineEdit)
        elif nrVars == len(self.labels): 
            pass
        else: #Else, we added a fully new number, so we reset everything
            for label in self.labels:
                self.layout().removeWidget(label)
                label.deleteLater()
            for lineEdit in self.lineEdits:
                self.layout().removeWidget(lineEdit)
                lineEdit.deleteLater()

            self.labels = []
            self.lineEdits = []

            for i in range(nrVars):
                label = QLabel(f&#34;Score {i+1}:&#34;)
                lineEdit = QLineEdit()
                self.variableContainer.addWidget(label,i,0)
                self.labels.append(label)
                self.variableContainer.addWidget(lineEdit,i,1)
                self.lineEdits.append(lineEdit)

class nodz_caseSwitchDialog(QDialog):
    &#34;&#34;&#34;
    The ScoringEnd (i.e. the end of the scoring) dialog window.
    &#34;&#34;&#34;
    def __init__(self, parentNode=None, currentNode=None):
        &#34;&#34;&#34;
        Initialize the ScoringEnd (i.e. the end of the scoring) dialog window.
        
        Args:
            parent: The parent widget (default is None).
            currentNode: The current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__()
        if currentNode == None:
            logging.error(f&#34;Error in nodz_caseSwitchDialog: currentNode is None&#34;)
            return
        self.caseSwitchInfo = currentNode.caseSwitchInfo
        self.setWindowTitle(&#34;CaseSwitch&#34;)
        #Add an OK/Cancel box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Create the QVBoxLayout
        layout = QVBoxLayout()

        # Create a QWidget to contain the QGridLayout
        self.grid_widget = QGridLayout()
            
        self.varSwitchAdvLineEdit = utils.multiLineEdit_valueVarAdv(&#39;CaseSwitch&#39;,&#39;Var&#39;,self.grid_widget,currentNode.flowChart,True,self.textChanged,&#39;Variable&#39;)
        #Set the current variables:
        try:
            self.varSwitchAdvLineEdit.line_edit.textChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.line_edit.setText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit.objectName()])
            self.varSwitchAdvLineEdit.line_edit.textChanged.connect(self.textChanged)
            
            self.varSwitchAdvLineEdit.line_edit_variable.textChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.line_edit_variable.setText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_variable.objectName()])
            self.varSwitchAdvLineEdit.line_edit_variable.textChanged.connect(self.textChanged)
            
            self.varSwitchAdvLineEdit.line_edit_adv.textChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.line_edit_adv.setText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_adv.objectName()])
            self.varSwitchAdvLineEdit.line_edit_adv.textChanged.connect(self.textChanged)
            
            self.varSwitchAdvLineEdit.comboBox_switch.currentIndexChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.comboBox_switch.setCurrentText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.comboBox_switch.objectName()])
            self.varSwitchAdvLineEdit.comboBox_switch.currentIndexChanged.connect(self.textChanged)
        except:
            pass
        
        #Finally actually add it to layout
        self.grid_widget.addLayout(self.varSwitchAdvLineEdit,0,0)
        #update the hiding of value/adv/variable
        customParentChildren = [self.varSwitchAdvLineEdit.line_edit,self.varSwitchAdvLineEdit.line_edit_adv,self.varSwitchAdvLineEdit.line_edit_variable,self.varSwitchAdvLineEdit.line_edit_Button_adv,self.varSwitchAdvLineEdit.push_button_variable_adv]
        utils.hideAdvVariables(self.varSwitchAdvLineEdit.comboBox_switch,customParentChildren=customParentChildren)
            
        self.nrVarsSpinbox = QSpinBox()
        self.nrVarsSpinbox.setMinimum(1)
        self.nrVarsSpinbox.valueChanged.connect(self.updateLayout)
        self.grid_widget.addWidget(self.nrVarsSpinbox,1,0)

        self.variableContainer = QGridLayout()
        # self.grid_widget.addLayout(self.variableContainer,1,0)
        
        self.variableContainerscrollArea = QScrollArea(self)
        self.variableContainerscrollArea.setWidgetResizable(True)
        self.variableContainerscrollAreaWidgetContents = QWidget()
        self.variableContainerscrollAreaWidgetContents.setLayout(self.variableContainer)
        self.variableContainerscrollArea.setWidget(self.variableContainerscrollAreaWidgetContents)
        self.grid_widget.addWidget(self.variableContainerscrollArea,2,0)
        
        # Set a fixed size for the QScrollArea
        self.variableContainerscrollArea.setFixedSize(QSize(300, 300))  # Adjust the size as needed
        # Add the QMainWindow to the QVBoxLayout
        layout.addLayout(self.grid_widget)

        layout.addWidget(button_box)
        
        self.setLayout(layout)
        
        #Add a spacer item at the bottom of the variableContainer so it&#39;s pushing it down down down
        spacerItem = QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding)
        self.variableContainer.addItem(spacerItem, 999, 0)

        #Pre-load labels/line-Edits with the current plugs:
        self.labels = []
        self.lineEdits = []
        if currentNode is not None:
            currentPlugs = list(currentNode.plugs.items())
            for socket in currentPlugs:
                label = QLabel(f&#34;Option {len(self.labels)+1}:&#34;)
                lineEdit = QLineEdit()
                lineEdit.setText(socket[0])
                self.variableContainer.addWidget(label,len(self.labels),0)
                self.variableContainer.addWidget(lineEdit,len(self.labels),1)
                self.labels.append(label)
                self.lineEdits.append(lineEdit)
        
        self.nrVarsSpinbox.setValue(len(self.labels)) 
        
        #And update the layout at the start:
        # self.updateLayout()
    def textChanged(self):
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit.objectName()] = self.varSwitchAdvLineEdit.line_edit.text()
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_variable.objectName()] = self.varSwitchAdvLineEdit.line_edit_variable.text()
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_adv.objectName()] = self.varSwitchAdvLineEdit.line_edit_adv.text()
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.comboBox_switch.objectName()] = self.varSwitchAdvLineEdit.comboBox_switch.currentText()
        self.caseSwitchInfo
    
    def updateLayout(self):
        &#34;&#34;&#34;
        Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.
        
            Args:
                None
        
            Returns:
                None
        &#34;&#34;&#34;
        nrVars = self.nrVarsSpinbox.value()
        if nrVars == len(self.labels)-1: #If we want to remove the last one
            tobeRemovedLabel = self.labels[-1]
            tobeRemovedLineEdit = self.lineEdits[-1]
            self.layout().removeWidget(tobeRemovedLabel)
            tobeRemovedLabel.deleteLater()
            self.layout().removeWidget(tobeRemovedLineEdit)
            tobeRemovedLineEdit.deleteLater()
            self.labels.pop()
            self.lineEdits.pop()
        elif nrVars == len(self.labels)+1: #if we want to add one...
            label = QLabel(f&#34;Option {len(self.labels)+1}:&#34;)
            lineEdit = QLineEdit()
            self.variableContainer.addWidget(label,len(self.labels),0)
            self.variableContainer.addWidget(lineEdit,len(self.labels),1)
            self.labels.append(label)
            self.lineEdits.append(lineEdit)
        elif nrVars == len(self.labels): 
            pass
        else: #Else, we added a fully new number, so we reset everything
            for label in self.labels:
                self.layout().removeWidget(label)
                label.deleteLater()
            for lineEdit in self.lineEdits:
                self.layout().removeWidget(lineEdit)
                lineEdit.deleteLater()

            self.labels = []
            self.lineEdits = []

            for i in range(nrVars):
                label = QLabel(f&#34;Option {i+1}:&#34;)
                lineEdit = QLineEdit()
                self.variableContainer.addWidget(label,i,0)
                self.labels.append(label)
                self.variableContainer.addWidget(lineEdit,i,1)
                self.lineEdits.append(lineEdit)



class FoVFindImaging_singleCh_configs(QDialog):
    &#34;&#34;&#34;
    I BELIEVE DEPRECATED (may 2024)
    Advanced dialog for user to input the configuration for a single channel single FOV imaging experiment.
    &#34;&#34;&#34;
    def __init__(self, parent=None, parentData=None):
        &#34;&#34;&#34;
        I BELIEVE DEPRECATED (may 2024)
        Advanced dialog for user to input the configuration for a single channel single FOV imaging experiment.

        Args:
            parent (QWidget): The parent widget for this dialog. Defaults to None.
            parentData: The data object for this app. Defaults to None.

        Returns:
            mdaData: The mdaData object with all the user input.
        &#34;&#34;&#34;
        super().__init__(parent)
        
        self.setWindowTitle(&#34;Advanced Input Dialog&#34;)
        if parentData is not None:
            core = parentData.core
            
            
            # Get all config groups
            allConfigGroups={}
            nrconfiggroups = core.get_available_config_groups().size()
            for config_group_id in range(nrconfiggroups):
                allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
            
            #Create the MM config via all config groups
            self.MMconfig = MMConfigUI(allConfigGroups, showConfigs = True,showStages=False,showROIoptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False, showCheckboxes=True,autoSaveLoad=False)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
                
            #Set the layout
            layout = QVBoxLayout()
            layout.addLayout(self.MMconfig.mainLayout)
            layout.addWidget(button_box)
            
            self.setLayout(layout)
        
    def getInputs(self):
        &#34;&#34;&#34;
        Get the UI configuration information.
        
        Args:
            onlyChecked (bool): A boolean flag indicating whether to return only the checked UI configuration information.
        
        Returns:
            dict: A dictionary containing the UI configuration information.
        &#34;&#34;&#34;
        return self.MMconfig.getUIConfigInfo(onlyChecked=True)
#endregion

#region NodzHelperClasses
class CustomGraphicsView(QtWidgets.QGraphicsView):
    &#34;&#34;&#34;
    Create a custom Graphics View for the Nodz container
    &#34;&#34;&#34;
    def resizeEvent(self, event):
        &#34;&#34;&#34;
        Handles resizing of the graphics view.
        
        Args:
            event (QResizeEvent): The resize event.
        &#34;&#34;&#34;
        super().resizeEvent(event)
        self.updateGraphicsViewSize()
    
    def updateGraphicsViewSize(self):
        &#34;&#34;&#34;
        Updates the size of the GraphicsView to match its viewport size.

        This function is called automatically when the viewport is resized.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        nodz.setFixedSize(self.viewport().size())

class GladosGraph():
    &#34;&#34;&#34; 
    Create a &#39;graph&#39; in code-form of all connections in the scoring or acquisition flowchart. Basically gives information about what node is connected to what other nodes
    &#34;&#34;&#34;
    #Also adds these values correctly for each node:
        # self.n_connect_at_start = 0 #number of others connected at start (which should all be finished!)
        # self.connectedToFinish = []
        # self.connectedToData = []
        
    def __init__(self,parent):
        &#34;&#34;&#34;
        Initialize a GladosGraph object
        Create a &#39;graph&#39; in code-form of all connections in the scoring or acquisition flowchart. Basically gives information about what node is connected to what other nodes

        This function initializes a GladosGraph object.

        Args:
            parent (nodz_mda.GladosFlowchart): The nodz_mda flowchart object.

        Returns:
            None

        &#34;&#34;&#34; 
        self.parent = parent
        self.nodes = []
        self.startNodeIndex = -1
        # self.unstartedNodes = []
        # self.ongoingNodes = []
        # self.finishedNodes = []

    def addRawGraphEval(self,graphEval):
        &#34;&#34;&#34;
        Adds information about connections to the nodes in a graphEval

        This function adds information about connections to the nodes in a graphEval.
        In particular, it adds to each node the nodes it is connected to
        based on the connections in graphEval.

        Args:
            graphEval (list): A list of tuples that describe the connections in the graph.
                Each tuple has the form (sending_node_name, receiving_node_name)

        Returns:
            None

        &#34;&#34;&#34;
        #Also generate a list of all nodes in this graph
        self.allNodeNames = []
        for graphEvalPartFull in graphEval:
            for graphEvalPartFull2 in graphEvalPartFull:
                graphEvalPart = graphEvalPartFull2.split(&#39;.&#39;)[0]
                if graphEvalPart not in self.allNodeNames:
                    self.allNodeNames.append(graphEvalPart)
        
        for nodeName in self.allNodeNames:
            self.nodes.append(self.parent.findNodeByName(nodeName))

class NodeSignalManager(QObject):
    &#34;&#34;&#34;
    The NodeSignalManager class is used to manage the signals emitted and received by nodes in the graph (i.e. those created by connections).
    This is a generic class to handle the signals of any number of nodes.
    &#34;&#34;&#34;
    
    #pyqtSignals need to be outside init def
    new_signal = pyqtSignal()
    
    def __init__(self):
        &#34;&#34;&#34;
        Constructor for the NodeSignalManager class.

        This class is used to manage the signals emitted by nodes in the graph.
        This is a generic class to handle the signals of any number of nodes.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        QObject.__init__(self)
        super().__init__()
        self.signals = []

    def add_signal(self, signal_name):
        &#34;&#34;&#34;
        Adds a new signal to the NodeSignalManager class.

        This function is used to dynamically add a new signal to the object.

        Args:
            signal_name (str): The name of the signal to be added.

        Returns:
            None
        &#34;&#34;&#34;
        # Dynamically add a new signal to the object
        setattr(self, signal_name, eval(&#39;self.new_signal&#39;))
        self.signals.append(eval(&#39;self.new_signal&#39;))
        

    def print_signals(self):
        &#34;&#34;&#34;
        Prints all the signals managed by this class.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        for signal in self.signals:
            logging.info(signal)

    def emit_all_signals(self):
        &#34;&#34;&#34;
        Emits all the signals managed by this class.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        for signal in self.signals:
            signal.emit()
            logging.debug(f&#34;emitting signal {signal}&#34;)
#endregion

class GladosNodzFlowChart_dockWidget(NodzMain.Nodz):
    &#34;&#34;&#34;
    Class that represents a Flowchart dock widget in napari-Glados. 
    Inherits from Nodz, which is a graph drawing tool.
    
    Main class of all Nodz-based Glados automisation.
    &#34;&#34;&#34;
    def __init__(self,core=None,shared_data=None,MM_JSON=None,parent:CustomGraphicsView|None=None):
        &#34;&#34;&#34;
        Initializes the GladosNodzFlowChart_dockWidget in napari-Glados. 
        Inherits from Nodz, which is a graph drawing tool.
        
        Main class of all Nodz-based Glados automisation.
        
        Args:
            core: Core object for MM/napari integration.
            shared_data: Shared data object.
            MM_JSON: JSON object for MM/napari integration.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        #If run as plugin, we need to specify the globals like this:
        if parent is not None: # from napari plugin run
            global livestate, napariViewer
            livestate = parent.livestate
            napariViewer = parent.napariViewer
            parent.shared_data = shared_data
            shared_data.napariViewer = napariViewer
        else: #assuming shared_data is global - from .py run
            try:
                # global core, napariViewer
                napariViewer = shared_data.napariViewer
            except:
                logging.warning(&#39;Line 1372 fails&#39;)
        
        self.parent = parent
        
        #Create a QGridLayout:
        self.mainLayout = QGridLayout()
        
        self.fullRunOngoing = False
        
        try:
            import glados_pycromanager
            # Get the installation path of the package
            package_path = os.path.dirname(glados_pycromanager.__file__)
            # Construct the path to the Icons folder
            self.iconFolder = os.path.join(package_path, &#39;GUI&#39;, &#39;Icons&#39;)
        except:
            self.iconFolder = &#39;&#39;
        if not os.path.exists(self.iconFolder) or self.iconFolder == &#39;&#39;:
            #Find the iconPath folder
            if os.path.exists(&#39;./glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados_pycromanager/GUI/Icons/&#39;
            elif os.path.exists(&#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/&#39;
            else:
                self.iconFolder = &#39;&#39;
            
            
        self.buttonsArea = QVBoxLayout()
        
        #Add a hbox with warning icons, and set them to be grayscale/inactive:
        self.warningArea = QHBoxLayout()
        #add a stretch before:
        self.warningArea.addStretch()
        self.errorIcon = QLabel()
        self.errorIcon = utils.setWarningErrorInfoIcon(self.errorIcon,&#39;error&#39;,self.iconFolder,alteration = &#39;grayscale&#39;)
        self.warningArea.addWidget(self.errorIcon)
        self.warningIcon = QLabel()
        self.warningIcon = utils.setWarningErrorInfoIcon(self.warningIcon,&#39;warning&#39;,self.iconFolder,alteration = &#39;grayscale&#39;)
        self.warningArea.addWidget(self.warningIcon)
        self.infoIcon = QLabel()
        self.infoIcon = utils.setWarningErrorInfoIcon(self.infoIcon,&#39;info&#39;,self.iconFolder,alteration = &#39;grayscale&#39;)
        self.warningArea.addWidget(self.infoIcon)
        
        #add a stretch after the icons:
        self.warningArea.addStretch()
        
        
        #Add the area:
        self.buttonsArea.addLayout(self.warningArea)
        
        
        #Add a few buttons:
        self.loadPickleButton = QPushButton(&#39; Load graph&#39;)
        self.buttonsArea.addWidget(self.loadPickleButton)
        self.loadPickleButton.clicked.connect(lambda index: self.loadGraphJSON())
        # icon: Flaticon.com
        self.loadPickleButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Load.png&#39;))
        
        self.storePickleButton = QPushButton(&#39; Store graph&#39;)
        self.buttonsArea.addWidget(self.storePickleButton)
        self.storePickleButton.clicked.connect(lambda index: self.storeGraphJSON())
        # icon: Flaticon.com
        self.storePickleButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Save.png&#39;))
        
        self.fullRunButton = QPushButton(&#39; Start run&#39;)
        self.buttonsArea.addWidget(self.fullRunButton)
        self.fullRunButton.clicked.connect(lambda index: self.fullAutonomousRunStart())
        self.fullRunButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_all.png&#39;))
        
        self.runInitButton = QPushButton(&#39; Init Only&#39;)
        self.buttonsArea.addWidget(self.runInitButton)
        self.runInitButton.clicked.connect(lambda index: self.runInitOnly())
        self.runInitButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_init.png&#39;))
        
        self.runScoringButton = QPushButton(&#39; Scoring Only&#39;)
        self.buttonsArea.addWidget(self.runScoringButton)
        self.runScoringButton.clicked.connect(lambda index: self.runScoringOnly())
        self.runScoringButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_score.png&#39;))
        
        self.runAcquiringButton = QPushButton(&#39; Acquiring Only&#39;)
        self.buttonsArea.addWidget(self.runAcquiringButton)
        self.runAcquiringButton.clicked.connect(lambda index: self.runAcquiring())
        self.runAcquiringButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_acq.png&#39;))
        
        
        self.interruptRunButton = QPushButton(&#39; Interrupt run&#39;)
        self.buttonsArea.addWidget(self.interruptRunButton)
        self.interruptRunButton.clicked.connect(lambda index: self.interruptRun())
        # self.runAcquiringButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_acq.png&#39;))
        
        # self.runScoringPlusAcqButton = QPushButton(&#39;Run Scoring + Acq&#39;)
        # self.buttonsArea.addWidget(self.runScoringPlusAcqButton)
        # self.runScoringPlusAcqButton.clicked.connect(lambda index: self.runScoring())
        
        # self.debugScoringButton = QPushButton(&#39;Debug Scoring&#39;)
        # self.buttonsArea.addWidget(self.debugScoringButton)
        # self.debugScoringButton.clicked.connect(lambda index: self.debugScoring())
        
        #Push buttons to top
        self.buttonsArea.addStretch()
        
        self.globalVariables={}
        self.globalVariables[&#39;TrialGlobalVariable&#39;]={}
        self.globalVariables[&#39;TrialGlobalVariable&#39;][&#39;type&#39;] = str
        self.globalVariables[&#39;TrialGlobalVariable&#39;][&#39;data&#39;] = &#39;test&#39;
        self.globalVariables[&#39;TrialGlobalVariable&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        self.globalVariables[&#39;XY_pos_measurementArray&#39;]={}
        self.globalVariables[&#39;XY_pos_measurementArray&#39;][&#39;type&#39;] = [np.ndarray,list]
        self.globalVariables[&#39;XY_pos_measurementArray&#39;][&#39;data&#39;] = []
        self.globalVariables[&#39;XY_pos_measurementArray&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        
        
        #import qgroupbox:
        from qtpy.QtWidgets import QGroupBox    
    
        #Create a tab widget:
        self.tabWidget = QTabWidget()
        
        self.decision_groupbox = QGroupBox(&#34;Decision Widget&#34;)
        # self.buttonsArea.addWidget(self.decision_groupbox)
        self.decisionWidget = DecisionWidget(nodzinstance=self)
        self.decision_groupbox.setLayout(self.decisionWidget.layout())
        
        self.scanwidget_groupbox = QGroupBox(&#34;Scan Widget&#34;)
        newgridlayout = QGridLayout()
        self.scanwidget_groupbox.setLayout(newgridlayout)
        self.scanningWidget = ScanningWidget(nodzinstance=self)
        newgridlayout.addWidget(self.scanningWidget)
        
        self.variablesWidgetGroupbox = QGroupBox(&#34;Variables&#34;)
        newgridlayout = QGridLayout()
        self.variablesWidgetGroupbox.setLayout(newgridlayout)
        self.variablesWidget = VariablesWidget(nodzinstance=self)
        newgridlayout.addWidget(self.variablesWidget)
        
        self.loggerINFOGroupBox = QGroupBox(&#34;Logger&#34;)
        newgridlayout = QGridLayout()
        self.loggerINFOGroupBox.setLayout(newgridlayout)
        self.loggerINFOWidget = LoggerWidget(logLevel=&#39;INFO&#39;)
        newgridlayout.addWidget(self.loggerINFOWidget)
        
        self.loggerDEBUGGroupBox = QGroupBox(&#34;LoggerDEBUG&#34;)
        newgridlayout = QGridLayout()
        self.loggerDEBUGGroupBox.setLayout(newgridlayout)
        self.loggerDEBUGWidget = LoggerWidget(logLevel=&#39;DEBUG&#39;)
        self.loggerDEBUGupdateButton = QPushButton(&#39;Update&#39;)
        self.loggerDEBUGupdateButton.clicked.connect(lambda index: self.loggerDEBUGWidget.update_log_content())
        newgridlayout.addWidget(self.loggerDEBUGWidget)
        newgridlayout.addWidget(self.loggerDEBUGupdateButton)
        
        
        
        def quickStartMenu(self):
            &#34;&#34;&#34;
            Shows the UserManual.md file
            &#34;&#34;&#34;
            try:
                quickStartWindow = utils.SmallWindow(self)
                QApplication.processEvents()
                quickStartWindow.setWindowTitle(&#39;Quick start / User Manual&#39;)
                QApplication.processEvents()
                
                if is_pip_installed():
                    package_path = os.path.dirname(glados_pycromanager.__file__)
                    quickStartWindow.addMarkdown(os.path.join(package_path, &#39;Documentation&#39;, &#39;UserManual.md&#39;))
                else:
                    quickStartWindow.addMarkdown(&#39;glados-pycromanager/glados_pycromanager/Documentation/UserManual.md&#39;)
                QApplication.processEvents()
                quickStartWindow.show()
            except Exception as e:
                logging.error(f&#39;Could not open quick start window. {e}&#39;)
        
        self.helpGroupBox = QGroupBox(&#34;Logger&#34;)
        newgridlayout = QGridLayout()
        self.helpGroupBox.setLayout(newgridlayout)
        #Add a User Manual Button:
        newgridlayout.addWidget(QLabel(&#39;Glados-Pycromanager\n\nCreated by Dr. Koen J.A. Martens\nkoenjamartens{at}gmail.com\n\nAutonomous microscopy is very much a work in progress!&#39;))
        button1 = QPushButton(&#39;User Manual&#39;)
        button1.clicked.connect(lambda index: quickStartMenu(self))
        newgridlayout.addWidget(button1)
        button2 = QPushButton(&#39;Developer Manual&#39;)
        newgridlayout.addWidget(button2)
        button3 = QPushButton(&#39;Complete software info&#39;)
        newgridlayout.addWidget(button3)
        
        # Create a QGraphicsView 
        self.graphics_view = CustomGraphicsView()
        super(GladosNodzFlowChart_dockWidget, self).__init__(parent=self.graphics_view)
        self.graphics_view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.defineNodeInfo()
        
        
        #One widget/layout has the nodz info and the buttons, the other has the tabWidget:
        self.NodzPlusButtonsWidget = QWidget()
        self.NodzPlusButtonsLayout = QGridLayout()
        self.NodzPlusButtonsWidget.setLayout(self.NodzPlusButtonsLayout)
        self.NodzPlusButtonsLayout.addWidget(self.graphics_view,0,0)
        self.NodzPlusButtonsLayout.addLayout(self.buttonsArea,0,1)
        self.NodzPlusButtonsLayout.setColumnStretch(0, 10)  # Give more stretch to graphics_view
        self.NodzPlusButtonsLayout.setColumnStretch(1, 1)   # Give less stretch to buttonsArea

        
        from PyQt5.QtWidgets import  QSplitter

        self.splitter = QSplitter()
        self.splitter.addWidget(self.NodzPlusButtonsWidget)
        self.splitter.addWidget(self.tabWidget)
        # Set a style sheet for the splitter handle to make it more visible
        self.splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background-color: #606060;
            }
        &#34;&#34;&#34;)
        
        self.mainLayout.addWidget(self.splitter)
        
        
        #Create a tab for the decision widget:
        self.tabWidget.addTab(self.decision_groupbox, &#34;Decision&#34;)
        self.tabWidget.addTab(self.scanwidget_groupbox, &#34;Scanning&#34;)
        self.tabWidget.addTab(self.variablesWidgetGroupbox, &#34;Variables&#34;)
        self.tabWidget.addTab(self.loggerINFOGroupBox, &#34;Logger&#34;)
        self.tabWidget.addTab(self.loggerDEBUGGroupBox, &#34;Debug&#34;)
        self.tabWidget.addTab(self.helpGroupBox, &#34;Help&#34;)
        
        #Global variables for MM/napari
        self.core = core
        self.shared_data = shared_data
        self.shared_data.nodzInstance = self
        self.MM_JSON=MM_JSON
        
        global nodz
        nodz = self
        self.initialize()
        self.show()
        #Needs these lines as init
        self.graphics_view.updateGraphicsViewSize()
        self.nodes = []
        self.nodeCounter={}
        self.preventAcq=False #Set to true if you want to prevent smart acquisition (i.e. scoring-only, never passing to acq)
        self.preventScoring=False #Set to true if you want to prevent smart scoring (i.e. init-only, never passing to scoring)
        
        #Connect required deleted/double clicked signals
        self.signal_NodeDeleted.connect(self.NodeRemoved)
        self.signal_NodeCreatedNodeItself.connect(self.NodeAdded)
        self.signal_NodeFullyInitialisedNodeItself.connect(self.NodeFullyInitialised)
        self.signal_NodeDoubleClicked.connect(self.NodeDoubleClicked)
        self.signal_PlugConnected.connect(self.PlugConnected)
        self.signal_PlugDisconnected.connect(self.PlugOrSocketDisconnected)
        self.signal_SocketConnected.connect(self.SocketConnected)
        
        
        self.signal_NodeMoved.connect(self.checkNodesOnErrors)
        self.signal_NodeEdited.connect(self.checkNodesOnErrors)
        self.signal_PlugConnectedStartConnection.connect(self.checkNodesOnErrors)
        self.signal_SocketConnectedStartConnection.connect(self.checkNodesOnErrors)
        self.signal_AttrEdited.connect(self.checkNodesOnErrors)
        self.signal_NodeFullyInitialisedNodeItself.connect(self.checkNodesOnErrors)
        self.signal_PlugDisconnected.connect(self.checkNodesOnErrors)
        self.signal_SocketDisconnected.connect(self.checkNodesOnErrors)
        
        
        #Handling of the CallAction threads belonging to nodes is done via a QThreadPool
        from PyQt5.QtCore import QThreadPool
        self.thread_pool = QThreadPool.globalInstance()
        
        #Focus on the nodes
        self._focus()
        
        
        self.coreVariables={}
        self.updateCoreVariables()
    
    #region NodzFlowChart Node Methods
    def defineNodeInfo(self):
        &#34;&#34;&#34;
        Define the node information for all nodes in the flowchart.

        This function is called once at the initialization of the flowchart.
        It returns a dictionary containing all nodes and their info.
        The info is used by the flowchart to create the nodes and their connections.
        
        It also contains layout information (colors and such)
        &#34;&#34;&#34;
        self.nodeInfo = {}
        
        #Order: ChangeMicroscope|AnalysisMethods|RealTimeThings|Logics|Reports|StartStops|Advanceds
        self.nodeInfo[&#39;__RightClickMenuNodeOrder__&#39;] = [
            &#39;acquisition&#39;,&#39;changeProperties&#39;,&#39;changeStagePos&#39;,&#39;|&#39;,
            &#39;analysisMeasurement&#39;,&#39;customFunction&#39;,&#39;storeData&#39;,&#39;timer&#39;,&#39;|&#39;,
            &#39;realTimeAnalysis&#39;,&#39;visualisation&#39;,&#39;|&#39;,
            &#39;newGlobalVar&#39;,&#39;changeGlobalVar&#39;,&#39;caseSwitch&#39;,&#39;ifStatement&#39;,&#39;ANDlogic&#39;,&#39;|&#39;,
            &#39;slackReport&#39;,&#39;stickyNote&#39;,&#39;|&#39;,
            &#39;initStart&#39;,&#39;initEnd&#39;,&#39;scoringStart&#39;,&#39;scoringEndVar&#39;,&#39;earlyScoreFail&#39;,&#39;acqStart&#39;,&#39;acqEnd&#39;,&#39;|&#39;,
            &#39;runInlineScript&#39;,&#39;analysisMeasurementDEBUG&#39;]
        #If we miss any in here, they&#39;ll be added at the bottom in later logic
        #  
        
        #We define the node info for each type of node like this: (might be expanded in the future)
        self.nodeInfo[&#39;acquisition&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;acquisition&#39;][&#39;name&#39;] = &#39;acquisition&#39;
        self.nodeInfo[&#39;acquisition&#39;][&#39;displayName&#39;] = &#39;Acquisition&#39;
        self.nodeInfo[&#39;acquisition&#39;][&#39;startAttributes&#39;] = [&#39;Acquisition start&#39;]
        self.nodeInfo[&#39;acquisition&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;acquisition&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;,&#39;Real-time&#39;]
        
        self.nodeInfo[&#39;changeProperties&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;changeProperties&#39;][&#39;name&#39;] = &#39;changeProperties&#39;
        self.nodeInfo[&#39;changeProperties&#39;][&#39;displayName&#39;] = &#39;Change Properties&#39;
        self.nodeInfo[&#39;changeProperties&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;changeProperties&#39;][&#39;finishedAttributes&#39;] = [&#39;Done&#39;]
        
        self.nodeInfo[&#39;visualisation&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;visualisation&#39;][&#39;name&#39;] = &#39;visualisation&#39;
        self.nodeInfo[&#39;visualisation&#39;][&#39;displayName&#39;] = &#39;Visualisation&#39;
        self.nodeInfo[&#39;visualisation&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;visualisation&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;stickyNote&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;stickyNote&#39;][&#39;name&#39;] = &#39;stickyNote&#39;
        self.nodeInfo[&#39;stickyNote&#39;][&#39;displayName&#39;] = &#39;Sticky Note&#39;
        self.nodeInfo[&#39;stickyNote&#39;][&#39;NodeSize&#39;] = 70
        
        self.nodeInfo[&#39;realTimeAnalysis&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;name&#39;] = &#39;realTimeAnalysis&#39;
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;displayName&#39;] = &#39;Real-Time analysis&#39;
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;NodeSize&#39;] = 60
        
        # self.nodeInfo[&#39;reporting&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;reporting&#39;][&#39;name&#39;] = &#39;reporting&#39;
        # self.nodeInfo[&#39;reporting&#39;][&#39;displayName&#39;] = &#39;Report&#39;
        # self.nodeInfo[&#39;reporting&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
        # self.nodeInfo[&#39;reporting&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;changeStagePos&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;name&#39;] = &#39;changeStagePos&#39;
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;displayName&#39;] = &#39;Change Stage Position&#39;
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;finishedAttributes&#39;] = [&#39;Done&#39;]
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;analysisMeasurement&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;name&#39;] = &#39;analysisMeasurement&#39;
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;displayName&#39;] = &#39;Analysis [Measurement]&#39;
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        # self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;]
        
        self.nodeInfo[&#39;customFunction&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;customFunction&#39;][&#39;name&#39;] = &#39;customFunction&#39;
        self.nodeInfo[&#39;customFunction&#39;][&#39;displayName&#39;] = &#39;Custom Function&#39;
        self.nodeInfo[&#39;customFunction&#39;][&#39;startAttributes&#39;] = [&#39;Function start&#39;]
        self.nodeInfo[&#39;customFunction&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        
        # self.nodeInfo[&#39;analysisShapes&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;name&#39;] = &#39;analysisShapes&#39;
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;displayName&#39;] = &#39;Analysis [Shapes]&#39;
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
        
        # self.nodeInfo[&#39;analysisImages&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;name&#39;] = &#39;analysisImages&#39;
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;displayName&#39;] = &#39;Analysis [Images]&#39;
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
        
        self.nodeInfo[&#39;scoringStart&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;scoringStart&#39;][&#39;name&#39;] = &#39;scoringStart&#39;
        self.nodeInfo[&#39;scoringStart&#39;][&#39;displayName&#39;] = &#39;Scoring start&#39;
        self.nodeInfo[&#39;scoringStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;scoringStart&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;scoringStart&#39;][&#39;NodeSize&#39;] = 60
        
        # self.nodeInfo[&#39;scoringEnd&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;name&#39;] = &#39;scoringEnd&#39;
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;displayName&#39;] = &#39;Scoring end&#39;
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;bottomAttributes&#39;] = [&#39;Report&#39;]
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;scoringEndVar&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;name&#39;] = &#39;scoringEndVar&#39;
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;displayName&#39;] = &#39;Scoring end&#39;
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;earlyScoreFail&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;name&#39;] = &#39;earlyScoreFail&#39;
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;displayName&#39;] = &#39;Early score end&#39;
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;acqStart&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;acqStart&#39;][&#39;name&#39;] = &#39;acqStart&#39;
        self.nodeInfo[&#39;acqStart&#39;][&#39;displayName&#39;] = &#39;Acquiring start&#39;
        self.nodeInfo[&#39;acqStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;acqStart&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;acqStart&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;acqEnd&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;acqEnd&#39;][&#39;name&#39;] = &#39;acqEnd&#39;
        self.nodeInfo[&#39;acqEnd&#39;][&#39;displayName&#39;] = &#39;Acquiring end&#39;
        self.nodeInfo[&#39;acqEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;acqEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;acqEnd&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;initStart&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;initStart&#39;][&#39;name&#39;] = &#39;initStart&#39;
        self.nodeInfo[&#39;initStart&#39;][&#39;displayName&#39;] = &#39;Initialisation start&#39;
        self.nodeInfo[&#39;initStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;initStart&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;initStart&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;initEnd&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;initEnd&#39;][&#39;name&#39;] = &#39;initEnd&#39;
        self.nodeInfo[&#39;initEnd&#39;][&#39;displayName&#39;] = &#39;Initialisation end&#39;
        self.nodeInfo[&#39;initEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;initEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;initEnd&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;timer&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;timer&#39;][&#39;name&#39;] = &#39;timer&#39;
        self.nodeInfo[&#39;timer&#39;][&#39;displayName&#39;] = &#39;Timer&#39;
        self.nodeInfo[&#39;timer&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;timer&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;timer&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;storeData&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;storeData&#39;][&#39;name&#39;] = &#39;storeData&#39;
        self.nodeInfo[&#39;storeData&#39;][&#39;displayName&#39;] = &#39;Store Data&#39;
        self.nodeInfo[&#39;storeData&#39;][&#39;startAttributes&#39;] = [&#39;Store&#39;]
        self.nodeInfo[&#39;storeData&#39;][&#39;finishedAttributes&#39;] = [&#39;Stored&#39;]
        self.nodeInfo[&#39;storeData&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;newGlobalVar&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;name&#39;] = &#39;newGlobalVar&#39;
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;displayName&#39;] = &#39;New Global Variable&#39;
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;changeGlobalVar&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;name&#39;] = &#39;changeGlobalVar&#39;
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;displayName&#39;] = &#39;Change Global Variable&#39;
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;ifStatement&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;ifStatement&#39;][&#39;name&#39;] = &#39;ifStatement&#39;
        self.nodeInfo[&#39;ifStatement&#39;][&#39;displayName&#39;] = &#39;If-statement&#39;
        self.nodeInfo[&#39;ifStatement&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;ifStatement&#39;][&#39;finishedAttributes&#39;] = [&#39;Succeed&#39;,&#39;Fail&#39;]
        self.nodeInfo[&#39;ifStatement&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;runInlineScript&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;name&#39;] = &#39;runInlineScript&#39;
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;displayName&#39;] = &#39;Run advanced script&#39;
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        
        self.nodeInfo[&#39;caseSwitch&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;name&#39;] = &#39;caseSwitch&#39;
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;displayName&#39;] = &#39;Case/Switch&#39;
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;finishedAttributes&#39;] = [&#39;Error&#39;]
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;slackReport&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;slackReport&#39;][&#39;name&#39;] = &#39;slackReport&#39;
        self.nodeInfo[&#39;slackReport&#39;][&#39;displayName&#39;] = &#39;Slack Report&#39;
        self.nodeInfo[&#39;slackReport&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;slackReport&#39;][&#39;finishedAttributes&#39;] = [&#39;Send&#39;]
        self.nodeInfo[&#39;slackReport&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;ANDlogic&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;name&#39;] = &#39;ANDlogic&#39;
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;displayName&#39;] = &#39;AND-Logic&#39;
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;startAttributes&#39;] = [&#39;In&#39;]
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;finishedAttributes&#39;] = [&#39;Out&#39;]
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;NodeSize&#39;] = 30
        
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;name&#39;] = &#39;analysisMeasurementDEBUG&#39;
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;displayName&#39;] = &#39;DEBUG Analysis [Measurement]&#39;
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;]
        
        #We also add some custom JSON info about the node layout (colors and such)
        import json
        #NOTE: taking a lot of these by grouping-colors. I.e. I create one color (acquisition), then for others in the same &#39;group&#39;, I use analogous scheme of colorffy.com
        self.nodeLayout = json.loads(&#39;&#39;&#39;{
            
            &#34;scoringStart&#34;: {
                &#34;bg&#34;: [80, 180, 80, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;scoringEnd&#34;: {
                &#34;bg&#34;: [120, 180, 120, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;scoringEndVar&#34;: {
                &#34;bg&#34;: [120, 180, 120, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;earlyScoreFail&#34;: {
                &#34;bg&#34;: [220, 180, 120, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            &#34;acqStart&#34;: {
                &#34;bg&#34;: [224, 195, 69, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;acqEnd&#34;: {
                &#34;bg&#34;: [234, 205, 109, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;initStart&#34;: {
                &#34;bg&#34;: [180, 80, 180, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;initEnd&#34;: {
                &#34;bg&#34;: [180, 120, 180, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            
            &#34;acquisition&#34;: {
                &#34;bg&#34;: [79, 79, 183, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;changeProperties&#34;: {
                &#34;bg&#34;: [121, 79, 183, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;changeStagePos&#34;: {
                &#34;bg&#34;: [79, 100, 183, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;analysisMeasurement&#34;: {
                &#34;bg&#34;: [240, 113, 103, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;customFunction&#34;: {
                &#34;bg&#34;: [240, 168, 103, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;storeData&#34;: {
                &#34;bg&#34;: [240, 140, 103, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;timer&#34;: {
                &#34;bg&#34;: [197, 93, 85, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;realTimeAnalysis&#34;: {
                &#34;bg&#34;: [63, 99, 129, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;visualisation&#34;: {
                &#34;bg&#34;: [63, 125, 129, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;reporting&#34;: {
                &#34;bg&#34;: [63, 129, 107, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;newGlobalVar&#34;: {
                &#34;bg&#34;: [123, 194, 112, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;changeGlobalVar&#34;: {
                &#34;bg&#34;: [134, 203, 151, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;caseSwitch&#34;: {
                &#34;bg&#34;: [112, 194, 134, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;ifStatement&#34;: {
                &#34;bg&#34;: [143, 184, 155, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;ANDlogic&#34;: {
                &#34;bg&#34;: [112, 194, 118, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;slackReport&#34;: {
                &#34;bg&#34;: [68, 129, 168, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;stickyNote&#34;: {
                &#34;bg&#34;: [230, 185, 5, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;runInlineScript&#34;: {
                &#34;bg&#34;: [179, 98, 122, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;analysisMeasurementDEBUG&#34;: {
                &#34;bg&#34;: [162, 65, 98, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            }
            
            
            
        }&#39;&#39;&#39;)
        self.addConfig(self.nodeLayout)
    
    def performPostNodeCreation_Start(self,newNode,nodeType):
        &#34;&#34;&#34;
        Handles post-node-creation functions for nodes.

        This function handles post-node-creation functions for nodes, such as
        setting the node name and preset, and adding custom attributes.

        Args:
            newNode (nodz.Node): The newly created node.
            nodeType (str): The type of node that was created.
        &#34;&#34;&#34;
        if not newNode.createdFromLoading: #Normal case when it&#39;s simply created from the nodz canvas
            newNodeName = self.nodeInfo[nodeType][&#39;name&#39;]+&#34;_&#34;+str(self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;])
            #Increase the nodeCounter - use the neverReset one to completely eliminate options of same-named nodes ever
            self.nodeInfo[nodeType][&#39;NodeCounter&#39;]+=1
            self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;]+=1
        elif newNode.createdFromLoading: #Special case in case it&#39;s created from loading the whole graph
            newNodeName = newNode.name #Don&#39;t change the name
            self.nodeInfo[nodeType][&#39;NodeCounter&#39;]+=1
            #Get the node name:
            lastUnderscore = newNode.name.rfind(&#39;_&#39;)
            newNodeNumber = int(newNode.name[lastUnderscore+1:])
            #And set the nodecounterneverreset to be this value +1 or higher
            if self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] &lt; newNodeNumber+1:
                self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] = newNodeNumber+1
        newNode.flowChart = self
        if nodeType in self.config:
            configtype = nodeType
        else:
            configtype = &#39;node_preset_1&#39;
            
        
        #Change name, change sdisplayName, change preset:
        newNode.changeName(newNodeName)
        newNode.changeDisplayName(self.nodeInfo[nodeType][&#39;displayName&#39;])
        newNode.changePreset(configtype)
        
        self.nodes.append(newNode)
        
        self.updateNumberStartFinishedDataAttributes(newNode,nodeType)
        
        #Custom functions that should be done
        if nodeType == &#39;acquisition&#39;:
            #Attach a MDA data to this node
            parentV = None
            if self.parent is not None:
                parentV = self.parent
                
            
            #Set the variableNodz info, maybe later do this in seperate function?
            newNode.variablesNodz[&#39;data&#39;] = {}
            from ndtiff import NDTiffDataset
            newNode.variablesNodz[&#39;data&#39;][&#39;type&#39;] = [NDTiffDataset, np.ndarray]
            newNode.variablesNodz[&#39;data&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;data&#39;][&#39;importance&#39;] = &#39;Default&#39;
            newNode.variablesNodz[&#39;order&#39;] = {}
            newNode.variablesNodz[&#39;order&#39;][&#39;type&#39;] = [str]
            newNode.variablesNodz[&#39;order&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;order&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;exposure_ms&#39;] = {}
            newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;type&#39;] = [float]
            newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_timepoints&#39;] = {}
            newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;time_interval_ms&#39;] = {}
            newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;type&#39;] = [float]
            newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;xy_positions&#39;] = {}
            newNode.variablesNodz[&#39;xy_positions&#39;][&#39;type&#39;] = [np.ndarray]
            newNode.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;xy_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_xy_positions&#39;] = {}
            newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;z_positions&#39;] = {}
            newNode.variablesNodz[&#39;z_positions&#39;][&#39;type&#39;] = [np.ndarray]
            newNode.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;z_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_z_positions&#39;] = {}
            newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;channel_group&#39;] = {}
            newNode.variablesNodz[&#39;channel_group&#39;][&#39;type&#39;] = [str]
            newNode.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;channel_group&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;channels&#39;] = {}
            newNode.variablesNodz[&#39;channels&#39;][&#39;type&#39;] = [np.ndarray]
            newNode.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;channels&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_channels&#39;] = {}
            newNode.variablesNodz[&#39;n_channels&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_channels&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;storage_path&#39;] = {}
            newNode.variablesNodz[&#39;storage_path&#39;][&#39;type&#39;] = [str]
            newNode.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;storage_path&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            
            #Attach a MDA data to this node
            newNode.mdaData = MDAGlados(self.core,self.MM_JSON,None,self.shared_data,hasGUI=True,parent=parentV,node=newNode) # type: ignore
            
            #Initialise with showing only time.
            newNode.mdaData.GUI_show_channel = False
            newNode.mdaData.GUI_show_exposure = True
            newNode.mdaData.GUI_show_order = True
            newNode.mdaData.GUI_show_storage = False
            newNode.mdaData.GUI_show_time = True
            newNode.mdaData.GUI_show_xy = False
            newNode.mdaData.GUI_show_z = False
            
            #Do the acquisition upon callAction
            newNode.callAction = lambda self, node=newNode: node.mdaData.MDA_acq_from_Node(node)
            
            #Add the node emits of &#39;finishing&#39; upon MDA completion.
            #Also connect the node&#39;s finishedMDA
            #This order is important!
            newNode.mdaData.MDA_completed.connect(newNode.finishedmda)
            newNode.mdaData.MDA_completed.connect(lambda self, node = newNode: node.customFinishedEmits.emit_all_signals())
            #Note: the recorded MDA data is stored in node.mdaData.data - any analysis method should find/read this.
            #The core is at node.mdaData.core
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;realTimeAnalysis&#39;:
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;visualisation&#39;:
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;changeProperties&#39;:
            #attach MMconfigUI to this:
            # Get all config groups
            allConfigGroups={}
            nrconfiggroups = self.core.get_available_config_groups().size() #type:ignore
            for config_group_id in range(nrconfiggroups):
                allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
        
        
            newNode.MMconfigInfo = MMConfigUI(allConfigGroups,showConfigs = True,showStages=False,showROIoptions=False,showShutterOptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False,showCheckboxes = True,autoSaveLoad=False) # type: ignore
            
            #Add the callaction
            newNode.callAction = lambda self, node=newNode: self.MMconfigChangeRan(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;changeStagePos&#39;:
            # Get all config group s
            allConfigGroups={}
            nrconfiggroups = self.core.get_available_config_groups().size() #type:ignore
            for config_group_id in range(nrconfiggroups):
                allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
        
            newNode.MMconfigInfo = MMConfigUI(allConfigGroups,showConfigs = False,showStages=False,showROIoptions=False,showShutterOptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False,showCheckboxes = False,showRelativeStages = True, autoSaveLoad=False) # type: ignore
            
            #Add the callaction
            newNode.callAction = lambda self, node=newNode: self.MMstageChangeRan(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within 
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;customFunction&#39;:
            newNode.callAction = lambda self, node=newNode: self.CustomFunctionNode_started(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #initialise the scoring_analysis_currentData values:
            #Rather stupidly, but I create the double-click-dialog, but just never show it.
            dialog = nodz_customFunctionDialog(currentNode = newNode, parent = self)
            newNode.customFunction_currentData=dialog.currentData
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;analysisMeasurement&#39;:
            newNode.callAction = lambda self, node=newNode: self.AnalysisNode_started(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #initialise the scoring_analysis_currentData values:
            #Rather stupidly, but I create the double-click-dialog, but just never show it.
            dialog = nodz_analysisDialog(currentNode = newNode, parent = self)
            newNode.scoring_analysis_currentData=dialog.currentData
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;analysisMeasurementDEBUG&#39;:
            #This is a DEBUG type of analysis measurement which blocks the main thread, but allows for easier debugging.
            newNode.callAction = lambda self, node=newNode: self.AnalysisNode_DEBUG_started(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #initialise the scoring_analysis_currentData values:
            #Rather stupidly, but I create the double-click-dialog, but just never show it.
            dialog = nodz_analysisDialog(currentNode = newNode, parent = self)
            newNode.scoring_analysis_currentData=dialog.currentData
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;timer&#39;:
            newNode.callAction = lambda self, node=newNode: self.timerCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;storeData&#39;:
            newNode.callAction = lambda self, node=newNode: self.storeDataCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;changeGlobalVar&#39;:
            newNode.callAction = lambda self, node=newNode: self.changeGlobalVarCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;ifStatement&#39;:
            newNode.callAction = lambda self, node=newNode: self.ifStatementCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;newGlobalVar&#39;:
            newNode.callAction = lambda self, node=newNode: self.newGlobalVarCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;runInlineScript&#39;:
            newNode.callAction = lambda self, node=newNode: self.runInlineScriptCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;caseSwitch&#39;:
            newNode.callAction = lambda self, node=newNode: self.runCaseSwitchCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;slackReport&#39;:
            newNode.callAction = lambda self, node=newNode: self.runslackReportCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;scoringStart&#39;:
            newNode.callAction = lambda self, node=newNode: self.scoringStart(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;scoringEnd&#39;:
            newNode.callAction = lambda self, node=newNode: self.scoringEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            #Update the decisionwidget after loading the scoringEnd node:
            self.decisionWidget.updateAllDecisions()
        elif nodeType == &#39;scoringEndVar&#39;:
            newNode.callAction = lambda self, node=newNode: self.scoringEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            #Update the decisionwidget after loading the scoringEnd node:
            self.decisionWidget.updateAllDecisions()
        elif nodeType == &#39;earlyScoreFail&#39;:
            newNode.callAction = lambda self, node=newNode: self.earlyScoringFail(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;earlyScoringFail&#39;)
        elif nodeType == &#39;acqEnd&#39;:
            newNode.callAction = lambda self, node=newNode: self.acquiringEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;initStart&#39;:
            newNode.callAction = lambda self, node=newNode: self.initStart(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;initEnd&#39;:
            newNode.callAction = lambda self, node=newNode: self.initEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;ANDlogic&#39;:
            newNode.callAction = lambda self, node=newNode: self.and_logicCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;caseSwitch&#39;:
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        else:
            newNode.callAction = None

        newNode.update()

    def nodeRan(self,node):
        &#34;&#34;&#34; 
        Function that&#39;s called at the start of every node
        Updates the core variables and the variables in the UI.
        &#34;&#34;&#34;
        try:
            self.update()
            # self.updateCoreVariables()
            self.variablesWidget.updateVariables()
        except:
            pass
        logging.debug(f&#39;Node with name {node.name} ran&#39;)

    def NodeDoubleClicked(self,nodeName):
        &#34;&#34;&#34;
        Handle double-clicking on a node in the flowchart.

        When a node is double-clicked, this function is called. Depending on the node, this 
        function will open a dialog to modify the node&#39;s data.
        &#34;&#34;&#34;
        currentNode = self.findNodeByName(nodeName)
        if &#39;acquisition&#39; in nodeName:
            dialog = nodz_openMDADialog(parentData=self,currentNode = currentNode)
            if dialog.exec_() == QDialog.Accepted:
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;acquisition&#39;)
                currentNode.dialogInfo = dialog #type:ignore
                logging.debug(f&#34;MDA dialog input: {dialog.getInputs()}&#34;)
            
            # currentNode.mdaData.exposure_ms = dialog.getExposureTime()
            # currentNode.mdaData.mda = dialog.getInputs()#type:ignore
            dialogmdaData = dialog.getmdaData()
            attrs_to_not_copy = [&#39;gui&#39;,&#39;core&#39;,&#39;shared_data&#39;,&#39;has_GUI&#39;,&#39;data&#39;,&#39;staticMetaObject&#39;,&#39;MDA_completed&#39;,&#39;MM_JSON&#39;]
            #Loop over all attributes in dialogmdaData:
            for attrs in vars(dialogmdaData):
                if attrs not in attrs_to_not_copy:
                    setattr(currentNode.mdaData,attrs,getattr(dialogmdaData,attrs)) #type:ignore
            
            currentNode.update() #type:ignore
        elif &#39;changeProperties&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #Show dialog:
            if &#39;MMconfigInfo&#39; in vars(currentNode):
                storedConfigsStrings = currentNode.MMconfigInfo.config_string_storage #type: ignore
            else:
                currentNode.MMconfigInfo = [] #type: ignore
                storedConfigsStrings = None
            dialog = nodz_openMMConfigDialog(parentNode=currentNode,storedConfigsStrings = storedConfigsStrings) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeProperties&#39;)
                #Update the results of this dialog into the nodz node   
                self.changeConfigStorageInNodz(currentNode,dialog.ConfigsToBeChanged())
        elif &#39;visualisation_&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #Show dialog:
            dialog = nodz_visualisationDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;visualisation&#39;)
                currentNode.visualisation_currentData[&#39;layerName&#39;] = dialog.layerNameEdit.text() #type:ignore
                currentNode.visualisation_currentData[&#39;colormap&#39;] = dialog.colormapComboBox.currentText() #type:ignore
        elif &#39;changeStagePos&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #Show dialog:
            if &#39;MMconfigInfo&#39; in vars(currentNode):
                storedRelStagesString = currentNode.MMconfigInfo.relstage_string_storage #type: ignore
            else:
                currentNode.MMconfigInfo = [] #type: ignore
                storedRelStagesString = None
            dialog = nodz_openMMConfigDialog(parentNode=currentNode,storedrelStagesString = storedRelStagesString) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                #Update the results of this dialog into the nodz node
                self.changeRelStageStorageInNodz(currentNode,dialog.RelStageInfo())
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeStagePos&#39;)
                
        elif &#39;analysisMeasurement&#39; in nodeName or &#39;analysisMeasurementDEBUG&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            dialog = nodz_analysisDialog(currentNode = currentNode, parent = self)
            if dialog.exec_() == QDialog.Accepted:
                
                #Update the results of this dialog into the nodz node
                currentNode.scoring_analysis_currentData = dialog.currentData #type:ignore
                utils.analysis_outputs_to_variableNodz(currentNode)
                try:
                    currentNode.dialogInfo = dialog #type:ignore
                    self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;analysisMeasurement&#39;)
                except:
                    logging.warning(&#39;Failed to set text in analysisMeasurementDialog&#39;)
                logging.debug(&#39;Pressed OK on analysisMeasurementDialog&#39;)
        elif &#39;customFunction&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            dialog = nodz_customFunctionDialog(currentNode = currentNode, parent = self)
            if dialog.exec_() == QDialog.Accepted:
                #Update the results of this dialog into the nodz node
                currentNode.customFunction_currentData = dialog.currentData #type:ignore
                utils.customFunction_outputs_to_variableNodz(currentNode)
                try:
                    currentNode.dialogInfo = dialog #type:ignore
                    self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;customFunction&#39;)
                except:
                    logging.warning(&#39;Failed to set text in analysisMeasurementDialog&#39;)
                logging.debug(&#39;Pressed OK on customFunctionDialog&#39;)
            
            
        elif &#39;realTimeAnalysis&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #TODO: pre-load dialog.currentData with currentNode.currentData if that exists (better naming i guess) to hold all pre-selected data 
            dialog = nodz_realTimeAnalysisDialog(currentNode = currentNode, parent = self)
            if dialog.exec_() == QDialog.Accepted:
                #Update the results of this dialog into the nodz node
                currentNode.real_time_analysis_currentData = dialog.currentData #type:ignore
                currentNode.real_time_analysis_currentData[&#39;__selectedDropdownEntryRTAnalysis__&#39;] = dialog.comboBox_RTanalysisFunctions.currentText() #type:ignore
                currentNode.real_time_analysis_currentData[&#39;__realTimeVisualisation__&#39;] = dialog.visualisationBox.isChecked() #type:ignore 
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;RTanalysisMeasurement&#39;)
                logging.debug(&#39;Pressed OK on RTanalysis&#39;)
                
        elif &#39;timer&#39; in nodeName:
            dialog = nodz_openTimerDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.timerInfo = dialog.timerInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;timer&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;storeData&#39; in nodeName:
            dialog = nodz_openStoreDataDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.storeDataInfo = dialog.storeDataInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;storeData&#39;)
        elif &#39;changeGlobalVar&#39; in nodeName:
            dialog = nodz_openChangeGlobalVarDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.changeGlobalVarInfo = dialog.changeGlobalVarInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeGlobalVar&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;ifStatement&#39; in nodeName:
            dialog = nodz_openIfStatementDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.ifStatementInfo = dialog.ifStatementInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;ifStatement&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;newGlobalVar&#39; in nodeName:
            dialog = nodz_openNewGlobalVarDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.newGlobalVarInfo = dialog.newGlobalVarInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;newGlobalVar&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;runInlineScript&#39; in nodeName:
            dialog = nodz_openInlineScriptDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.InlineScriptInfo = dialog.InlineScriptInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;runInlineScript&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;caseSwitch&#39; in nodeName:
            dialog = nodz_caseSwitchDialog(parentNode=currentNode,currentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                dialogLineEdits = []
                for lineEdit in dialog.lineEdits:
                    dialogLineEdits.append(lineEdit.text())
                self.update_plugs_fromDialog(currentNode,dialogLineEdits)
                
                currentNode.caseSwitchInfo = dialog.caseSwitchInfo
                currentNode.caseSwitchInfo[&#39;Plugs&#39;] = dialogLineEdits
                
                #Update the node itself
                self.update()
                nodeType = self.nodeLookupName_withoutCounter(nodeName)
                for _ in range(3):
                    self.updateNumberStartFinishedDataAttributes(currentNode,nodeType)
                    self.update()
                
                logging.debug(dialogLineEdits)
                logging.debug(&#39;Pressed OK on caseSwitch&#39;)
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;caseSwitch&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;slackReport&#39; in nodeName:
            dialog = nodz_slackReportDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.slackReportInfo = dialog.slackReportInfo
                logging.debug(&#39;Pressed OK on caseSwitch&#39;)
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;slackReport&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;stickyNote&#39; in nodeName:
            dialog = nodz_stickyNoteDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.stickyNoteInfo = dialog.stickyNoteInfo
                logging.debug(&#39;Pressed OK on stickyNote&#39;)
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;stickyNote&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;scoringStart&#39; in nodeName:
            currentNode.callAction(self) #type:ignore
        elif &#39;scoringEndVar&#39; in nodeName:
            dialog = nodz_openScoringEndVarDialog(parent=self,currentNode=currentNode)
            if dialog.exec_() == QDialog.Accepted:
                #Update the decisionwidget:
                self.decisionWidget.updateAllDecisions()
                logging.debug(&#39;Pressed OK on scoringEndVar&#39;)
        elif &#39;scoringEnd&#39; in nodeName:
            dialog = nodz_openScoringEndDialog(parent=self,currentNode=currentNode)
            if dialog.exec_() == QDialog.Accepted:
                dialogLineEdits = []
                for lineEdit in dialog.lineEdits:
                    dialogLineEdits.append(lineEdit.text())
                self.update_scoring_end(currentNode,dialogLineEdits)
                #Update the node itself
                self.update()
                nodeType = self.nodeLookupName_withoutCounter(nodeName)
                self.updateNumberStartFinishedDataAttributes(currentNode,nodeType)
                self.update()
                
                #Update the decisionwidget:
                self.decisionWidget.updateAllDecisions()
                logging.debug(dialogLineEdits)
                logging.debug(&#39;Pressed OK on scoringEnd&#39;)
    
    def singleNodeTypeInit(self):
        &#34;&#34;&#34; 
        Initialise the info for a single node type. Hand-in-hand with defineNodeInfo.
        &#34;&#34;&#34;
        init = {}
        init[&#39;name&#39;] = &#39;name&#39;
        init[&#39;displayName&#39;] = &#39;DisplayName&#39;
        init[&#39;startAttributes&#39;] = []
        init[&#39;finishedAttributes&#39;] = []
        init[&#39;dataAttributes&#39;] = []
        init[&#39;bottomAttributes&#39;] = []
        init[&#39;topAttributes&#39;] = []
        init[&#39;NodeCounter&#39;] = 0
        init[&#39;NodeCounterNeverReset&#39;] = 0
        init[&#39;MaxNodeCounter&#39;] = np.inf
        init[&#39;NodeSize&#39;] = 100
        return init

    def NodeAdded(self,node):
        &#34;&#34;&#34;
        Handle when one or more nodes are created in the flowchart.

        When one or more nodes are created in the flowchart, this function is called.
        It does some pre-processing of the node and then calls performPostNodeCreation_Start.
        &#34;&#34;&#34;
        logging.debug(&#39;one or more nodes are created!&#39;)
        nodeType = self.nodeLookupName_withoutCounter(node.name)
        self.performPostNodeCreation_Start(node,nodeType)
        self.checkNodesOnErrors()

    def NodeFullyInitialised(self,node):
        &#34;&#34;&#34;
        Handle when a node is fully initialised.
        
        Specifically, when all e.g. data[&#39;NODES_SCORING_SCORING&#39;] from loading is added to the node, only after that, this will run.

        This function is called when a node is fully initialised. It does some
        post-initialisation processing for nodes based on their type.

        Parameters
        ----------
        node : Node
            The node that has been fully initialised.
        &#34;&#34;&#34;
        nodeType = self.nodeLookupName_withoutCounter(node.name)
        if nodeType == &#39;scoringEnd&#39;:
            self.update_scoring_end(node,node.scoring_end_currentData[&#39;Variables&#39;])
        if nodeType == &#39;caseSwitch&#39;:
            if &#39;Plugs&#39; in node.caseSwitchInfo:
                self.update_plugs_fromDialog(node,node.caseSwitchInfo[&#39;Plugs&#39;])
                
        self.checkNodesOnErrors()

    def NodeRemoved(self,nodeNames):
        &#34;&#34;&#34;
        Handle when one or more nodes are removed from the flowchart.

        When one or more nodes are removed from the flowchart, this function is called.
        It will update the node counters of the corresponding node types.
        &#34;&#34;&#34;
        logging.debug(&#39;one or more nodes are removed!&#39;)
        for nodeName in nodeNames:
            for node_type, node_data in self.nodeInfo.items():
                if node_type != &#39;__RightClickMenuNodeOrder__&#39;:
                    try:
                        if node_data[&#39;name&#39;] in nodeName:
                            # if self.nodeInfo[node_type][&#39;MaxNodeCounter&#39;] &lt; np.inf:
                            self.nodeInfo[node_type][&#39;NodeCounter&#39;] -= 1
                    except:
                        pass
            #Also remove from self.nodes:
            node = self.findNodeByName(nodeName)
            try:
                self.nodes.remove(node)
            except:
                logging.warning(f&#34;failed to remove node: {nodeName}&#34;)
        self.checkNodesOnErrors()
    
    def finishedEmits(self,node):
        &#34;&#34;&#34;
        This function emits the customFinishedEmits signal of a node, and allt he customDataEmits

        Args:
            node (nodz.Node): The node that needs to finish.

        Returns:
            None
        &#34;&#34;&#34;
        self.updateCoreVariables()
        node.status=&#39;finished&#39;
        self.shared_data.warningErrorInfoInfo[&#39;Info&#39;][&#39;LastNodeRan&#39;] = node.name
        
        self.update()
        if node.customFinishedEmits is not None and len(node.customFinishedEmits.signals)&gt;0:
            node.customFinishedEmits.emit_all_signals()
        if node.customDataEmits is not None and len(node.customDataEmits.signals)&gt;0:
            node.customDataEmits.emit_all_signals()

        if &#39;dialogInfo&#39; in vars(node):
            self.set_readable_text_after_dialogChange(node,node.dialogInfo)

    def giveInfoOnNode(self,node):
        &#34;&#34;&#34;
        Prints information about a node in the flowchart

        This function prints some basic information about a node in the flowchart.

        Args:
            node (nodz.Node): The node to get information about.

        Returns:
            None
        &#34;&#34;&#34;
        logging.info(&#39;--------&#39;)
        logging.info(node)
        logging.info(f&#34;node name: {node.name}&#34;)
        logging.info(f&#34;incoming connections: {node.n_connect_at_start}&#34; )
    #endregion
    
    #region NodzFlowChart Helpers
    def obtainAllNodes(self):
        &#34;&#34;&#34; 
        Obtain all nodes, return them
        &#34;&#34;&#34;
        return self.nodes
    
    def updateNumberStartFinishedDataAttributes(self,newNode,nodeType):
        &#34;&#34;&#34;
        Updates custom attributes for a new node based on the specified node type.
        
        Args:
            newNode: The new node to update custom attributes for.
            nodeType: The type of the node to determine which custom attributes to update.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        if len(self.nodeInfo[nodeType][&#39;startAttributes&#39;]) &gt; 0:
            newNode.customStartEmits = NodeSignalManager()
        else:
            newNode.customStartEmits = None
        if len(self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]) &gt; 0:
            newNode.customFinishedEmits = NodeSignalManager()
        else:
            newNode.customFinishedEmits = None
        if len(self.nodeInfo[nodeType][&#39;dataAttributes&#39;]) &gt; 0:
            newNode.customDataEmits = NodeSignalManager()
        else:
            newNode.customDataEmits = None
        if len(self.nodeInfo[nodeType][&#39;bottomAttributes&#39;]) &gt; 0:
            newNode.customBottomEmits = NodeSignalManager()
        else:
            newNode.customBottomEmits = None
        if len(self.nodeInfo[nodeType][&#39;topAttributes&#39;]) &gt; 0:
            newNode.customTopEmits = NodeSignalManager()
        else:
            newNode.customTopEmits = None
            
        #Add custom attributes where necessary
        for attr in self.nodeInfo[nodeType][&#39;startAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=True)
            newNode.customStartEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=True, socket=False)
            newNode.customFinishedEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;dataAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=True, socket=False)
            newNode.customDataEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;bottomAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=False, bottomAttr=True)
            newNode.customBottomEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;topAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=False, topAttr=True)
            newNode.customTopEmits.add_signal(attr) #type: ignore
        
        logging.debug(&#34;updated custom attributes&#34;)
    
    def advNodeInfo(self,node,event):
        &#34;&#34;&#34;
        Show advanced information about a node in a popup window.
        
        Args:
            node: The node object for which advanced information is to be displayed.
            event: The event triggering the display of advanced information.
        
        Returns:
            None
        &#34;&#34;&#34;
        #Create a quick popup window with a line edit and an ok/cancel:
        dialog = QDialog()
        dialog.setWindowTitle(&#39;Node info&#39;)
        dialog.setModal(True)
        layout = QVBoxLayout(dialog)

        
        textEdit = QTextEdit()
        
        attrs_to_show = [&#39;name&#39;,&#39;displayName&#39;,&#39;nodePreset&#39;,&#39;plugs&#39;,&#39;sockets&#39;,&#39;scoring_analysis_currentData&#39;,&#39;scoring_end_currentData&#39;,&#39;scoring_scoring_currentData&#39;,&#39;scoring_visualisation_currentData&#39;,&#39;visualisation_currentData&#39;,&#39;real_time_analysis_currentData&#39;]
        
        text_to_show = &#39;&#39;
        for attr in attrs_to_show:
            if hasattr(node,attr):
                text_to_show += f&#39;{attr}: {str(getattr(node,attr))}\n&#39;
        
        #Custom add these ones:
        if hasattr(node,&#39;mdaData&#39;):
            if hasattr(node.mdaData,&#39;mda&#39;):
                text_to_show += f&#39;mda: {str(node.mdaData.mda)}\n&#39;
        if hasattr(node,&#39;MMconfigInfo&#39;):
            if hasattr(node.MMconfigInfo,&#39;config_string_storage&#39;):
                text_to_show += f&#39;config_string_storage: {str(node.MMconfigInfo.config_string_storage)}\n&#39;
        
        textEdit.setText(text_to_show)
        layout.addWidget(textEdit)

        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok, dialog)
        layout.addWidget(buttonBox)

        buttonBox.accepted.connect(dialog.accept)
        
        if dialog.exec_() == QDialog.Accepted:
            logging.debug(&#39;advanced node info closed&#39;)

    def explore_attributes(self, obj, indent=0):
        &#34;&#34;&#34;
        Recursively print the attributes of an object.

        This function is used for debugging purposes to explore the attributes of an object.
        It will print the attributes of `obj` and all of its sub-attributes, up to a maximum
        depth of 20.

        Parameters
        ----------
        obj : object
            The object to explore
        indent : int, optional
            The indentation level, by default 0
        &#34;&#34;&#34;
        if indent &lt; 20:
            attributes = vars(obj)
            for attr_name in attributes:
                if not attr_name.startswith(&#39;_&#39;):
                    attr = getattr(obj, attr_name)
                    if not callable(attr):
                        logging.debug(&#34; &#34; * indent + attr_name)
                    else:
                        logging.debug(&#34; &#34; * indent + attr_name + &#39;()&#39;)
                    if hasattr(attr, &#39;__dict__&#39;):
                        self.explore_attributes(attr, indent + 2)
                # except:
                #     pass

    def nodeLookupName_withoutCounter(self,nodeName):
        &#34;&#34;&#34;
        Returns the node name without the counter suffix.

        Given a node name like &#34;MyNode_0&#34; this function returns &#34;MyNode&#34;.

        Parameters
        ----------
        nodeName : str
            The node name to strip the counter from.

        Returns
        -------
        str
            The node name without the counter suffix.
        &#34;&#34;&#34;
        #Find the last underscore (&#39;_0, _1, etc&#39;)
        index_last_underscore = nodeName.rfind(&#39;_&#39;)
        nodeNameNC = nodeName[:index_last_underscore]
        finalNodeName=None
        #Now get the correct lookup name by looking through all nodeInfo items
        for node_name, node_data in self.nodeInfo.items():
            # Check if the name matches the specific value
            if &#39;name&#39; in node_data and node_data[&#39;name&#39;] == nodeNameNC:
                finalNodeName = node_name
        
        return finalNodeName
    
    def findNodeByName(self, name):
        &#34;&#34;&#34;
        Function to find a node based on its name attribute

        Args:
            name (str): The name of the node to find

        Returns:
            nodz.node: The node with the given name or None if not found
        &#34;&#34;&#34;
        for node in self.nodes:
            #check if the attribute &#39;name&#39; is found:
            if hasattr(node, &#39;name&#39;):
                if node.name == name:
                    return node
        return None
    
    def changeNodeName(self, node, event):
        &#34;&#34;&#34;
        Change the name of a node.
        
        Args:
            node: The node whose name will be changed.
            event: The event triggering the name change.
        
        Returns:
            None
        &#34;&#34;&#34;
        #Create a quick popup window with a line edit and an ok/cancel:
        dialog = QDialog()
        dialog.setWindowTitle(&#39;Change node name&#39;)
        dialog.setModal(True)
        layout = QVBoxLayout(dialog)

        lineEdit = QLineEdit()
        lineEdit.setText(node.displayName)
        layout.addWidget(lineEdit)

        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, Qt.Horizontal, dialog) #type:ignore
        buttonBox.accepted.connect(dialog.accept)
        buttonBox.rejected.connect(dialog.reject)
        layout.addWidget(buttonBox)

        if dialog.exec_() == QDialog.Accepted:
            node.displayName = lineEdit.text()
        
    def changeNodeColor(self, node, event):
        &#34;&#34;&#34;
        Change the color of a node.
        
        Args:
            node: The node object whose color will be changed.
            event: The event that triggers the color change.
        
        Returns:
            None
        &#34;&#34;&#34;
        color = QColorDialog.getColor()
        node.alternateFillColor = color.getRgb()
        #Force the change in the node:
        node.BGcolChanged()
        node.update()
        logging.debug(f&#34;Node color changed to {node.alternateFillColor}&#34;)

    def limitTextLength(self,text,textLength:int=40):
        &#34;&#34;&#34; 
        Get a string (text) and return a &#34;abc...def&#34; string if it&#39;s too long.
        &#34;&#34;&#34;
        if type(text) != str:
            text = str(text)
        textLength = int(textLength)
        if textLength % 1 == 0: #if odd length, make it even
            textLength = int(textLength+1)
        if len(text) &gt; textLength:
            displayVal = text[:20] + &#39;...&#39; + text[-20:]
        else:
            displayVal = text
        return displayVal

    def set_readable_text_after_dialogChange(self,currentNode,dialog,nodeType=None):
        &#34;&#34;&#34;Script which sets a readable text inside the textfield of the currentNode after a dialog is closed (i.e. a popup window is closed).

        Args:
            currentNode (Nodz Node): Current Nodz Node
            dialog (QDialog): Dialog output
            nodeType (str): Type of node
        &#34;&#34;&#34;
        displayHTMLtext = &#39;&#39;
        if nodeType == None:
            nodeType = currentNode.name.split(&#39;_&#39;)[0]
        if nodeType == &#39;analysisMeasurement&#39; or nodeType == &#39;analysisMeasurementDEBUG&#39;:
            methodName = dialog.currentData[&#39;__selectedDropdownEntryAnalysis__&#39;]
            methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
            reqKwValues = []
            optKwValues = []
            
            reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
            optKwargs = utils.optKwargsFromFunction(methodFunctionName)
            
            displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&lt;br&gt;Input:&#34;
            
            relativeData = {}
            for key in dialog.currentData:
                if &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                    relativeData[key] = dialog.currentData[key]
            
            allValues = utils.nodz_dataFromGeneralAdvancedLineEditDialog(relativeData,currentNode.flowChart)
            
            for rkw in reqKwargs:
                displayVal = self.limitTextLength(str(allValues[rkw][1]))
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{rkw}&lt;/b&gt;: {displayVal}&#34;

            for okw in optKwargs:
                displayVal = self.limitTextLength(str(allValues[okw][1]))
                displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{okw}&lt;/i&gt;: {displayVal}&#34;
            
            displayHTMLtext += &#34;&lt;br&gt;&lt;br&gt;Output:&#34;
            htmloutputadded=False
            for varName in currentNode.variablesNodz:
                currData = str(currentNode.variablesNodz[varName][&#39;data&#39;])
                typing = currentNode.variablesNodz[varName][&#39;type&#39;]
                importance = currentNode.variablesNodz[varName][&#39;importance&#39;]
                
                if currData is not None:
                    currData = self.limitTextLength(currData)
                else:
                    currData = &#39;None&#39;
                
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{varName}&lt;/b&gt;: {str(currData)}&#34;
                htmloutputadded=True
            
            if not htmloutputadded:
                displayHTMLtext += f&#34;&lt;br&gt;None&#34;
        elif nodeType == &#39;RTanalysisMeasurement&#39;:
            methodName = dialog.currentData[&#39;__selectedDropdownEntryRTAnalysis__&#39;]
            methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
            reqKwValues = []
            optKwValues = []
            
            reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
            optKwargs = utils.optKwargsFromFunction(methodFunctionName)
            
            for key in dialog.currentData:
                for rkw in reqKwargs:
                    if rkw in key and &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                        reqKwValues.append(dialog.currentData[key])
                for okw in optKwargs:
                    if okw in key and &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                        optKwValues.append(dialog.currentData[key])
            
            displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&#34;
            for i in range(len(reqKwargs)):
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{reqKwargs[i]}&lt;/b&gt;: {reqKwValues[i]}&#34;
            for i in range(len(optKwargs)):
                displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{optKwargs[i]}&lt;/i&gt;: {optKwValues[i]}&#34;
                
        elif nodeType == &#39;visualisation&#39;:
            displayHTMLtext = f&#34;&lt;b&gt;Layer name: {dialog.layerNameEdit.text()}&lt;/b&gt;&#34;
            if dialog.colormapComboBox.currentText() != &#39;None&#39;:
                displayHTMLtext += f&#34;&lt;br&gt;Colormap: {dialog.colormapComboBox.currentText()}&#34;
        elif nodeType == &#39;acquisition&#39;:
            displayHTMLtext = f&#34;&lt;b&gt;{len(dialog.getInputs())} frames with order {dialog.mdaconfig.order}&lt;/b&gt;&#34;
            if dialog.mdaconfig.GUI_exposure_enabled:
                displayHTMLtext += f&#34;&lt;br&gt;{dialog.getExposureTime()} ms exposure time&#34;
            if dialog.mdaconfig.GUI_show_time:
                displayHTMLtext += f&#34;&lt;br&gt;{dialog.mdaconfig.num_time_points} time points&#34;
            if dialog.mdaconfig.GUI_show_channel:
                displayHTMLtext += f&#34;&lt;br&gt;{len(dialog.mdaconfig.channel_exposures_ms)} channels in group {dialog.mdaconfig.channel_group}&#34;
            if dialog.mdaconfig.GUI_show_xy:
                displayHTMLtext += f&#34;&lt;br&gt;{len(dialog.mdaconfig.xy_positions)} XY positions&#34;
            if dialog.mdaconfig.GUI_show_z:
                if dialog.mdaconfig.z_nr_steps is not None:
                    displayHTMLtext += f&#34;&lt;br&gt;{dialog.mdaconfig.z_nr_steps} Z positions&#34;
                else:
                    nrZsteps = (dialog.mdaconfig.z_end-dialog.mdaconfig.z_start)//dialog.mdaconfig.z_step_distance
                    displayHTMLtext += f&#34;&lt;br&gt;{nrZsteps} Z positions&#34;
        elif nodeType == &#39;changeProperties&#39;:
            displayHTMLtext = f&#34;Changing {len(dialog.ConfigsToBeChanged())} config(s):&#34;
            for config in dialog.ConfigsToBeChanged():
                try:
                    displayRounded = str(round(float(config[1]),3))
                except:
                    displayRounded = config[1]
                displayHTMLtext += f&#34;&lt;br&gt;{config[0]} to {displayRounded}&#34;
        elif nodeType == &#39;scoreEnd&#39;:
            import time
            from datetime import datetime
            displayHTMLtext = f&#34;&lt;i&gt; {datetime.fromtimestamp(time.time()).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&lt;/i&gt;&#34;
            for score_entry in dialog[0]:
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{score_entry}:&lt;/b&gt; {format(dialog[1][score_entry],&#39;.2f&#39;)}&#34;
            if len(dialog) &gt; 2:
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{dialog[2]}&lt;/b&gt;&#34;
        elif nodeType == &#39;scoreStart&#39;:
            import time
            from datetime import datetime
            displayHTMLtext = &#34;&lt;b&gt;Scoring started at:&lt;/b&gt;&#34;
            displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt; {datetime.fromtimestamp(time.time()).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&lt;/i&gt;&#34;
        
        elif nodeType == &#39;earlyScoringFail&#39;:
            displayHTMLtext = f&#34;This node will fail this score and go to the next position!&#34;
        elif nodeType == &#39;timer&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(dialog.timerInfo,currentNode.flowChart)
            try:
                displayHTMLtext = f&#34;&lt;b&gt;Timer:&lt;/b&gt; wait {str(values[&#39;wait_time&#39;][1])} s&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;storeData&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.storeDataInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = f&#34;Store data &lt;b&gt;{self.limitTextLength(values[&#39;item_to_store&#39;][1])}&lt;/b&gt; at location &lt;b&gt;{self.limitTextLength(values[&#39;store_location&#39;][1])}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;changeGlobalVar&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.changeGlobalVarInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = f&#34;Change global variable &lt;b&gt;{self.limitTextLength(values[&#39;globalVarName&#39;][1])}&lt;/b&gt; to &lt;b&gt;{self.limitTextLength(values[&#39;globalVarValue&#39;][1],textLength = 60)}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        
        elif nodeType == &#39;ifStatement&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.ifStatementInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                comparatorValue = values[&#39;comparator&#39;][1]
                #Replace &lt; inside the value:
                comparatorValue = comparatorValue.replace(&#39;&lt;&#39;,&#39;&amp;lt;&#39;)
                
                displayHTMLtext = f&#34;Assess the statement &lt;b&gt;{values[&#39;valueToCheck&#39;][1]} {comparatorValue} {values[&#39;valueCheckAgainst&#39;][1]}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
            
        elif nodeType == &#39;runInlineScript&#39;:
            scriptInfo = currentNode.InlineScriptInfo
            n_lines = len(scriptInfo.split(&#39;\n&#39;))
            if n_lines == 1:
                displayHTMLtext = f&#34;Run a pycromanager script with &lt;b&gt;{n_lines} line&lt;/b&gt;&#34;
            else:
                displayHTMLtext = f&#34;Run a pycromanager script with &lt;b&gt;{n_lines} lines&lt;/b&gt;&#34;
        elif nodeType == &#39;newGlobalVar&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.newGlobalVarInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = f&#34;Create new global variable &lt;b&gt;{self.limitTextLength(values[&#39;globalVarName&#39;][1])}&lt;/b&gt; with value &lt;b&gt;{self.limitTextLength(values[&#39;globalVarValue&#39;][1])}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;customFunction&#39;:
            methodName = dialog.currentData[&#39;__selectedDropdownEntryAnalysis__&#39;]
            methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
            reqKwValues = []
            optKwValues = []
            
            reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
            optKwargs = utils.optKwargsFromFunction(methodFunctionName)
            
            displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&lt;br&gt;Input:&#34;
            
            relativeData = {}
            for key in dialog.currentData:
                if &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                    relativeData[key] = dialog.currentData[key]
            
            allValues = utils.nodz_dataFromGeneralAdvancedLineEditDialog(relativeData,currentNode.flowChart,dontEvaluate=True)
            
            for rkw in reqKwargs:
                displayVal = str(allValues[rkw][1])
                if len(displayVal) &gt; 40:
                    displayVal = displayVal[:20] + &#39;...&#39; + displayVal[-20:]
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{rkw}&lt;/b&gt;: {displayVal}&#34;

            for okw in optKwargs:
                displayVal = str(allValues[okw][1])
                if len(displayVal) &gt; 40:
                    displayVal = displayVal[:20] + &#39;...&#39; + displayVal[-20:]
                displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{okw}&lt;/i&gt;: {displayVal}&#34;
            
            
            displayHTMLtext += &#34;&lt;br&gt;&lt;br&gt;Output:&#34;
            
            htmloutputadded=False
            
            for varName in currentNode.variablesNodz:
                currData = str(currentNode.variablesNodz[varName][&#39;data&#39;])
                if currData is not None:
                    currData = self.limitTextLength(currData)
                else:
                    currData = &#39;None&#39;
                typing = currentNode.variablesNodz[varName][&#39;type&#39;]
                importance = currentNode.variablesNodz[varName][&#39;importance&#39;]
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{varName}&lt;/b&gt;: {str(currData)}&#34;
                htmloutputadded=True
            
            if not htmloutputadded:
                displayHTMLtext += f&#34;&lt;br&gt;None&#34;
        elif nodeType == &#34;changeStagePos&#34;:
            #Find the chosen stage and corresponding set movement (relative only for now)
            for key in dialog.RelStageInfo():
                if key[0] == &#39;__chosenRelStage__&#39;:
                    chosenStage = key[1]
            for key in dialog.RelStageInfo():
                if key[0] == chosenStage:
                    setMovement = key[1]
            #Set the displayHTML text:
            try:
                displayHTMLtext = &#34;&lt;b&gt;Relative&lt;/b&gt; movement of stage &lt;b&gt;&#34;+chosenStage+&#34;&lt;/b&gt; by &lt;b&gt;&#34;+str(setMovement)+&#34;&lt;/b&gt; units&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#34;caseSwitch&#34;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.caseSwitchInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = &#34;Perform a case/switch logic based on variable &lt;b&gt;&#34;+self.limitTextLength(values[&#39;Var&#39;][1])+&#34;&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;stickyNote&#39;:
            displayHTMLtext = f&#34;{currentNode.stickyNoteInfo}&#34;
        elif nodeType == &#39;slackReport&#39;:
            displayHTMLtext = f&#34;{currentNode.slackReportInfo}&#34;
        elif nodeType == &#34;__InitRequireUserDoubleClick__&#34;:
            displayHTMLtext = &#34;&lt;font color=&#39;#a00000&#39;&gt;Double-click this node to initialize it correctly.&lt;/font&gt;&#34;
        #And update the display
        currentNode.updateDisplayText(displayHTMLtext)
        return displayHTMLtext

    def getDevicesOfDeviceType(self,devicetype):
        &#34;&#34;&#34;
        Find all devices that have a specific devicetype.
        
        Args:
            devicetype (str): The type of device to search for. Refer to https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html for all devicetypes.
        
        Returns:
            list: A list of devices that match the specified devicetype.
        &#34;&#34;&#34;
        
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        #Get devices
        devices = self.shared_data.core.get_loaded_devices() #type:ignore
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.shared_data.core.get_device_type(device).to_string() == devicetype: #type:ignore
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType

    def PlugOrSocketConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a plug or socket is connected.

        When a plug or socket is connected, this function is called. It will check if the destination
        node should be marked as &#39;started&#39; or &#39;finished&#39; based on the attributes connected.
        &#34;&#34;&#34;
        logging.debug(f&#34;plug/socket connected start: {srcNodeName}, {plugAttribute}, {dstNodeName}, {socketAttribute}&#34;)
    
    def PlugOrSocketDisconnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a plug or socket is disconnected.

        When a plug or socket is disconnected, this function is called. It will disconnect
        the finished event of the source node from the &#39;we finished one of the prerequisites&#39; at the destination node.
        &#34;&#34;&#34;
        logging.debug(&#39;plugorsocketdisconnected&#39;)
        self.checkNodesOnErrors()
    
    def PlugConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a plug is connected.

        When a plug is connected, this function is called. It will check if the destination
        node should be marked as &#39;started&#39; based on the attributes connected.
        &#34;&#34;&#34;
        #Check if all are non-Nones:
        logging.debug(&#39;plug connected&#39;)
        self.checkNodesOnErrors()
        
    def SocketConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a socket is connected.

        When a socket is connected, this function is called. It does not do anything
        special, it only exists to keep the Node class happy by having a method that
        corresponds to the &#39;SocketConnected&#39; signal from the FlowChart.
        &#34;&#34;&#34;
        #Only one specific use-case at the moment:
        #If a connection is made between any node N to an analysisMeasurement node, and if there is at least one acquisition node linked at or downstream of N, and if the input of the analysisMeasurement is not already defined, and if the input is actually an image, fill the input data of the analysisMeasurement node to be the data of this acquisition node.
        
        
        #Possibly later, for any other nodes, set the &#39;input&#39; of the right node to the &#39;default&#39; of the left node, if typing accomodates.
        
        #TODO
        #First, we need to create some function to look at the downstream-connected nodes of some node - this needs to be a rather proper function.
        
        if &#39;analysisMeasurement_&#39; in dstNodeName or &#39;analysisMeasurementDEBUG_&#39; in dstNodeName:
            srcNode = nodz_utils.findNodeByName(self,srcNodeName)
            dstNode = nodz_utils.findNodeByName(self,dstNodeName)
            
            downstreamConnections = nodz_utils.findConnectedToNode(self.evaluateGraph(),dstNodeName,[],upstream=False,downstream=True) 
            #Note: first entry is always closest to node.
            #So we check if there is at least one acquisition node downstream of the dstNode:
            shortestConnectedAcquisition = None
            for connection in downstreamConnections:
                if &#39;acquisition_&#39; in connection:
                    shortestConnectedAcquisition = nodz_utils.findNodeByName(self,connection)
                    break
            
            if shortestConnectedAcquisition is not None:
                for function in dstNode.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;]: #type:ignore
                    inputOfFunction = utils.inputFromFunction(function[1])[0][0]
                    
                    lineEditName = &#39;LineEdit#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                    lineEditVarName = &#39;LineEditVariable#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                    lineEditAdvName = &#39;LineEditAdv#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                    if lineEditVarName in dstNode.scoring_analysis_currentData: #type:ignore
                        if dstNode.scoring_analysis_currentData[lineEditVarName] == &#39;&#39;: #type:ignore
                            import ndtiff
                            if ndtiff.NDTiffDataset in inputOfFunction[&#39;type&#39;]: #type:ignore
                                if ndtiff.NDTiffDataset in shortestConnectedAcquisition.variablesNodz[&#39;data&#39;][&#39;type&#39;]:
                                    dstNode.scoring_analysis_currentData[lineEditVarName] = &#39;data@&#39;+shortestConnectedAcquisition.name #type:ignore
                                
        
        
        #Check if all are non-Nones:
        logging.debug(&#39;socket connected&#39;)
        self.checkNodesOnErrors()
    
    def prepareGraph(self, methodName=&#39;Score&#39;):
        &#34;&#34;&#34;
        Function to prepare a graph based on the flowchart&#39;s connections.
        The resulting graph will have all nodes connected by edges based on the connections
        in the flowchart
        &#34;&#34;&#34;
        graphEval = self.evaluateGraph()
        if methodName == &#39;Score&#39;:
            scoreGraph = GladosGraph(self)
            scoreGraph.addRawGraphEval(graphEval)
            for node in scoreGraph.nodes:
                self.giveInfoOnNode(node)
            return scoreGraph
    
    def GraphToSignals(self):
        &#34;&#34;&#34;Idea: we evaluate the graph at this time point, connect all signals/emits:
        
        &#34;&#34;&#34;
        logging.debug(&#39;graphicing to signals&#39;)
        #Loop over all nodes:
        for node in self.nodes:
            node.n_connect_at_start = 0
            node.n_connect_at_start_finished = 0
            #Disconnect all signals, but only if there are any
            if node.customFinishedEmits is not None and len(node.customFinishedEmits.signals)&gt;0:
                signal = node.customFinishedEmits.signals[0] #type: ignore
                try:
                    #This disconnects all signals
                    signal.disconnect()
                except:
                    #Otherwise we FULLY reset the signal?
                    logging.debug(&#39;attempted to disconnect a disconnected signal&#39;)
                    # nodeType = self.nodeLookupName_withoutCounter(node.name)
                    # if len(self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]) &gt; 0:
                    #     node.customFinishedEmits = NodeSignalManager()
                    #     for attr in self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]:
                    #         node.customFinishedEmits.add_signal(attr) #type: ignore
                    # else:
                    #     node.customFinishedEmits = None
            
            if node.customDataEmits is not None and len(node.customDataEmits.signals)&gt;0:
                signal = node.customDataEmits.signals[0] #type: ignore
                try:
                    #This disconnects all signals
                    signal.disconnect()
                except:
                    logging.warning(&#39;attempted to disconnect a disconnected signal&#39;)
                    # nodeType = self.nodeLookupName_withoutCounter(node.name)
                    # if len(self.nodeInfo[nodeType][&#39;dataAttributes&#39;]) &gt; 0:
                    #     node.customDataEmits = NodeSignalManager()
                    #     for attr in self.nodeInfo[nodeType][&#39;dataAttributes&#39;]:
                    #         node.customDataEmits.add_signal(attr) #type: ignore
                    # else:
                    #     node.customDataEmits = None
            
        #Create all required signal connections
        currentgraph = self.evaluateGraph()
        for connection in currentgraph:
            plugAttribute = connection[0][connection[0].rfind(&#39;.&#39;)+1:]
            socketAttribute = connection[1][connection[1].rfind(&#39;.&#39;)+1:]
            srcNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
            dstNodeName = connection[1][:connection[1].rfind(&#39;.&#39;)]
            
            if self.nodeLookupName_withoutCounter(srcNodeName) is not None and self.nodeLookupName_withoutCounter(dstNodeName) is not None:
                typeOfFinishedAttributes_of_srcNode = self.nodeInfo[self.nodeLookupName_withoutCounter(srcNodeName)][&#39;finishedAttributes&#39;]
                typeOfDataAttributes_of_srcNode = self.nodeInfo[self.nodeLookupName_withoutCounter(srcNodeName)][&#39;dataAttributes&#39;]
                typeOfStartAttributes_of_dstNode = self.nodeInfo[self.nodeLookupName_withoutCounter(dstNodeName)][&#39;startAttributes&#39;]
            
                #Connect the finished event of the source node to the &#39;we finished one of the prerequisites&#39; at the destination node
                if plugAttribute in typeOfFinishedAttributes_of_srcNode and socketAttribute in typeOfStartAttributes_of_dstNode:
                    srcNode = self.findNodeByName(srcNodeName)
                    dstNode = self.findNodeByName(dstNodeName)
                    #The destination node needs one extra to be started...
                    dstNode.n_connect_at_start += 1 #type: ignore
                    
                    #And the finished event of the source node is connected to the &#39;we finished one of the prerequisites&#39; at the destination node
                    srcNode.customFinishedEmits.signals[0].connect(dstNode.oneConnectionAtStartIsFinished) #type: ignore
                    
                    logging.debug(f&#34;connected Finish {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
                #Same for data
                elif plugAttribute in typeOfDataAttributes_of_srcNode and socketAttribute in typeOfStartAttributes_of_dstNode:
                    srcNode = self.findNodeByName(srcNodeName)
                    dstNode = self.findNodeByName(dstNodeName)
                    #The destination node needs one extra to be started...
                    dstNode.n_connect_at_start += 1 #type: ignore
                    
                    #And the finished event of the source node is connected to the &#39;we gave data&#39; at the destination node
                    srcNode.customDataEmits.signals[0].connect(dstNode.oneConnectionAtStartProvidesData) #type: ignore
                    logging.debug(f&#34;connected Data {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
                else:
                    logging.warning(f&#34;not connected {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
    
    def getNodz(self):
        &#34;&#34;&#34;
        Return the current instance of the class.
        
        Returns:
            object: The current instance of the class.
        &#34;&#34;&#34;
        return self
    
    def updateCoreVariables(self):
        &#34;&#34;&#34;
        
        Idea, get information like this:
        self.coreVariables is initialised like {}
        
        self.coreVariables[&#39;TrialGlobalVariable&#39;]={}
        self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;type&#39;] = str
        self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;data&#39;] = &#39;test&#39;
        self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        
        &#34;&#34;&#34;
        allXYstages = utils.getCoreDevicesOfDeviceType(self.core,&#39;XYStageDevice&#39;)
        all1Dstages = utils.getCoreDevicesOfDeviceType(self.core,&#39;StageDevice&#39;)
        
        #Core variables to store:
        #Stage positions, all stages
        for stage in allXYstages:
            xypos = self.core.get_xy_stage_position(stage) #type:ignore
            self.createSingleCoreVar(stage+&#39;_current_pos&#39;,[xypos.x,xypos.y],[list,np.ndarray]) #type:ignore
        
        for stage in all1Dstages:
            pos = self.core.get_position(stage) #type:ignore
            self.createSingleCoreVar(stage+&#39;_current_pos&#39;,[pos],[list,np.ndarray]) #type:ignore
        
        #Config values, all configs
        allConfigs = self.core.get_available_config_groups()
        if allConfigs != None:
            nrconfiggroups = allConfigs.size()
            for config_id in range(nrconfiggroups):
                configInfo = ConfigInfo(self.core,config_id)
                configName = configInfo.configGroupName()
                configValue = configInfo.getStorableValue()
                try:
                    typev = [type(configValue)]
                except:
                    typev = [str]
                self.createSingleCoreVar(&#39;config_&#39;+configName,configValue,typev) #type:ignore
            
        #Pixel size, ROI size
        self.createSingleCoreVar(&#39;Pixel_size_um&#39;,self.core.get_pixel_size_um(),[float]) #type:ignore
        self.createSingleCoreVar(&#39;ROI_size&#39;,[self.core.get_roi().width,self.core.get_roi().height],[list,np.ndarray]) #type:ignore
    
    def createSingleCoreVar(self,name,data,type,importance=&#39;Informative&#39;):
        self.coreVariables[name] = {} 
        self.coreVariables[name][&#39;type&#39;] = type 
        self.coreVariables[name][&#39;data&#39;] = data 
        self.coreVariables[name][&#39;importance&#39;] = importance 
    
    def cleanupNodeList(self):
        #Ensure that self.nodes accurately reflects the nodes on the screen.
        nodeNamesOnScreen = []
        for node in self.scene().nodes:
            nodeNamesOnScreen = nodeNamesOnScreen +[node]
        
        for node in self.nodes:
            if node.name not in nodeNamesOnScreen:
                self.nodes.remove(node)
    
    def checkNodesOnErrors(self):
        #Idea: check all nodes for errors, alongside unconnected nodes. If so, update the warning. If not, reset the warning to none.
        
        if not self.shared_data.loadingOngoing:
            #Check that all nodes have connections where required.
            #Effectively, this means that all nodes should have a downstream connector
            self.cleanupNodeList()
            
            for node in self.nodes:
                #Init all nodes with no error:
                node.errorInfo = &#39;&#39;
                
                #check fo downstream connections
                downstreamNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[],upstream=False,downstream=True)
                if len(downstreamNodes) == 0:
                    #Check if it requires one...
                    if len(node.sockets) &gt; 0:
                        node.errorInfo = &#39;No downstream connections found.&#39;
            
            utils.updateAutonousErrorWarningInfo(self.shared_data)
        
        # self.shared_data.warningErrorInfoInfo[&#39;Errors&#39;] = totalNodeErrorMessage
    
    #endregion
    
    #region NodzFlowChart Saving Loading
    def storeGraphJSON(self):
        &#34;&#34;&#34;
        Save the current graph to a JSON file.

        This function saves the current graph to a JSON file, which can be loaded later using `loadPickle()`.
        &#34;&#34;&#34;
        filename, _ = QFileDialog.getSaveFileName(self, &#39;Save file&#39;, &#39;&#39;, &#39;JSON files (*.json)&#39;)
        if filename:
            if not filename.endswith(&#39;.json&#39;):
                filename += &#39;.json&#39;
            with open(filename, &#39;wb&#39;) as f:
                self.saveGraph(filename)
    
    def loadGraphJSON(self):
        &#34;&#34;&#34;
        Load the graph from a JSON file.

        This function loads the graph from a JSON file created using `storeGraphJSON()`.
        &#34;&#34;&#34;        
        filename, _ = QFileDialog.getOpenFileName(self, &#39;Open file&#39;, &#39;&#39;, &#39;JSON files (*.json)&#39;)
        if filename:
            try:
                #Fully clear graph and delete all nodes from memory:
                self.clearGraph()
                self.nodes = []
                #Set all counters to 0:
                for nodeType in self.nodeInfo:
                    if nodeType[:2] != &#39;__&#39;: #Ignore internal/special node info (&#39;__init__&#39; etc)
                        self.nodeInfo[nodeType][&#39;NodeCounter&#39;] = 0
                        self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] = 0
                #Load the graph
                with open(filename, &#39;rb&#39;) as f:
                    self.loadGraph_KM(filename)
                
                #Update warnings/info/errors:
                self.shared_data.warningErrorInfoInfo[&#34;Info&#34;][&#39;Other&#39;] = [&#34;Loaded &#34;+filename]
                # utils.updateAutonousErrorWarningInfo(self.shared_data)
            except:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText(&#34;Could not load file: &#34; + filename)
                msg.setWindowTitle(&#34;Warning&#34;)
                msg.setStandardButtons(QMessageBox.Ok)
                msg.exec_()
    #endregion
    
    #region NodzFlowChart Node-specific
    def update_scoring_end(self,currentNode,dialogLineEdits):
        &#34;&#34;&#34;
        Update the &#34;scoring end&#34; current node with new dialog line edits.
        
        Args:
            currentNode: The current node to update.
            dialogLineEdits: The new sockets of the current node.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        currentNode.scoring_end_currentData[&#39;Variables&#39;] = dialogLineEdits #type: ignore
        
        #the dialogLineEdits should be the new sockets of the current node. However, if a plug with the name already exists, it shouldn&#39;t be changed.
        import time
        sleepTime = 0.02
        for _ in range(3): #Just repeat everything 3 times and hope it solves itself
            self.update()
            time.sleep(sleepTime)
            current_sockets = [item[0] for item in list(currentNode.sockets.items())]
            if dialogLineEdits != current_sockets:
                
                for socket_id in reversed(range(len(currentNode.attrs))):
                    socket = currentNode.attrs[socket_id]
                    #We check if the socket is in dialogLineEdits:
                    if socket not in dialogLineEdits and socket in current_sockets:
                        #If it isn&#39;t, we just delete it:
                        self.deleteAttribute(currentNode,socket_id)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                
                #Check which are different (index-wise) between dialogLineEdits and current_sockets:
                diff_indexes = []
                same_indexes = []
                for i in range(min(len(dialogLineEdits),len(current_sockets))):
                    if dialogLineEdits[i] != current_sockets[i]:
                        diff_indexes.append(i)
                    else:
                        same_indexes.append(i)
                #Also append indexes if dialogLineEdits is longer than current_sockets:
                if len(dialogLineEdits) &gt; len(current_sockets):
                    for i in range(len(current_sockets),len(dialogLineEdits)):
                        diff_indexes.append(i)
                
                offset = 100
                #Then we create new sockets or move existing sockets, only for those that have a different pos
                for socket_new in ([dialogLineEdits[i] for i in diff_indexes]):
                    pos_in_dialogLineEdits = dialogLineEdits.index(socket_new)
                    if socket_new not in currentNode.sockets:
                        self.createAttribute(currentNode, name=socket_new, index=pos_in_dialogLineEdits+offset, preset=&#39;attr_default&#39;, plug=False, socket=True, dataType=None, socketMaxConnections=1)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                    else: #Else we move it from some other location to where we want it
                        #Find this socket in currentNode.sockets.items():
                        socketFull = list(currentNode.sockets.items())
                        pos_in_node_info = [socket_id for socket_id in range(len(socketFull)) if socketFull[socket_id][0] == socket_new][0]
                        old_pos = socketFull[pos_in_node_info][1].index
                        #Physically move it
                        self.editAttribute(currentNode,old_pos,newName = None, newIndex=pos_in_dialogLineEdits+offset)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
        
        #We also need to add these attributes to the nodes startAttributes in self.nodeInfo:
        self.nodeInfo[self.nodeLookupName_withoutCounter(currentNode.name)][&#39;startAttributes&#39;] = dialogLineEdits
    
    def update_plugs_fromDialog(self,currentNode,dialogLineEdits):
        &#34;&#34;&#34;
        Update the &#34;scoring end&#34; current node with new dialog line edits.
        
        Args:
            currentNode: The current node to update.
            dialogLineEdits: The new sockets of the current node.
        
        Returns:
            None
        &#34;&#34;&#34;
                
        #the dialogLineEdits should be the new plugs of the current node. However, if a plug with the name already exists, it shouldn&#39;t be changed.
        import time
        sleepTime = 0.02
        for _ in range(3): #Just repeat everything 3 times and hope it solves itself
            self.update()
            time.sleep(sleepTime)
            current_plugs = [item[0] for item in list(currentNode.plugs.items())]
            if dialogLineEdits != current_plugs:
                
                for plug_id in reversed(range(len(currentNode.attrs))):
                    plug = currentNode.attrs[plug_id]
                    #We check if the plug is in dialogLineEdits:
                    if plug not in dialogLineEdits and plug in current_plugs:
                        logging.debug(plug_id)
                        #If it isn&#39;t, we just delete it:
                        self.deleteAttribute(currentNode,plug_id)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                
                #Check which are different (index-wise) between dialogLineEdits and current_plugs:
                diff_indexes = []
                same_indexes = []
                for i in range(min(len(dialogLineEdits),len(current_plugs))):
                    if dialogLineEdits[i] != current_plugs[i]:
                        diff_indexes.append(i)
                    else:
                        same_indexes.append(i)
                #Also append indexes if dialogLineEdits is longer than current_plugs:
                if len(dialogLineEdits) &gt; len(current_plugs):
                    for i in range(len(current_plugs),len(dialogLineEdits)):
                        diff_indexes.append(i)
                
                offset = 100
                #Then we create new plugs or move existing plugs, only for those that have a different pos
                for plug_new in ([dialogLineEdits[i] for i in diff_indexes]):
                    pos_in_dialogLineEdits = dialogLineEdits.index(plug_new)
                    if plug_new not in currentNode.plugs:
                        self.createAttribute(currentNode, name=plug_new, index=pos_in_dialogLineEdits+offset, preset=&#39;attr_default&#39;, plug=True, socket=False, dataType=None)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                    else: #Else we move it from some other location to where we want it
                        #Find this plug in currentNode.plugs.items():
                        plugFull = list(currentNode.plugs.items())
                        pos_in_node_info = [plug_id for plug_id in range(len(plugFull)) if plugFull[plug_id][0] == plug_new][0]
                        old_pos = plugFull[pos_in_node_info][1].index
                        #Physically move it
                        self.editAttribute(currentNode,old_pos,newName = None, newIndex=pos_in_dialogLineEdits+offset)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
        
        #We also need to add these attributes to the nodes startAttributes in self.nodeInfo:
        self.nodeInfo[self.nodeLookupName_withoutCounter(currentNode.name)][&#39;finishedAttributes&#39;] = dialogLineEdits
    
    def changeConfigStorageInNodz(self,currentNode,configNameSet):
        &#34;&#34;&#34;
        Function to change the config storage of a nodz node from the double-click popup to the MMconfigInfo class stored inside the node.

        This is useful when storing and loading configurations for a node, as the MMconfigInfo class can be serialized and deserialized.

        Args:
            currentNode (nodz.Node): The node to change the config storage of.
            configNameSet (set of tuples): A set of tuples in the form (configName, selectedValue)
        &#34;&#34;&#34;
        #Changes a config from a double-click config popup to the MMconfig stored inside the nodz node itself (i.e. storing/loading of configs)
        
        #Add all of them to the MMconfigInfo.config_string_storage:
        currentNode.MMconfigInfo.config_string_storage=[]
        for singleConfig in configNameSet:
            currentNode.MMconfigInfo.config_string_storage.append([singleConfig[0],singleConfig[1]])
        return
    
    def changeRelStageStorageInNodz(self,currentNode,relstageinfo):
        
        currentNode.MMconfigInfo.relstage_string_storage=relstageinfo
    
    def AnalysisNode_DEBUG_started(self,node):
        &#34;&#34;&#34;
        Perform the Analysis set in a node
        
        Args:
            node: The node for which calls the analysis
        
        Returns:
            None
        &#34;&#34;&#34;
        #Find the node that is connected (i.e. downstream) to this
        connectedNode = None
        for connection in self.evaluateGraph():
            if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == &#39;Analysis start&#39;:
                if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                    connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                    connectedNode = self.findNodeByName(connectedNodeName)
        if connectedNode is None:
            logging.error(&#39;Error! No connected node found for scoring analysis&#39;)
            return
        
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        #Figure out which function is selected in the scoring_analysis node
        selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
        #Figure out the belonging evaluation-text
        evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
        
        #And evaluate the custom function with custom parameters
        output = eval(evalText) #type:ignore
        
        #Display final output to the user for now
        logging.info(f&#34;Final output from node {node.name}: {output}&#34;)
        
        #Set the status of the nodz-coupled vis and real-time to finished:
        #Look at the &#39;Visual&#39; bottom attribute and visualise if needed
        visualAttr = node.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            visual_connected_node_name = visualAttr.connections[0].socketNode
            for nodeV in self.nodes:
                if nodeV.name == visual_connected_node_name:
                    visual_connected_node = nodeV
                    
                    selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
                    visualEvalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;(output,napariLayer)&#39;,&#39;self.shared_data.core&#39;,nodzInfo=self)
                    visualEvalText = visualEvalText.replace(selectedFunction,f&#39;{selectedFunction}_visualise&#39;) #type:ignore
                    
                    chosenLayerType = &#39;points&#39;
                    
                    layerTypeInfo = [
                        [&#39;Analysis_Measurements&#39;,&#39;points&#39;],
                        [&#39;Analysis_Shapes&#39;,&#39;shapes&#39;],
                        [&#39;Analysis_Images&#39;,&#39;image&#39;],
                    ]
                    
                    folderName = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))+os.sep+&#39;AutonomousMicroscopy&#39;+os.sep
                    
                    for layerType in layerTypeInfo:
                        for root, dirs, files in os.walk(folderName+layerType[0]):
                            for file in files:
                                if selectedFunction.split(&#39;.&#39;)[0] in file: #type:ignore
                                    if file.endswith(&#34;.py&#34;):
                                        with open(os.path.join(root, file), &#39;r&#39;) as f:
                                            filecontent = f.read()
                                        if selectedFunction.split(&#39;.&#39;)[1]+&#39;(&#39; in filecontent: #type:ignore
                                            chosenLayerType = layerType[1]
                                            break #to avoid searching in other files for this function
                    
                    
                    layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                    
                    #If a layer with this name already exists, simply remove it:
                    for layer in self.shared_data.napariViewer.layers: #type:ignore
                        if layer.name == layerName:
                            self.shared_data.napariViewer.layers.remove(layer) #type:ignore
                            
                    cmap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                    if chosenLayerType == &#39;points&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_points(
                            data=None,
                            text=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;shapes&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_shapes(
                            data=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;image&#39;:
                        logging.debug(&#39;creating new image layer&#39;)
                        viewer = self.shared_data.napariViewer #type:ignore
                        im = np.random.random((30, 30))
                        napariLayer = viewer.add_image(
                            data=im,
                            name=layerName,
                            colormap = cmap
                        )
                    
                    visualOutput = eval(visualEvalText)
                    
                    visual_connected_node.status = &#39;finished&#39;
            
            
        node.scoring_analysis_currentData[&#39;__output__&#39;] = output
        
        #Store the output as NodzVariables
        utils.analysis_outputs_store_as_variableNodz(node)
        
        
        #Finish up
        self.finishedEmits(node)
    
    def AnalysisNode_started(self,node):
        &#34;&#34;&#34;
        Perform the Analysis set in a node
        
        Args:
            node: The node for which calls the analysis
        
        Returns:
            None
        &#34;&#34;&#34;
        #Find the node that is connected (i.e. downstream) to this
        connectedNode = None
        for connection in self.evaluateGraph():
            if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == &#39;Analysis start&#39;:
                if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                    connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                    connectedNode = self.findNodeByName(connectedNodeName)
        if connectedNode is None:
            logging.error(&#39;Error! No connected node found for scoring analysis&#39;)
            return
        
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        #Figure out which function is selected in the scoring_analysis node
        selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
        #Figure out the belonging evaluation-text
        evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
        
        
        worker = generalNodzCallActionWorker(nodzType=&#39;AnalysisNode&#39;,args={&#34;evalText&#34;:evalText, &#34;nodeDict&#34;:nodeDict, &#34;node&#34;:node, &#34;core&#34;: self.core, &#34;shared_data&#34;: self.shared_data})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.analysisNode_finished(node))
        #Star the worker
        self.thread_pool.start(worker)
        
    def analysisNode_finished(self,node):
        #Set the status of the nodz-coupled vis and real-time to finished:
        #Look at the &#39;Visual&#39; bottom attribute and visualise if needed
        output = node.output
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        visualAttr = node.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            visual_connected_node_name = visualAttr.connections[0].socketNode
            for nodeV in self.nodes:
                if nodeV.name == visual_connected_node_name:
                    visual_connected_node = nodeV
                    
                    selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
                    visualEvalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;(output,napariLayer)&#39;,&#39;self.shared_data.core&#39;,nodzInfo=self)
                    visualEvalText = visualEvalText.replace(selectedFunction,f&#39;{selectedFunction}_visualise&#39;) #type:ignore
                    
                    chosenLayerType = &#39;points&#39;
                    
                    layerTypeInfo = [
                        [&#39;Analysis_Measurements&#39;,&#39;points&#39;],
                        [&#39;Analysis_Shapes&#39;,&#39;shapes&#39;],
                        [&#39;Analysis_Images&#39;,&#39;image&#39;],
                    ]
                    
                    folderName = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))+os.sep+&#39;AutonomousMicroscopy&#39;+os.sep
                    
                    for layerType in layerTypeInfo:
                        for root, dirs, files in os.walk(folderName+layerType[0]):
                            for file in files:
                                if selectedFunction.split(&#39;.&#39;)[0] in file: #type:ignore
                                    if file.endswith(&#34;.py&#34;):
                                        with open(os.path.join(root, file), &#39;r&#39;) as f:
                                            filecontent = f.read()
                                        if selectedFunction.split(&#39;.&#39;)[1]+&#39;(&#39; in filecontent: #type:ignore
                                            chosenLayerType = layerType[1]
                                            break #to avoid searching in other files for this function
                    
                    
                    layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                    
                    #If a layer with this name already exists, simply remove it:
                    for layer in self.shared_data.napariViewer.layers: #type:ignore
                        if layer.name == layerName:
                            self.shared_data.napariViewer.layers.remove(layer) #type:ignore
                            
                    cmap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                    if chosenLayerType == &#39;points&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_points(
                            data=None,
                            text=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;shapes&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_shapes(
                            data=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;image&#39;:
                        logging.debug(&#39;creating new image layer&#39;)
                        viewer = self.shared_data.napariViewer #type:ignore
                        im = np.random.random((30, 30))
                        napariLayer = viewer.add_image(
                            data=im,
                            name=layerName,
                            colormap = cmap
                        )
                    
                    visualOutput = eval(visualEvalText)
                    
                    visual_connected_node.status = &#39;finished&#39;
        
        
        node.scoring_analysis_currentData[&#39;__output__&#39;] = node.output
        
        #Store the output as NodzVariables
        utils.analysis_outputs_store_as_variableNodz(node)
        
        
        #Finish up
        self.finishedEmits(node)
    
    def CustomFunctionNode_started(self,node):
        &#34;&#34;&#34;
        Perform the Custom Function set in a node
        
        Args:
            node: The node for which calls the analysis
        
        Returns:
            None
        &#34;&#34;&#34;
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        #Figure out which function is selected in the customFunction node
        selectedFunction = utils.functionNameFromDisplayName(node.customFunction_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.customFunction_currentData[&#39;__displayNameFunctionNameMap__&#39;])
        #Figure out the belonging evaluation-text
        evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.customFunction_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
        
        worker = generalNodzCallActionWorker(nodzType=&#39;CustomFunctionNode&#39;,args={&#34;evalText&#34;:evalText, &#34;nodeDict&#34;:nodeDict, &#34;node&#34;:node, &#34;core&#34;: self.core, &#34;shared_data&#34;: self.shared_data})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.CustomFunctionNode_finished(node))
        #Star the worker
        self.thread_pool.start(worker)
        
        # #And evaluate the custom function with custom parameters
        # output = eval(evalText) #type:ignore
        
        # node.customFunction_currentData[&#39;__output__&#39;] = output
        
        # #Store the output as NodzVariables
        # # utils.analysis_outputs_store_as_variableNodz(node)
        
        # #Finish up
        # self.finishedEmits(node)
    
    def CustomFunctionNode_finished(self,node):
        
        output = node.output
        node.customFunction_currentData[&#39;__output__&#39;] = node.output
        
        #Store the output as NodzVariables #TODO
        utils.customFunction_outputs_store_as_variableNodz(node)
        
        #Finish up
        self.finishedEmits(node)
        
        
    def MMstageChangeRan(self,node):
        #TODO: Implement this :)
        &#34;&#34;&#34;
        Change the stage of the microscope based on the node info
        
        Args:
            node: The MM node to change the stage for.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        for stor in node.MMconfigInfo.relstage_string_storage:
            if stor[0] == &#39;__chosenRelStage__&#39;:
                stageToMove = stor[1]
        
        for stor in node.MMconfigInfo.relstage_string_storage:
            if stor[0] == stageToMove:
                distToMove = float(stor[1])
        
        self.core.set_relative_position(stageToMove,distToMove)
        
        self.finishedEmits(node)
        
    def MMconfigChangeRan(self,node):
        &#34;&#34;&#34;
        Handle the configuration change event for a node.

        This function handles the configuration change event for a node, by
        changing the desired configs in the Core.

        Args:
            node (nodz.Node): The node that has triggered the event.
        &#34;&#34;&#34;
        logging.debug(&#39;MMconfigChangeRan&#39;)
        
        
        #Create the worker
        worker = generalNodzCallActionWorker(nodzType=&#39;MMconfigChangeRan&#39;,args={&#34;config_string_storage&#34;:node.MMconfigInfo.config_string_storage, &#34;MMconfig&#34;:node.MMconfigInfo, &#34;core&#34;: self.core})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.finishedEmits(node))
        #Star the worker
        self.thread_pool.start(worker)
        
        # self.finishedEmits(node)

    def acquiringStart(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Acquiring Start node in the Flowchart.

        This function signals to the rest of the flowchart that it&#39;s time to start
        the Acquiring routine.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        if self.preventAcq == False:
            logging.debug(&#39;Starting the acquiring routine!&#39;)
            
            #Set all connected nodes to idle
            connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
            for connectedNode in connectedNodes:
                for nodeC in self.nodes:
                    if nodeC.name == connectedNode:
                        nodeC.status=&#39;idle&#39;
            self.update()
                        
            self.GraphToSignals()
            
            self.finishedEmits(node)
        else:
            logging.warning(&#39;Would have started acquiring, but was prevented!&#39;)
    
    def acquiringEnd(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Acquiring End node in the Flowchart.

        This function signals to the rest of the flowchart that the Acquiring routine is ended

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        #This finishedEmit needs to be at the start of this function :) 
        self.finishedEmits(node)
        logging.debug(&#34;End Acquiring----------------------------------------------------------&#34;)
        if self.fullRunOngoing:
            #if there are more positions to look at...
            if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                logging.info(f&#39;Just did position {self.fullRunCurrentPos+1}/{self.fullRunPositions[&#34;nrPositions&#34;]}, continuing!--------------------------------------------------------&#39;)
                self.fullRunCurrentPos +=1
                #And start a new score/acq at a new pos:
                self.startNewScoreAcqAtPos()
            else:
                logging.info(f&#39;ALLDONE Just did position {self.fullRunCurrentPos+1}/{self.fullRunPositions[&#34;nrPositions&#34;]}, continuing!----------------------------------------------------------&#39;)
                self.singleRunOngoing = False
        else:
            logging.info(&#34;ACQUIRING FULL RUN IS NOT ONGOING--------------------------------------------&#34;)
        logging.debug(&#34;End Acquiring2------------------------------------------------------------&#34;)
        
    
    def initStart(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Initialisation Start node in the Flowchart.

        This function signals to the rest of the flowchart that it&#39;s time to start
        the init routine.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        logging.debug(&#39;Starting the initialisation routine!&#39;)
        
        #Set all connected nodes to idle
        connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
        for connectedNode in connectedNodes:
            for nodeC in self.nodes:
                if nodeC.name == connectedNode:
                    nodeC.status=&#39;idle&#39;
        
        self.set_readable_text_after_dialogChange(node,&#39;&#39;,&#39;initStart&#39;)
        
        self.GraphToSignals()
        #Effectively, only finishes the initStart node
        self.finishedEmits(node)
    
    def initEnd(self,node):
    
        logging.debug(&#39;Initialisation finished fully!&#39;)
        node.status = &#39;finished&#39;
        #Find the acqStart node:
        scoringStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for nodeF in flowChart.nodes:
                if &#39;scoringStart_&#39; in nodeF.name:
                    scoringStartNode = nodeF
        
        #Run the scoring_start routine:
        if scoringStartNode is not None:
            if self.fullRunOngoing:
                logging.info(&#39;Starting full run routine!&#39;)
                self.startNewScoreAcqAtPos()
            else:
                logging.info(&#39;Starting single scoring only!&#39;)
                self.scoringStart(scoringStartNode)
        else:
            logging.error(&#39;Could not find scoringStartNode node in flowchart&#39;)
    
    def scoringStart(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Scoring Start node in the Flowchart.

        This function signals to the rest of the flowchart that it&#39;s time to start
        the scoring routine.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        
        if self.preventScoring == False:
            logging.debug(&#39;Starting the score routine!&#39;)
            
            #Set all connected nodes to idle
            connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
            for connectedNode in connectedNodes:
                for nodeC in self.nodes:
                    if nodeC.name == connectedNode:
                        nodeC.status=&#39;idle&#39;
            
            #Get all connections:
            allConnections = []
            for connectedNode in connectedNodes:
                for nodeC in self.nodes:
                    if nodeC.name == connectedNode:
                        for attr in nodeC.sockets:
                            connections = nodeC.sockets[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
                        for attr in nodeC.plugs:
                            connections = nodeC.plugs[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
                        for attr in nodeC.topAttrs:
                            connections = nodeC.topAttrs[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
                        for attr in nodeC.bottomAttrs:
                            connections = nodeC.bottomAttrs[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
            
            for connection in allConnections:
                connection._pen.setColor(QColor(*self.config[&#39;connection_color&#39;]))
                connection.updatePath()
            
            self.set_readable_text_after_dialogChange(node,&#39;&#39;,&#39;scoreStart&#39;)
            
            self.GraphToSignals()
            
            self.finishedEmits(node)
        else:
            logging.warning(&#39;Actively blocked scoring due to self.preventScoring!&#39;)
            
    def scoringEnd(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Scoring End node in the Flowchart.

        This function signals to the rest of the flowchart that the scoring routine is finished.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        self.finishedEmits(node)
        #Find the nodes that are connected downstream of this:
        try:
            data = {}
            attrs = []
            for attr in node.attrs:
                connectedNode = None
                for connection in self.evaluateGraph():
                    if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == attr:
                        if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                            connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                            connectedNode = self.findNodeByName(connectedNodeName)
            
                        data[attr] = connectedNode.scoring_analysis_currentData[&#39;__output__&#39;] #type:ignore
                        attrs.append(attr)
                        logging.debug(f&#34;Data found for {attr}: {data[attr]}&#34;)
        except:
            pass
        
        try:
            testPassed = self.decisionWidget.testCurrentDecision()
            testPassedText = &#39;Test is Passed&#39; if testPassed else &#39;Test is Not Passed&#39;
            # readableText = self.set_readable_text_after_dialogChange(node,[attrs,data,testPassedText],&#39;scoreEnd&#39;)
            
            logging.info(&#39;Scoring finished fully!&#39;)
            if testPassed:
                logging.info(&#34;Test is... Passed!&#34;)
                
                #Find the acqStart node:
                acqStartNode = None
                flowChart = self
                if len(flowChart.nodes) &gt; 0:
                    #Find the scoringEnd node in flowChart:
                    for nodeF in flowChart.nodes:
                        if &#39;acqStart_&#39; in nodeF.name:
                            acqStartNode = nodeF
                
                #Run the scoring_start routine:
                if acqStartNode is not None:
                    logging.info(&#39;Starting acquisition routine!&#39;)
                    self.acquiringStart(acqStartNode)
                else:
                    logging.error(&#39;Could not find acqStart node in flowchart&#39;)
                
            elif not testPassed:
                logging.info(&#34;Test is... Not Passed!&#34;)
                #Go to next XY position
                if self.fullRunOngoing:
                    if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                        self.fullRunCurrentPos +=1
                        #And start a new score/acq at a new pos:
                        self.startNewScoreAcqAtPos()
                    else:
                        self.singleRunOngoing = False
                        logging.info(&#39;All done!&#39;)
            logging.info(&#39;----------------------&#39;)

        except:
            testPassed = False
            node.status = &#39;error&#39;
            testPassedText = &#39;Error when assessing test&#39;
            readableText = self.set_readable_text_after_dialogChange(node,[attrs,data,testPassedText],&#39;scoreEnd&#39;)
        
        
        #Find the reporting node(s)
        connectedNodes = nodz_utils.getConnectedNodes(node, &#39;bottomAttr&#39;)
        for node in connectedNodes:
            logging.debug(node.name)
            if &#39;reporting_&#39; in node.name:
                node.status = &#39;running&#39;
                if &#39;SLACK&#39; in self.shared_data.globalData: #type:ignore
                    if self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;] is not None and not len(self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;]) == 0: #type:ignore
                        slackReadableText = readableText
                        slackReadableText = slackReadableText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                        slackReadableText = &#34;New Score: \n&#34; + slackReadableText
                        self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].chat_postMessage(channel=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],text=slackReadableText) #type:ignore
                        node.status = &#39;finished&#39;
                    else:
                        node.status = &#39;error&#39;
                else:
                    node.status = &#39;error&#39;
        
        self.preventAcq = False
    
    def earlyScoringFail(self,node):
        #Sob asically it&#39;s the Scoring node, but hard-coded to fail.
        logging.info(&#34;Scoring early abandoned!&#34;)
        self.finishedEmits(node)
        node.status=&#39;finished&#39;
        #Go to next XY position
        if self.fullRunOngoing:
            if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                self.fullRunCurrentPos +=1
                #And start a new score/acq at a new pos:
                self.startNewScoreAcqAtPos()
            else:
                self.singleRunOngoing = False
                logging.info(&#39;All done!&#39;)
        
    
    def and_logicCallAction(self,node):
        &#34;&#34;&#34; 
        Runs when the and_logic gate is fully completed
        &#34;&#34;&#34;
        #Honestly just needs to run the next nodes
        self.finishedEmits(node)
    
    def timerCallAction(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Timer Call node in the Flowchart.

        This function waits for a specified amount of time before triggering the next node in the flowchart.

        Args:
            node (nodz.Node): The node that has triggered the event.
        Returns:
            None
        &#34;&#34;&#34;        
        #Get info
        vardata = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.timerInfo, node.flowChart)
        wait_time = float(vardata[&#39;wait_time&#39;][0])

        #Create the worker
        worker = generalNodzCallActionWorker(nodzType=&#39;Timer&#39;,args={&#34;wait_time&#34;:wait_time})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.finishedEmits(node))
        #Star the worker
        self.thread_pool.start(worker)
    
    def storeDataCallAction(self,node):
        
        &#34;&#34;&#34;
        This function is the action function for the storeData Call node in the Flowchart.

        This function stores data.

        Args:
            node (nodz.Node): The node that has triggered the event.
        &#34;&#34;&#34;
        
        #Extract Data
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.storeDataInfo,node.flowChart)
        
        #Get the store-data from a variable
        storeInfo = varInfo[&#39;item_to_store&#39;][0]
        storeLoc = varInfo[&#39;store_location&#39;][0]
        
        #Check if storeInfo is image-like:
        if isinstance(storeInfo, np.ndarray) and storeInfo.ndim &gt; 1:
            #Check if we want to store a tiff
            if storeLoc[-4:] == &#39;.tif&#39; or storeLoc[-5:] == &#39;.tiff&#39;:
                import tifffile
                tifffile.imsave(storeLoc,storeInfo)
                logging.debug(f&#39;Stored TIF image at {storeLoc}&#39;)
        
        self.finishedEmits(node)

    def changeGlobalVarCallAction(self,node):
        &#34;&#34;&#34;
        The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.
        
        Args:
            self: Refer to the class itself
            node: Identify which node triggered the event
        &#34;&#34;&#34;
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.changeGlobalVarInfo,node.flowChart)
        
        variable = varInfo[&#39;globalVarName&#39;][1]
        value = varInfo[&#39;globalVarValue&#39;][0]
        
        utils.nodz_setVariableToValue(variable,value,node.flowChart)
        
        
        self.finishedEmits(node)
    
    def newGlobalVarCallAction(self,node):
        &#34;&#34;&#34;
        The newGlobalVarCallAction function is the action function for the new global var Call node in the Flowchart.
        
        Args:
            self: Refer to the class itself
            node: Identify which node triggered the event
        &#34;&#34;&#34;
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.newGlobalVarInfo,node.flowChart)
        
        variable = varInfo[&#39;globalVarName&#39;][1]
        value = varInfo[&#39;globalVarValue&#39;][0]
        
        #Create the new global Variable
        if variable  in node.flowChart.globalVariables:
            #If it&#39;s already present, give a warning for now, but still set it.
            logging.warning(f&#39;New global variable {variable} defined with same name as already existing - overwriting it!&#39;)
            
        node.flowChart.globalVariables[variable] = {}
        node.flowChart.globalVariables[variable][&#39;data&#39;] = value
        #Try to find the type of the variable automatically, else just set it as str
        try:
            node.flowChart.globalVariables[variable][&#39;type&#39;] = [(type(eval(value)))]
        except: #This will effectively set it as a string.
            node.flowChart.globalVariables[variable][&#39;type&#39;] = [(type((value)))]
        node.flowChart.globalVariables[variable][&#39;importance&#39;] = &#39;informative&#39;
        import time
        node.flowChart.globalVariables[variable][&#39;lastUpdateTime&#39;] = time.time()
        
        
        self.finishedEmits(node)
    
    def ifStatementCallAction(self,node):
        &#34;&#34;&#34;
        The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.
        
        Args:
            self: Refer to the class itself
            node: Identify which node triggered the event
        &#34;&#34;&#34;
        
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.ifStatementInfo,node.flowChart)
        
        result = eval(str(varInfo[&#39;valueToCheck&#39;][0])+varInfo[&#39;comparator&#39;][0]+str(varInfo[&#39;valueCheckAgainst&#39;][0]))
        
        if result == True:
            graph = node.flowChart.evaluateGraph()
            for graphConnection in graph:
                if graphConnection[0] == node.name+&#39;.Succeed&#39;:
                    foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                    foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                    node.status=&#39;finished&#39;
                    foundNode.oneConnectionAtStartIsFinished()
                    break    
        elif result == False:
            graph = node.flowChart.evaluateGraph()
            for graphConnection in graph:
                if graphConnection[0] == node.name+&#39;.Fail&#39;:
                    foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                    foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                    node.status=&#39;finished&#39;
                    foundNode.oneConnectionAtStartIsFinished()
                    break    
    
    def runInlineScriptCallAction(self,node):
        scriptText = node.InlineScriptInfo
        
        core = shared_data.core
        #Go over each line of scriptText, broken by a \n:
        lineData = scriptText.split(&#39;\n&#39;)
        errored=False
        for line in lineData:
            if errored:
                break
            try:
                eval(line)
                logging.debug(f&#39;Ran commdand succesfully: {line}&#39;)
            except Exception as e:
                logging.error(f&#39;Error with line {line}: {e}. Script broken off&#39;)
                errored=True
        
        if errored==False:
            logging.debug(&#39;Fully ran custom script!&#39;)
        
        self.finishedEmits(node)
    
    def runCaseSwitchCallAction(self,node):
        &#34;&#34;&#34; 
        Call action to runa  case/switch statement.
        &#34;&#34;&#34;
        CurrentValueWantedVariable = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.caseSwitchInfo,node.flowChart)[&#39;Var&#39;][0]
        
        
        #Alright so emitting the signals doesn&#39;t work because they&#39;re all connected.
        #So, idea is to evaluate the graph, find the correct linked node, and start that one from here.
        correctPlugFound = False
        graph = node.flowChart.evaluateGraph()
        for graphConnection in graph:
            if correctPlugFound == False and graphConnection[0] == node.name+&#39;.&#39;+str(CurrentValueWantedVariable):
                foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                logging.debug(f&#34;Node {node.name} found a case/switch with value {CurrentValueWantedVariable} connected to node {foundNodeName}&#34;)
                foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                foundNode.oneConnectionAtStartIsFinished()
                correctPlugFound = True
                node.status=&#39;finished&#39;
                break
            
        #If none are found:
        if correctPlugFound == False:
            logging.warning(&#39;Case/Switch not found, using the Error&#39;)
            for graphConnection in graph:
                if graphConnection[0] == node.name+&#39;.Error&#39;:
                    foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                    foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                    foundNode.oneConnectionAtStartIsFinished()
                    node.status=&#39;finished&#39;
    
    def runslackReportCallAction(self,node):
        &#34;&#34;&#34;
        Call action to send a message to Slack
        &#34;&#34;&#34;
        node.status=&#39;finished&#39;
        try:
            readableText = utils.nodz_evaluateAdv(node.slackReportInfo,node.flowChart,skipEval=True)
            if readableText == None:
                readableText = node.slackReportInfo
            if &#39;SLACK-CLIENT&#39; in self.shared_data.globalData: #type:ignore
                if self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;] is not None and not len(self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;]) == 0: #type:ignore
                    slackReadableText = readableText
                    if not (&#34;&lt;img&gt;&#34; in node.slackReportInfo and &#34;&lt;/img&gt;&#34; in node.slackReportInfo):
                        slackReadableText = slackReadableText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                        self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].chat_postMessage(channel=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],text=slackReadableText) 
                    else: #we have an image!
                        import re
                        #Extract the text between img tags:
                        imgInfo = re.findall(&#39;&lt;img&gt;(.*?)&lt;/img&gt;&#39;,node.slackReportInfo)[0]
                        restText = re.sub(&#39;&lt;img&gt;(.*?)&lt;/img&gt;&#39;,&#39;&#39;,node.slackReportInfo)
                        restText = restText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                        restText = restText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                        restText = restText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                        restText = restText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                        restText = restText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                        
                        #remove the curly brackets in imgInfo:
                        imgInfo = imgInfo.replace(&#39;{&#39;,&#39;&#39;)
                        imgInfo = imgInfo.replace(&#39;}&#39;,&#39;&#39;)
                        
                        #Get the image
                        im = utils.nodz_evaluateVar(imgInfo,node.flowChart)
                        # Convert the ndarray to a PIL Image
                        from PIL import Image
                        image = Image.fromarray(im/65535*255)# Or convert to RGB
                        image = image.convert(&#34;RGB&#34;)
                        
                        #Store the im as a PNG in a temporary folder:
                        import tempfile
                        tempDir = tempfile.TemporaryDirectory()
                        tempFile = os.path.join(tempDir.name,&#39;slackImage.png&#39;)
                        
                        # Save the image as a PNG file
                        image.save(tempFile, &#34;PNG&#34;)
                        #Send the message with the read-tempFile
                        slack_image = self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].files_upload(
                            title=&#34;Glados Image&#34;,
                            channels=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],
                            content=open(tempFile, &#39;rb&#39;).read(),
                            initial_comment = restText,
                        )
        except Exception as e:
            logging.warning(f&#39;Slack gave an unexpected error: {e}&#39;)
                    
        self.finishedEmits(node)
    #endregion
    
    #region NodzFlowChart runs
    def fullAutonomousRunStart(self):
        &#34;&#34;&#34;
        Starts a full autonomous run - i.e. scoring and acquisition
        
        Args:
            self: The object instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.info(&#39;Starting a full run&#39;)
        self.preventAcq = False
        self.preventScoring = False
        
        #General idea: first check if there are no glaring errors (scoring, position)
        #then go to whatever start position based on the xy positions
        #then run scoring+acquisition there
        
            
        
        self.fullRunOngoing = True
        self.fullRunCurrentPos = 0
        self.fullRunPositions = self.scanningWidget.getPositionInfo()
        # self.startNewScoreAcqAtPos()
        
        #Find the init_start node:
        initStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;initStart_&#39; in node.name:
                    initStartNode = node
        
        #Run the init_start routine:
        if initStartNode is not None:
            self.initStart(initStartNode)
        else:
            logging.error(&#39;Could not find initStart node in flowchart&#39;)

    def startNewScoreAcqAtPos(self):
        &#34;&#34;&#34;
        Starts a new score acquisition at the current microscope position.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        import time
        positions = self.fullRunPositions
        pos = self.fullRunCurrentPos
        
        self.shared_data.warningErrorInfoInfo[&#39;Info&#39;][&#39;Other&#39;] = [f&#34;Autonomous run is ongoing! Currently at pos {str(pos+1)}/{str(positions[&#39;nrPositions&#39;])}  ({str(round(pos/positions[&#39;nrPositions&#39;]*100,2))}%)&#34;]
        
        logging.info(f&#39;Starting new score acq at position {pos} -------------------------------------------------------------------------------&#39;)
        
        #Set all stages correct
        for stage in positions[pos][&#39;STAGES&#39;]:
            if stage != &#39;&#39;:
                stagepos = positions[pos][stage]
                #Check if this stage is an XY stage device...
                #Since then we need to do something 2-dimensional
                if stage in self.getDevicesOfDeviceType(&#39;XYStageDevice&#39;):
                    logging.debug(f&#39;Moving stage {stage} to position {stagepos}&#39;)
                    self.shared_data.core.set_xy_position(stage,stagepos[0],stagepos[1]) #type:ignore
                    self.shared_data.core.wait_for_system() #type:ignore
                else:#else we can move a 1d stage:
                    logging.debug(f&#39;Moving stage {stage} to position {stagepos}&#39;)
                    self.shared_data.core.set_position(stage,stagepos[0]) #type:ignore
                    self.shared_data.core.wait_for_system() #type:ignore
        
        self.runScoring()
    
    def runInitOnly(self):
        &#34;&#34;&#34;
        Run ONLY the init process at the current position. Actively prevents scoring
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.preventScoring = True
        self.preventAcq = False
        
        #Find the scoring_start node:
        initStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;initStart_&#39; in node.name:
                    initStartNode = node
        
        #Run the scoring_start routine:
        if initStartNode is not None:
            self.initStart(initStartNode)
        else:
            logging.error(&#39;Could not find initStart node in flowchart&#39;)
            
    
    def runScoringOnly(self):
        &#34;&#34;&#34;
        Run ONLY the scoring process at the current position. Actively prevents acquisition
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.preventAcq = True
        self.preventScoring = False
        
        #Find the scoring_start node:
        scoreStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringStart_&#39; in node.name:
                    scoreStartNode = node
        
        #Run the scoring_start routine:
        if scoreStartNode is not None:
            self.scoringStart(scoreStartNode)
        else:
            logging.error(&#39;Could not find scoringStart node in flowchart&#39;)
    
    def runScoring(self):
        &#34;&#34;&#34;
        Runs the scoring process starting from the scoring_start node, without inhibiting acquisition later - i.e. the scoring before a possible acquisition
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.preventAcq = False
        self.preventScoring = False
        #Find the scoring_start node:
        scoreStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringStart_&#39; in node.name:
                    scoreStartNode = node
        
        
        
        #Run the scoring_start routine:
        if scoreStartNode is not None:
            self.scoringStart(scoreStartNode)
        else:
            logging.error(&#39;Could not find scoringStart node in flowchart&#39;)
    
    def runAcquiring(self):
        &#34;&#34;&#34;
        Run the acquiring process at this microscopy XY position
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.info(&#34;Run Acquiring&#34;)
        
        #Find the acqStart node:
        acqStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;acqStart_&#39; in node.name:
                    acqStartNode = node
        
        #Run the scoring_start routine:
        if acqStartNode is not None:
            self.acquiringStart(acqStartNode)
        else:
            logging.error(&#39;Could not find acqStart node in flowchart&#39;)
    
    def interruptRun(self):
        &#34;&#34;&#34; 
        Interrupt the run - stop the scoring/init/acq and stop ongoing acquisitions.
        &#34;&#34;&#34;
        
        #Trying this for now:
        self.shared_data._mdaModeAcqData.abort()
        
        return
    
    def debugScoring(self):
        &#34;&#34;&#34;
        Function to get some debug information from the scoring function(s)
        &#34;&#34;&#34;
        logging.debug(&#34;Debug Scoring&#34;)
        scoreGraph = self.prepareGraph(methodName = &#34;Score&#34;)
        
        
        logging.debug(self)
        logging.debug(self.evaluateGraph())
    #endregion
    
    #region NodzFlowChart GraphArea functions
    def contextMenuEvent(self, QMouseevent):
        &#34;&#34;&#34;
        Function to create a context menu when right-clicking on the nodz canvas

        This function creates a context menu with all available node types that the user can select from, and adds the node to the nodz canvas at the position of the mouse click.

        Args:
            QMouseevent (PyQt5.QtGui.QMouseEvent): The mouse event that triggered this context menu
        &#34;&#34;&#34;
        #Check if we are right-clicking on a node:
        item_at_mouse = self.scene().itemAt(self.mapToScene(QMouseevent.pos()), QtGui.QTransform())
        
        if item_at_mouse == None:
            context_menu = QMenu(self)
            
            def addToContextMenu(context_menu,node_type,node_data):
                &#34;&#34;&#34;  
                Add a node type with node data to the right-click context menu
                &#34;&#34;&#34;
                new_subAction = QAction(node_data[&#39;displayName&#39;], self)
                context_menu.addAction(new_subAction)
                # Define a closure to capture the current value of node_type
                def create_lambda(node_type):
                    &#34;&#34;&#34;
                    Create a lambda function that calls the createNodeFromRightClick method with the specified node type.
                    
                    Args:
                        node_type: The type of node to be created.
                    
                    Returns:
                        A lambda function that takes an event and calls createNodeFromRightClick with the specified node type.
                    &#34;&#34;&#34;
                    return lambda _, event=QMouseevent: self.createNodeFromRightClick(event, nodeType=node_type)
                # Connect each action to its own lambda function
                new_subAction.triggered.connect(create_lambda(node_type))
            
            
            #Every type of node should be in here:
            allEntries = self.nodeInfo[&#39;__RightClickMenuNodeOrder__&#39;]
            
            addedMissedNodeType = False
            #But, we also loop over all entries in self.nodeInfo, and see if we missed any. If we did, we add them to the context menu.
            for nodeType in self.nodeInfo:
                if nodeType != &#39;__RightClickMenuNodeOrder__&#39; and nodeType not in allEntries:
                    if not addedMissedNodeType:
                        allEntries.append(&#39;|&#39;)
                        addedMissedNodeType = True
                    allEntries.append(nodeType)
            
            #We loop over all entries in here:
            for nodeType in allEntries:
                if nodeType == &#39;|&#39;:
                    context_menu.addSeparator()
                else:
                    if nodeType in self.nodeInfo:
                        node_type = nodeType
                        node_data = self.nodeInfo[nodeType]
                        addToContextMenu(context_menu,node_type,node_data)
            
            # Show the context menu at the event&#39;s position
            context_menu.exec_(QMouseevent.globalPos())
        elif item_at_mouse in self.nodes:
            
            context_menu = QMenu(self)
            
            #Add a change-name option
            changeName_subAction = QAction(&#39;Change name&#39;, self)
            context_menu.addAction(changeName_subAction)
            def create_lambda_changeName(item_at_mouse):
                &#34;&#34;&#34;
                Creates a lambda function to change the name of a node.
                
                Args:
                    item_at_mouse: The item at the mouse position.
                
                Returns:
                    A lambda function that calls the changeNodeName method with the item_at_mouse and event as arguments.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.changeNodeName(item_at_mouse, event)
            changeName_subAction.triggered.connect(create_lambda_changeName(item_at_mouse))
            
            #Add a change-color option
            changeColor_subAction = QAction(&#39;Change color&#39;, self)
            context_menu.addAction(changeColor_subAction)
            def create_lambda_changeColor(item_at_mouse):
                &#34;&#34;&#34;
                Creates a lambda function that changes the color of a node.
                
                Args:
                    item_at_mouse: The item at the mouse position.
                
                Returns:
                    A lambda function that calls the &#39;changeNodeColor&#39; method with the specified item and event.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.changeNodeColor(item_at_mouse, event)
            changeColor_subAction.triggered.connect(create_lambda_changeColor(item_at_mouse))
            
            #Add a advanced-info option
            advNodeInfo_subAction = QAction(&#39;Advanced Node info&#39;, self)
            context_menu.addAction(advNodeInfo_subAction)
            def create_lambda_advNodeInfo(item_at_mouse):
                &#34;&#34;&#34;
                Create a lambda function to call the advNodeInfo method with the given item at mouse position.
                
                Args:
                    item_at_mouse: The item at the mouse position to be passed to the advNodeInfo method.
                
                Returns:
                    A lambda function that calls the advNodeInfo method with the item_at_mouse and event parameters.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.advNodeInfo(item_at_mouse, event)
            advNodeInfo_subAction.triggered.connect(create_lambda_advNodeInfo(item_at_mouse))
            
            context_menu.exec_(QMouseevent.globalPos())

    def createNewNode(self, nodeType, event):
        &#34;&#34;&#34;
        Creates a new node on the nodz canvas, with name and preset specified.

        This function creates a new node on the nodz canvas at the position of the mouse event.
        The name of the node is specified by appending a number to the nodeType parameter.
        The preset of the node is set to &#39;node_preset_1&#39;.

        Args:
            nodeType (str): The type of node to create.
            event (PyQt5.QtGui.QMouseEvent): The mouse event that triggered this node creation.
        Returns:
            nodz.Node: The created nodz node.
        &#34;&#34;&#34;
        if self.nodeInfo[nodeType][&#39;NodeCounter&#39;] &gt;= self.nodeInfo[nodeType][&#39;MaxNodeCounter&#39;]:
            logging.error(&#39;Not allowed! Maximum number of nodes of this type reached&#39;)
            return
        
        #Create the new node with correct name and preset
        newNode = self.createNode(name=nodeType+&#34;_&#34;, preset = &#39;node_preset_1&#39;, position=self.mapToScene(event.pos()),displayName = self.nodeInfo[nodeType][&#39;displayName&#39;],nodeInfo=self.nodeInfo[nodeType])
        
        #Do post-node-creation functions - does this via the pyqtsignal!
        return newNode
    
    def createNodeFromRightClick(self,event,nodeType=None):
        &#34;&#34;&#34;
        This function creates a new node in the flowchart when the user right-clicks in the flowchart area. Mostly a wrapper function

        Args:
            event (QMouseEvent): The mouse event that triggered this function.
            nodeType (str): The type of node to create. Defaults to None.

        Returns:
            None
        &#34;&#34;&#34;
        self.createNewNode(nodeType,event)
    
    def focus(self):
        &#34;&#34;&#34;
        Focuses on the entire canvas
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self._focus()
    #endregion

#region ScanningWidget
class ScanningWidget(QWidget):
    &#34;&#34;&#34; 
    The scanning widget which handles the xy(z) scanning in a full autonomous runs. Mainly contains multiple advScanGridLayouts() which each individually handle a single method of xy(z) scanning.
    &#34;&#34;&#34;
    def __init__(self, nodzinstance=None,parent=None):
        &#34;&#34;&#34;
        Initializes the scanning widget class.
        
        Args:
            nodzinstance: The nodz instance to be associated with.
            parent: The parent widget.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        # super().__init__()
        self.nodzinstance=nodzinstance
        self.scanMode = &#39;LoadPos&#39;
        self.scanArray_modes = [
                            [&#39;LoadPos&#39;,&#39;Load a POS list&#39;]]
                
        self.scanLayouts = {}
        self.currentMode = None
        
        self.create_GUI()
    
    def create_GUI(self):
        &#34;&#34;&#34;
        Create scanning widget GUI with mode dropdown and corresponding advScanGridLayout layouts.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.mode_dropdown = QComboBox()
        self.mode_dropdown.addItems([option[1] for option in self.scanArray_modes])
        self.mode_layout = QGridLayout()
        self.mode_layout.addWidget(QLabel(&#39;Mode: &#39;),0,0)
        self.mode_layout.addWidget(self.mode_dropdown,0,1)

        from PyQt5.QtWidgets import QHBoxLayout
        for mode_option in self.scanArray_modes:
            self.scanLayouts[mode_option[0]] = advScanGridLayout(mode=mode_option[0],parent=self)
            
            self.scanLayouts[mode_option[0]].setVisible(True) #False
        
        self.layoutV = QVBoxLayout()
        self.layoutV.addLayout(self.mode_layout)
        counter = 2
        for mode_option in self.scanArray_modes:
            self.mode_layout.addWidget(self.scanLayouts[mode_option[0]],counter,0,1,2)
            counter+=1
        self.setLayout(self.layoutV)
        
        self.mode_dropdown.currentIndexChanged.connect(self.changeScanMode)
        self.changeScanMode()

    def changeScanMode(self):
        &#34;&#34;&#34;
        Change the scan mode based on the selected index. - i.e. hide all non-chosen advScanGridLayouts and show the chosen one.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for groupbox in self.scanLayouts.values():
            groupbox.setVisible(False) #False
            
        try:
            self.scanLayouts[self.scanArray_modes[self.mode_dropdown.currentIndex()][0]].setVisible(True)
            
            self.currentMode = self.scanArray_modes[self.mode_dropdown.currentIndex()][0]
        except:
            pass

    def getPositionInfo(self):
        &#34;&#34;&#34;
        Get the position information of the chosen advScanGridLayout. (i.e. list of XY(Z) positions)
        
        Returns:
            The position information.
        &#34;&#34;&#34;
        return self.scanLayouts[self.scanArray_modes[self.mode_dropdown.currentIndex()][0]].getPositionInfo()
    
    
    def updateAllScans(self):
        &#34;&#34;&#34;
        Update all scannings in the scan layouts based on the internal stored data.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for scanMode in self.scanLayouts:
            if scanMode == &#34;LoadPos&#34;:
                try:
                    self.scanLayouts[scanMode].lineEdit_posFilename.setText(self.scanLayouts[scanMode].scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;])
                except:
                    logging.debug(&#39;No fileName specified in scanMode loading&#39;)
        logging.debug(&#39;Updated all scan layouts&#39;)

    def assessScan(self):
        &#34;&#34;&#34;
        Return true or false whether or not the current scan will run normally or not
        &#34;&#34;&#34;
        assessment=False
        
        if self.scanMode == &#39;LoadPos&#39;:
            if self.scanLayouts[&#39;LoadPos&#39;].lineEdit_posFilename.text()[-4:] == &#39;.pos&#39;:
                assessment = True
        return assessment

class advScanGridLayout(QGroupBox):
    &#34;&#34;&#34; 
    advScanGridLayouts each individually handle a single method of xy(z) scanning. Easiest example is &#39;loading a POS file&#39;.
    The advScanGridLayouts are created in the ScanningWidget class
    The layouts should be based around the self.mode parameter, where the .mode is a string which defines the methodologies used. The modes are defined in the ScanningWidget class
    Currently implemented:
        &#39;LoadPos&#39;: Load a POS list
    &#34;&#34;&#34;
    def __init__(self, mode=None,parent=None):
        &#34;&#34;&#34;
        Initializes the class with the given mode and parent.
        
        Args:
            mode (str): The mode to be set for the class.
            parent (object): The parent object associated with this class.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.parent = parent #type:ignore
        super().__init__(parent)
        self.mode = mode
        self.scanningInfoGUI = {}
        #Create a QGridLayout to place in this groupbox:
        try:
            self.setLayout(QGridLayout())
        except:
            pass
        #Create a quick label that we place in 1,1:
        self.layout().addWidget(QLabel(f&#34;{mode}&#34;,self))
        if mode == &#39;LoadPos&#39;:
            self.loadPos_update()
    
    def update(self):
        &#34;&#34;&#34;
        General Update class, can be called from the parent class
        
        Args:
            self: The object itself.
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.debug(&#39;update&#39;)
    
    def getPositionInfo(self):
        &#34;&#34;&#34;
        General method to get the opsition info. Should basically return a well-formatted XY(Z) position list - see self.mode == LoadPos for an example.
        
        Args:
            None
        
        Returns:
            dict: A dictionary containing position information
        &#34;&#34;&#34;
        if self.mode == &#39;LoadPos&#39;:
            positions = {}
            #Read a JSON:
            import json
            with open(self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;], &#39;r&#39;) as f:
                xypositionsRaw = json.load(f)

            positions[&#39;nrPositions&#39;] = len(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;])
            for pos_id in range(positions[&#39;nrPositions&#39;]):
                positions[pos_id] = {}
                positions[pos_id][&#39;STAGES&#39;] = []
                if &#39;DefaultXYStage&#39; in xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id]:
                    positions[pos_id][&#39;STAGES&#39;].append(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DefaultXYStage&#39;][&#39;scalar&#39;])
                if &#39;DefaultZStage&#39; in xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id]:
                    positions[pos_id][&#39;STAGES&#39;].append(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DefaultZStage&#39;][&#39;scalar&#39;])
                
                for stage in positions[pos_id][&#39;STAGES&#39;]:
                    devicePositions = xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DevicePositions&#39;][&#39;array&#39;]
                    for devicePosition in devicePositions:
                        if stage == devicePosition[&#39;Device&#39;][&#39;scalar&#39;]:
                            positions[pos_id][stage] = devicePosition[&#39;Position_um&#39;][&#39;array&#39;]
                
            return positions
    
    def loadPos_update(self):
        &#34;&#34;&#34;
        Update function specific for the &#39;loadPos&#39; method - linked from the general update() method.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.scanningInfoGUI[&#39;LoadPos&#39;] = {}
        
        def load_pos_file():
            &#34;&#34;&#34;
            Load POS file using QFileDialog and set the filename in the line edit widget.
            
            Args:
                None
            
            Returns:
                None
            &#34;&#34;&#34;
            from qtpy.QtWidgets import QFileDialog
            filename, _ = QFileDialog.getOpenFileName(self,&#39;Open file&#39;, &#39;&#39;, &#39;*.POS Files (*.pos)&#39;)
            if filename:
                self.lineEdit_posFilename.setText(filename)
                self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;] = filename

        def update_file_name(new_file_name):
            &#34;&#34;&#34;
            Update the file name in the scanning information GUI.
            
            Args:
                new_file_name (str): The new file name to be set in the scanning information GUI.
            
            Returns:
                None
            &#34;&#34;&#34;
            self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;] = new_file_name
    
        self.lineEdit_posFilename = QLineEdit()
        self.layout().addWidget(self.lineEdit_posFilename,1,0) #type:ignore
        self.lineEdit_posFilename.textChanged.connect(lambda x: update_file_name(x))

        button_browsePosFile = QPushButton(&#39;...&#39;)
        self.layout().addWidget(button_browsePosFile,1,1) #type:ignore
        button_browsePosFile.clicked.connect(load_pos_file)
#endregion

#region DecisionWidget
class DecisionWidget(QWidget):
    &#34;&#34;&#34; 
    The decisionWidget handles having all the advDecisionLayouts, which are used for different scoring/passing/decision metrics (i.e. saying &#39;this field-of-view is good enough&#39;).
    Look at advDecisionGridLayout for implementation of the actual decision routines.
    &#34;&#34;&#34;
    def __init__(self, nodzinstance=None,parent=None):
        &#34;&#34;&#34;
        Initializes the DecisionWidget class.  Importantly defines the individual modes of the advDecisionLayout.
        
        Args:
            nodzinstance (object, optional): An instance of the nodz class. Defaults to None.
            parent (object, optional): The parent object. Defaults to None.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        # super().__init__()
        self.nodzinstance=nodzinstance
        self.decisionMode = &#39;DirectDecision&#39;
        self.decisionArray_modes = [
                            [&#39;DirectDecision&#39;,&#39;Direct Decision&#39;],
                            [&#39;FullScan&#39;,&#39;Full Scan, then acquire&#39;],
                            [&#39;RandomScan&#39;,&#39;Randomly scan Nth percentile, then acquire&#39;],
                            [&#39;StayOnFOV&#39;,&#39;Conditionally stay on a FoV&#39;]]
        
        self.decisionArray_decisionTypes = {}
        self.decisionArray_decisionTypes[&#39;DirectDecision&#39;] = [
                            [&#39;AND_Score&#39;,&#39;All scoring conditions met&#39;],
                            [&#39;AND_Score_VAR&#39;,&#39;All VAR scoring conditions met&#39;],
                            [&#39;OR_Score&#39;,&#39;Any scoring condition met&#39;],
                            [&#39;Advanced&#39;,&#39;Advanced scoring condition&#39;]]
        self.decisionArray_decisionTypes[&#39;FullScan&#39;] = [
                            ]
        self.decisionArray_decisionTypes[&#39;RandomScan&#39;] = [
                            ]
        self.decisionArray_decisionTypes[&#39;StayOnFOV&#39;] = [
                            ]
        
        self.finalDecisionLayout = QVBoxLayout()
        
        self.decisionLayouts = {}
        self.currentMode = None
        self.currentDecision = None
        
        self.create_GUI()
    
    def create_GUI(self):
        &#34;&#34;&#34;
        Create GUI for decision making. Importantly adds all the advDecisionLayouts with individual modes.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        # self.setWindowTitle(&#39;Decision&#39;)
        self.mode_dropdown = QComboBox()
        self.mode_dropdown.addItems([option[1] for option in self.decisionArray_modes])
        self.mode_dropdown.currentIndexChanged.connect(self.updateAllDecisions)
        self.mode_layout = QGridLayout()
        self.mode_layout.addWidget(QLabel(&#39;Mode: &#39;),0,0)
        self.mode_layout.addWidget(self.mode_dropdown,0,1)

        from PyQt5.QtWidgets import QHBoxLayout
        for mode_option in self.decisionArray_modes:
            self.decisionLayouts[mode_option[0]] = QWidget()
            #Add a layout to this widget:
            self.decisionLayouts[mode_option[0]].layout = QHBoxLayout()
            self.decisionLayouts[mode_option[0]].setLayout(self.decisionLayouts[mode_option[0]].layout)
            self.decisionLayouts[mode_option[0]].setVisible(False) #False
            
            self.decisionLayouts[mode_option[0]].mode_dropdown = QComboBox()
            self.decisionLayouts[mode_option[0]].mode_dropdown.currentIndexChanged.connect(self.updateAllDecisions)
            self.decisionLayouts[mode_option[0]].mode_dropdown.addItems([option[1] for option in self.decisionArray_decisionTypes[mode_option[0]]])
            
            self.decisionLayouts[mode_option[0]].mode_layout = QGridLayout()
            self.decisionLayouts[mode_option[0]].mode_layout.addWidget(QLabel(&#39;Decision mode: &#39;),0,0)
            self.decisionLayouts[mode_option[0]].mode_layout.addWidget(self.decisionLayouts[mode_option[0]].mode_dropdown,0,1)
            self.decisionLayouts[mode_option[0]].decisiontypes={}
            
            counter2 = 1
            for option in self.decisionArray_decisionTypes[mode_option[0]]:
                self.decisionLayouts[mode_option[0]].decisiontypes[option[0]] = advDecisionGridLayout(mode=mode_option[0],decision=option[0],parent=self)
                self.decisionLayouts[mode_option[0]].decisiontypes[option[0]].setVisible(False)
                self.decisionLayouts[mode_option[0]].mode_layout.addWidget(self.decisionLayouts[mode_option[0]].decisiontypes[option[0]],counter2,0,1,2)
                counter2+=1
            
            self.decisionLayouts[mode_option[0]].layout.addLayout(self.decisionLayouts[mode_option[0]].mode_layout)
            
        self.layoutV = QVBoxLayout()
        # Create the QScrollArea
        self.scrollArea = QScrollArea(self)
        self.scrollArea.setWidgetResizable(True)
        self.scrollAreaWidgetContents = QWidget()
        self.scrollAreaWidgetContents.setLayout(self.mode_layout)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)

        # Add the QScrollArea to the QVBoxLayout
        self.layoutV.addWidget(self.scrollArea)
        # self.layoutV.addLayout(self.mode_layout)
        counter = 2
        for mode_option in self.decisionArray_modes:
            self.mode_layout.addWidget(self.decisionLayouts[mode_option[0]],counter,0,1,2)
            counter+=1
        self.setLayout(self.layoutV)
        
        for mode_option in self.decisionArray_modes:
            self.decisionLayouts[mode_option[0]].mode_dropdown.currentIndexChanged.connect(self.changeDecisionMode)
        
        self.mode_dropdown.currentIndexChanged.connect(self.changeMode)
        self.changeMode()
        self.changeDecisionMode()

    def changeMode(self):
        &#34;&#34;&#34;
        Change the mode of the decision layout. Mostly hides/shows individual decisionLayouts.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for groupbox in self.decisionLayouts.values():
            groupbox.setVisible(False) #False
        try:
            self.decisionLayouts[self.decisionArray_modes[self.mode_dropdown.currentIndex()][0]].setVisible(True)
        except:
            pass

    def changeDecisionMode(self):        
        &#34;&#34;&#34;
        Change the decision mode by setting the visibility of decision layouts. Mostly hides/shows individual decisionLayouts and sets its own mode/decision.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        #Set all of these: self.decisionLayouts[currentMode][currentDecision].setVisible(True) to invis:
        for mode in self.decisionLayouts:
            for option in self.decisionLayouts[mode].decisiontypes:
                if isinstance(self.decisionLayouts[mode].decisiontypes[option],advDecisionGridLayout):
                    self.decisionLayouts[mode].decisiontypes[option].setVisible(False)
        
        # #Then, we do something specific based on this decision:
        currentMode = self.decisionArray_modes[self.mode_dropdown.currentIndex()][0]
        currentDecisionLong = self.decisionLayouts[currentMode].mode_dropdown.currentText()
        currentDecision = &#39;&#39;
        for option in self.decisionArray_decisionTypes[currentMode]:
            if currentDecisionLong == option[1]:
                currentDecision = option[0]
        
        self.decisionLayouts[currentMode].decisiontypes[currentDecision].setVisible(True)
        self.currentMode = currentMode
        self.currentDecision = currentDecision
    
    def updateAllDecisions(self):
        &#34;&#34;&#34;
        Update all decisions in the decision layouts.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for mode in self.decisionLayouts:
            if hasattr(self.decisionLayouts[mode], &#39;decisiontypes&#39;):
                for option in self.decisionLayouts[mode].decisiontypes:
                    self.decisionLayouts[mode].decisiontypes[option].update()

    def testCurrentDecision(self):
        &#34;&#34;&#34;
        Tests whether the current FoV passes the currently selected Decision. Mostly wrapper for calling test_decision of the chosen decision in advDecisionGridLayout
        
        Args:
            None
        
        Returns:
            bool: True if the test for the current decision passed, False otherwise.
        &#34;&#34;&#34;
        testPassed = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision].test_decision()
        return testPassed


    def assessDecision(self):
        &#34;&#34;&#34;
        Return true or false whether or not the current decision will run normally or not
        &#34;&#34;&#34;
        assessment=False
        # If AND-score, check if all required inputs have text
        if self.currentMode == &#39;DirectDecision&#39; and self.currentDecision == &#39;AND_Score&#39;:
            layout = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision]
            if &#39;Start&#39; in layout.decisionInfoGUI:
                if layout.decisionInfoGUI[&#39;Start&#39;][&#39;dropdown&#39;].currentText() != None and layout.decisionInfoGUI[&#39;Start&#39;][&#39;dropdown&#39;].currentText() != &#39;&#39; and layout.decisionInfoGUI[&#39;Start&#39;][&#39;lineedit&#39;].text() != None and layout.decisionInfoGUI[&#39;Start&#39;][&#39;lineedit&#39;].text() != &#39;&#39;:
                    assessment = True
        #If AND-score-VAR, check if all required inputs have text
        elif self.currentMode == &#39;DirectDecision&#39; and self.currentDecision == &#39;AND_Score_VAR&#39;:
            layout = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision]
            for input in layout.decisionInfoGUIVAR:
                vv = layout.decisionInfoGUIVAR[input]
                if vv[&#39;varName&#39;].text() != None and vv[&#39;varName&#39;].text() != &#39;&#39; and vv[&#39;lineedit&#39;].text() != None and vv[&#39;lineedit&#39;].text() != &#39;&#39;:
                    assessment = True
                    break
            
        return assessment

class advDecisionGridLayout(QGroupBox):
    &#34;&#34;&#34; 
    advDecisionGridLayout each individually handle a single method of decision. Easiest example is DirectDecision mode with &#39;AND_SCORE&#39; decision.
    Each layout requires a MODE and a DECISION, where the MODE is one of four options (DirectDecision, fullscan, randomscan, stayonfov) --&gt; see ScanningWidget init, and the DECISION is more flexible (i.e. &#39;all scores are passed&#39;, or &#39;at least 1 score is passed&#39; in the DirectDecision mode)
    The advDecisionGridLayout are created in the DecisionWidget class
    Currently implemented:
        &#39;DirectDecision&#39; --&gt; &#39;AND_Score&#39;: Checks if all scores are passed.
        &#39;DirectDecision&#39; --&gt; &#39;AND_Score_VAR&#39;: Checks if all scores, based on variables, are passed.
    &#34;&#34;&#34;
    def __init__(self, mode=None,decision=None,parent=None):
        &#34;&#34;&#34;
        Initialize the class with the provided mode, decision, and parent.
        
        Args:
            mode (str): The mode to be set for the instance.
            decision (str): The decision to be set for the instance.
            parent (object): The parent object associated with this instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.parent = parent #type:ignore
        super().__init__(parent)
        self.mode = mode
        self.decision = decision
        self.decisionInfoGUI = {} #Will finally contain all decision info in GUI form!
        self.decisionInfoGUIVAR = {} #Will finally contain all decision info in GUI form!
        #Create a QGridLayout to place in this groupbox:
        self.setLayout(QGridLayout())
        #Create a quick label that we place in 1,1:
        self.layout().addWidget(QLabel(f&#34;{mode} and {decision}&#34;,self),1,1) #type:ignore
        if mode == &#39;DirectDecision&#39;:
            if decision == &#39;AND_Score&#39;:
                self.directDecision_AND_Score_update()
            elif decision == &#39;AND_Score_VAR&#39;:
                self.directDecision_AND_Score_VAR_update()
    
    def update(self):
        &#34;&#34;&#34;
        Update the object based on the current mode and decision.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        if self.mode == &#39;DirectDecision&#39;:
            if self.decision == &#39;AND_Score&#39;:
                self.directDecision_AND_Score_update()
            elif self.decision == &#39;AND_Score_VAR&#39;:
                self.directDecision_AND_Score_VAR_update()
    
    def test_decision(self):
        &#34;&#34;&#34;
        Make a decision based on the mode and decision type. Should always output a boolean
        
        Args:
            mode (str): The mode of decision making.
            decision (str): The type of decision to be made.
        
        Returns:
            str: The result of the decision making process.
        &#34;&#34;&#34;
        if self.mode == &#39;DirectDecision&#39;:
            if self.decision == &#39;AND_Score&#39;:
                return self.directDecision_AND_Score_test()
            if self.decision == &#39;AND_Score_VAR&#39;:
                return self.directDecision_AND_Score_VAR_test()
    
    def getScoreMetrics(self):
        &#34;&#34;&#34;
        Get the score metrics from the scoringEnd node.
        
        Args:
            None
        
        Returns:
            list: A list of score metrics (i.e. sockets of score node).
        &#34;&#34;&#34;
        scoreMetrics = []
        #Get all score metrics (i.e. sockets of score node)
        flowChart = self.parent.nodzinstance
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringEnd_&#39; in node.name:
                    break
            
            #Now get the scores from here:
            for socket in node.sockets:
                scoreMetrics.append(socket)
        return scoreMetrics
    
    def remove_widgets_in_layout(self,layout):
        &#34;&#34;&#34;
        Removes all widgets in the given layout recursively.
        
        Args:
            layout: The layout from which widgets will be removed.
        
        Returns:
            None
        &#34;&#34;&#34;
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()
            elif item.layout() is not None:
                self.remove_widgets_in_layout(item.layout())
    
    def directDecision_AND_Score_test(self):
        &#34;&#34;&#34;
        Code to test whether the current score passes the decision matrix or not. Should always output a boolean
        &#34;&#34;&#34;
        finalTest = False
        scoreMetrics = self.getScoreMetrics()
        
        #Get all score metrics (i.e. sockets of score node)
        flowChart = self.parent.nodzinstance
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringEnd_&#39; in node.name:
                    break
        
        #Find the nodes that are connected downstream of this:
        data = {}
        for attr in node.attrs:
            connectedNode = None
            for connection in flowChart.evaluateGraph():
                if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == attr:
                    if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                        connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                        connectedNode = flowChart.findNodeByName(connectedNodeName)
        
                    data[attr] = connectedNode.scoring_analysis_currentData[&#39;__output__&#39;] #type:ignore
        
        #Data now contains the values of the scores
        self.decisionInfoGUI
        scoreMetric = &#39;ScoreA&#39;
        indivBooleans = {}
        for scoreMetric in scoreMetrics:
            hbox = self.decisionInfoGUI[scoreMetric]
            operator = hbox[&#39;dropdown&#39;].currentText()
            value = hbox[&#39;lineedit&#39;].text()
            
            if eval(f&#34;{data[scoreMetric]} {operator} {value}&#34;):
                indivBooleans[scoreMetric] = True
            else:
                indivBooleans[scoreMetric] = False
        
        if all(indivBooleans.values()):
            finalTest = True
        
        return finalTest
    
    def directDecision_AND_Score_update(self):
        &#34;&#34;&#34;
        Code to update the GUI of the DirectDecision_AND_Score groupbox
        &#34;&#34;&#34;
        from PyQt5.QtWidgets import QComboBox, QHBoxLayout, QLabel, QLineEdit, QPushButton
        self.remove_widgets_in_layout(self.layout())
        
        self.outerLayout = QVBoxLayout()
        self.layout().addLayout(self.outerLayout,0,0) #type:ignore
        
        #Get out of this function if flowChart isn&#39;t initialised yet (i.e. first start-up):
        try:
            self.parent.nodzinstance.nodes
        except RuntimeError:
            return
        
        scoreMetrics = self.getScoreMetrics()
        
        for scoreMetric in scoreMetrics:
            hbox = QHBoxLayout()
            label = QLabel(scoreMetric)
            hbox.addWidget(label)
            dropdown = QComboBox()
            dropdown.addItems([&#39;&gt;&#39;,&#39;&gt;=&#39;,&#39;==&#39;,&#39;&lt;=&#39;,&#39;&lt;&#39;,&#39;!=&#39;])
            hbox.addWidget(dropdown)
            lineedit = QLineEdit()
            hbox.addWidget(lineedit)
            self.decisionInfoGUI[scoreMetric] = {}
            self.decisionInfoGUI[scoreMetric][&#39;dropdown&#39;] = dropdown
            self.decisionInfoGUI[scoreMetric][&#39;lineedit&#39;] = lineedit
            self.outerLayout.addLayout(hbox)
    
    def directDecision_AND_Score_VAR_test(self):
        &#34;&#34;&#34;
        Code to test whether the current score passes the decision matrix or not. Should always output a boolean
        &#34;&#34;&#34;
        finalTest = False
        #Data now contains the values of the scores
        self.decisionInfoGUIVAR
        
        totalTrueTests = 0
        requiredTrueTests = 0
        for decision in self.decisionInfoGUIVAR:
            if self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text() != &#39;&#39;:
                requiredTrueTests+=1
                logging.debug(self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text())
                
                #We get the value of the variable:
                varCurrentValue = utils.nodz_evaluateVar(self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text(),self.parent.nodzinstance)
                
                operator = self.decisionInfoGUIVAR[decision][&#39;dropdown&#39;].currentText()
                varTestValue = self.decisionInfoGUIVAR[decision][&#39;lineedit&#39;].text()
                
                varcurrentvalEvaluable = False
                try:
                    eval(f&#34;{varCurrentValue}&#34;)
                    varcurrentvalEvaluable = True
                except:
                    varcurrentvalEvaluable = False
                    
                vartestvalEvaluable = False
                try:
                    eval(f&#34;{varTestValue}&#34;)
                    vartestvalEvaluable = True
                except:
                    vartestvalEvaluable = False
                    
                if not varcurrentvalEvaluable and not vartestvalEvaluable:
                    evalText = f&#34;&#39;{varCurrentValue}&#39; {operator} &#39;{varTestValue}&#39;&#34;
                elif varcurrentvalEvaluable and not vartestvalEvaluable:
                    evalText = f&#34;{varCurrentValue} {operator} &#39;{varTestValue}&#39;&#34;
                elif not varcurrentvalEvaluable and vartestvalEvaluable:
                    evalText = f&#34;&#39;{varCurrentValue}&#39; {operator} {varTestValue}&#34;
                else:
                    evalText = f&#34;{varCurrentValue} {operator} {varTestValue}&#34;
                
                logging.debug(evalText)
                
                if eval(evalText):
                    totalTrueTests+=1
        
        if totalTrueTests == requiredTrueTests:
            finalTest = True
        
        return finalTest
    
    def directDecision_AND_Score_VAR_update(self):
        &#34;&#34;&#34;
        Code to update the GUI of the DirectDecision_AND_Score groupbox
        &#34;&#34;&#34;
        from PyQt5.QtWidgets import QComboBox, QHBoxLayout, QLabel, QLineEdit, QPushButton
        self.remove_widgets_in_layout(self.layout())
        
        self.outerLayout = QVBoxLayout()
        self.layout().addLayout(self.outerLayout,0,0) #type:ignore
        
        #Get out of this function if flowChart isn&#39;t initialised yet (i.e. first start-up):
        try:
            self.parent.nodzinstance.nodes
        except RuntimeError:
            return
        
        n_score_metrics = 5
        
        for n in range(n_score_metrics):
            hbox = QHBoxLayout()
            label = QLabel(str(n+1)+&#39;:&#39;)
            hbox.addWidget(label)
            
            varName = QLineEdit()
            varName.setObjectName(&#39;directDecision_AND_Score_VAR__varName_&#39;+str(n+1))
            hbox.addWidget(varName)
            
            dropdown = QComboBox()
            dropdown.addItems([&#39;&gt;&#39;,&#39;&gt;=&#39;,&#39;==&#39;,&#39;&lt;=&#39;,&#39;&lt;&#39;,&#39;!=&#39;])
            dropdown.setObjectName(&#39;directDecision_AND_Score_VAR__dropdown_&#39;+str(n+1))
            hbox.addWidget(dropdown)
            lineedit = QLineEdit()
            lineedit.setObjectName(&#39;directDecision_AND_Score_VAR__lineedit_&#39;+str(n+1))
            hbox.addWidget(lineedit)
            self.decisionInfoGUIVAR[n] = {}
            self.decisionInfoGUIVAR[n][&#39;varName&#39;] = varName
            self.decisionInfoGUIVAR[n][&#39;dropdown&#39;] = dropdown
            self.decisionInfoGUIVAR[n][&#39;lineedit&#39;] = lineedit
            self.outerLayout.addLayout(hbox)
#endregion

#region VariablesWidget
from PyQt5.QtWidgets import QTableWidget

class HoverTableWidget(QTableWidget):
    cellHovered = pyqtSignal(int, int)

    def __init__(self,parent=None):
        super().__init__(parent)
        self.setMouseTracking(True)  # Enable mouse tracking without pressing a button
        self.setSortingEnabled(True) #Enable sorting the columns
        self.verticalHeader().hide() #Hide the row numbering

    def mouseMoveEvent(self, event):
        index = self.indexAt(event.pos())
        if index.isValid():
            self.cellHovered.emit(index.row(), index.column())
        super().mouseMoveEvent(event)

    def leaveEvent(self, event):
        # Emit cellHovered signal with invalid index when mouse leaves
        self.cellHovered.emit(-1, -1)
        super().leaveEvent(event)
        
class VariablesBase(QWidget):
    &#34;&#34;&#34; 
    Show the variables of all nodz-instances, possibly filtered on connectedNodz only.
    &#34;&#34;&#34;
    def __init__(self, 
                nodzinstance:GladosNodzFlowChart_dockWidget,
                parent=None,
                doubleClickEffect=None,
                doubleClickLineEditChange=None,
                connectedNode_showOnlyDownstream=None,
                typeInfo=None):
        &#34;&#34;&#34;
        Initializes the scanning widget class.
        
        Args:
            nodzinstance: The nodz instance to be associated with.
            parent: The parent widget.
            doubleClickEffect: what you want to do if double-clicked. Options: None, &#39;updateLineEdit&#39;
            
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        # super().__init__()
        self.nodzinstance=nodzinstance
        
        if typeInfo is not None:
            #if typeInfo is not in an array, put it inside one
            if isinstance(typeInfo,type):
                typeInfo = [typeInfo]
            
            #Specifically check if there is a FLOAT type, but no INT type. If so, add the INT type as well
            hasFloatInt = [0,0]
            for typev in typeInfo:
                if typev == int:
                    hasFloatInt[1] = 1
                elif typev == float:
                    hasFloatInt[0] = 1
            if hasFloatInt == [1,0]:
                typeInfo.append(int)
                
        self.typeInfo = typeInfo
        
        self.create_GUI()
        
        return self
    
    def create_GUI(self):
        &#34;&#34;&#34;
        Create a QTableWidget GUI
        &#34;&#34;&#34;
        logging.debug(&#39;Inside variableswidget-createGUi&#39;)
        self.buttonTest = QPushButton(&#34;Update&#34;)
        self.buttonTest.clicked.connect(self.updateVariables)
        
        self.lineEditHover = QLabel(&#34;Hover over a Cell&#34;,self)
        self.lineEditHover.setEnabled(False)
        
        headers = [&#34;CellValue&#34;, &#34;Origin&#34;, &#34;Name&#34;, &#34;Value&#34;, &#34;Importance&#34;, &#34;Type&#34;, &#34;LastChanged&#34;]
        self.variablesTableWidget = HoverTableWidget()
        self.variablesTableWidget.setColumnCount(len(headers))
        self.variablesTableWidget.setHorizontalHeaderLabels(headers)
        
        # Connect the cellDoubleClicked signal to a custom slot
        self.variablesTableWidget.cellClicked.connect(self.on_cell_clicked)
        self.variablesTableWidget.cellDoubleClicked.connect(self.on_cell_double_clicked)
        self.variablesTableWidget.cellHovered.connect(self.on_cell_hovered)
        
        self.layoutV = QVBoxLayout()
        self.layoutV.addWidget(self.buttonTest)
        self.layoutV.addWidget(self.lineEditHover)
        self.layoutV.addWidget(self.variablesTableWidget)
        self.setLayout(self.layoutV)
        
    def on_cell_hovered(self, row, column):
        # Get the hovered entry
        try:
            #Specifically, get the origin Nodz
            hovered_entry = self.variablesTableWidget.item(row,1).text()# self.variablesTableWidget.item(row, column).text()
        except:
            hovered_entry = None
            
        #Loop over the nods in the nodzinstance:
        for node in self.nodzinstance.nodes:
            from PyQt5.QtWidgets import QGraphicsColorizeEffect, QGraphicsEffect, QGraphicsDropShadowEffect, QGraphicsView, QApplication
            if node.name == hovered_entry:                
                #Add a green shadow effect if it&#39;s the one hovered over.
                effect = QGraphicsDropShadowEffect()
                effect.setBlurRadius(60)
                effect.setColor(QColor(0, 200, 100, 230))
                effect.setOffset(0,0)

                node.setGraphicsEffect(effect)
            else:
                node.setGraphicsEffect(None)
                
        self.lineEditHover.setText(f&#34;Hovered: {hovered_entry}&#34;)

    def on_cell_clicked(self, row, column):
        self.selected_entry = []
        for col in range(self.variablesTableWidget.columnCount()):
            textEntry = &#39;&#39;
            try:
                textEntry = self.variablesTableWidget.item(row, col).text()
            except AttributeError:
                textEntry = &#39;None&#39;
            self.selected_entry.append(textEntry)
        
        import pyperclip
        copystr = f&#39;{self.selected_entry[2]}@{self.selected_entry[1]}&#39;
        pyperclip.copy(copystr)
        
            
    def on_cell_double_clicked(self, row, column):
        #Figure out the selected row
        self.selected_entry = []
        for col in range(self.variablesTableWidget.columnCount()):
            textEntry = &#39;&#39;
            try:
                textEntry = self.variablesTableWidget.item(row, col).text()
            except AttributeError:
                textEntry = &#39;None&#39;
            self.selected_entry.append(textEntry)
    
    def get_selected_entry(self):
        return getattr(self, &#39;selected_entry&#39;, None)
    
    def updateVariables(self):
        &#34;&#34;&#34;
        Update the nodz-variables.
        &#34;&#34;&#34;
        
        self.nodzinstance.updateCoreVariables()
        
        allvariableData = {}
        #Add all global variables
        for var in self.nodzinstance.globalVariables:
            pos = len(allvariableData)
            correctTyping = False
            if self.typeInfo is not None:
                variableTypes = self.nodzinstance.globalVariables[var][&#39;type&#39;]
                if isinstance(variableTypes,type):
                    variableTypes = [variableTypes]
                if isinstance(self.typeInfo,type):
                    self.typeInfo = [self.typeInfo]
                
                for variableType in variableTypes:
                    for selftype in self.typeInfo:
                        if variableType == selftype:
                            correctTyping = True
            else: #if no typing specified, accept everything
                correctTyping = True
            
            if correctTyping:
                allvariableData[pos] = self.nodzinstance.globalVariables[var]
                allvariableData[pos][&#39;NodeOrigin&#39;] = &#39;Global&#39;
                allvariableData[pos][&#39;VariableName&#39;] = var
            
        #Add all core variables
        for var in self.nodzinstance.coreVariables:
            pos = len(allvariableData)
            correctTyping = False
            if self.typeInfo is not None:
                variableTypes = self.nodzinstance.coreVariables[var][&#39;type&#39;]
                if isinstance(variableTypes,type):
                    variableTypes = [variableTypes]
                if isinstance(self.typeInfo,type):
                    self.typeInfo = [self.typeInfo]
                
                for variableType in variableTypes:
                    for selftype in self.typeInfo:
                        if variableType == selftype:
                            correctTyping = True
            else: #if no typing specified, accept everything
                correctTyping = True
            
            if correctTyping:
                allvariableData[pos] = self.nodzinstance.coreVariables[var]
                allvariableData[pos][&#39;NodeOrigin&#39;] = &#39;Core&#39;
                allvariableData[pos][&#39;VariableName&#39;] = var
            
        #Add all variables of all nodes
        allNodes = self.nodzinstance.obtainAllNodes()
        
        for node in allNodes:
            for var in node.variablesNodz:
                pos = len(allvariableData)
                correctTyping = False
                if self.typeInfo is not None:
                    variableTypes = node.variablesNodz[var][&#39;type&#39;]
                    if isinstance(variableTypes,type):
                        variableTypes = [variableTypes]
                    if isinstance(self.typeInfo,type):
                        self.typeInfo = [self.typeInfo]
                    
                    for variableType in variableTypes:
                        for selftype in self.typeInfo:
                            if variableType == selftype:
                                correctTyping = True
                else: #if no typing specified, accept everything
                    correctTyping = True
                
                if correctTyping:
                    allvariableData[pos] = node.variablesNodz[var]
                    allvariableData[pos][&#39;NodeOrigin&#39;] = node.name
                    allvariableData[pos][&#39;VariableName&#39;] = var
            
        
        # Set the number of rows
        self.variablesTableWidget.setRowCount(len(allvariableData))

        from PyQt5.QtWidgets import QTableWidgetItem
        from datetime import datetime
        # Fill the table with data
        for row_id in range(len(allvariableData)):
            varData = allvariableData[row_id]
            # headers = [&#34;CellValue&#34;, &#34;Origin&#34;, &#34;Name&#34;, &#34;Value&#34;, &#34;Importance&#34;,&#34;Type&#34;, &#34;LastChanged&#34;]
            self.variablesTableWidget.setItem(row_id, 1, QTableWidgetItem(str(varData[&#39;NodeOrigin&#39;])))
            self.variablesTableWidget.setItem(row_id, 2, QTableWidgetItem(str(varData[&#39;VariableName&#39;])))
            self.variablesTableWidget.setItem(row_id, 3, QTableWidgetItem(str(varData[&#39;data&#39;])))
            self.variablesTableWidget.setItem(row_id, 4, QTableWidgetItem(str(varData[&#39;importance&#39;])))
            self.variablesTableWidget.setItem(row_id, 5, QTableWidgetItem(str(varData[&#39;type&#39;])))
            if &#39;lastUpdateTime&#39; in varData and varData[&#39;lastUpdateTime&#39;] is not None:
                self.variablesTableWidget.setItem(row_id, 6, QTableWidgetItem(str(datetime.fromtimestamp(varData[&#39;lastUpdateTime&#39;]).strftime(&#34;%H:%M:%S %d-%m-%Y&#34;))))
            else:
                self.variablesTableWidget.setItem(row_id, 6, QTableWidgetItem(&#39;None&#39;))

class VariablesWidget(VariablesBase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class VariablesDialog(QDialog, VariablesBase):
    def __init__(self, *args, **kwargs):
        QDialog.__init__(self)
        variablesWidget = VariablesBase.__init__(self, *args, **kwargs)
        self.setWindowTitle(&#34;Variables Dialog&#34;)
        #Create a container layout:
        # layout = QVBoxLayout()
        
        
        # Set font size for all items in the table
        font = QFont()
        font.setPointSize(7)  # Set the desired font size
        variablesWidget.variablesTableWidget.setFont(font)

        # Set font size for headers
        header_font = QFont()
        header_font.setPointSize(10)  # Set the desired font size for headers
        variablesWidget.variablesTableWidget.horizontalHeader().setFont(header_font)
        variablesWidget.variablesTableWidget.verticalHeader().setFont(header_font)
        
        from PyQt5.QtWidgets import QApplication, QTableWidget, QTableWidgetItem, QHeaderView

        # Make the table more compact
        variablesWidget.variablesTableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        variablesWidget.variablesTableWidget.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)
        variablesWidget.variablesTableWidget.verticalHeader().setDefaultSectionSize(25)  # Set the default height of each row

        
        #Update the variables
        variablesWidget.updateVariables()
        self.layout().addWidget(variablesWidget)
        
        
        
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        
        # Add button box to the layout
        self.layout().addWidget(self.buttonBox)
        self.setMinimumSize(300,300)
        self.setBaseSize(300,300)
        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        
    def on_cell_double_clicked(self, row, column):
        super().on_cell_double_clicked(row, column)
        #remove hover-effect
        self.variablesTableWidget.cellHovered.emit(-1, -1)
        self.accept()  # Close the dialog with the Accepted result
        
#endregion

#region LoggerWidget
class LoggerWidget(QPlainTextEdit):
    def __init__(self, logLevel=&#39;INFO&#39;):
        super().__init__()
        
        # Set the widget to read-only
        self.setReadOnly(True)
        
        # Get the appdata folder
        appdata_folder = os.getenv(&#39;APPDATA&#39;)
        if appdata_folder is None:
            raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        self.app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
    
        #Find all log files
        log_files = [f for f in os.listdir(self.app_specific_folder) if f.endswith(&#34;.log&#34;)]
        if not log_files:
            return None
    
        if logLevel == &#39;DEBUG&#39;:
            correct_level_log_files = [f for f in log_files if &#39;DEBUG&#39; in f]
            self.most_recent_file = max(correct_level_log_files, key=lambda f: os.path.getmtime(os.path.join(self.app_specific_folder, f)))
        else:
            correct_level_log_files = [f for f in log_files if &#39;INFO&#39; in f]
            self.most_recent_file = max(correct_level_log_files, key=lambda f: os.path.getmtime(os.path.join(self.app_specific_folder, f)))
        
        self.update_log_content()
        
        #random value between around 500: (desyncs multiple logger widgets)
        import random
        if not logLevel == &#39;DEBUG&#39;:
            # Set up a timer to periodically update the log content
            self.timer = QTimer(self)
            self.timer.timeout.connect(self.update_log_content)
            self.timer.start(random.randint(400, 600))
            
    def update_log_content(self):
        &#34;&#34;&#34; 
        Update the contents of the logger view by re-reading the log_file
        &#34;&#34;&#34;
        if not self.most_recent_file:
            return

        with open(os.path.join(self.app_specific_folder,self.most_recent_file), &#39;r&#39;) as log_file:
            self.setPlainText(log_file.read())
            self.moveCursor(QTextCursor.End)  # Scroll to the bottom

#endregion

#region NodzWorkers
from PyQt5.QtWidgets import QApplication, QLabel, QVBoxLayout, QPushButton, QWidget
from PyQt5.QtCore import QThreadPool, QRunnable, pyqtSlot
# Define a WorkerSignals class to handle signals
class WorkerSignals(QObject):
    &#34;&#34;&#34;  
    Signals belonging to generalNodzCallActionWorker
    &#34;&#34;&#34;
    finished = pyqtSignal()

class generalNodzCallActionWorker(QRunnable):
    
    &#34;&#34;&#34; 
    General worker that can do async running of callActions belonging to nodes.
    &#34;&#34;&#34;
    
    def __init__(self,nodzType,args):
        &#34;&#34;&#34; 
        Init only passes nodzType and args to the super class.
        &#34;&#34;&#34;
        super(generalNodzCallActionWorker,self).__init__()
        self.nodzType = nodzType
        self.args = args
        self.signals = WorkerSignals()
        logging.debug(f&#34;GeneralNodzCallActionworker INIT with nodzType: {self.nodzType} and args: {self.args}&#34;)
    
    def run(self):
        &#34;&#34;&#34; 
        Running of the different callActions belonging to all nodes.
        &#34;&#34;&#34;
        import logging
        logging.debug(f&#34;GeneralNodzCallActionworker RUN with nodzType: {self.nodzType} and args: {self.args}&#34;)
        #Timer
        if self.nodzType == &#39;Timer&#39;:
            import time
            time.sleep(self.args[&#39;wait_time&#39;])
        elif self.nodzType == &#39;MMconfigChangeRan&#39;:
            #We need to change some configs (probably):
            for config_to_change in self.args[&#39;config_string_storage&#39;]:
                
                #Find the correct config_group in MMconfig:
                for config_group_id_loop in self.args[&#39;MMconfig&#39;].config_groups:
                    config_group_name = self.args[&#39;MMconfig&#39;].config_groups[config_group_id_loop].configGroupName()
                    if config_group_name == config_to_change[0]:
                        config_group_id = config_group_id_loop
                        #Over-write the grouptype like this:
                        config_group_type = &#39;InputField&#39;
                        if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isInputField():
                            config_group_type = &#39;InputField&#39;
                        if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isDropDown():
                            config_group_type = &#39;DropDown&#39;
                        if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isSlider():
                            config_group_type = &#39;Slider&#39;
                
                if config_group_type == &#39;DropDown&#39;:
                    logging.debug(&#39;Changing dropDown value from MMconfig-Nodz!&#39;)
                    #Change the config, and wait for the config to be changed - this works for groups
                    self.args[&#39;core&#39;].set_config(config_to_change[0],config_to_change[1]) #type:ignore
                    self.args[&#39;core&#39;].wait_for_config(config_to_change[0],config_to_change[1])#type:ignore
                elif config_group_type == &#39;InputField&#39;:
                    logging.info(&#39;Changing inputField value from MMconfig-Nodz!&#39;)
                    CurrentText = config_to_change[1]
                    #Get the config group name:
                    configGroupName = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].configGroupName()

                    #An Editfield config by definition (?) only has a single property underneath, so get that:
                    underlyingProperty = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_available_configs(configGroupName).get(0)
                    configdata = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_config_data(configGroupName,underlyingProperty)
                    device_label = configdata.get_setting(0).get_device_label()
                    property_name = configdata.get_setting(0).get_property_name()

                    #Set this property:
                    self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.set_property(device_label,property_name,CurrentText)
                    logging.info(f&#34;Changed {device_label}.{property_name} to {CurrentText}&#34;)
                elif config_group_type == &#39;Slider&#39;:
                    logging.debug(&#39;Changing slider value from MMconfig-Nodz!&#39;)
                    newValue = config_to_change[1]
                    #Get the true value from the conversion - not required in MMconfig-nodz:
                    trueValue = newValue
                    
                    #Get the config group name:
                    configGroupName = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].configGroupName()
                    #Set in MM:
                    #A slider config by definition (?) only has a single property underneath, so get that:
                    underlyingProperty = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_available_configs(configGroupName).get(0)
                    configdata = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_config_data(configGroupName,underlyingProperty)
                    device_label = configdata.get_setting(0).get_device_label()
                    property_name = configdata.get_setting(0).get_property_name()

                    #Set this property:
                    self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.set_property(device_label,property_name,trueValue)
                    logging.info(f&#34;Changed {device_label}.{property_name} to {trueValue}&#34;)
                    
        elif self.nodzType == &#39;AnalysisNode&#39; or self.nodzType == &#39;CustomFunctionNode&#39;:
            #Get all the necessary info
            evalText = self.args[&#39;evalText&#39;]
            nodeDict = self.args[&#39;nodeDict&#39;]
            node = self.args[&#39;node&#39;]
            core = self.args[&#39;core&#39;]
            shared_data = self.args[&#39;shared_data&#39;]
            self.shared_data = shared_data
            logging.info(evalText)
            #Finally do the analysis
            node.output = eval(evalText)
        
        #Emit that the node is finished :) 
        self.signals.finished.emit()

#endregion


def flowChart_dockWidgets(core,MM_JSON,main_layout,sshared_data):
    &#34;&#34;&#34;
    Creates a dock widget with a flowchart for running analysis workflows

    This function creates a dock widget with a flowchart for running analysis workflows.

    Args:
        core (pycro-manager.Core): A connection to the micro-manager API.
        MM_JSON (dict): A dictionary containing the settings from the Micro-Manager settings file.
        main_layout (PyQt5.QtWidgets.QVBoxLayout): The main layout of the dock widget.
        sshared_data (Shared_data): A shared data class instance containing shared data between widgets.

    Returns:
        GladosNodzFlowChart_dockWidget: The flowchart dock widget.
    &#34;&#34;&#34;

    global shared_data, napariViewer
    shared_data = sshared_data
    napariViewer = shared_data.napariViewer
    
    #Create the a flowchart testing
    flowChart_dockWidget = GladosNodzFlowChart_dockWidget(core=core,shared_data=shared_data,MM_JSON=MM_JSON)
    main_layout.addLayout(flowChart_dockWidget.mainLayout,0,0)
    #should have nodes
    
    flowChart_dockWidget.getNodz()
    
    return flowChart_dockWidget</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="FlowChart_dockWidgets.flowChart_dockWidgets"><code class="name flex">
<span>def <span class="ident">flowChart_dockWidgets</span></span>(<span>core, MM_JSON, main_layout, sshared_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a dock widget with a flowchart for running analysis workflows</p>
<p>This function creates a dock widget with a flowchart for running analysis workflows.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>core</code></strong> :&ensp;<code>pycro-manager.Core</code></dt>
<dd>A connection to the micro-manager API.</dd>
<dt><strong><code>MM_JSON</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing the settings from the Micro-Manager settings file.</dd>
<dt><strong><code>main_layout</code></strong> :&ensp;<code>PyQt5.QtWidgets.QVBoxLayout</code></dt>
<dd>The main layout of the dock widget.</dd>
<dt><strong><code>sshared_data</code></strong> :&ensp;<code>Shared_data</code></dt>
<dd>A shared data class instance containing shared data between widgets.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget">GladosNodzFlowChart_dockWidget</a></code></dt>
<dd>The flowchart dock widget.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flowChart_dockWidgets(core,MM_JSON,main_layout,sshared_data):
    &#34;&#34;&#34;
    Creates a dock widget with a flowchart for running analysis workflows

    This function creates a dock widget with a flowchart for running analysis workflows.

    Args:
        core (pycro-manager.Core): A connection to the micro-manager API.
        MM_JSON (dict): A dictionary containing the settings from the Micro-Manager settings file.
        main_layout (PyQt5.QtWidgets.QVBoxLayout): The main layout of the dock widget.
        sshared_data (Shared_data): A shared data class instance containing shared data between widgets.

    Returns:
        GladosNodzFlowChart_dockWidget: The flowchart dock widget.
    &#34;&#34;&#34;

    global shared_data, napariViewer
    shared_data = sshared_data
    napariViewer = shared_data.napariViewer
    
    #Create the a flowchart testing
    flowChart_dockWidget = GladosNodzFlowChart_dockWidget(core=core,shared_data=shared_data,MM_JSON=MM_JSON)
    main_layout.addLayout(flowChart_dockWidget.mainLayout,0,0)
    #should have nodes
    
    flowChart_dockWidget.getNodz()
    
    return flowChart_dockWidget</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.is_pip_installed"><code class="name flex">
<span>def <span class="ident">is_pip_installed</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_pip_installed():
    return &#39;site-packages&#39; in __file__ or &#39;dist-packages&#39; in __file__</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="FlowChart_dockWidgets.AnalysisScoringVisualisationDialog"><code class="flex name class">
<span>class <span class="ident">AnalysisScoringVisualisationDialog</span></span>
<span>(</span><span>parent=None, currentNode=None, addVisualisationBox=False)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for analysis/scoring/visualisation methods in the Nodz layout. Basically based on EVE's flexible file-finding function methodology. Also used for real-time analysis dialog.</p>
<p>Advanced input dialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>QWidget</code></dt>
<dd>Parent widget.</dd>
<dt><strong><code>currentNode</code></strong> :&ensp;<code>Nodz</code></dt>
<dd>Node data.</dd>
<dt><strong><code>addVisualisationBox</code></strong></dt>
<dd>A boolean indicating whether to add a visualization CheckBox (default is False). </dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing the line edit and combo box input from the user.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnalysisScoringVisualisationDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for analysis/scoring/visualisation methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology. Also used for real-time analysis dialog.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None, addVisualisationBox = False):
        &#34;&#34;&#34;
        Advanced input dialog.

        Args:
            parent (QWidget): Parent widget.
            currentNode (Nodz): Node data.
            addVisualisationBox: A boolean indicating whether to add a visualization CheckBox (default is False). 

        Returns:
            tuple: A tuple containing the line edit and combo box input from the user.
        &#34;&#34;&#34;
        super().__init__()
        
        self.currentData = {}
        
        # Create layout
        layout = QVBoxLayout()
        
        self.mainLayout = QGridLayout()
        layout.addLayout(self.mainLayout)
        
        bottomHbox = QHBoxLayout()
        
        if addVisualisationBox:
            self.visualisationBox = QCheckBox()
            visualisationLabel = QLabel(&#39;Visualise&#39;)
            visualiseHbox = QHBoxLayout()
            visualiseHbox.addWidget(self.visualisationBox)
            visualiseHbox.addWidget(visualisationLabel)
            bottomHbox.addLayout(visualiseHbox)
            
        #Add a OK/cancel button set:
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        bottomHbox.addWidget(button_box)
        #Add this to the bottom of the layout, stretching horizontally but centering in the center:
        layout.addLayout(bottomHbox)
        
        self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_analysisDialog" href="#FlowChart_dockWidgets.nodz_analysisDialog">nodz_analysisDialog</a></li>
<li><a title="FlowChart_dockWidgets.nodz_customFunctionDialog" href="#FlowChart_dockWidgets.nodz_customFunctionDialog">nodz_customFunctionDialog</a></li>
<li><a title="FlowChart_dockWidgets.nodz_realTimeAnalysisDialog" href="#FlowChart_dockWidgets.nodz_realTimeAnalysisDialog">nodz_realTimeAnalysisDialog</a></li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.CustomGraphicsView"><code class="flex name class">
<span>class <span class="ident">CustomGraphicsView</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a custom Graphics View for the Nodz container</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CustomGraphicsView(QtWidgets.QGraphicsView):
    &#34;&#34;&#34;
    Create a custom Graphics View for the Nodz container
    &#34;&#34;&#34;
    def resizeEvent(self, event):
        &#34;&#34;&#34;
        Handles resizing of the graphics view.
        
        Args:
            event (QResizeEvent): The resize event.
        &#34;&#34;&#34;
        super().resizeEvent(event)
        self.updateGraphicsViewSize()
    
    def updateGraphicsViewSize(self):
        &#34;&#34;&#34;
        Updates the size of the GraphicsView to match its viewport size.

        This function is called automatically when the viewport is resized.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        nodz.setFixedSize(self.viewport().size())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGraphicsView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.CustomGraphicsView.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles resizing of the graphics view.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>QResizeEvent</code></dt>
<dd>The resize event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event):
    &#34;&#34;&#34;
    Handles resizing of the graphics view.
    
    Args:
        event (QResizeEvent): The resize event.
    &#34;&#34;&#34;
    super().resizeEvent(event)
    self.updateGraphicsViewSize()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.CustomGraphicsView.updateGraphicsViewSize"><code class="name flex">
<span>def <span class="ident">updateGraphicsViewSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the size of the GraphicsView to match its viewport size.</p>
<p>This function is called automatically when the viewport is resized.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateGraphicsViewSize(self):
    &#34;&#34;&#34;
    Updates the size of the GraphicsView to match its viewport size.

    This function is called automatically when the viewport is resized.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    nodz.setFixedSize(self.viewport().size())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.DecisionWidget"><code class="flex name class">
<span>class <span class="ident">DecisionWidget</span></span>
<span>(</span><span>nodzinstance=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The decisionWidget handles having all the advDecisionLayouts, which are used for different scoring/passing/decision metrics (i.e. saying 'this field-of-view is good enough').
Look at advDecisionGridLayout for implementation of the actual decision routines.</p>
<p>Initializes the DecisionWidget class.
Importantly defines the individual modes of the advDecisionLayout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodzinstance</code></strong> :&ensp;<code>object</code>, optional</dt>
<dd>An instance of the nodz class. Defaults to None.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>object</code>, optional</dt>
<dd>The parent object. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DecisionWidget(QWidget):
    &#34;&#34;&#34; 
    The decisionWidget handles having all the advDecisionLayouts, which are used for different scoring/passing/decision metrics (i.e. saying &#39;this field-of-view is good enough&#39;).
    Look at advDecisionGridLayout for implementation of the actual decision routines.
    &#34;&#34;&#34;
    def __init__(self, nodzinstance=None,parent=None):
        &#34;&#34;&#34;
        Initializes the DecisionWidget class.  Importantly defines the individual modes of the advDecisionLayout.
        
        Args:
            nodzinstance (object, optional): An instance of the nodz class. Defaults to None.
            parent (object, optional): The parent object. Defaults to None.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        # super().__init__()
        self.nodzinstance=nodzinstance
        self.decisionMode = &#39;DirectDecision&#39;
        self.decisionArray_modes = [
                            [&#39;DirectDecision&#39;,&#39;Direct Decision&#39;],
                            [&#39;FullScan&#39;,&#39;Full Scan, then acquire&#39;],
                            [&#39;RandomScan&#39;,&#39;Randomly scan Nth percentile, then acquire&#39;],
                            [&#39;StayOnFOV&#39;,&#39;Conditionally stay on a FoV&#39;]]
        
        self.decisionArray_decisionTypes = {}
        self.decisionArray_decisionTypes[&#39;DirectDecision&#39;] = [
                            [&#39;AND_Score&#39;,&#39;All scoring conditions met&#39;],
                            [&#39;AND_Score_VAR&#39;,&#39;All VAR scoring conditions met&#39;],
                            [&#39;OR_Score&#39;,&#39;Any scoring condition met&#39;],
                            [&#39;Advanced&#39;,&#39;Advanced scoring condition&#39;]]
        self.decisionArray_decisionTypes[&#39;FullScan&#39;] = [
                            ]
        self.decisionArray_decisionTypes[&#39;RandomScan&#39;] = [
                            ]
        self.decisionArray_decisionTypes[&#39;StayOnFOV&#39;] = [
                            ]
        
        self.finalDecisionLayout = QVBoxLayout()
        
        self.decisionLayouts = {}
        self.currentMode = None
        self.currentDecision = None
        
        self.create_GUI()
    
    def create_GUI(self):
        &#34;&#34;&#34;
        Create GUI for decision making. Importantly adds all the advDecisionLayouts with individual modes.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        # self.setWindowTitle(&#39;Decision&#39;)
        self.mode_dropdown = QComboBox()
        self.mode_dropdown.addItems([option[1] for option in self.decisionArray_modes])
        self.mode_dropdown.currentIndexChanged.connect(self.updateAllDecisions)
        self.mode_layout = QGridLayout()
        self.mode_layout.addWidget(QLabel(&#39;Mode: &#39;),0,0)
        self.mode_layout.addWidget(self.mode_dropdown,0,1)

        from PyQt5.QtWidgets import QHBoxLayout
        for mode_option in self.decisionArray_modes:
            self.decisionLayouts[mode_option[0]] = QWidget()
            #Add a layout to this widget:
            self.decisionLayouts[mode_option[0]].layout = QHBoxLayout()
            self.decisionLayouts[mode_option[0]].setLayout(self.decisionLayouts[mode_option[0]].layout)
            self.decisionLayouts[mode_option[0]].setVisible(False) #False
            
            self.decisionLayouts[mode_option[0]].mode_dropdown = QComboBox()
            self.decisionLayouts[mode_option[0]].mode_dropdown.currentIndexChanged.connect(self.updateAllDecisions)
            self.decisionLayouts[mode_option[0]].mode_dropdown.addItems([option[1] for option in self.decisionArray_decisionTypes[mode_option[0]]])
            
            self.decisionLayouts[mode_option[0]].mode_layout = QGridLayout()
            self.decisionLayouts[mode_option[0]].mode_layout.addWidget(QLabel(&#39;Decision mode: &#39;),0,0)
            self.decisionLayouts[mode_option[0]].mode_layout.addWidget(self.decisionLayouts[mode_option[0]].mode_dropdown,0,1)
            self.decisionLayouts[mode_option[0]].decisiontypes={}
            
            counter2 = 1
            for option in self.decisionArray_decisionTypes[mode_option[0]]:
                self.decisionLayouts[mode_option[0]].decisiontypes[option[0]] = advDecisionGridLayout(mode=mode_option[0],decision=option[0],parent=self)
                self.decisionLayouts[mode_option[0]].decisiontypes[option[0]].setVisible(False)
                self.decisionLayouts[mode_option[0]].mode_layout.addWidget(self.decisionLayouts[mode_option[0]].decisiontypes[option[0]],counter2,0,1,2)
                counter2+=1
            
            self.decisionLayouts[mode_option[0]].layout.addLayout(self.decisionLayouts[mode_option[0]].mode_layout)
            
        self.layoutV = QVBoxLayout()
        # Create the QScrollArea
        self.scrollArea = QScrollArea(self)
        self.scrollArea.setWidgetResizable(True)
        self.scrollAreaWidgetContents = QWidget()
        self.scrollAreaWidgetContents.setLayout(self.mode_layout)
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)

        # Add the QScrollArea to the QVBoxLayout
        self.layoutV.addWidget(self.scrollArea)
        # self.layoutV.addLayout(self.mode_layout)
        counter = 2
        for mode_option in self.decisionArray_modes:
            self.mode_layout.addWidget(self.decisionLayouts[mode_option[0]],counter,0,1,2)
            counter+=1
        self.setLayout(self.layoutV)
        
        for mode_option in self.decisionArray_modes:
            self.decisionLayouts[mode_option[0]].mode_dropdown.currentIndexChanged.connect(self.changeDecisionMode)
        
        self.mode_dropdown.currentIndexChanged.connect(self.changeMode)
        self.changeMode()
        self.changeDecisionMode()

    def changeMode(self):
        &#34;&#34;&#34;
        Change the mode of the decision layout. Mostly hides/shows individual decisionLayouts.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for groupbox in self.decisionLayouts.values():
            groupbox.setVisible(False) #False
        try:
            self.decisionLayouts[self.decisionArray_modes[self.mode_dropdown.currentIndex()][0]].setVisible(True)
        except:
            pass

    def changeDecisionMode(self):        
        &#34;&#34;&#34;
        Change the decision mode by setting the visibility of decision layouts. Mostly hides/shows individual decisionLayouts and sets its own mode/decision.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        #Set all of these: self.decisionLayouts[currentMode][currentDecision].setVisible(True) to invis:
        for mode in self.decisionLayouts:
            for option in self.decisionLayouts[mode].decisiontypes:
                if isinstance(self.decisionLayouts[mode].decisiontypes[option],advDecisionGridLayout):
                    self.decisionLayouts[mode].decisiontypes[option].setVisible(False)
        
        # #Then, we do something specific based on this decision:
        currentMode = self.decisionArray_modes[self.mode_dropdown.currentIndex()][0]
        currentDecisionLong = self.decisionLayouts[currentMode].mode_dropdown.currentText()
        currentDecision = &#39;&#39;
        for option in self.decisionArray_decisionTypes[currentMode]:
            if currentDecisionLong == option[1]:
                currentDecision = option[0]
        
        self.decisionLayouts[currentMode].decisiontypes[currentDecision].setVisible(True)
        self.currentMode = currentMode
        self.currentDecision = currentDecision
    
    def updateAllDecisions(self):
        &#34;&#34;&#34;
        Update all decisions in the decision layouts.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for mode in self.decisionLayouts:
            if hasattr(self.decisionLayouts[mode], &#39;decisiontypes&#39;):
                for option in self.decisionLayouts[mode].decisiontypes:
                    self.decisionLayouts[mode].decisiontypes[option].update()

    def testCurrentDecision(self):
        &#34;&#34;&#34;
        Tests whether the current FoV passes the currently selected Decision. Mostly wrapper for calling test_decision of the chosen decision in advDecisionGridLayout
        
        Args:
            None
        
        Returns:
            bool: True if the test for the current decision passed, False otherwise.
        &#34;&#34;&#34;
        testPassed = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision].test_decision()
        return testPassed


    def assessDecision(self):
        &#34;&#34;&#34;
        Return true or false whether or not the current decision will run normally or not
        &#34;&#34;&#34;
        assessment=False
        # If AND-score, check if all required inputs have text
        if self.currentMode == &#39;DirectDecision&#39; and self.currentDecision == &#39;AND_Score&#39;:
            layout = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision]
            if &#39;Start&#39; in layout.decisionInfoGUI:
                if layout.decisionInfoGUI[&#39;Start&#39;][&#39;dropdown&#39;].currentText() != None and layout.decisionInfoGUI[&#39;Start&#39;][&#39;dropdown&#39;].currentText() != &#39;&#39; and layout.decisionInfoGUI[&#39;Start&#39;][&#39;lineedit&#39;].text() != None and layout.decisionInfoGUI[&#39;Start&#39;][&#39;lineedit&#39;].text() != &#39;&#39;:
                    assessment = True
        #If AND-score-VAR, check if all required inputs have text
        elif self.currentMode == &#39;DirectDecision&#39; and self.currentDecision == &#39;AND_Score_VAR&#39;:
            layout = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision]
            for input in layout.decisionInfoGUIVAR:
                vv = layout.decisionInfoGUIVAR[input]
                if vv[&#39;varName&#39;].text() != None and vv[&#39;varName&#39;].text() != &#39;&#39; and vv[&#39;lineedit&#39;].text() != None and vv[&#39;lineedit&#39;].text() != &#39;&#39;:
                    assessment = True
                    break
            
        return assessment</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.DecisionWidget.assessDecision"><code class="name flex">
<span>def <span class="ident">assessDecision</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true or false whether or not the current decision will run normally or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assessDecision(self):
    &#34;&#34;&#34;
    Return true or false whether or not the current decision will run normally or not
    &#34;&#34;&#34;
    assessment=False
    # If AND-score, check if all required inputs have text
    if self.currentMode == &#39;DirectDecision&#39; and self.currentDecision == &#39;AND_Score&#39;:
        layout = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision]
        if &#39;Start&#39; in layout.decisionInfoGUI:
            if layout.decisionInfoGUI[&#39;Start&#39;][&#39;dropdown&#39;].currentText() != None and layout.decisionInfoGUI[&#39;Start&#39;][&#39;dropdown&#39;].currentText() != &#39;&#39; and layout.decisionInfoGUI[&#39;Start&#39;][&#39;lineedit&#39;].text() != None and layout.decisionInfoGUI[&#39;Start&#39;][&#39;lineedit&#39;].text() != &#39;&#39;:
                assessment = True
    #If AND-score-VAR, check if all required inputs have text
    elif self.currentMode == &#39;DirectDecision&#39; and self.currentDecision == &#39;AND_Score_VAR&#39;:
        layout = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision]
        for input in layout.decisionInfoGUIVAR:
            vv = layout.decisionInfoGUIVAR[input]
            if vv[&#39;varName&#39;].text() != None and vv[&#39;varName&#39;].text() != &#39;&#39; and vv[&#39;lineedit&#39;].text() != None and vv[&#39;lineedit&#39;].text() != &#39;&#39;:
                assessment = True
                break
        
    return assessment</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.DecisionWidget.changeDecisionMode"><code class="name flex">
<span>def <span class="ident">changeDecisionMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the decision mode by setting the visibility of decision layouts. Mostly hides/shows individual decisionLayouts and sets its own mode/decision.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeDecisionMode(self):        
    &#34;&#34;&#34;
    Change the decision mode by setting the visibility of decision layouts. Mostly hides/shows individual decisionLayouts and sets its own mode/decision.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    #Set all of these: self.decisionLayouts[currentMode][currentDecision].setVisible(True) to invis:
    for mode in self.decisionLayouts:
        for option in self.decisionLayouts[mode].decisiontypes:
            if isinstance(self.decisionLayouts[mode].decisiontypes[option],advDecisionGridLayout):
                self.decisionLayouts[mode].decisiontypes[option].setVisible(False)
    
    # #Then, we do something specific based on this decision:
    currentMode = self.decisionArray_modes[self.mode_dropdown.currentIndex()][0]
    currentDecisionLong = self.decisionLayouts[currentMode].mode_dropdown.currentText()
    currentDecision = &#39;&#39;
    for option in self.decisionArray_decisionTypes[currentMode]:
        if currentDecisionLong == option[1]:
            currentDecision = option[0]
    
    self.decisionLayouts[currentMode].decisiontypes[currentDecision].setVisible(True)
    self.currentMode = currentMode
    self.currentDecision = currentDecision</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.DecisionWidget.changeMode"><code class="name flex">
<span>def <span class="ident">changeMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the mode of the decision layout. Mostly hides/shows individual decisionLayouts.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeMode(self):
    &#34;&#34;&#34;
    Change the mode of the decision layout. Mostly hides/shows individual decisionLayouts.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    for groupbox in self.decisionLayouts.values():
        groupbox.setVisible(False) #False
    try:
        self.decisionLayouts[self.decisionArray_modes[self.mode_dropdown.currentIndex()][0]].setVisible(True)
    except:
        pass</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.DecisionWidget.create_GUI"><code class="name flex">
<span>def <span class="ident">create_GUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create GUI for decision making. Importantly adds all the advDecisionLayouts with individual modes.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_GUI(self):
    &#34;&#34;&#34;
    Create GUI for decision making. Importantly adds all the advDecisionLayouts with individual modes.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    # self.setWindowTitle(&#39;Decision&#39;)
    self.mode_dropdown = QComboBox()
    self.mode_dropdown.addItems([option[1] for option in self.decisionArray_modes])
    self.mode_dropdown.currentIndexChanged.connect(self.updateAllDecisions)
    self.mode_layout = QGridLayout()
    self.mode_layout.addWidget(QLabel(&#39;Mode: &#39;),0,0)
    self.mode_layout.addWidget(self.mode_dropdown,0,1)

    from PyQt5.QtWidgets import QHBoxLayout
    for mode_option in self.decisionArray_modes:
        self.decisionLayouts[mode_option[0]] = QWidget()
        #Add a layout to this widget:
        self.decisionLayouts[mode_option[0]].layout = QHBoxLayout()
        self.decisionLayouts[mode_option[0]].setLayout(self.decisionLayouts[mode_option[0]].layout)
        self.decisionLayouts[mode_option[0]].setVisible(False) #False
        
        self.decisionLayouts[mode_option[0]].mode_dropdown = QComboBox()
        self.decisionLayouts[mode_option[0]].mode_dropdown.currentIndexChanged.connect(self.updateAllDecisions)
        self.decisionLayouts[mode_option[0]].mode_dropdown.addItems([option[1] for option in self.decisionArray_decisionTypes[mode_option[0]]])
        
        self.decisionLayouts[mode_option[0]].mode_layout = QGridLayout()
        self.decisionLayouts[mode_option[0]].mode_layout.addWidget(QLabel(&#39;Decision mode: &#39;),0,0)
        self.decisionLayouts[mode_option[0]].mode_layout.addWidget(self.decisionLayouts[mode_option[0]].mode_dropdown,0,1)
        self.decisionLayouts[mode_option[0]].decisiontypes={}
        
        counter2 = 1
        for option in self.decisionArray_decisionTypes[mode_option[0]]:
            self.decisionLayouts[mode_option[0]].decisiontypes[option[0]] = advDecisionGridLayout(mode=mode_option[0],decision=option[0],parent=self)
            self.decisionLayouts[mode_option[0]].decisiontypes[option[0]].setVisible(False)
            self.decisionLayouts[mode_option[0]].mode_layout.addWidget(self.decisionLayouts[mode_option[0]].decisiontypes[option[0]],counter2,0,1,2)
            counter2+=1
        
        self.decisionLayouts[mode_option[0]].layout.addLayout(self.decisionLayouts[mode_option[0]].mode_layout)
        
    self.layoutV = QVBoxLayout()
    # Create the QScrollArea
    self.scrollArea = QScrollArea(self)
    self.scrollArea.setWidgetResizable(True)
    self.scrollAreaWidgetContents = QWidget()
    self.scrollAreaWidgetContents.setLayout(self.mode_layout)
    self.scrollArea.setWidget(self.scrollAreaWidgetContents)

    # Add the QScrollArea to the QVBoxLayout
    self.layoutV.addWidget(self.scrollArea)
    # self.layoutV.addLayout(self.mode_layout)
    counter = 2
    for mode_option in self.decisionArray_modes:
        self.mode_layout.addWidget(self.decisionLayouts[mode_option[0]],counter,0,1,2)
        counter+=1
    self.setLayout(self.layoutV)
    
    for mode_option in self.decisionArray_modes:
        self.decisionLayouts[mode_option[0]].mode_dropdown.currentIndexChanged.connect(self.changeDecisionMode)
    
    self.mode_dropdown.currentIndexChanged.connect(self.changeMode)
    self.changeMode()
    self.changeDecisionMode()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.DecisionWidget.testCurrentDecision"><code class="name flex">
<span>def <span class="ident">testCurrentDecision</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the current FoV passes the currently selected Decision. Mostly wrapper for calling test_decision of the chosen decision in advDecisionGridLayout</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the test for the current decision passed, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testCurrentDecision(self):
    &#34;&#34;&#34;
    Tests whether the current FoV passes the currently selected Decision. Mostly wrapper for calling test_decision of the chosen decision in advDecisionGridLayout
    
    Args:
        None
    
    Returns:
        bool: True if the test for the current decision passed, False otherwise.
    &#34;&#34;&#34;
    testPassed = self.decisionLayouts[self.currentMode].decisiontypes[self.currentDecision].test_decision()
    return testPassed</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.DecisionWidget.updateAllDecisions"><code class="name flex">
<span>def <span class="ident">updateAllDecisions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update all decisions in the decision layouts.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateAllDecisions(self):
    &#34;&#34;&#34;
    Update all decisions in the decision layouts.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    for mode in self.decisionLayouts:
        if hasattr(self.decisionLayouts[mode], &#39;decisiontypes&#39;):
            for option in self.decisionLayouts[mode].decisiontypes:
                self.decisionLayouts[mode].decisiontypes[option].update()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.FoVFindImaging_singleCh_configs"><code class="flex name class">
<span>class <span class="ident">FoVFindImaging_singleCh_configs</span></span>
<span>(</span><span>parent=None, parentData=None)</span>
</code></dt>
<dd>
<div class="desc"><p>I BELIEVE DEPRECATED (may 2024)
Advanced dialog for user to input the configuration for a single channel single FOV imaging experiment.</p>
<p>I BELIEVE DEPRECATED (may 2024)
Advanced dialog for user to input the configuration for a single channel single FOV imaging experiment.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>QWidget</code></dt>
<dd>The parent widget for this dialog. Defaults to None.</dd>
<dt><strong><code>parentData</code></strong></dt>
<dd>The data object for this app. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>mdaData</code></dt>
<dd>The mdaData object with all the user input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FoVFindImaging_singleCh_configs(QDialog):
    &#34;&#34;&#34;
    I BELIEVE DEPRECATED (may 2024)
    Advanced dialog for user to input the configuration for a single channel single FOV imaging experiment.
    &#34;&#34;&#34;
    def __init__(self, parent=None, parentData=None):
        &#34;&#34;&#34;
        I BELIEVE DEPRECATED (may 2024)
        Advanced dialog for user to input the configuration for a single channel single FOV imaging experiment.

        Args:
            parent (QWidget): The parent widget for this dialog. Defaults to None.
            parentData: The data object for this app. Defaults to None.

        Returns:
            mdaData: The mdaData object with all the user input.
        &#34;&#34;&#34;
        super().__init__(parent)
        
        self.setWindowTitle(&#34;Advanced Input Dialog&#34;)
        if parentData is not None:
            core = parentData.core
            
            
            # Get all config groups
            allConfigGroups={}
            nrconfiggroups = core.get_available_config_groups().size()
            for config_group_id in range(nrconfiggroups):
                allConfigGroups[config_group_id] = ConfigInfo(core,config_group_id)
            
            #Create the MM config via all config groups
            self.MMconfig = MMConfigUI(allConfigGroups, showConfigs = True,showStages=False,showROIoptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False, showCheckboxes=True,autoSaveLoad=False)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
                
            #Set the layout
            layout = QVBoxLayout()
            layout.addLayout(self.MMconfig.mainLayout)
            layout.addWidget(button_box)
            
            self.setLayout(layout)
        
    def getInputs(self):
        &#34;&#34;&#34;
        Get the UI configuration information.
        
        Args:
            onlyChecked (bool): A boolean flag indicating whether to return only the checked UI configuration information.
        
        Returns:
            dict: A dictionary containing the UI configuration information.
        &#34;&#34;&#34;
        return self.MMconfig.getUIConfigInfo(onlyChecked=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.FoVFindImaging_singleCh_configs.getInputs"><code class="name flex">
<span>def <span class="ident">getInputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the UI configuration information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>onlyChecked</code></strong> :&ensp;<code>bool</code></dt>
<dd>A boolean flag indicating whether to return only the checked UI configuration information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the UI configuration information.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInputs(self):
    &#34;&#34;&#34;
    Get the UI configuration information.
    
    Args:
        onlyChecked (bool): A boolean flag indicating whether to return only the checked UI configuration information.
    
    Returns:
        dict: A dictionary containing the UI configuration information.
    &#34;&#34;&#34;
    return self.MMconfig.getUIConfigInfo(onlyChecked=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.GladosGraph"><code class="flex name class">
<span>class <span class="ident">GladosGraph</span></span>
<span>(</span><span>parent)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a 'graph' in code-form of all connections in the scoring or acquisition flowchart. Basically gives information about what node is connected to what other nodes</p>
<p>Initialize a GladosGraph object
Create a 'graph' in code-form of all connections in the scoring or acquisition flowchart. Basically gives information about what node is connected to what other nodes</p>
<p>This function initializes a GladosGraph object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>nodz_mda.GladosFlowchart</code></dt>
<dd>The nodz_mda flowchart object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GladosGraph():
    &#34;&#34;&#34; 
    Create a &#39;graph&#39; in code-form of all connections in the scoring or acquisition flowchart. Basically gives information about what node is connected to what other nodes
    &#34;&#34;&#34;
    #Also adds these values correctly for each node:
        # self.n_connect_at_start = 0 #number of others connected at start (which should all be finished!)
        # self.connectedToFinish = []
        # self.connectedToData = []
        
    def __init__(self,parent):
        &#34;&#34;&#34;
        Initialize a GladosGraph object
        Create a &#39;graph&#39; in code-form of all connections in the scoring or acquisition flowchart. Basically gives information about what node is connected to what other nodes

        This function initializes a GladosGraph object.

        Args:
            parent (nodz_mda.GladosFlowchart): The nodz_mda flowchart object.

        Returns:
            None

        &#34;&#34;&#34; 
        self.parent = parent
        self.nodes = []
        self.startNodeIndex = -1
        # self.unstartedNodes = []
        # self.ongoingNodes = []
        # self.finishedNodes = []

    def addRawGraphEval(self,graphEval):
        &#34;&#34;&#34;
        Adds information about connections to the nodes in a graphEval

        This function adds information about connections to the nodes in a graphEval.
        In particular, it adds to each node the nodes it is connected to
        based on the connections in graphEval.

        Args:
            graphEval (list): A list of tuples that describe the connections in the graph.
                Each tuple has the form (sending_node_name, receiving_node_name)

        Returns:
            None

        &#34;&#34;&#34;
        #Also generate a list of all nodes in this graph
        self.allNodeNames = []
        for graphEvalPartFull in graphEval:
            for graphEvalPartFull2 in graphEvalPartFull:
                graphEvalPart = graphEvalPartFull2.split(&#39;.&#39;)[0]
                if graphEvalPart not in self.allNodeNames:
                    self.allNodeNames.append(graphEvalPart)
        
        for nodeName in self.allNodeNames:
            self.nodes.append(self.parent.findNodeByName(nodeName))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.GladosGraph.addRawGraphEval"><code class="name flex">
<span>def <span class="ident">addRawGraphEval</span></span>(<span>self, graphEval)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds information about connections to the nodes in a graphEval</p>
<p>This function adds information about connections to the nodes in a graphEval.
In particular, it adds to each node the nodes it is connected to
based on the connections in graphEval.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graphEval</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of tuples that describe the connections in the graph.
Each tuple has the form (sending_node_name, receiving_node_name)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addRawGraphEval(self,graphEval):
    &#34;&#34;&#34;
    Adds information about connections to the nodes in a graphEval

    This function adds information about connections to the nodes in a graphEval.
    In particular, it adds to each node the nodes it is connected to
    based on the connections in graphEval.

    Args:
        graphEval (list): A list of tuples that describe the connections in the graph.
            Each tuple has the form (sending_node_name, receiving_node_name)

    Returns:
        None

    &#34;&#34;&#34;
    #Also generate a list of all nodes in this graph
    self.allNodeNames = []
    for graphEvalPartFull in graphEval:
        for graphEvalPartFull2 in graphEvalPartFull:
            graphEvalPart = graphEvalPartFull2.split(&#39;.&#39;)[0]
            if graphEvalPart not in self.allNodeNames:
                self.allNodeNames.append(graphEvalPart)
    
    for nodeName in self.allNodeNames:
        self.nodes.append(self.parent.findNodeByName(nodeName))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget"><code class="flex name class">
<span>class <span class="ident">GladosNodzFlowChart_dockWidget</span></span>
<span>(</span><span>core=None, shared_data=None, MM_JSON=None, parent:Â <a title="FlowChart_dockWidgets.CustomGraphicsView" href="#FlowChart_dockWidgets.CustomGraphicsView">CustomGraphicsView</a>Â |Â NoneÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that represents a Flowchart dock widget in napari-Glados.
Inherits from Nodz, which is a graph drawing tool.</p>
<p>Main class of all Nodz-based Glados automisation.</p>
<p>Initializes the GladosNodzFlowChart_dockWidget in napari-Glados.
Inherits from Nodz, which is a graph drawing tool.</p>
<p>Main class of all Nodz-based Glados automisation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>core</code></strong></dt>
<dd>Core object for MM/napari integration.</dd>
<dt><strong><code>shared_data</code></strong></dt>
<dd>Shared data object.</dd>
<dt><strong><code>MM_JSON</code></strong></dt>
<dd>JSON object for MM/napari integration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GladosNodzFlowChart_dockWidget(NodzMain.Nodz):
    &#34;&#34;&#34;
    Class that represents a Flowchart dock widget in napari-Glados. 
    Inherits from Nodz, which is a graph drawing tool.
    
    Main class of all Nodz-based Glados automisation.
    &#34;&#34;&#34;
    def __init__(self,core=None,shared_data=None,MM_JSON=None,parent:CustomGraphicsView|None=None):
        &#34;&#34;&#34;
        Initializes the GladosNodzFlowChart_dockWidget in napari-Glados. 
        Inherits from Nodz, which is a graph drawing tool.
        
        Main class of all Nodz-based Glados automisation.
        
        Args:
            core: Core object for MM/napari integration.
            shared_data: Shared data object.
            MM_JSON: JSON object for MM/napari integration.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        #If run as plugin, we need to specify the globals like this:
        if parent is not None: # from napari plugin run
            global livestate, napariViewer
            livestate = parent.livestate
            napariViewer = parent.napariViewer
            parent.shared_data = shared_data
            shared_data.napariViewer = napariViewer
        else: #assuming shared_data is global - from .py run
            try:
                # global core, napariViewer
                napariViewer = shared_data.napariViewer
            except:
                logging.warning(&#39;Line 1372 fails&#39;)
        
        self.parent = parent
        
        #Create a QGridLayout:
        self.mainLayout = QGridLayout()
        
        self.fullRunOngoing = False
        
        try:
            import glados_pycromanager
            # Get the installation path of the package
            package_path = os.path.dirname(glados_pycromanager.__file__)
            # Construct the path to the Icons folder
            self.iconFolder = os.path.join(package_path, &#39;GUI&#39;, &#39;Icons&#39;)
        except:
            self.iconFolder = &#39;&#39;
        if not os.path.exists(self.iconFolder) or self.iconFolder == &#39;&#39;:
            #Find the iconPath folder
            if os.path.exists(&#39;./glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados_pycromanager/GUI/Icons/&#39;
            elif os.path.exists(&#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/General_Start.png&#39;):
                self.iconFolder = &#39;./glados-pycromanager/glados_pycromanager/GUI/Icons/&#39;
            else:
                self.iconFolder = &#39;&#39;
            
            
        self.buttonsArea = QVBoxLayout()
        
        #Add a hbox with warning icons, and set them to be grayscale/inactive:
        self.warningArea = QHBoxLayout()
        #add a stretch before:
        self.warningArea.addStretch()
        self.errorIcon = QLabel()
        self.errorIcon = utils.setWarningErrorInfoIcon(self.errorIcon,&#39;error&#39;,self.iconFolder,alteration = &#39;grayscale&#39;)
        self.warningArea.addWidget(self.errorIcon)
        self.warningIcon = QLabel()
        self.warningIcon = utils.setWarningErrorInfoIcon(self.warningIcon,&#39;warning&#39;,self.iconFolder,alteration = &#39;grayscale&#39;)
        self.warningArea.addWidget(self.warningIcon)
        self.infoIcon = QLabel()
        self.infoIcon = utils.setWarningErrorInfoIcon(self.infoIcon,&#39;info&#39;,self.iconFolder,alteration = &#39;grayscale&#39;)
        self.warningArea.addWidget(self.infoIcon)
        
        #add a stretch after the icons:
        self.warningArea.addStretch()
        
        
        #Add the area:
        self.buttonsArea.addLayout(self.warningArea)
        
        
        #Add a few buttons:
        self.loadPickleButton = QPushButton(&#39; Load graph&#39;)
        self.buttonsArea.addWidget(self.loadPickleButton)
        self.loadPickleButton.clicked.connect(lambda index: self.loadGraphJSON())
        # icon: Flaticon.com
        self.loadPickleButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Load.png&#39;))
        
        self.storePickleButton = QPushButton(&#39; Store graph&#39;)
        self.buttonsArea.addWidget(self.storePickleButton)
        self.storePickleButton.clicked.connect(lambda index: self.storeGraphJSON())
        # icon: Flaticon.com
        self.storePickleButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Save.png&#39;))
        
        self.fullRunButton = QPushButton(&#39; Start run&#39;)
        self.buttonsArea.addWidget(self.fullRunButton)
        self.fullRunButton.clicked.connect(lambda index: self.fullAutonomousRunStart())
        self.fullRunButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_all.png&#39;))
        
        self.runInitButton = QPushButton(&#39; Init Only&#39;)
        self.buttonsArea.addWidget(self.runInitButton)
        self.runInitButton.clicked.connect(lambda index: self.runInitOnly())
        self.runInitButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_init.png&#39;))
        
        self.runScoringButton = QPushButton(&#39; Scoring Only&#39;)
        self.buttonsArea.addWidget(self.runScoringButton)
        self.runScoringButton.clicked.connect(lambda index: self.runScoringOnly())
        self.runScoringButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_score.png&#39;))
        
        self.runAcquiringButton = QPushButton(&#39; Acquiring Only&#39;)
        self.buttonsArea.addWidget(self.runAcquiringButton)
        self.runAcquiringButton.clicked.connect(lambda index: self.runAcquiring())
        self.runAcquiringButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_acq.png&#39;))
        
        
        self.interruptRunButton = QPushButton(&#39; Interrupt run&#39;)
        self.buttonsArea.addWidget(self.interruptRunButton)
        self.interruptRunButton.clicked.connect(lambda index: self.interruptRun())
        # self.runAcquiringButton.setIcon(QIcon(self.iconFolder+os.sep+&#39;Start_acq.png&#39;))
        
        # self.runScoringPlusAcqButton = QPushButton(&#39;Run Scoring + Acq&#39;)
        # self.buttonsArea.addWidget(self.runScoringPlusAcqButton)
        # self.runScoringPlusAcqButton.clicked.connect(lambda index: self.runScoring())
        
        # self.debugScoringButton = QPushButton(&#39;Debug Scoring&#39;)
        # self.buttonsArea.addWidget(self.debugScoringButton)
        # self.debugScoringButton.clicked.connect(lambda index: self.debugScoring())
        
        #Push buttons to top
        self.buttonsArea.addStretch()
        
        self.globalVariables={}
        self.globalVariables[&#39;TrialGlobalVariable&#39;]={}
        self.globalVariables[&#39;TrialGlobalVariable&#39;][&#39;type&#39;] = str
        self.globalVariables[&#39;TrialGlobalVariable&#39;][&#39;data&#39;] = &#39;test&#39;
        self.globalVariables[&#39;TrialGlobalVariable&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        self.globalVariables[&#39;XY_pos_measurementArray&#39;]={}
        self.globalVariables[&#39;XY_pos_measurementArray&#39;][&#39;type&#39;] = [np.ndarray,list]
        self.globalVariables[&#39;XY_pos_measurementArray&#39;][&#39;data&#39;] = []
        self.globalVariables[&#39;XY_pos_measurementArray&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        
        
        #import qgroupbox:
        from qtpy.QtWidgets import QGroupBox    
    
        #Create a tab widget:
        self.tabWidget = QTabWidget()
        
        self.decision_groupbox = QGroupBox(&#34;Decision Widget&#34;)
        # self.buttonsArea.addWidget(self.decision_groupbox)
        self.decisionWidget = DecisionWidget(nodzinstance=self)
        self.decision_groupbox.setLayout(self.decisionWidget.layout())
        
        self.scanwidget_groupbox = QGroupBox(&#34;Scan Widget&#34;)
        newgridlayout = QGridLayout()
        self.scanwidget_groupbox.setLayout(newgridlayout)
        self.scanningWidget = ScanningWidget(nodzinstance=self)
        newgridlayout.addWidget(self.scanningWidget)
        
        self.variablesWidgetGroupbox = QGroupBox(&#34;Variables&#34;)
        newgridlayout = QGridLayout()
        self.variablesWidgetGroupbox.setLayout(newgridlayout)
        self.variablesWidget = VariablesWidget(nodzinstance=self)
        newgridlayout.addWidget(self.variablesWidget)
        
        self.loggerINFOGroupBox = QGroupBox(&#34;Logger&#34;)
        newgridlayout = QGridLayout()
        self.loggerINFOGroupBox.setLayout(newgridlayout)
        self.loggerINFOWidget = LoggerWidget(logLevel=&#39;INFO&#39;)
        newgridlayout.addWidget(self.loggerINFOWidget)
        
        self.loggerDEBUGGroupBox = QGroupBox(&#34;LoggerDEBUG&#34;)
        newgridlayout = QGridLayout()
        self.loggerDEBUGGroupBox.setLayout(newgridlayout)
        self.loggerDEBUGWidget = LoggerWidget(logLevel=&#39;DEBUG&#39;)
        self.loggerDEBUGupdateButton = QPushButton(&#39;Update&#39;)
        self.loggerDEBUGupdateButton.clicked.connect(lambda index: self.loggerDEBUGWidget.update_log_content())
        newgridlayout.addWidget(self.loggerDEBUGWidget)
        newgridlayout.addWidget(self.loggerDEBUGupdateButton)
        
        
        
        def quickStartMenu(self):
            &#34;&#34;&#34;
            Shows the UserManual.md file
            &#34;&#34;&#34;
            try:
                quickStartWindow = utils.SmallWindow(self)
                QApplication.processEvents()
                quickStartWindow.setWindowTitle(&#39;Quick start / User Manual&#39;)
                QApplication.processEvents()
                
                if is_pip_installed():
                    package_path = os.path.dirname(glados_pycromanager.__file__)
                    quickStartWindow.addMarkdown(os.path.join(package_path, &#39;Documentation&#39;, &#39;UserManual.md&#39;))
                else:
                    quickStartWindow.addMarkdown(&#39;glados-pycromanager/glados_pycromanager/Documentation/UserManual.md&#39;)
                QApplication.processEvents()
                quickStartWindow.show()
            except Exception as e:
                logging.error(f&#39;Could not open quick start window. {e}&#39;)
        
        self.helpGroupBox = QGroupBox(&#34;Logger&#34;)
        newgridlayout = QGridLayout()
        self.helpGroupBox.setLayout(newgridlayout)
        #Add a User Manual Button:
        newgridlayout.addWidget(QLabel(&#39;Glados-Pycromanager\n\nCreated by Dr. Koen J.A. Martens\nkoenjamartens{at}gmail.com\n\nAutonomous microscopy is very much a work in progress!&#39;))
        button1 = QPushButton(&#39;User Manual&#39;)
        button1.clicked.connect(lambda index: quickStartMenu(self))
        newgridlayout.addWidget(button1)
        button2 = QPushButton(&#39;Developer Manual&#39;)
        newgridlayout.addWidget(button2)
        button3 = QPushButton(&#39;Complete software info&#39;)
        newgridlayout.addWidget(button3)
        
        # Create a QGraphicsView 
        self.graphics_view = CustomGraphicsView()
        super(GladosNodzFlowChart_dockWidget, self).__init__(parent=self.graphics_view)
        self.graphics_view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.defineNodeInfo()
        
        
        #One widget/layout has the nodz info and the buttons, the other has the tabWidget:
        self.NodzPlusButtonsWidget = QWidget()
        self.NodzPlusButtonsLayout = QGridLayout()
        self.NodzPlusButtonsWidget.setLayout(self.NodzPlusButtonsLayout)
        self.NodzPlusButtonsLayout.addWidget(self.graphics_view,0,0)
        self.NodzPlusButtonsLayout.addLayout(self.buttonsArea,0,1)
        self.NodzPlusButtonsLayout.setColumnStretch(0, 10)  # Give more stretch to graphics_view
        self.NodzPlusButtonsLayout.setColumnStretch(1, 1)   # Give less stretch to buttonsArea

        
        from PyQt5.QtWidgets import  QSplitter

        self.splitter = QSplitter()
        self.splitter.addWidget(self.NodzPlusButtonsWidget)
        self.splitter.addWidget(self.tabWidget)
        # Set a style sheet for the splitter handle to make it more visible
        self.splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background-color: #606060;
            }
        &#34;&#34;&#34;)
        
        self.mainLayout.addWidget(self.splitter)
        
        
        #Create a tab for the decision widget:
        self.tabWidget.addTab(self.decision_groupbox, &#34;Decision&#34;)
        self.tabWidget.addTab(self.scanwidget_groupbox, &#34;Scanning&#34;)
        self.tabWidget.addTab(self.variablesWidgetGroupbox, &#34;Variables&#34;)
        self.tabWidget.addTab(self.loggerINFOGroupBox, &#34;Logger&#34;)
        self.tabWidget.addTab(self.loggerDEBUGGroupBox, &#34;Debug&#34;)
        self.tabWidget.addTab(self.helpGroupBox, &#34;Help&#34;)
        
        #Global variables for MM/napari
        self.core = core
        self.shared_data = shared_data
        self.shared_data.nodzInstance = self
        self.MM_JSON=MM_JSON
        
        global nodz
        nodz = self
        self.initialize()
        self.show()
        #Needs these lines as init
        self.graphics_view.updateGraphicsViewSize()
        self.nodes = []
        self.nodeCounter={}
        self.preventAcq=False #Set to true if you want to prevent smart acquisition (i.e. scoring-only, never passing to acq)
        self.preventScoring=False #Set to true if you want to prevent smart scoring (i.e. init-only, never passing to scoring)
        
        #Connect required deleted/double clicked signals
        self.signal_NodeDeleted.connect(self.NodeRemoved)
        self.signal_NodeCreatedNodeItself.connect(self.NodeAdded)
        self.signal_NodeFullyInitialisedNodeItself.connect(self.NodeFullyInitialised)
        self.signal_NodeDoubleClicked.connect(self.NodeDoubleClicked)
        self.signal_PlugConnected.connect(self.PlugConnected)
        self.signal_PlugDisconnected.connect(self.PlugOrSocketDisconnected)
        self.signal_SocketConnected.connect(self.SocketConnected)
        
        
        self.signal_NodeMoved.connect(self.checkNodesOnErrors)
        self.signal_NodeEdited.connect(self.checkNodesOnErrors)
        self.signal_PlugConnectedStartConnection.connect(self.checkNodesOnErrors)
        self.signal_SocketConnectedStartConnection.connect(self.checkNodesOnErrors)
        self.signal_AttrEdited.connect(self.checkNodesOnErrors)
        self.signal_NodeFullyInitialisedNodeItself.connect(self.checkNodesOnErrors)
        self.signal_PlugDisconnected.connect(self.checkNodesOnErrors)
        self.signal_SocketDisconnected.connect(self.checkNodesOnErrors)
        
        
        #Handling of the CallAction threads belonging to nodes is done via a QThreadPool
        from PyQt5.QtCore import QThreadPool
        self.thread_pool = QThreadPool.globalInstance()
        
        #Focus on the nodes
        self._focus()
        
        
        self.coreVariables={}
        self.updateCoreVariables()
    
    #region NodzFlowChart Node Methods
    def defineNodeInfo(self):
        &#34;&#34;&#34;
        Define the node information for all nodes in the flowchart.

        This function is called once at the initialization of the flowchart.
        It returns a dictionary containing all nodes and their info.
        The info is used by the flowchart to create the nodes and their connections.
        
        It also contains layout information (colors and such)
        &#34;&#34;&#34;
        self.nodeInfo = {}
        
        #Order: ChangeMicroscope|AnalysisMethods|RealTimeThings|Logics|Reports|StartStops|Advanceds
        self.nodeInfo[&#39;__RightClickMenuNodeOrder__&#39;] = [
            &#39;acquisition&#39;,&#39;changeProperties&#39;,&#39;changeStagePos&#39;,&#39;|&#39;,
            &#39;analysisMeasurement&#39;,&#39;customFunction&#39;,&#39;storeData&#39;,&#39;timer&#39;,&#39;|&#39;,
            &#39;realTimeAnalysis&#39;,&#39;visualisation&#39;,&#39;|&#39;,
            &#39;newGlobalVar&#39;,&#39;changeGlobalVar&#39;,&#39;caseSwitch&#39;,&#39;ifStatement&#39;,&#39;ANDlogic&#39;,&#39;|&#39;,
            &#39;slackReport&#39;,&#39;stickyNote&#39;,&#39;|&#39;,
            &#39;initStart&#39;,&#39;initEnd&#39;,&#39;scoringStart&#39;,&#39;scoringEndVar&#39;,&#39;earlyScoreFail&#39;,&#39;acqStart&#39;,&#39;acqEnd&#39;,&#39;|&#39;,
            &#39;runInlineScript&#39;,&#39;analysisMeasurementDEBUG&#39;]
        #If we miss any in here, they&#39;ll be added at the bottom in later logic
        #  
        
        #We define the node info for each type of node like this: (might be expanded in the future)
        self.nodeInfo[&#39;acquisition&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;acquisition&#39;][&#39;name&#39;] = &#39;acquisition&#39;
        self.nodeInfo[&#39;acquisition&#39;][&#39;displayName&#39;] = &#39;Acquisition&#39;
        self.nodeInfo[&#39;acquisition&#39;][&#39;startAttributes&#39;] = [&#39;Acquisition start&#39;]
        self.nodeInfo[&#39;acquisition&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;acquisition&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;,&#39;Real-time&#39;]
        
        self.nodeInfo[&#39;changeProperties&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;changeProperties&#39;][&#39;name&#39;] = &#39;changeProperties&#39;
        self.nodeInfo[&#39;changeProperties&#39;][&#39;displayName&#39;] = &#39;Change Properties&#39;
        self.nodeInfo[&#39;changeProperties&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;changeProperties&#39;][&#39;finishedAttributes&#39;] = [&#39;Done&#39;]
        
        self.nodeInfo[&#39;visualisation&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;visualisation&#39;][&#39;name&#39;] = &#39;visualisation&#39;
        self.nodeInfo[&#39;visualisation&#39;][&#39;displayName&#39;] = &#39;Visualisation&#39;
        self.nodeInfo[&#39;visualisation&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;visualisation&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;stickyNote&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;stickyNote&#39;][&#39;name&#39;] = &#39;stickyNote&#39;
        self.nodeInfo[&#39;stickyNote&#39;][&#39;displayName&#39;] = &#39;Sticky Note&#39;
        self.nodeInfo[&#39;stickyNote&#39;][&#39;NodeSize&#39;] = 70
        
        self.nodeInfo[&#39;realTimeAnalysis&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;name&#39;] = &#39;realTimeAnalysis&#39;
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;displayName&#39;] = &#39;Real-Time analysis&#39;
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;NodeSize&#39;] = 60
        
        # self.nodeInfo[&#39;reporting&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;reporting&#39;][&#39;name&#39;] = &#39;reporting&#39;
        # self.nodeInfo[&#39;reporting&#39;][&#39;displayName&#39;] = &#39;Report&#39;
        # self.nodeInfo[&#39;reporting&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
        # self.nodeInfo[&#39;reporting&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;changeStagePos&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;name&#39;] = &#39;changeStagePos&#39;
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;displayName&#39;] = &#39;Change Stage Position&#39;
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;finishedAttributes&#39;] = [&#39;Done&#39;]
        self.nodeInfo[&#39;changeStagePos&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;analysisMeasurement&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;name&#39;] = &#39;analysisMeasurement&#39;
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;displayName&#39;] = &#39;Analysis [Measurement]&#39;
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        # self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
        self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;]
        
        self.nodeInfo[&#39;customFunction&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;customFunction&#39;][&#39;name&#39;] = &#39;customFunction&#39;
        self.nodeInfo[&#39;customFunction&#39;][&#39;displayName&#39;] = &#39;Custom Function&#39;
        self.nodeInfo[&#39;customFunction&#39;][&#39;startAttributes&#39;] = [&#39;Function start&#39;]
        self.nodeInfo[&#39;customFunction&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        
        # self.nodeInfo[&#39;analysisShapes&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;name&#39;] = &#39;analysisShapes&#39;
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;displayName&#39;] = &#39;Analysis [Shapes]&#39;
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        # self.nodeInfo[&#39;analysisShapes&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
        
        # self.nodeInfo[&#39;analysisImages&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;name&#39;] = &#39;analysisImages&#39;
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;displayName&#39;] = &#39;Analysis [Images]&#39;
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        # self.nodeInfo[&#39;analysisImages&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
        
        self.nodeInfo[&#39;scoringStart&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;scoringStart&#39;][&#39;name&#39;] = &#39;scoringStart&#39;
        self.nodeInfo[&#39;scoringStart&#39;][&#39;displayName&#39;] = &#39;Scoring start&#39;
        self.nodeInfo[&#39;scoringStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;scoringStart&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;scoringStart&#39;][&#39;NodeSize&#39;] = 60
        
        # self.nodeInfo[&#39;scoringEnd&#39;] = self.singleNodeTypeInit()
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;name&#39;] = &#39;scoringEnd&#39;
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;displayName&#39;] = &#39;Scoring end&#39;
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;bottomAttributes&#39;] = [&#39;Report&#39;]
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
        # self.nodeInfo[&#39;scoringEnd&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;scoringEndVar&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;name&#39;] = &#39;scoringEndVar&#39;
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;displayName&#39;] = &#39;Scoring end&#39;
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;scoringEndVar&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;earlyScoreFail&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;name&#39;] = &#39;earlyScoreFail&#39;
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;displayName&#39;] = &#39;Early score end&#39;
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;acqStart&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;acqStart&#39;][&#39;name&#39;] = &#39;acqStart&#39;
        self.nodeInfo[&#39;acqStart&#39;][&#39;displayName&#39;] = &#39;Acquiring start&#39;
        self.nodeInfo[&#39;acqStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;acqStart&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;acqStart&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;acqEnd&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;acqEnd&#39;][&#39;name&#39;] = &#39;acqEnd&#39;
        self.nodeInfo[&#39;acqEnd&#39;][&#39;displayName&#39;] = &#39;Acquiring end&#39;
        self.nodeInfo[&#39;acqEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;acqEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;acqEnd&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;initStart&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;initStart&#39;][&#39;name&#39;] = &#39;initStart&#39;
        self.nodeInfo[&#39;initStart&#39;][&#39;displayName&#39;] = &#39;Initialisation start&#39;
        self.nodeInfo[&#39;initStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;initStart&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;initStart&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;initEnd&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;initEnd&#39;][&#39;name&#39;] = &#39;initEnd&#39;
        self.nodeInfo[&#39;initEnd&#39;][&#39;displayName&#39;] = &#39;Initialisation end&#39;
        self.nodeInfo[&#39;initEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
        self.nodeInfo[&#39;initEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
        self.nodeInfo[&#39;initEnd&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;timer&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;timer&#39;][&#39;name&#39;] = &#39;timer&#39;
        self.nodeInfo[&#39;timer&#39;][&#39;displayName&#39;] = &#39;Timer&#39;
        self.nodeInfo[&#39;timer&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;timer&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;timer&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;storeData&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;storeData&#39;][&#39;name&#39;] = &#39;storeData&#39;
        self.nodeInfo[&#39;storeData&#39;][&#39;displayName&#39;] = &#39;Store Data&#39;
        self.nodeInfo[&#39;storeData&#39;][&#39;startAttributes&#39;] = [&#39;Store&#39;]
        self.nodeInfo[&#39;storeData&#39;][&#39;finishedAttributes&#39;] = [&#39;Stored&#39;]
        self.nodeInfo[&#39;storeData&#39;][&#39;NodeSize&#39;] = 40
        
        self.nodeInfo[&#39;newGlobalVar&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;name&#39;] = &#39;newGlobalVar&#39;
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;displayName&#39;] = &#39;New Global Variable&#39;
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;newGlobalVar&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;changeGlobalVar&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;name&#39;] = &#39;changeGlobalVar&#39;
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;displayName&#39;] = &#39;Change Global Variable&#39;
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;ifStatement&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;ifStatement&#39;][&#39;name&#39;] = &#39;ifStatement&#39;
        self.nodeInfo[&#39;ifStatement&#39;][&#39;displayName&#39;] = &#39;If-statement&#39;
        self.nodeInfo[&#39;ifStatement&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;ifStatement&#39;][&#39;finishedAttributes&#39;] = [&#39;Succeed&#39;,&#39;Fail&#39;]
        self.nodeInfo[&#39;ifStatement&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;runInlineScript&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;name&#39;] = &#39;runInlineScript&#39;
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;displayName&#39;] = &#39;Run advanced script&#39;
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;runInlineScript&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        
        self.nodeInfo[&#39;caseSwitch&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;name&#39;] = &#39;caseSwitch&#39;
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;displayName&#39;] = &#39;Case/Switch&#39;
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;finishedAttributes&#39;] = [&#39;Error&#39;]
        self.nodeInfo[&#39;caseSwitch&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;slackReport&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;slackReport&#39;][&#39;name&#39;] = &#39;slackReport&#39;
        self.nodeInfo[&#39;slackReport&#39;][&#39;displayName&#39;] = &#39;Slack Report&#39;
        self.nodeInfo[&#39;slackReport&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
        self.nodeInfo[&#39;slackReport&#39;][&#39;finishedAttributes&#39;] = [&#39;Send&#39;]
        self.nodeInfo[&#39;slackReport&#39;][&#39;NodeSize&#39;] = 60
        
        self.nodeInfo[&#39;ANDlogic&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;name&#39;] = &#39;ANDlogic&#39;
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;displayName&#39;] = &#39;AND-Logic&#39;
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;startAttributes&#39;] = [&#39;In&#39;]
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;finishedAttributes&#39;] = [&#39;Out&#39;]
        self.nodeInfo[&#39;ANDlogic&#39;][&#39;NodeSize&#39;] = 30
        
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;] = self.singleNodeTypeInit()
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;name&#39;] = &#39;analysisMeasurementDEBUG&#39;
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;displayName&#39;] = &#39;DEBUG Analysis [Measurement]&#39;
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
        self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;]
        
        #We also add some custom JSON info about the node layout (colors and such)
        import json
        #NOTE: taking a lot of these by grouping-colors. I.e. I create one color (acquisition), then for others in the same &#39;group&#39;, I use analogous scheme of colorffy.com
        self.nodeLayout = json.loads(&#39;&#39;&#39;{
            
            &#34;scoringStart&#34;: {
                &#34;bg&#34;: [80, 180, 80, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;scoringEnd&#34;: {
                &#34;bg&#34;: [120, 180, 120, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;scoringEndVar&#34;: {
                &#34;bg&#34;: [120, 180, 120, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;earlyScoreFail&#34;: {
                &#34;bg&#34;: [220, 180, 120, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            &#34;acqStart&#34;: {
                &#34;bg&#34;: [224, 195, 69, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;acqEnd&#34;: {
                &#34;bg&#34;: [234, 205, 109, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;initStart&#34;: {
                &#34;bg&#34;: [180, 80, 180, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;initEnd&#34;: {
                &#34;bg&#34;: [180, 120, 180, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            
            &#34;acquisition&#34;: {
                &#34;bg&#34;: [79, 79, 183, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;changeProperties&#34;: {
                &#34;bg&#34;: [121, 79, 183, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;changeStagePos&#34;: {
                &#34;bg&#34;: [79, 100, 183, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;analysisMeasurement&#34;: {
                &#34;bg&#34;: [240, 113, 103, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;customFunction&#34;: {
                &#34;bg&#34;: [240, 168, 103, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;storeData&#34;: {
                &#34;bg&#34;: [240, 140, 103, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;timer&#34;: {
                &#34;bg&#34;: [197, 93, 85, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;realTimeAnalysis&#34;: {
                &#34;bg&#34;: [63, 99, 129, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;visualisation&#34;: {
                &#34;bg&#34;: [63, 125, 129, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;reporting&#34;: {
                &#34;bg&#34;: [63, 129, 107, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;newGlobalVar&#34;: {
                &#34;bg&#34;: [123, 194, 112, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;changeGlobalVar&#34;: {
                &#34;bg&#34;: [134, 203, 151, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;caseSwitch&#34;: {
                &#34;bg&#34;: [112, 194, 134, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;ifStatement&#34;: {
                &#34;bg&#34;: [143, 184, 155, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;ANDlogic&#34;: {
                &#34;bg&#34;: [112, 194, 118, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;slackReport&#34;: {
                &#34;bg&#34;: [68, 129, 168, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;stickyNote&#34;: {
                &#34;bg&#34;: [230, 185, 5, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            
            
            &#34;runInlineScript&#34;: {
                &#34;bg&#34;: [179, 98, 122, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            },
            &#34;analysisMeasurementDEBUG&#34;: {
                &#34;bg&#34;: [162, 65, 98, 255],
                &#34;border&#34;: [50, 50, 50, 255],
                &#34;border_sel&#34;: [170, 80, 80, 255],
                &#34;text&#34;: [180, 180, 240, 255]
            }
            
            
            
        }&#39;&#39;&#39;)
        self.addConfig(self.nodeLayout)
    
    def performPostNodeCreation_Start(self,newNode,nodeType):
        &#34;&#34;&#34;
        Handles post-node-creation functions for nodes.

        This function handles post-node-creation functions for nodes, such as
        setting the node name and preset, and adding custom attributes.

        Args:
            newNode (nodz.Node): The newly created node.
            nodeType (str): The type of node that was created.
        &#34;&#34;&#34;
        if not newNode.createdFromLoading: #Normal case when it&#39;s simply created from the nodz canvas
            newNodeName = self.nodeInfo[nodeType][&#39;name&#39;]+&#34;_&#34;+str(self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;])
            #Increase the nodeCounter - use the neverReset one to completely eliminate options of same-named nodes ever
            self.nodeInfo[nodeType][&#39;NodeCounter&#39;]+=1
            self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;]+=1
        elif newNode.createdFromLoading: #Special case in case it&#39;s created from loading the whole graph
            newNodeName = newNode.name #Don&#39;t change the name
            self.nodeInfo[nodeType][&#39;NodeCounter&#39;]+=1
            #Get the node name:
            lastUnderscore = newNode.name.rfind(&#39;_&#39;)
            newNodeNumber = int(newNode.name[lastUnderscore+1:])
            #And set the nodecounterneverreset to be this value +1 or higher
            if self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] &lt; newNodeNumber+1:
                self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] = newNodeNumber+1
        newNode.flowChart = self
        if nodeType in self.config:
            configtype = nodeType
        else:
            configtype = &#39;node_preset_1&#39;
            
        
        #Change name, change sdisplayName, change preset:
        newNode.changeName(newNodeName)
        newNode.changeDisplayName(self.nodeInfo[nodeType][&#39;displayName&#39;])
        newNode.changePreset(configtype)
        
        self.nodes.append(newNode)
        
        self.updateNumberStartFinishedDataAttributes(newNode,nodeType)
        
        #Custom functions that should be done
        if nodeType == &#39;acquisition&#39;:
            #Attach a MDA data to this node
            parentV = None
            if self.parent is not None:
                parentV = self.parent
                
            
            #Set the variableNodz info, maybe later do this in seperate function?
            newNode.variablesNodz[&#39;data&#39;] = {}
            from ndtiff import NDTiffDataset
            newNode.variablesNodz[&#39;data&#39;][&#39;type&#39;] = [NDTiffDataset, np.ndarray]
            newNode.variablesNodz[&#39;data&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;data&#39;][&#39;importance&#39;] = &#39;Default&#39;
            newNode.variablesNodz[&#39;order&#39;] = {}
            newNode.variablesNodz[&#39;order&#39;][&#39;type&#39;] = [str]
            newNode.variablesNodz[&#39;order&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;order&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;exposure_ms&#39;] = {}
            newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;type&#39;] = [float]
            newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_timepoints&#39;] = {}
            newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;time_interval_ms&#39;] = {}
            newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;type&#39;] = [float]
            newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;xy_positions&#39;] = {}
            newNode.variablesNodz[&#39;xy_positions&#39;][&#39;type&#39;] = [np.ndarray]
            newNode.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;xy_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_xy_positions&#39;] = {}
            newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;z_positions&#39;] = {}
            newNode.variablesNodz[&#39;z_positions&#39;][&#39;type&#39;] = [np.ndarray]
            newNode.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;z_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_z_positions&#39;] = {}
            newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;channel_group&#39;] = {}
            newNode.variablesNodz[&#39;channel_group&#39;][&#39;type&#39;] = [str]
            newNode.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;channel_group&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;channels&#39;] = {}
            newNode.variablesNodz[&#39;channels&#39;][&#39;type&#39;] = [np.ndarray]
            newNode.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;channels&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;n_channels&#39;] = {}
            newNode.variablesNodz[&#39;n_channels&#39;][&#39;type&#39;] = [int]
            newNode.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;n_channels&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            newNode.variablesNodz[&#39;storage_path&#39;] = {}
            newNode.variablesNodz[&#39;storage_path&#39;][&#39;type&#39;] = [str]
            newNode.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = None
            newNode.variablesNodz[&#39;storage_path&#39;][&#39;importance&#39;] = &#39;Informative&#39;
            
            #Attach a MDA data to this node
            newNode.mdaData = MDAGlados(self.core,self.MM_JSON,None,self.shared_data,hasGUI=True,parent=parentV,node=newNode) # type: ignore
            
            #Initialise with showing only time.
            newNode.mdaData.GUI_show_channel = False
            newNode.mdaData.GUI_show_exposure = True
            newNode.mdaData.GUI_show_order = True
            newNode.mdaData.GUI_show_storage = False
            newNode.mdaData.GUI_show_time = True
            newNode.mdaData.GUI_show_xy = False
            newNode.mdaData.GUI_show_z = False
            
            #Do the acquisition upon callAction
            newNode.callAction = lambda self, node=newNode: node.mdaData.MDA_acq_from_Node(node)
            
            #Add the node emits of &#39;finishing&#39; upon MDA completion.
            #Also connect the node&#39;s finishedMDA
            #This order is important!
            newNode.mdaData.MDA_completed.connect(newNode.finishedmda)
            newNode.mdaData.MDA_completed.connect(lambda self, node = newNode: node.customFinishedEmits.emit_all_signals())
            #Note: the recorded MDA data is stored in node.mdaData.data - any analysis method should find/read this.
            #The core is at node.mdaData.core
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;realTimeAnalysis&#39;:
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;visualisation&#39;:
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;changeProperties&#39;:
            #attach MMconfigUI to this:
            # Get all config groups
            allConfigGroups={}
            nrconfiggroups = self.core.get_available_config_groups().size() #type:ignore
            for config_group_id in range(nrconfiggroups):
                allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
        
        
            newNode.MMconfigInfo = MMConfigUI(allConfigGroups,showConfigs = True,showStages=False,showROIoptions=False,showShutterOptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False,showCheckboxes = True,autoSaveLoad=False) # type: ignore
            
            #Add the callaction
            newNode.callAction = lambda self, node=newNode: self.MMconfigChangeRan(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;changeStagePos&#39;:
            # Get all config group s
            allConfigGroups={}
            nrconfiggroups = self.core.get_available_config_groups().size() #type:ignore
            for config_group_id in range(nrconfiggroups):
                allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
        
            newNode.MMconfigInfo = MMConfigUI(allConfigGroups,showConfigs = False,showStages=False,showROIoptions=False,showShutterOptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False,showCheckboxes = False,showRelativeStages = True, autoSaveLoad=False) # type: ignore
            
            #Add the callaction
            newNode.callAction = lambda self, node=newNode: self.MMstageChangeRan(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within 
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;customFunction&#39;:
            newNode.callAction = lambda self, node=newNode: self.CustomFunctionNode_started(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #initialise the scoring_analysis_currentData values:
            #Rather stupidly, but I create the double-click-dialog, but just never show it.
            dialog = nodz_customFunctionDialog(currentNode = newNode, parent = self)
            newNode.customFunction_currentData=dialog.currentData
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;analysisMeasurement&#39;:
            newNode.callAction = lambda self, node=newNode: self.AnalysisNode_started(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #initialise the scoring_analysis_currentData values:
            #Rather stupidly, but I create the double-click-dialog, but just never show it.
            dialog = nodz_analysisDialog(currentNode = newNode, parent = self)
            newNode.scoring_analysis_currentData=dialog.currentData
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;analysisMeasurementDEBUG&#39;:
            #This is a DEBUG type of analysis measurement which blocks the main thread, but allows for easier debugging.
            newNode.callAction = lambda self, node=newNode: self.AnalysisNode_DEBUG_started(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #initialise the scoring_analysis_currentData values:
            #Rather stupidly, but I create the double-click-dialog, but just never show it.
            dialog = nodz_analysisDialog(currentNode = newNode, parent = self)
            newNode.scoring_analysis_currentData=dialog.currentData
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;timer&#39;:
            newNode.callAction = lambda self, node=newNode: self.timerCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;storeData&#39;:
            newNode.callAction = lambda self, node=newNode: self.storeDataCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;changeGlobalVar&#39;:
            newNode.callAction = lambda self, node=newNode: self.changeGlobalVarCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;ifStatement&#39;:
            newNode.callAction = lambda self, node=newNode: self.ifStatementCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;newGlobalVar&#39;:
            newNode.callAction = lambda self, node=newNode: self.newGlobalVarCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;runInlineScript&#39;:
            newNode.callAction = lambda self, node=newNode: self.runInlineScriptCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;caseSwitch&#39;:
            newNode.callAction = lambda self, node=newNode: self.runCaseSwitchCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;slackReport&#39;:
            newNode.callAction = lambda self, node=newNode: self.runslackReportCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        elif nodeType == &#39;scoringStart&#39;:
            newNode.callAction = lambda self, node=newNode: self.scoringStart(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;scoringEnd&#39;:
            newNode.callAction = lambda self, node=newNode: self.scoringEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            #Update the decisionwidget after loading the scoringEnd node:
            self.decisionWidget.updateAllDecisions()
        elif nodeType == &#39;scoringEndVar&#39;:
            newNode.callAction = lambda self, node=newNode: self.scoringEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            #Update the decisionwidget after loading the scoringEnd node:
            self.decisionWidget.updateAllDecisions()
        elif nodeType == &#39;earlyScoreFail&#39;:
            newNode.callAction = lambda self, node=newNode: self.earlyScoringFail(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;earlyScoringFail&#39;)
        elif nodeType == &#39;acqEnd&#39;:
            newNode.callAction = lambda self, node=newNode: self.acquiringEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;initStart&#39;:
            newNode.callAction = lambda self, node=newNode: self.initStart(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;initEnd&#39;:
            newNode.callAction = lambda self, node=newNode: self.initEnd(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;ANDlogic&#39;:
            newNode.callAction = lambda self, node=newNode: self.and_logicCallAction(node)
            newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        elif nodeType == &#39;caseSwitch&#39;:
            #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
            if not newNode.createdFromLoading:
                self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
        else:
            newNode.callAction = None

        newNode.update()

    def nodeRan(self,node):
        &#34;&#34;&#34; 
        Function that&#39;s called at the start of every node
        Updates the core variables and the variables in the UI.
        &#34;&#34;&#34;
        try:
            self.update()
            # self.updateCoreVariables()
            self.variablesWidget.updateVariables()
        except:
            pass
        logging.debug(f&#39;Node with name {node.name} ran&#39;)

    def NodeDoubleClicked(self,nodeName):
        &#34;&#34;&#34;
        Handle double-clicking on a node in the flowchart.

        When a node is double-clicked, this function is called. Depending on the node, this 
        function will open a dialog to modify the node&#39;s data.
        &#34;&#34;&#34;
        currentNode = self.findNodeByName(nodeName)
        if &#39;acquisition&#39; in nodeName:
            dialog = nodz_openMDADialog(parentData=self,currentNode = currentNode)
            if dialog.exec_() == QDialog.Accepted:
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;acquisition&#39;)
                currentNode.dialogInfo = dialog #type:ignore
                logging.debug(f&#34;MDA dialog input: {dialog.getInputs()}&#34;)
            
            # currentNode.mdaData.exposure_ms = dialog.getExposureTime()
            # currentNode.mdaData.mda = dialog.getInputs()#type:ignore
            dialogmdaData = dialog.getmdaData()
            attrs_to_not_copy = [&#39;gui&#39;,&#39;core&#39;,&#39;shared_data&#39;,&#39;has_GUI&#39;,&#39;data&#39;,&#39;staticMetaObject&#39;,&#39;MDA_completed&#39;,&#39;MM_JSON&#39;]
            #Loop over all attributes in dialogmdaData:
            for attrs in vars(dialogmdaData):
                if attrs not in attrs_to_not_copy:
                    setattr(currentNode.mdaData,attrs,getattr(dialogmdaData,attrs)) #type:ignore
            
            currentNode.update() #type:ignore
        elif &#39;changeProperties&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #Show dialog:
            if &#39;MMconfigInfo&#39; in vars(currentNode):
                storedConfigsStrings = currentNode.MMconfigInfo.config_string_storage #type: ignore
            else:
                currentNode.MMconfigInfo = [] #type: ignore
                storedConfigsStrings = None
            dialog = nodz_openMMConfigDialog(parentNode=currentNode,storedConfigsStrings = storedConfigsStrings) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeProperties&#39;)
                #Update the results of this dialog into the nodz node   
                self.changeConfigStorageInNodz(currentNode,dialog.ConfigsToBeChanged())
        elif &#39;visualisation_&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #Show dialog:
            dialog = nodz_visualisationDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;visualisation&#39;)
                currentNode.visualisation_currentData[&#39;layerName&#39;] = dialog.layerNameEdit.text() #type:ignore
                currentNode.visualisation_currentData[&#39;colormap&#39;] = dialog.colormapComboBox.currentText() #type:ignore
        elif &#39;changeStagePos&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #Show dialog:
            if &#39;MMconfigInfo&#39; in vars(currentNode):
                storedRelStagesString = currentNode.MMconfigInfo.relstage_string_storage #type: ignore
            else:
                currentNode.MMconfigInfo = [] #type: ignore
                storedRelStagesString = None
            dialog = nodz_openMMConfigDialog(parentNode=currentNode,storedrelStagesString = storedRelStagesString) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                #Update the results of this dialog into the nodz node
                self.changeRelStageStorageInNodz(currentNode,dialog.RelStageInfo())
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeStagePos&#39;)
                
        elif &#39;analysisMeasurement&#39; in nodeName or &#39;analysisMeasurementDEBUG&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            dialog = nodz_analysisDialog(currentNode = currentNode, parent = self)
            if dialog.exec_() == QDialog.Accepted:
                
                #Update the results of this dialog into the nodz node
                currentNode.scoring_analysis_currentData = dialog.currentData #type:ignore
                utils.analysis_outputs_to_variableNodz(currentNode)
                try:
                    currentNode.dialogInfo = dialog #type:ignore
                    self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;analysisMeasurement&#39;)
                except:
                    logging.warning(&#39;Failed to set text in analysisMeasurementDialog&#39;)
                logging.debug(&#39;Pressed OK on analysisMeasurementDialog&#39;)
        elif &#39;customFunction&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            dialog = nodz_customFunctionDialog(currentNode = currentNode, parent = self)
            if dialog.exec_() == QDialog.Accepted:
                #Update the results of this dialog into the nodz node
                currentNode.customFunction_currentData = dialog.currentData #type:ignore
                utils.customFunction_outputs_to_variableNodz(currentNode)
                try:
                    currentNode.dialogInfo = dialog #type:ignore
                    self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;customFunction&#39;)
                except:
                    logging.warning(&#39;Failed to set text in analysisMeasurementDialog&#39;)
                logging.debug(&#39;Pressed OK on customFunctionDialog&#39;)
            
            
        elif &#39;realTimeAnalysis&#39; in nodeName:
            currentNode = self.findNodeByName(nodeName)
            #TODO: pre-load dialog.currentData with currentNode.currentData if that exists (better naming i guess) to hold all pre-selected data 
            dialog = nodz_realTimeAnalysisDialog(currentNode = currentNode, parent = self)
            if dialog.exec_() == QDialog.Accepted:
                #Update the results of this dialog into the nodz node
                currentNode.real_time_analysis_currentData = dialog.currentData #type:ignore
                currentNode.real_time_analysis_currentData[&#39;__selectedDropdownEntryRTAnalysis__&#39;] = dialog.comboBox_RTanalysisFunctions.currentText() #type:ignore
                currentNode.real_time_analysis_currentData[&#39;__realTimeVisualisation__&#39;] = dialog.visualisationBox.isChecked() #type:ignore 
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;RTanalysisMeasurement&#39;)
                logging.debug(&#39;Pressed OK on RTanalysis&#39;)
                
        elif &#39;timer&#39; in nodeName:
            dialog = nodz_openTimerDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.timerInfo = dialog.timerInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;timer&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;storeData&#39; in nodeName:
            dialog = nodz_openStoreDataDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.storeDataInfo = dialog.storeDataInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;storeData&#39;)
        elif &#39;changeGlobalVar&#39; in nodeName:
            dialog = nodz_openChangeGlobalVarDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.changeGlobalVarInfo = dialog.changeGlobalVarInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeGlobalVar&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;ifStatement&#39; in nodeName:
            dialog = nodz_openIfStatementDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.ifStatementInfo = dialog.ifStatementInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;ifStatement&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;newGlobalVar&#39; in nodeName:
            dialog = nodz_openNewGlobalVarDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.newGlobalVarInfo = dialog.newGlobalVarInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;newGlobalVar&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;runInlineScript&#39; in nodeName:
            dialog = nodz_openInlineScriptDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.InlineScriptInfo = dialog.InlineScriptInfo #type:ignore
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;runInlineScript&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;caseSwitch&#39; in nodeName:
            dialog = nodz_caseSwitchDialog(parentNode=currentNode,currentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                dialogLineEdits = []
                for lineEdit in dialog.lineEdits:
                    dialogLineEdits.append(lineEdit.text())
                self.update_plugs_fromDialog(currentNode,dialogLineEdits)
                
                currentNode.caseSwitchInfo = dialog.caseSwitchInfo
                currentNode.caseSwitchInfo[&#39;Plugs&#39;] = dialogLineEdits
                
                #Update the node itself
                self.update()
                nodeType = self.nodeLookupName_withoutCounter(nodeName)
                for _ in range(3):
                    self.updateNumberStartFinishedDataAttributes(currentNode,nodeType)
                    self.update()
                
                logging.debug(dialogLineEdits)
                logging.debug(&#39;Pressed OK on caseSwitch&#39;)
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;caseSwitch&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;slackReport&#39; in nodeName:
            dialog = nodz_slackReportDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.slackReportInfo = dialog.slackReportInfo
                logging.debug(&#39;Pressed OK on caseSwitch&#39;)
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;slackReport&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;stickyNote&#39; in nodeName:
            dialog = nodz_stickyNoteDialog(parentNode=currentNode) #type:ignore
            if dialog.exec_() == QDialog.Accepted:
                currentNode.stickyNoteInfo = dialog.stickyNoteInfo
                logging.debug(&#39;Pressed OK on stickyNote&#39;)
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;stickyNote&#39;)
            # currentNode.callAction(self) #type:ignore
        elif &#39;scoringStart&#39; in nodeName:
            currentNode.callAction(self) #type:ignore
        elif &#39;scoringEndVar&#39; in nodeName:
            dialog = nodz_openScoringEndVarDialog(parent=self,currentNode=currentNode)
            if dialog.exec_() == QDialog.Accepted:
                #Update the decisionwidget:
                self.decisionWidget.updateAllDecisions()
                logging.debug(&#39;Pressed OK on scoringEndVar&#39;)
        elif &#39;scoringEnd&#39; in nodeName:
            dialog = nodz_openScoringEndDialog(parent=self,currentNode=currentNode)
            if dialog.exec_() == QDialog.Accepted:
                dialogLineEdits = []
                for lineEdit in dialog.lineEdits:
                    dialogLineEdits.append(lineEdit.text())
                self.update_scoring_end(currentNode,dialogLineEdits)
                #Update the node itself
                self.update()
                nodeType = self.nodeLookupName_withoutCounter(nodeName)
                self.updateNumberStartFinishedDataAttributes(currentNode,nodeType)
                self.update()
                
                #Update the decisionwidget:
                self.decisionWidget.updateAllDecisions()
                logging.debug(dialogLineEdits)
                logging.debug(&#39;Pressed OK on scoringEnd&#39;)
    
    def singleNodeTypeInit(self):
        &#34;&#34;&#34; 
        Initialise the info for a single node type. Hand-in-hand with defineNodeInfo.
        &#34;&#34;&#34;
        init = {}
        init[&#39;name&#39;] = &#39;name&#39;
        init[&#39;displayName&#39;] = &#39;DisplayName&#39;
        init[&#39;startAttributes&#39;] = []
        init[&#39;finishedAttributes&#39;] = []
        init[&#39;dataAttributes&#39;] = []
        init[&#39;bottomAttributes&#39;] = []
        init[&#39;topAttributes&#39;] = []
        init[&#39;NodeCounter&#39;] = 0
        init[&#39;NodeCounterNeverReset&#39;] = 0
        init[&#39;MaxNodeCounter&#39;] = np.inf
        init[&#39;NodeSize&#39;] = 100
        return init

    def NodeAdded(self,node):
        &#34;&#34;&#34;
        Handle when one or more nodes are created in the flowchart.

        When one or more nodes are created in the flowchart, this function is called.
        It does some pre-processing of the node and then calls performPostNodeCreation_Start.
        &#34;&#34;&#34;
        logging.debug(&#39;one or more nodes are created!&#39;)
        nodeType = self.nodeLookupName_withoutCounter(node.name)
        self.performPostNodeCreation_Start(node,nodeType)
        self.checkNodesOnErrors()

    def NodeFullyInitialised(self,node):
        &#34;&#34;&#34;
        Handle when a node is fully initialised.
        
        Specifically, when all e.g. data[&#39;NODES_SCORING_SCORING&#39;] from loading is added to the node, only after that, this will run.

        This function is called when a node is fully initialised. It does some
        post-initialisation processing for nodes based on their type.

        Parameters
        ----------
        node : Node
            The node that has been fully initialised.
        &#34;&#34;&#34;
        nodeType = self.nodeLookupName_withoutCounter(node.name)
        if nodeType == &#39;scoringEnd&#39;:
            self.update_scoring_end(node,node.scoring_end_currentData[&#39;Variables&#39;])
        if nodeType == &#39;caseSwitch&#39;:
            if &#39;Plugs&#39; in node.caseSwitchInfo:
                self.update_plugs_fromDialog(node,node.caseSwitchInfo[&#39;Plugs&#39;])
                
        self.checkNodesOnErrors()

    def NodeRemoved(self,nodeNames):
        &#34;&#34;&#34;
        Handle when one or more nodes are removed from the flowchart.

        When one or more nodes are removed from the flowchart, this function is called.
        It will update the node counters of the corresponding node types.
        &#34;&#34;&#34;
        logging.debug(&#39;one or more nodes are removed!&#39;)
        for nodeName in nodeNames:
            for node_type, node_data in self.nodeInfo.items():
                if node_type != &#39;__RightClickMenuNodeOrder__&#39;:
                    try:
                        if node_data[&#39;name&#39;] in nodeName:
                            # if self.nodeInfo[node_type][&#39;MaxNodeCounter&#39;] &lt; np.inf:
                            self.nodeInfo[node_type][&#39;NodeCounter&#39;] -= 1
                    except:
                        pass
            #Also remove from self.nodes:
            node = self.findNodeByName(nodeName)
            try:
                self.nodes.remove(node)
            except:
                logging.warning(f&#34;failed to remove node: {nodeName}&#34;)
        self.checkNodesOnErrors()
    
    def finishedEmits(self,node):
        &#34;&#34;&#34;
        This function emits the customFinishedEmits signal of a node, and allt he customDataEmits

        Args:
            node (nodz.Node): The node that needs to finish.

        Returns:
            None
        &#34;&#34;&#34;
        self.updateCoreVariables()
        node.status=&#39;finished&#39;
        self.shared_data.warningErrorInfoInfo[&#39;Info&#39;][&#39;LastNodeRan&#39;] = node.name
        
        self.update()
        if node.customFinishedEmits is not None and len(node.customFinishedEmits.signals)&gt;0:
            node.customFinishedEmits.emit_all_signals()
        if node.customDataEmits is not None and len(node.customDataEmits.signals)&gt;0:
            node.customDataEmits.emit_all_signals()

        if &#39;dialogInfo&#39; in vars(node):
            self.set_readable_text_after_dialogChange(node,node.dialogInfo)

    def giveInfoOnNode(self,node):
        &#34;&#34;&#34;
        Prints information about a node in the flowchart

        This function prints some basic information about a node in the flowchart.

        Args:
            node (nodz.Node): The node to get information about.

        Returns:
            None
        &#34;&#34;&#34;
        logging.info(&#39;--------&#39;)
        logging.info(node)
        logging.info(f&#34;node name: {node.name}&#34;)
        logging.info(f&#34;incoming connections: {node.n_connect_at_start}&#34; )
    #endregion
    
    #region NodzFlowChart Helpers
    def obtainAllNodes(self):
        &#34;&#34;&#34; 
        Obtain all nodes, return them
        &#34;&#34;&#34;
        return self.nodes
    
    def updateNumberStartFinishedDataAttributes(self,newNode,nodeType):
        &#34;&#34;&#34;
        Updates custom attributes for a new node based on the specified node type.
        
        Args:
            newNode: The new node to update custom attributes for.
            nodeType: The type of the node to determine which custom attributes to update.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        if len(self.nodeInfo[nodeType][&#39;startAttributes&#39;]) &gt; 0:
            newNode.customStartEmits = NodeSignalManager()
        else:
            newNode.customStartEmits = None
        if len(self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]) &gt; 0:
            newNode.customFinishedEmits = NodeSignalManager()
        else:
            newNode.customFinishedEmits = None
        if len(self.nodeInfo[nodeType][&#39;dataAttributes&#39;]) &gt; 0:
            newNode.customDataEmits = NodeSignalManager()
        else:
            newNode.customDataEmits = None
        if len(self.nodeInfo[nodeType][&#39;bottomAttributes&#39;]) &gt; 0:
            newNode.customBottomEmits = NodeSignalManager()
        else:
            newNode.customBottomEmits = None
        if len(self.nodeInfo[nodeType][&#39;topAttributes&#39;]) &gt; 0:
            newNode.customTopEmits = NodeSignalManager()
        else:
            newNode.customTopEmits = None
            
        #Add custom attributes where necessary
        for attr in self.nodeInfo[nodeType][&#39;startAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=True)
            newNode.customStartEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=True, socket=False)
            newNode.customFinishedEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;dataAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=True, socket=False)
            newNode.customDataEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;bottomAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=False, bottomAttr=True)
            newNode.customBottomEmits.add_signal(attr) #type: ignore
        for attr in self.nodeInfo[nodeType][&#39;topAttributes&#39;]:
            self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=False, topAttr=True)
            newNode.customTopEmits.add_signal(attr) #type: ignore
        
        logging.debug(&#34;updated custom attributes&#34;)
    
    def advNodeInfo(self,node,event):
        &#34;&#34;&#34;
        Show advanced information about a node in a popup window.
        
        Args:
            node: The node object for which advanced information is to be displayed.
            event: The event triggering the display of advanced information.
        
        Returns:
            None
        &#34;&#34;&#34;
        #Create a quick popup window with a line edit and an ok/cancel:
        dialog = QDialog()
        dialog.setWindowTitle(&#39;Node info&#39;)
        dialog.setModal(True)
        layout = QVBoxLayout(dialog)

        
        textEdit = QTextEdit()
        
        attrs_to_show = [&#39;name&#39;,&#39;displayName&#39;,&#39;nodePreset&#39;,&#39;plugs&#39;,&#39;sockets&#39;,&#39;scoring_analysis_currentData&#39;,&#39;scoring_end_currentData&#39;,&#39;scoring_scoring_currentData&#39;,&#39;scoring_visualisation_currentData&#39;,&#39;visualisation_currentData&#39;,&#39;real_time_analysis_currentData&#39;]
        
        text_to_show = &#39;&#39;
        for attr in attrs_to_show:
            if hasattr(node,attr):
                text_to_show += f&#39;{attr}: {str(getattr(node,attr))}\n&#39;
        
        #Custom add these ones:
        if hasattr(node,&#39;mdaData&#39;):
            if hasattr(node.mdaData,&#39;mda&#39;):
                text_to_show += f&#39;mda: {str(node.mdaData.mda)}\n&#39;
        if hasattr(node,&#39;MMconfigInfo&#39;):
            if hasattr(node.MMconfigInfo,&#39;config_string_storage&#39;):
                text_to_show += f&#39;config_string_storage: {str(node.MMconfigInfo.config_string_storage)}\n&#39;
        
        textEdit.setText(text_to_show)
        layout.addWidget(textEdit)

        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok, dialog)
        layout.addWidget(buttonBox)

        buttonBox.accepted.connect(dialog.accept)
        
        if dialog.exec_() == QDialog.Accepted:
            logging.debug(&#39;advanced node info closed&#39;)

    def explore_attributes(self, obj, indent=0):
        &#34;&#34;&#34;
        Recursively print the attributes of an object.

        This function is used for debugging purposes to explore the attributes of an object.
        It will print the attributes of `obj` and all of its sub-attributes, up to a maximum
        depth of 20.

        Parameters
        ----------
        obj : object
            The object to explore
        indent : int, optional
            The indentation level, by default 0
        &#34;&#34;&#34;
        if indent &lt; 20:
            attributes = vars(obj)
            for attr_name in attributes:
                if not attr_name.startswith(&#39;_&#39;):
                    attr = getattr(obj, attr_name)
                    if not callable(attr):
                        logging.debug(&#34; &#34; * indent + attr_name)
                    else:
                        logging.debug(&#34; &#34; * indent + attr_name + &#39;()&#39;)
                    if hasattr(attr, &#39;__dict__&#39;):
                        self.explore_attributes(attr, indent + 2)
                # except:
                #     pass

    def nodeLookupName_withoutCounter(self,nodeName):
        &#34;&#34;&#34;
        Returns the node name without the counter suffix.

        Given a node name like &#34;MyNode_0&#34; this function returns &#34;MyNode&#34;.

        Parameters
        ----------
        nodeName : str
            The node name to strip the counter from.

        Returns
        -------
        str
            The node name without the counter suffix.
        &#34;&#34;&#34;
        #Find the last underscore (&#39;_0, _1, etc&#39;)
        index_last_underscore = nodeName.rfind(&#39;_&#39;)
        nodeNameNC = nodeName[:index_last_underscore]
        finalNodeName=None
        #Now get the correct lookup name by looking through all nodeInfo items
        for node_name, node_data in self.nodeInfo.items():
            # Check if the name matches the specific value
            if &#39;name&#39; in node_data and node_data[&#39;name&#39;] == nodeNameNC:
                finalNodeName = node_name
        
        return finalNodeName
    
    def findNodeByName(self, name):
        &#34;&#34;&#34;
        Function to find a node based on its name attribute

        Args:
            name (str): The name of the node to find

        Returns:
            nodz.node: The node with the given name or None if not found
        &#34;&#34;&#34;
        for node in self.nodes:
            #check if the attribute &#39;name&#39; is found:
            if hasattr(node, &#39;name&#39;):
                if node.name == name:
                    return node
        return None
    
    def changeNodeName(self, node, event):
        &#34;&#34;&#34;
        Change the name of a node.
        
        Args:
            node: The node whose name will be changed.
            event: The event triggering the name change.
        
        Returns:
            None
        &#34;&#34;&#34;
        #Create a quick popup window with a line edit and an ok/cancel:
        dialog = QDialog()
        dialog.setWindowTitle(&#39;Change node name&#39;)
        dialog.setModal(True)
        layout = QVBoxLayout(dialog)

        lineEdit = QLineEdit()
        lineEdit.setText(node.displayName)
        layout.addWidget(lineEdit)

        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, Qt.Horizontal, dialog) #type:ignore
        buttonBox.accepted.connect(dialog.accept)
        buttonBox.rejected.connect(dialog.reject)
        layout.addWidget(buttonBox)

        if dialog.exec_() == QDialog.Accepted:
            node.displayName = lineEdit.text()
        
    def changeNodeColor(self, node, event):
        &#34;&#34;&#34;
        Change the color of a node.
        
        Args:
            node: The node object whose color will be changed.
            event: The event that triggers the color change.
        
        Returns:
            None
        &#34;&#34;&#34;
        color = QColorDialog.getColor()
        node.alternateFillColor = color.getRgb()
        #Force the change in the node:
        node.BGcolChanged()
        node.update()
        logging.debug(f&#34;Node color changed to {node.alternateFillColor}&#34;)

    def limitTextLength(self,text,textLength:int=40):
        &#34;&#34;&#34; 
        Get a string (text) and return a &#34;abc...def&#34; string if it&#39;s too long.
        &#34;&#34;&#34;
        if type(text) != str:
            text = str(text)
        textLength = int(textLength)
        if textLength % 1 == 0: #if odd length, make it even
            textLength = int(textLength+1)
        if len(text) &gt; textLength:
            displayVal = text[:20] + &#39;...&#39; + text[-20:]
        else:
            displayVal = text
        return displayVal

    def set_readable_text_after_dialogChange(self,currentNode,dialog,nodeType=None):
        &#34;&#34;&#34;Script which sets a readable text inside the textfield of the currentNode after a dialog is closed (i.e. a popup window is closed).

        Args:
            currentNode (Nodz Node): Current Nodz Node
            dialog (QDialog): Dialog output
            nodeType (str): Type of node
        &#34;&#34;&#34;
        displayHTMLtext = &#39;&#39;
        if nodeType == None:
            nodeType = currentNode.name.split(&#39;_&#39;)[0]
        if nodeType == &#39;analysisMeasurement&#39; or nodeType == &#39;analysisMeasurementDEBUG&#39;:
            methodName = dialog.currentData[&#39;__selectedDropdownEntryAnalysis__&#39;]
            methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
            reqKwValues = []
            optKwValues = []
            
            reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
            optKwargs = utils.optKwargsFromFunction(methodFunctionName)
            
            displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&lt;br&gt;Input:&#34;
            
            relativeData = {}
            for key in dialog.currentData:
                if &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                    relativeData[key] = dialog.currentData[key]
            
            allValues = utils.nodz_dataFromGeneralAdvancedLineEditDialog(relativeData,currentNode.flowChart)
            
            for rkw in reqKwargs:
                displayVal = self.limitTextLength(str(allValues[rkw][1]))
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{rkw}&lt;/b&gt;: {displayVal}&#34;

            for okw in optKwargs:
                displayVal = self.limitTextLength(str(allValues[okw][1]))
                displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{okw}&lt;/i&gt;: {displayVal}&#34;
            
            displayHTMLtext += &#34;&lt;br&gt;&lt;br&gt;Output:&#34;
            htmloutputadded=False
            for varName in currentNode.variablesNodz:
                currData = str(currentNode.variablesNodz[varName][&#39;data&#39;])
                typing = currentNode.variablesNodz[varName][&#39;type&#39;]
                importance = currentNode.variablesNodz[varName][&#39;importance&#39;]
                
                if currData is not None:
                    currData = self.limitTextLength(currData)
                else:
                    currData = &#39;None&#39;
                
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{varName}&lt;/b&gt;: {str(currData)}&#34;
                htmloutputadded=True
            
            if not htmloutputadded:
                displayHTMLtext += f&#34;&lt;br&gt;None&#34;
        elif nodeType == &#39;RTanalysisMeasurement&#39;:
            methodName = dialog.currentData[&#39;__selectedDropdownEntryRTAnalysis__&#39;]
            methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
            reqKwValues = []
            optKwValues = []
            
            reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
            optKwargs = utils.optKwargsFromFunction(methodFunctionName)
            
            for key in dialog.currentData:
                for rkw in reqKwargs:
                    if rkw in key and &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                        reqKwValues.append(dialog.currentData[key])
                for okw in optKwargs:
                    if okw in key and &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                        optKwValues.append(dialog.currentData[key])
            
            displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&#34;
            for i in range(len(reqKwargs)):
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{reqKwargs[i]}&lt;/b&gt;: {reqKwValues[i]}&#34;
            for i in range(len(optKwargs)):
                displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{optKwargs[i]}&lt;/i&gt;: {optKwValues[i]}&#34;
                
        elif nodeType == &#39;visualisation&#39;:
            displayHTMLtext = f&#34;&lt;b&gt;Layer name: {dialog.layerNameEdit.text()}&lt;/b&gt;&#34;
            if dialog.colormapComboBox.currentText() != &#39;None&#39;:
                displayHTMLtext += f&#34;&lt;br&gt;Colormap: {dialog.colormapComboBox.currentText()}&#34;
        elif nodeType == &#39;acquisition&#39;:
            displayHTMLtext = f&#34;&lt;b&gt;{len(dialog.getInputs())} frames with order {dialog.mdaconfig.order}&lt;/b&gt;&#34;
            if dialog.mdaconfig.GUI_exposure_enabled:
                displayHTMLtext += f&#34;&lt;br&gt;{dialog.getExposureTime()} ms exposure time&#34;
            if dialog.mdaconfig.GUI_show_time:
                displayHTMLtext += f&#34;&lt;br&gt;{dialog.mdaconfig.num_time_points} time points&#34;
            if dialog.mdaconfig.GUI_show_channel:
                displayHTMLtext += f&#34;&lt;br&gt;{len(dialog.mdaconfig.channel_exposures_ms)} channels in group {dialog.mdaconfig.channel_group}&#34;
            if dialog.mdaconfig.GUI_show_xy:
                displayHTMLtext += f&#34;&lt;br&gt;{len(dialog.mdaconfig.xy_positions)} XY positions&#34;
            if dialog.mdaconfig.GUI_show_z:
                if dialog.mdaconfig.z_nr_steps is not None:
                    displayHTMLtext += f&#34;&lt;br&gt;{dialog.mdaconfig.z_nr_steps} Z positions&#34;
                else:
                    nrZsteps = (dialog.mdaconfig.z_end-dialog.mdaconfig.z_start)//dialog.mdaconfig.z_step_distance
                    displayHTMLtext += f&#34;&lt;br&gt;{nrZsteps} Z positions&#34;
        elif nodeType == &#39;changeProperties&#39;:
            displayHTMLtext = f&#34;Changing {len(dialog.ConfigsToBeChanged())} config(s):&#34;
            for config in dialog.ConfigsToBeChanged():
                try:
                    displayRounded = str(round(float(config[1]),3))
                except:
                    displayRounded = config[1]
                displayHTMLtext += f&#34;&lt;br&gt;{config[0]} to {displayRounded}&#34;
        elif nodeType == &#39;scoreEnd&#39;:
            import time
            from datetime import datetime
            displayHTMLtext = f&#34;&lt;i&gt; {datetime.fromtimestamp(time.time()).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&lt;/i&gt;&#34;
            for score_entry in dialog[0]:
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{score_entry}:&lt;/b&gt; {format(dialog[1][score_entry],&#39;.2f&#39;)}&#34;
            if len(dialog) &gt; 2:
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{dialog[2]}&lt;/b&gt;&#34;
        elif nodeType == &#39;scoreStart&#39;:
            import time
            from datetime import datetime
            displayHTMLtext = &#34;&lt;b&gt;Scoring started at:&lt;/b&gt;&#34;
            displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt; {datetime.fromtimestamp(time.time()).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&lt;/i&gt;&#34;
        
        elif nodeType == &#39;earlyScoringFail&#39;:
            displayHTMLtext = f&#34;This node will fail this score and go to the next position!&#34;
        elif nodeType == &#39;timer&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(dialog.timerInfo,currentNode.flowChart)
            try:
                displayHTMLtext = f&#34;&lt;b&gt;Timer:&lt;/b&gt; wait {str(values[&#39;wait_time&#39;][1])} s&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;storeData&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.storeDataInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = f&#34;Store data &lt;b&gt;{self.limitTextLength(values[&#39;item_to_store&#39;][1])}&lt;/b&gt; at location &lt;b&gt;{self.limitTextLength(values[&#39;store_location&#39;][1])}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;changeGlobalVar&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.changeGlobalVarInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = f&#34;Change global variable &lt;b&gt;{self.limitTextLength(values[&#39;globalVarName&#39;][1])}&lt;/b&gt; to &lt;b&gt;{self.limitTextLength(values[&#39;globalVarValue&#39;][1],textLength = 60)}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        
        elif nodeType == &#39;ifStatement&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.ifStatementInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                comparatorValue = values[&#39;comparator&#39;][1]
                #Replace &lt; inside the value:
                comparatorValue = comparatorValue.replace(&#39;&lt;&#39;,&#39;&amp;lt;&#39;)
                
                displayHTMLtext = f&#34;Assess the statement &lt;b&gt;{values[&#39;valueToCheck&#39;][1]} {comparatorValue} {values[&#39;valueCheckAgainst&#39;][1]}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
            
        elif nodeType == &#39;runInlineScript&#39;:
            scriptInfo = currentNode.InlineScriptInfo
            n_lines = len(scriptInfo.split(&#39;\n&#39;))
            if n_lines == 1:
                displayHTMLtext = f&#34;Run a pycromanager script with &lt;b&gt;{n_lines} line&lt;/b&gt;&#34;
            else:
                displayHTMLtext = f&#34;Run a pycromanager script with &lt;b&gt;{n_lines} lines&lt;/b&gt;&#34;
        elif nodeType == &#39;newGlobalVar&#39;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.newGlobalVarInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = f&#34;Create new global variable &lt;b&gt;{self.limitTextLength(values[&#39;globalVarName&#39;][1])}&lt;/b&gt; with value &lt;b&gt;{self.limitTextLength(values[&#39;globalVarValue&#39;][1])}&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;customFunction&#39;:
            methodName = dialog.currentData[&#39;__selectedDropdownEntryAnalysis__&#39;]
            methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
            reqKwValues = []
            optKwValues = []
            
            reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
            optKwargs = utils.optKwargsFromFunction(methodFunctionName)
            
            displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&lt;br&gt;Input:&#34;
            
            relativeData = {}
            for key in dialog.currentData:
                if &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                    relativeData[key] = dialog.currentData[key]
            
            allValues = utils.nodz_dataFromGeneralAdvancedLineEditDialog(relativeData,currentNode.flowChart,dontEvaluate=True)
            
            for rkw in reqKwargs:
                displayVal = str(allValues[rkw][1])
                if len(displayVal) &gt; 40:
                    displayVal = displayVal[:20] + &#39;...&#39; + displayVal[-20:]
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{rkw}&lt;/b&gt;: {displayVal}&#34;

            for okw in optKwargs:
                displayVal = str(allValues[okw][1])
                if len(displayVal) &gt; 40:
                    displayVal = displayVal[:20] + &#39;...&#39; + displayVal[-20:]
                displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{okw}&lt;/i&gt;: {displayVal}&#34;
            
            
            displayHTMLtext += &#34;&lt;br&gt;&lt;br&gt;Output:&#34;
            
            htmloutputadded=False
            
            for varName in currentNode.variablesNodz:
                currData = str(currentNode.variablesNodz[varName][&#39;data&#39;])
                if currData is not None:
                    currData = self.limitTextLength(currData)
                else:
                    currData = &#39;None&#39;
                typing = currentNode.variablesNodz[varName][&#39;type&#39;]
                importance = currentNode.variablesNodz[varName][&#39;importance&#39;]
                displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{varName}&lt;/b&gt;: {str(currData)}&#34;
                htmloutputadded=True
            
            if not htmloutputadded:
                displayHTMLtext += f&#34;&lt;br&gt;None&#34;
        elif nodeType == &#34;changeStagePos&#34;:
            #Find the chosen stage and corresponding set movement (relative only for now)
            for key in dialog.RelStageInfo():
                if key[0] == &#39;__chosenRelStage__&#39;:
                    chosenStage = key[1]
            for key in dialog.RelStageInfo():
                if key[0] == chosenStage:
                    setMovement = key[1]
            #Set the displayHTML text:
            try:
                displayHTMLtext = &#34;&lt;b&gt;Relative&lt;/b&gt; movement of stage &lt;b&gt;&#34;+chosenStage+&#34;&lt;/b&gt; by &lt;b&gt;&#34;+str(setMovement)+&#34;&lt;/b&gt; units&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#34;caseSwitch&#34;:
            values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.caseSwitchInfo,currentNode.flowChart,dontEvaluate=True)
            try:
                displayHTMLtext = &#34;Perform a case/switch logic based on variable &lt;b&gt;&#34;+self.limitTextLength(values[&#39;Var&#39;][1])+&#34;&lt;/b&gt;&#34;
            except:
                displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        elif nodeType == &#39;stickyNote&#39;:
            displayHTMLtext = f&#34;{currentNode.stickyNoteInfo}&#34;
        elif nodeType == &#39;slackReport&#39;:
            displayHTMLtext = f&#34;{currentNode.slackReportInfo}&#34;
        elif nodeType == &#34;__InitRequireUserDoubleClick__&#34;:
            displayHTMLtext = &#34;&lt;font color=&#39;#a00000&#39;&gt;Double-click this node to initialize it correctly.&lt;/font&gt;&#34;
        #And update the display
        currentNode.updateDisplayText(displayHTMLtext)
        return displayHTMLtext

    def getDevicesOfDeviceType(self,devicetype):
        &#34;&#34;&#34;
        Find all devices that have a specific devicetype.
        
        Args:
            devicetype (str): The type of device to search for. Refer to https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html for all devicetypes.
        
        Returns:
            list: A list of devices that match the specified devicetype.
        &#34;&#34;&#34;
        
        #Find all devices that have a specific devicetype
        #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
        #for all devicetypes
        #Get devices
        devices = self.shared_data.core.get_loaded_devices() #type:ignore
        devices = [devices.get(i) for i in range(devices.size())]
        devicesOfType = []
        #Loop over devices
        for device in devices:
            if self.shared_data.core.get_device_type(device).to_string() == devicetype: #type:ignore
                logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
                devicesOfType.append(device)
        return devicesOfType

    def PlugOrSocketConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a plug or socket is connected.

        When a plug or socket is connected, this function is called. It will check if the destination
        node should be marked as &#39;started&#39; or &#39;finished&#39; based on the attributes connected.
        &#34;&#34;&#34;
        logging.debug(f&#34;plug/socket connected start: {srcNodeName}, {plugAttribute}, {dstNodeName}, {socketAttribute}&#34;)
    
    def PlugOrSocketDisconnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a plug or socket is disconnected.

        When a plug or socket is disconnected, this function is called. It will disconnect
        the finished event of the source node from the &#39;we finished one of the prerequisites&#39; at the destination node.
        &#34;&#34;&#34;
        logging.debug(&#39;plugorsocketdisconnected&#39;)
        self.checkNodesOnErrors()
    
    def PlugConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a plug is connected.

        When a plug is connected, this function is called. It will check if the destination
        node should be marked as &#39;started&#39; based on the attributes connected.
        &#34;&#34;&#34;
        #Check if all are non-Nones:
        logging.debug(&#39;plug connected&#39;)
        self.checkNodesOnErrors()
        
    def SocketConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
        &#34;&#34;&#34;
        Handle when a socket is connected.

        When a socket is connected, this function is called. It does not do anything
        special, it only exists to keep the Node class happy by having a method that
        corresponds to the &#39;SocketConnected&#39; signal from the FlowChart.
        &#34;&#34;&#34;
        #Only one specific use-case at the moment:
        #If a connection is made between any node N to an analysisMeasurement node, and if there is at least one acquisition node linked at or downstream of N, and if the input of the analysisMeasurement is not already defined, and if the input is actually an image, fill the input data of the analysisMeasurement node to be the data of this acquisition node.
        
        
        #Possibly later, for any other nodes, set the &#39;input&#39; of the right node to the &#39;default&#39; of the left node, if typing accomodates.
        
        #TODO
        #First, we need to create some function to look at the downstream-connected nodes of some node - this needs to be a rather proper function.
        
        if &#39;analysisMeasurement_&#39; in dstNodeName or &#39;analysisMeasurementDEBUG_&#39; in dstNodeName:
            srcNode = nodz_utils.findNodeByName(self,srcNodeName)
            dstNode = nodz_utils.findNodeByName(self,dstNodeName)
            
            downstreamConnections = nodz_utils.findConnectedToNode(self.evaluateGraph(),dstNodeName,[],upstream=False,downstream=True) 
            #Note: first entry is always closest to node.
            #So we check if there is at least one acquisition node downstream of the dstNode:
            shortestConnectedAcquisition = None
            for connection in downstreamConnections:
                if &#39;acquisition_&#39; in connection:
                    shortestConnectedAcquisition = nodz_utils.findNodeByName(self,connection)
                    break
            
            if shortestConnectedAcquisition is not None:
                for function in dstNode.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;]: #type:ignore
                    inputOfFunction = utils.inputFromFunction(function[1])[0][0]
                    
                    lineEditName = &#39;LineEdit#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                    lineEditVarName = &#39;LineEditVariable#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                    lineEditAdvName = &#39;LineEditAdv#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                    if lineEditVarName in dstNode.scoring_analysis_currentData: #type:ignore
                        if dstNode.scoring_analysis_currentData[lineEditVarName] == &#39;&#39;: #type:ignore
                            import ndtiff
                            if ndtiff.NDTiffDataset in inputOfFunction[&#39;type&#39;]: #type:ignore
                                if ndtiff.NDTiffDataset in shortestConnectedAcquisition.variablesNodz[&#39;data&#39;][&#39;type&#39;]:
                                    dstNode.scoring_analysis_currentData[lineEditVarName] = &#39;data@&#39;+shortestConnectedAcquisition.name #type:ignore
                                
        
        
        #Check if all are non-Nones:
        logging.debug(&#39;socket connected&#39;)
        self.checkNodesOnErrors()
    
    def prepareGraph(self, methodName=&#39;Score&#39;):
        &#34;&#34;&#34;
        Function to prepare a graph based on the flowchart&#39;s connections.
        The resulting graph will have all nodes connected by edges based on the connections
        in the flowchart
        &#34;&#34;&#34;
        graphEval = self.evaluateGraph()
        if methodName == &#39;Score&#39;:
            scoreGraph = GladosGraph(self)
            scoreGraph.addRawGraphEval(graphEval)
            for node in scoreGraph.nodes:
                self.giveInfoOnNode(node)
            return scoreGraph
    
    def GraphToSignals(self):
        &#34;&#34;&#34;Idea: we evaluate the graph at this time point, connect all signals/emits:
        
        &#34;&#34;&#34;
        logging.debug(&#39;graphicing to signals&#39;)
        #Loop over all nodes:
        for node in self.nodes:
            node.n_connect_at_start = 0
            node.n_connect_at_start_finished = 0
            #Disconnect all signals, but only if there are any
            if node.customFinishedEmits is not None and len(node.customFinishedEmits.signals)&gt;0:
                signal = node.customFinishedEmits.signals[0] #type: ignore
                try:
                    #This disconnects all signals
                    signal.disconnect()
                except:
                    #Otherwise we FULLY reset the signal?
                    logging.debug(&#39;attempted to disconnect a disconnected signal&#39;)
                    # nodeType = self.nodeLookupName_withoutCounter(node.name)
                    # if len(self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]) &gt; 0:
                    #     node.customFinishedEmits = NodeSignalManager()
                    #     for attr in self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]:
                    #         node.customFinishedEmits.add_signal(attr) #type: ignore
                    # else:
                    #     node.customFinishedEmits = None
            
            if node.customDataEmits is not None and len(node.customDataEmits.signals)&gt;0:
                signal = node.customDataEmits.signals[0] #type: ignore
                try:
                    #This disconnects all signals
                    signal.disconnect()
                except:
                    logging.warning(&#39;attempted to disconnect a disconnected signal&#39;)
                    # nodeType = self.nodeLookupName_withoutCounter(node.name)
                    # if len(self.nodeInfo[nodeType][&#39;dataAttributes&#39;]) &gt; 0:
                    #     node.customDataEmits = NodeSignalManager()
                    #     for attr in self.nodeInfo[nodeType][&#39;dataAttributes&#39;]:
                    #         node.customDataEmits.add_signal(attr) #type: ignore
                    # else:
                    #     node.customDataEmits = None
            
        #Create all required signal connections
        currentgraph = self.evaluateGraph()
        for connection in currentgraph:
            plugAttribute = connection[0][connection[0].rfind(&#39;.&#39;)+1:]
            socketAttribute = connection[1][connection[1].rfind(&#39;.&#39;)+1:]
            srcNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
            dstNodeName = connection[1][:connection[1].rfind(&#39;.&#39;)]
            
            if self.nodeLookupName_withoutCounter(srcNodeName) is not None and self.nodeLookupName_withoutCounter(dstNodeName) is not None:
                typeOfFinishedAttributes_of_srcNode = self.nodeInfo[self.nodeLookupName_withoutCounter(srcNodeName)][&#39;finishedAttributes&#39;]
                typeOfDataAttributes_of_srcNode = self.nodeInfo[self.nodeLookupName_withoutCounter(srcNodeName)][&#39;dataAttributes&#39;]
                typeOfStartAttributes_of_dstNode = self.nodeInfo[self.nodeLookupName_withoutCounter(dstNodeName)][&#39;startAttributes&#39;]
            
                #Connect the finished event of the source node to the &#39;we finished one of the prerequisites&#39; at the destination node
                if plugAttribute in typeOfFinishedAttributes_of_srcNode and socketAttribute in typeOfStartAttributes_of_dstNode:
                    srcNode = self.findNodeByName(srcNodeName)
                    dstNode = self.findNodeByName(dstNodeName)
                    #The destination node needs one extra to be started...
                    dstNode.n_connect_at_start += 1 #type: ignore
                    
                    #And the finished event of the source node is connected to the &#39;we finished one of the prerequisites&#39; at the destination node
                    srcNode.customFinishedEmits.signals[0].connect(dstNode.oneConnectionAtStartIsFinished) #type: ignore
                    
                    logging.debug(f&#34;connected Finish {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
                #Same for data
                elif plugAttribute in typeOfDataAttributes_of_srcNode and socketAttribute in typeOfStartAttributes_of_dstNode:
                    srcNode = self.findNodeByName(srcNodeName)
                    dstNode = self.findNodeByName(dstNodeName)
                    #The destination node needs one extra to be started...
                    dstNode.n_connect_at_start += 1 #type: ignore
                    
                    #And the finished event of the source node is connected to the &#39;we gave data&#39; at the destination node
                    srcNode.customDataEmits.signals[0].connect(dstNode.oneConnectionAtStartProvidesData) #type: ignore
                    logging.debug(f&#34;connected Data {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
                else:
                    logging.warning(f&#34;not connected {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
    
    def getNodz(self):
        &#34;&#34;&#34;
        Return the current instance of the class.
        
        Returns:
            object: The current instance of the class.
        &#34;&#34;&#34;
        return self
    
    def updateCoreVariables(self):
        &#34;&#34;&#34;
        
        Idea, get information like this:
        self.coreVariables is initialised like {}
        
        self.coreVariables[&#39;TrialGlobalVariable&#39;]={}
        self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;type&#39;] = str
        self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;data&#39;] = &#39;test&#39;
        self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        
        &#34;&#34;&#34;
        allXYstages = utils.getCoreDevicesOfDeviceType(self.core,&#39;XYStageDevice&#39;)
        all1Dstages = utils.getCoreDevicesOfDeviceType(self.core,&#39;StageDevice&#39;)
        
        #Core variables to store:
        #Stage positions, all stages
        for stage in allXYstages:
            xypos = self.core.get_xy_stage_position(stage) #type:ignore
            self.createSingleCoreVar(stage+&#39;_current_pos&#39;,[xypos.x,xypos.y],[list,np.ndarray]) #type:ignore
        
        for stage in all1Dstages:
            pos = self.core.get_position(stage) #type:ignore
            self.createSingleCoreVar(stage+&#39;_current_pos&#39;,[pos],[list,np.ndarray]) #type:ignore
        
        #Config values, all configs
        allConfigs = self.core.get_available_config_groups()
        if allConfigs != None:
            nrconfiggroups = allConfigs.size()
            for config_id in range(nrconfiggroups):
                configInfo = ConfigInfo(self.core,config_id)
                configName = configInfo.configGroupName()
                configValue = configInfo.getStorableValue()
                try:
                    typev = [type(configValue)]
                except:
                    typev = [str]
                self.createSingleCoreVar(&#39;config_&#39;+configName,configValue,typev) #type:ignore
            
        #Pixel size, ROI size
        self.createSingleCoreVar(&#39;Pixel_size_um&#39;,self.core.get_pixel_size_um(),[float]) #type:ignore
        self.createSingleCoreVar(&#39;ROI_size&#39;,[self.core.get_roi().width,self.core.get_roi().height],[list,np.ndarray]) #type:ignore
    
    def createSingleCoreVar(self,name,data,type,importance=&#39;Informative&#39;):
        self.coreVariables[name] = {} 
        self.coreVariables[name][&#39;type&#39;] = type 
        self.coreVariables[name][&#39;data&#39;] = data 
        self.coreVariables[name][&#39;importance&#39;] = importance 
    
    def cleanupNodeList(self):
        #Ensure that self.nodes accurately reflects the nodes on the screen.
        nodeNamesOnScreen = []
        for node in self.scene().nodes:
            nodeNamesOnScreen = nodeNamesOnScreen +[node]
        
        for node in self.nodes:
            if node.name not in nodeNamesOnScreen:
                self.nodes.remove(node)
    
    def checkNodesOnErrors(self):
        #Idea: check all nodes for errors, alongside unconnected nodes. If so, update the warning. If not, reset the warning to none.
        
        if not self.shared_data.loadingOngoing:
            #Check that all nodes have connections where required.
            #Effectively, this means that all nodes should have a downstream connector
            self.cleanupNodeList()
            
            for node in self.nodes:
                #Init all nodes with no error:
                node.errorInfo = &#39;&#39;
                
                #check fo downstream connections
                downstreamNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[],upstream=False,downstream=True)
                if len(downstreamNodes) == 0:
                    #Check if it requires one...
                    if len(node.sockets) &gt; 0:
                        node.errorInfo = &#39;No downstream connections found.&#39;
            
            utils.updateAutonousErrorWarningInfo(self.shared_data)
        
        # self.shared_data.warningErrorInfoInfo[&#39;Errors&#39;] = totalNodeErrorMessage
    
    #endregion
    
    #region NodzFlowChart Saving Loading
    def storeGraphJSON(self):
        &#34;&#34;&#34;
        Save the current graph to a JSON file.

        This function saves the current graph to a JSON file, which can be loaded later using `loadPickle()`.
        &#34;&#34;&#34;
        filename, _ = QFileDialog.getSaveFileName(self, &#39;Save file&#39;, &#39;&#39;, &#39;JSON files (*.json)&#39;)
        if filename:
            if not filename.endswith(&#39;.json&#39;):
                filename += &#39;.json&#39;
            with open(filename, &#39;wb&#39;) as f:
                self.saveGraph(filename)
    
    def loadGraphJSON(self):
        &#34;&#34;&#34;
        Load the graph from a JSON file.

        This function loads the graph from a JSON file created using `storeGraphJSON()`.
        &#34;&#34;&#34;        
        filename, _ = QFileDialog.getOpenFileName(self, &#39;Open file&#39;, &#39;&#39;, &#39;JSON files (*.json)&#39;)
        if filename:
            try:
                #Fully clear graph and delete all nodes from memory:
                self.clearGraph()
                self.nodes = []
                #Set all counters to 0:
                for nodeType in self.nodeInfo:
                    if nodeType[:2] != &#39;__&#39;: #Ignore internal/special node info (&#39;__init__&#39; etc)
                        self.nodeInfo[nodeType][&#39;NodeCounter&#39;] = 0
                        self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] = 0
                #Load the graph
                with open(filename, &#39;rb&#39;) as f:
                    self.loadGraph_KM(filename)
                
                #Update warnings/info/errors:
                self.shared_data.warningErrorInfoInfo[&#34;Info&#34;][&#39;Other&#39;] = [&#34;Loaded &#34;+filename]
                # utils.updateAutonousErrorWarningInfo(self.shared_data)
            except:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Warning)
                msg.setText(&#34;Could not load file: &#34; + filename)
                msg.setWindowTitle(&#34;Warning&#34;)
                msg.setStandardButtons(QMessageBox.Ok)
                msg.exec_()
    #endregion
    
    #region NodzFlowChart Node-specific
    def update_scoring_end(self,currentNode,dialogLineEdits):
        &#34;&#34;&#34;
        Update the &#34;scoring end&#34; current node with new dialog line edits.
        
        Args:
            currentNode: The current node to update.
            dialogLineEdits: The new sockets of the current node.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        currentNode.scoring_end_currentData[&#39;Variables&#39;] = dialogLineEdits #type: ignore
        
        #the dialogLineEdits should be the new sockets of the current node. However, if a plug with the name already exists, it shouldn&#39;t be changed.
        import time
        sleepTime = 0.02
        for _ in range(3): #Just repeat everything 3 times and hope it solves itself
            self.update()
            time.sleep(sleepTime)
            current_sockets = [item[0] for item in list(currentNode.sockets.items())]
            if dialogLineEdits != current_sockets:
                
                for socket_id in reversed(range(len(currentNode.attrs))):
                    socket = currentNode.attrs[socket_id]
                    #We check if the socket is in dialogLineEdits:
                    if socket not in dialogLineEdits and socket in current_sockets:
                        #If it isn&#39;t, we just delete it:
                        self.deleteAttribute(currentNode,socket_id)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                
                #Check which are different (index-wise) between dialogLineEdits and current_sockets:
                diff_indexes = []
                same_indexes = []
                for i in range(min(len(dialogLineEdits),len(current_sockets))):
                    if dialogLineEdits[i] != current_sockets[i]:
                        diff_indexes.append(i)
                    else:
                        same_indexes.append(i)
                #Also append indexes if dialogLineEdits is longer than current_sockets:
                if len(dialogLineEdits) &gt; len(current_sockets):
                    for i in range(len(current_sockets),len(dialogLineEdits)):
                        diff_indexes.append(i)
                
                offset = 100
                #Then we create new sockets or move existing sockets, only for those that have a different pos
                for socket_new in ([dialogLineEdits[i] for i in diff_indexes]):
                    pos_in_dialogLineEdits = dialogLineEdits.index(socket_new)
                    if socket_new not in currentNode.sockets:
                        self.createAttribute(currentNode, name=socket_new, index=pos_in_dialogLineEdits+offset, preset=&#39;attr_default&#39;, plug=False, socket=True, dataType=None, socketMaxConnections=1)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                    else: #Else we move it from some other location to where we want it
                        #Find this socket in currentNode.sockets.items():
                        socketFull = list(currentNode.sockets.items())
                        pos_in_node_info = [socket_id for socket_id in range(len(socketFull)) if socketFull[socket_id][0] == socket_new][0]
                        old_pos = socketFull[pos_in_node_info][1].index
                        #Physically move it
                        self.editAttribute(currentNode,old_pos,newName = None, newIndex=pos_in_dialogLineEdits+offset)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
        
        #We also need to add these attributes to the nodes startAttributes in self.nodeInfo:
        self.nodeInfo[self.nodeLookupName_withoutCounter(currentNode.name)][&#39;startAttributes&#39;] = dialogLineEdits
    
    def update_plugs_fromDialog(self,currentNode,dialogLineEdits):
        &#34;&#34;&#34;
        Update the &#34;scoring end&#34; current node with new dialog line edits.
        
        Args:
            currentNode: The current node to update.
            dialogLineEdits: The new sockets of the current node.
        
        Returns:
            None
        &#34;&#34;&#34;
                
        #the dialogLineEdits should be the new plugs of the current node. However, if a plug with the name already exists, it shouldn&#39;t be changed.
        import time
        sleepTime = 0.02
        for _ in range(3): #Just repeat everything 3 times and hope it solves itself
            self.update()
            time.sleep(sleepTime)
            current_plugs = [item[0] for item in list(currentNode.plugs.items())]
            if dialogLineEdits != current_plugs:
                
                for plug_id in reversed(range(len(currentNode.attrs))):
                    plug = currentNode.attrs[plug_id]
                    #We check if the plug is in dialogLineEdits:
                    if plug not in dialogLineEdits and plug in current_plugs:
                        logging.debug(plug_id)
                        #If it isn&#39;t, we just delete it:
                        self.deleteAttribute(currentNode,plug_id)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                
                #Check which are different (index-wise) between dialogLineEdits and current_plugs:
                diff_indexes = []
                same_indexes = []
                for i in range(min(len(dialogLineEdits),len(current_plugs))):
                    if dialogLineEdits[i] != current_plugs[i]:
                        diff_indexes.append(i)
                    else:
                        same_indexes.append(i)
                #Also append indexes if dialogLineEdits is longer than current_plugs:
                if len(dialogLineEdits) &gt; len(current_plugs):
                    for i in range(len(current_plugs),len(dialogLineEdits)):
                        diff_indexes.append(i)
                
                offset = 100
                #Then we create new plugs or move existing plugs, only for those that have a different pos
                for plug_new in ([dialogLineEdits[i] for i in diff_indexes]):
                    pos_in_dialogLineEdits = dialogLineEdits.index(plug_new)
                    if plug_new not in currentNode.plugs:
                        self.createAttribute(currentNode, name=plug_new, index=pos_in_dialogLineEdits+offset, preset=&#39;attr_default&#39;, plug=True, socket=False, dataType=None)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
                    else: #Else we move it from some other location to where we want it
                        #Find this plug in currentNode.plugs.items():
                        plugFull = list(currentNode.plugs.items())
                        pos_in_node_info = [plug_id for plug_id in range(len(plugFull)) if plugFull[plug_id][0] == plug_new][0]
                        old_pos = plugFull[pos_in_node_info][1].index
                        #Physically move it
                        self.editAttribute(currentNode,old_pos,newName = None, newIndex=pos_in_dialogLineEdits+offset)
                        time.sleep(sleepTime)
                        self.update()
                        time.sleep(sleepTime)
        
        #We also need to add these attributes to the nodes startAttributes in self.nodeInfo:
        self.nodeInfo[self.nodeLookupName_withoutCounter(currentNode.name)][&#39;finishedAttributes&#39;] = dialogLineEdits
    
    def changeConfigStorageInNodz(self,currentNode,configNameSet):
        &#34;&#34;&#34;
        Function to change the config storage of a nodz node from the double-click popup to the MMconfigInfo class stored inside the node.

        This is useful when storing and loading configurations for a node, as the MMconfigInfo class can be serialized and deserialized.

        Args:
            currentNode (nodz.Node): The node to change the config storage of.
            configNameSet (set of tuples): A set of tuples in the form (configName, selectedValue)
        &#34;&#34;&#34;
        #Changes a config from a double-click config popup to the MMconfig stored inside the nodz node itself (i.e. storing/loading of configs)
        
        #Add all of them to the MMconfigInfo.config_string_storage:
        currentNode.MMconfigInfo.config_string_storage=[]
        for singleConfig in configNameSet:
            currentNode.MMconfigInfo.config_string_storage.append([singleConfig[0],singleConfig[1]])
        return
    
    def changeRelStageStorageInNodz(self,currentNode,relstageinfo):
        
        currentNode.MMconfigInfo.relstage_string_storage=relstageinfo
    
    def AnalysisNode_DEBUG_started(self,node):
        &#34;&#34;&#34;
        Perform the Analysis set in a node
        
        Args:
            node: The node for which calls the analysis
        
        Returns:
            None
        &#34;&#34;&#34;
        #Find the node that is connected (i.e. downstream) to this
        connectedNode = None
        for connection in self.evaluateGraph():
            if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == &#39;Analysis start&#39;:
                if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                    connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                    connectedNode = self.findNodeByName(connectedNodeName)
        if connectedNode is None:
            logging.error(&#39;Error! No connected node found for scoring analysis&#39;)
            return
        
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        #Figure out which function is selected in the scoring_analysis node
        selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
        #Figure out the belonging evaluation-text
        evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
        
        #And evaluate the custom function with custom parameters
        output = eval(evalText) #type:ignore
        
        #Display final output to the user for now
        logging.info(f&#34;Final output from node {node.name}: {output}&#34;)
        
        #Set the status of the nodz-coupled vis and real-time to finished:
        #Look at the &#39;Visual&#39; bottom attribute and visualise if needed
        visualAttr = node.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            visual_connected_node_name = visualAttr.connections[0].socketNode
            for nodeV in self.nodes:
                if nodeV.name == visual_connected_node_name:
                    visual_connected_node = nodeV
                    
                    selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
                    visualEvalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;(output,napariLayer)&#39;,&#39;self.shared_data.core&#39;,nodzInfo=self)
                    visualEvalText = visualEvalText.replace(selectedFunction,f&#39;{selectedFunction}_visualise&#39;) #type:ignore
                    
                    chosenLayerType = &#39;points&#39;
                    
                    layerTypeInfo = [
                        [&#39;Analysis_Measurements&#39;,&#39;points&#39;],
                        [&#39;Analysis_Shapes&#39;,&#39;shapes&#39;],
                        [&#39;Analysis_Images&#39;,&#39;image&#39;],
                    ]
                    
                    folderName = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))+os.sep+&#39;AutonomousMicroscopy&#39;+os.sep
                    
                    for layerType in layerTypeInfo:
                        for root, dirs, files in os.walk(folderName+layerType[0]):
                            for file in files:
                                if selectedFunction.split(&#39;.&#39;)[0] in file: #type:ignore
                                    if file.endswith(&#34;.py&#34;):
                                        with open(os.path.join(root, file), &#39;r&#39;) as f:
                                            filecontent = f.read()
                                        if selectedFunction.split(&#39;.&#39;)[1]+&#39;(&#39; in filecontent: #type:ignore
                                            chosenLayerType = layerType[1]
                                            break #to avoid searching in other files for this function
                    
                    
                    layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                    
                    #If a layer with this name already exists, simply remove it:
                    for layer in self.shared_data.napariViewer.layers: #type:ignore
                        if layer.name == layerName:
                            self.shared_data.napariViewer.layers.remove(layer) #type:ignore
                            
                    cmap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                    if chosenLayerType == &#39;points&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_points(
                            data=None,
                            text=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;shapes&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_shapes(
                            data=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;image&#39;:
                        logging.debug(&#39;creating new image layer&#39;)
                        viewer = self.shared_data.napariViewer #type:ignore
                        im = np.random.random((30, 30))
                        napariLayer = viewer.add_image(
                            data=im,
                            name=layerName,
                            colormap = cmap
                        )
                    
                    visualOutput = eval(visualEvalText)
                    
                    visual_connected_node.status = &#39;finished&#39;
            
            
        node.scoring_analysis_currentData[&#39;__output__&#39;] = output
        
        #Store the output as NodzVariables
        utils.analysis_outputs_store_as_variableNodz(node)
        
        
        #Finish up
        self.finishedEmits(node)
    
    def AnalysisNode_started(self,node):
        &#34;&#34;&#34;
        Perform the Analysis set in a node
        
        Args:
            node: The node for which calls the analysis
        
        Returns:
            None
        &#34;&#34;&#34;
        #Find the node that is connected (i.e. downstream) to this
        connectedNode = None
        for connection in self.evaluateGraph():
            if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == &#39;Analysis start&#39;:
                if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                    connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                    connectedNode = self.findNodeByName(connectedNodeName)
        if connectedNode is None:
            logging.error(&#39;Error! No connected node found for scoring analysis&#39;)
            return
        
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        #Figure out which function is selected in the scoring_analysis node
        selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
        #Figure out the belonging evaluation-text
        evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
        
        
        worker = generalNodzCallActionWorker(nodzType=&#39;AnalysisNode&#39;,args={&#34;evalText&#34;:evalText, &#34;nodeDict&#34;:nodeDict, &#34;node&#34;:node, &#34;core&#34;: self.core, &#34;shared_data&#34;: self.shared_data})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.analysisNode_finished(node))
        #Star the worker
        self.thread_pool.start(worker)
        
    def analysisNode_finished(self,node):
        #Set the status of the nodz-coupled vis and real-time to finished:
        #Look at the &#39;Visual&#39; bottom attribute and visualise if needed
        output = node.output
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        visualAttr = node.bottomAttrs[&#39;Visual&#39;]
        if len(visualAttr.connections) &gt; 0:
            visual_connected_node_name = visualAttr.connections[0].socketNode
            for nodeV in self.nodes:
                if nodeV.name == visual_connected_node_name:
                    visual_connected_node = nodeV
                    
                    selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
                    visualEvalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;(output,napariLayer)&#39;,&#39;self.shared_data.core&#39;,nodzInfo=self)
                    visualEvalText = visualEvalText.replace(selectedFunction,f&#39;{selectedFunction}_visualise&#39;) #type:ignore
                    
                    chosenLayerType = &#39;points&#39;
                    
                    layerTypeInfo = [
                        [&#39;Analysis_Measurements&#39;,&#39;points&#39;],
                        [&#39;Analysis_Shapes&#39;,&#39;shapes&#39;],
                        [&#39;Analysis_Images&#39;,&#39;image&#39;],
                    ]
                    
                    folderName = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))+os.sep+&#39;AutonomousMicroscopy&#39;+os.sep
                    
                    for layerType in layerTypeInfo:
                        for root, dirs, files in os.walk(folderName+layerType[0]):
                            for file in files:
                                if selectedFunction.split(&#39;.&#39;)[0] in file: #type:ignore
                                    if file.endswith(&#34;.py&#34;):
                                        with open(os.path.join(root, file), &#39;r&#39;) as f:
                                            filecontent = f.read()
                                        if selectedFunction.split(&#39;.&#39;)[1]+&#39;(&#39; in filecontent: #type:ignore
                                            chosenLayerType = layerType[1]
                                            break #to avoid searching in other files for this function
                    
                    
                    layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                    
                    #If a layer with this name already exists, simply remove it:
                    for layer in self.shared_data.napariViewer.layers: #type:ignore
                        if layer.name == layerName:
                            self.shared_data.napariViewer.layers.remove(layer) #type:ignore
                            
                    cmap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                    if chosenLayerType == &#39;points&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_points(
                            data=None,
                            text=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;shapes&#39;:
                        viewer = self.shared_data.napariViewer #type:ignore
                        napariLayer = viewer.add_shapes(
                            data=None,
                            name=layerName,
                            colormap = cmap
                        )
                    elif chosenLayerType == &#39;image&#39;:
                        logging.debug(&#39;creating new image layer&#39;)
                        viewer = self.shared_data.napariViewer #type:ignore
                        im = np.random.random((30, 30))
                        napariLayer = viewer.add_image(
                            data=im,
                            name=layerName,
                            colormap = cmap
                        )
                    
                    visualOutput = eval(visualEvalText)
                    
                    visual_connected_node.status = &#39;finished&#39;
        
        
        node.scoring_analysis_currentData[&#39;__output__&#39;] = node.output
        
        #Store the output as NodzVariables
        utils.analysis_outputs_store_as_variableNodz(node)
        
        
        #Finish up
        self.finishedEmits(node)
    
    def CustomFunctionNode_started(self,node):
        &#34;&#34;&#34;
        Perform the Custom Function set in a node
        
        Args:
            node: The node for which calls the analysis
        
        Returns:
            None
        &#34;&#34;&#34;
        #Dictionary of nodes to pass around variables.
        nodeDict = utils.createNodeDictFromNodes(self.nodes)
        nodzInfo = node.flowChart
        
        #Figure out which function is selected in the customFunction node
        selectedFunction = utils.functionNameFromDisplayName(node.customFunction_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.customFunction_currentData[&#39;__displayNameFunctionNameMap__&#39;])
        #Figure out the belonging evaluation-text
        evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.customFunction_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
        
        worker = generalNodzCallActionWorker(nodzType=&#39;CustomFunctionNode&#39;,args={&#34;evalText&#34;:evalText, &#34;nodeDict&#34;:nodeDict, &#34;node&#34;:node, &#34;core&#34;: self.core, &#34;shared_data&#34;: self.shared_data})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.CustomFunctionNode_finished(node))
        #Star the worker
        self.thread_pool.start(worker)
        
        # #And evaluate the custom function with custom parameters
        # output = eval(evalText) #type:ignore
        
        # node.customFunction_currentData[&#39;__output__&#39;] = output
        
        # #Store the output as NodzVariables
        # # utils.analysis_outputs_store_as_variableNodz(node)
        
        # #Finish up
        # self.finishedEmits(node)
    
    def CustomFunctionNode_finished(self,node):
        
        output = node.output
        node.customFunction_currentData[&#39;__output__&#39;] = node.output
        
        #Store the output as NodzVariables #TODO
        utils.customFunction_outputs_store_as_variableNodz(node)
        
        #Finish up
        self.finishedEmits(node)
        
        
    def MMstageChangeRan(self,node):
        #TODO: Implement this :)
        &#34;&#34;&#34;
        Change the stage of the microscope based on the node info
        
        Args:
            node: The MM node to change the stage for.
        
        Returns:
            None
        &#34;&#34;&#34;
        
        for stor in node.MMconfigInfo.relstage_string_storage:
            if stor[0] == &#39;__chosenRelStage__&#39;:
                stageToMove = stor[1]
        
        for stor in node.MMconfigInfo.relstage_string_storage:
            if stor[0] == stageToMove:
                distToMove = float(stor[1])
        
        self.core.set_relative_position(stageToMove,distToMove)
        
        self.finishedEmits(node)
        
    def MMconfigChangeRan(self,node):
        &#34;&#34;&#34;
        Handle the configuration change event for a node.

        This function handles the configuration change event for a node, by
        changing the desired configs in the Core.

        Args:
            node (nodz.Node): The node that has triggered the event.
        &#34;&#34;&#34;
        logging.debug(&#39;MMconfigChangeRan&#39;)
        
        
        #Create the worker
        worker = generalNodzCallActionWorker(nodzType=&#39;MMconfigChangeRan&#39;,args={&#34;config_string_storage&#34;:node.MMconfigInfo.config_string_storage, &#34;MMconfig&#34;:node.MMconfigInfo, &#34;core&#34;: self.core})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.finishedEmits(node))
        #Star the worker
        self.thread_pool.start(worker)
        
        # self.finishedEmits(node)

    def acquiringStart(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Acquiring Start node in the Flowchart.

        This function signals to the rest of the flowchart that it&#39;s time to start
        the Acquiring routine.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        if self.preventAcq == False:
            logging.debug(&#39;Starting the acquiring routine!&#39;)
            
            #Set all connected nodes to idle
            connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
            for connectedNode in connectedNodes:
                for nodeC in self.nodes:
                    if nodeC.name == connectedNode:
                        nodeC.status=&#39;idle&#39;
            self.update()
                        
            self.GraphToSignals()
            
            self.finishedEmits(node)
        else:
            logging.warning(&#39;Would have started acquiring, but was prevented!&#39;)
    
    def acquiringEnd(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Acquiring End node in the Flowchart.

        This function signals to the rest of the flowchart that the Acquiring routine is ended

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        #This finishedEmit needs to be at the start of this function :) 
        self.finishedEmits(node)
        logging.debug(&#34;End Acquiring----------------------------------------------------------&#34;)
        if self.fullRunOngoing:
            #if there are more positions to look at...
            if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                logging.info(f&#39;Just did position {self.fullRunCurrentPos+1}/{self.fullRunPositions[&#34;nrPositions&#34;]}, continuing!--------------------------------------------------------&#39;)
                self.fullRunCurrentPos +=1
                #And start a new score/acq at a new pos:
                self.startNewScoreAcqAtPos()
            else:
                logging.info(f&#39;ALLDONE Just did position {self.fullRunCurrentPos+1}/{self.fullRunPositions[&#34;nrPositions&#34;]}, continuing!----------------------------------------------------------&#39;)
                self.singleRunOngoing = False
        else:
            logging.info(&#34;ACQUIRING FULL RUN IS NOT ONGOING--------------------------------------------&#34;)
        logging.debug(&#34;End Acquiring2------------------------------------------------------------&#34;)
        
    
    def initStart(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Initialisation Start node in the Flowchart.

        This function signals to the rest of the flowchart that it&#39;s time to start
        the init routine.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        logging.debug(&#39;Starting the initialisation routine!&#39;)
        
        #Set all connected nodes to idle
        connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
        for connectedNode in connectedNodes:
            for nodeC in self.nodes:
                if nodeC.name == connectedNode:
                    nodeC.status=&#39;idle&#39;
        
        self.set_readable_text_after_dialogChange(node,&#39;&#39;,&#39;initStart&#39;)
        
        self.GraphToSignals()
        #Effectively, only finishes the initStart node
        self.finishedEmits(node)
    
    def initEnd(self,node):
    
        logging.debug(&#39;Initialisation finished fully!&#39;)
        node.status = &#39;finished&#39;
        #Find the acqStart node:
        scoringStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for nodeF in flowChart.nodes:
                if &#39;scoringStart_&#39; in nodeF.name:
                    scoringStartNode = nodeF
        
        #Run the scoring_start routine:
        if scoringStartNode is not None:
            if self.fullRunOngoing:
                logging.info(&#39;Starting full run routine!&#39;)
                self.startNewScoreAcqAtPos()
            else:
                logging.info(&#39;Starting single scoring only!&#39;)
                self.scoringStart(scoringStartNode)
        else:
            logging.error(&#39;Could not find scoringStartNode node in flowchart&#39;)
    
    def scoringStart(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Scoring Start node in the Flowchart.

        This function signals to the rest of the flowchart that it&#39;s time to start
        the scoring routine.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        
        if self.preventScoring == False:
            logging.debug(&#39;Starting the score routine!&#39;)
            
            #Set all connected nodes to idle
            connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
            for connectedNode in connectedNodes:
                for nodeC in self.nodes:
                    if nodeC.name == connectedNode:
                        nodeC.status=&#39;idle&#39;
            
            #Get all connections:
            allConnections = []
            for connectedNode in connectedNodes:
                for nodeC in self.nodes:
                    if nodeC.name == connectedNode:
                        for attr in nodeC.sockets:
                            connections = nodeC.sockets[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
                        for attr in nodeC.plugs:
                            connections = nodeC.plugs[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
                        for attr in nodeC.topAttrs:
                            connections = nodeC.topAttrs[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
                        for attr in nodeC.bottomAttrs:
                            connections = nodeC.bottomAttrs[attr].connections
                            for connection in connections:
                                if connection not in allConnections:
                                    allConnections.append(connection)
            
            for connection in allConnections:
                connection._pen.setColor(QColor(*self.config[&#39;connection_color&#39;]))
                connection.updatePath()
            
            self.set_readable_text_after_dialogChange(node,&#39;&#39;,&#39;scoreStart&#39;)
            
            self.GraphToSignals()
            
            self.finishedEmits(node)
        else:
            logging.warning(&#39;Actively blocked scoring due to self.preventScoring!&#39;)
            
    def scoringEnd(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Scoring End node in the Flowchart.

        This function signals to the rest of the flowchart that the scoring routine is finished.

        Args:
            node (nodz.Node): The node that has triggered the event.

        Returns:
            None
        &#34;&#34;&#34;
        self.finishedEmits(node)
        #Find the nodes that are connected downstream of this:
        try:
            data = {}
            attrs = []
            for attr in node.attrs:
                connectedNode = None
                for connection in self.evaluateGraph():
                    if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == attr:
                        if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                            connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                            connectedNode = self.findNodeByName(connectedNodeName)
            
                        data[attr] = connectedNode.scoring_analysis_currentData[&#39;__output__&#39;] #type:ignore
                        attrs.append(attr)
                        logging.debug(f&#34;Data found for {attr}: {data[attr]}&#34;)
        except:
            pass
        
        try:
            testPassed = self.decisionWidget.testCurrentDecision()
            testPassedText = &#39;Test is Passed&#39; if testPassed else &#39;Test is Not Passed&#39;
            # readableText = self.set_readable_text_after_dialogChange(node,[attrs,data,testPassedText],&#39;scoreEnd&#39;)
            
            logging.info(&#39;Scoring finished fully!&#39;)
            if testPassed:
                logging.info(&#34;Test is... Passed!&#34;)
                
                #Find the acqStart node:
                acqStartNode = None
                flowChart = self
                if len(flowChart.nodes) &gt; 0:
                    #Find the scoringEnd node in flowChart:
                    for nodeF in flowChart.nodes:
                        if &#39;acqStart_&#39; in nodeF.name:
                            acqStartNode = nodeF
                
                #Run the scoring_start routine:
                if acqStartNode is not None:
                    logging.info(&#39;Starting acquisition routine!&#39;)
                    self.acquiringStart(acqStartNode)
                else:
                    logging.error(&#39;Could not find acqStart node in flowchart&#39;)
                
            elif not testPassed:
                logging.info(&#34;Test is... Not Passed!&#34;)
                #Go to next XY position
                if self.fullRunOngoing:
                    if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                        self.fullRunCurrentPos +=1
                        #And start a new score/acq at a new pos:
                        self.startNewScoreAcqAtPos()
                    else:
                        self.singleRunOngoing = False
                        logging.info(&#39;All done!&#39;)
            logging.info(&#39;----------------------&#39;)

        except:
            testPassed = False
            node.status = &#39;error&#39;
            testPassedText = &#39;Error when assessing test&#39;
            readableText = self.set_readable_text_after_dialogChange(node,[attrs,data,testPassedText],&#39;scoreEnd&#39;)
        
        
        #Find the reporting node(s)
        connectedNodes = nodz_utils.getConnectedNodes(node, &#39;bottomAttr&#39;)
        for node in connectedNodes:
            logging.debug(node.name)
            if &#39;reporting_&#39; in node.name:
                node.status = &#39;running&#39;
                if &#39;SLACK&#39; in self.shared_data.globalData: #type:ignore
                    if self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;] is not None and not len(self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;]) == 0: #type:ignore
                        slackReadableText = readableText
                        slackReadableText = slackReadableText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                        slackReadableText = &#34;New Score: \n&#34; + slackReadableText
                        self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].chat_postMessage(channel=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],text=slackReadableText) #type:ignore
                        node.status = &#39;finished&#39;
                    else:
                        node.status = &#39;error&#39;
                else:
                    node.status = &#39;error&#39;
        
        self.preventAcq = False
    
    def earlyScoringFail(self,node):
        #Sob asically it&#39;s the Scoring node, but hard-coded to fail.
        logging.info(&#34;Scoring early abandoned!&#34;)
        self.finishedEmits(node)
        node.status=&#39;finished&#39;
        #Go to next XY position
        if self.fullRunOngoing:
            if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                self.fullRunCurrentPos +=1
                #And start a new score/acq at a new pos:
                self.startNewScoreAcqAtPos()
            else:
                self.singleRunOngoing = False
                logging.info(&#39;All done!&#39;)
        
    
    def and_logicCallAction(self,node):
        &#34;&#34;&#34; 
        Runs when the and_logic gate is fully completed
        &#34;&#34;&#34;
        #Honestly just needs to run the next nodes
        self.finishedEmits(node)
    
    def timerCallAction(self,node):
        &#34;&#34;&#34;
        This function is the action function for the Timer Call node in the Flowchart.

        This function waits for a specified amount of time before triggering the next node in the flowchart.

        Args:
            node (nodz.Node): The node that has triggered the event.
        Returns:
            None
        &#34;&#34;&#34;        
        #Get info
        vardata = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.timerInfo, node.flowChart)
        wait_time = float(vardata[&#39;wait_time&#39;][0])

        #Create the worker
        worker = generalNodzCallActionWorker(nodzType=&#39;Timer&#39;,args={&#34;wait_time&#34;:wait_time})
        #Add the finished emit
        worker.signals.finished.connect(lambda: self.finishedEmits(node))
        #Star the worker
        self.thread_pool.start(worker)
    
    def storeDataCallAction(self,node):
        
        &#34;&#34;&#34;
        This function is the action function for the storeData Call node in the Flowchart.

        This function stores data.

        Args:
            node (nodz.Node): The node that has triggered the event.
        &#34;&#34;&#34;
        
        #Extract Data
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.storeDataInfo,node.flowChart)
        
        #Get the store-data from a variable
        storeInfo = varInfo[&#39;item_to_store&#39;][0]
        storeLoc = varInfo[&#39;store_location&#39;][0]
        
        #Check if storeInfo is image-like:
        if isinstance(storeInfo, np.ndarray) and storeInfo.ndim &gt; 1:
            #Check if we want to store a tiff
            if storeLoc[-4:] == &#39;.tif&#39; or storeLoc[-5:] == &#39;.tiff&#39;:
                import tifffile
                tifffile.imsave(storeLoc,storeInfo)
                logging.debug(f&#39;Stored TIF image at {storeLoc}&#39;)
        
        self.finishedEmits(node)

    def changeGlobalVarCallAction(self,node):
        &#34;&#34;&#34;
        The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.
        
        Args:
            self: Refer to the class itself
            node: Identify which node triggered the event
        &#34;&#34;&#34;
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.changeGlobalVarInfo,node.flowChart)
        
        variable = varInfo[&#39;globalVarName&#39;][1]
        value = varInfo[&#39;globalVarValue&#39;][0]
        
        utils.nodz_setVariableToValue(variable,value,node.flowChart)
        
        
        self.finishedEmits(node)
    
    def newGlobalVarCallAction(self,node):
        &#34;&#34;&#34;
        The newGlobalVarCallAction function is the action function for the new global var Call node in the Flowchart.
        
        Args:
            self: Refer to the class itself
            node: Identify which node triggered the event
        &#34;&#34;&#34;
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.newGlobalVarInfo,node.flowChart)
        
        variable = varInfo[&#39;globalVarName&#39;][1]
        value = varInfo[&#39;globalVarValue&#39;][0]
        
        #Create the new global Variable
        if variable  in node.flowChart.globalVariables:
            #If it&#39;s already present, give a warning for now, but still set it.
            logging.warning(f&#39;New global variable {variable} defined with same name as already existing - overwriting it!&#39;)
            
        node.flowChart.globalVariables[variable] = {}
        node.flowChart.globalVariables[variable][&#39;data&#39;] = value
        #Try to find the type of the variable automatically, else just set it as str
        try:
            node.flowChart.globalVariables[variable][&#39;type&#39;] = [(type(eval(value)))]
        except: #This will effectively set it as a string.
            node.flowChart.globalVariables[variable][&#39;type&#39;] = [(type((value)))]
        node.flowChart.globalVariables[variable][&#39;importance&#39;] = &#39;informative&#39;
        import time
        node.flowChart.globalVariables[variable][&#39;lastUpdateTime&#39;] = time.time()
        
        
        self.finishedEmits(node)
    
    def ifStatementCallAction(self,node):
        &#34;&#34;&#34;
        The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.
        
        Args:
            self: Refer to the class itself
            node: Identify which node triggered the event
        &#34;&#34;&#34;
        
        varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.ifStatementInfo,node.flowChart)
        
        result = eval(str(varInfo[&#39;valueToCheck&#39;][0])+varInfo[&#39;comparator&#39;][0]+str(varInfo[&#39;valueCheckAgainst&#39;][0]))
        
        if result == True:
            graph = node.flowChart.evaluateGraph()
            for graphConnection in graph:
                if graphConnection[0] == node.name+&#39;.Succeed&#39;:
                    foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                    foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                    node.status=&#39;finished&#39;
                    foundNode.oneConnectionAtStartIsFinished()
                    break    
        elif result == False:
            graph = node.flowChart.evaluateGraph()
            for graphConnection in graph:
                if graphConnection[0] == node.name+&#39;.Fail&#39;:
                    foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                    foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                    node.status=&#39;finished&#39;
                    foundNode.oneConnectionAtStartIsFinished()
                    break    
    
    def runInlineScriptCallAction(self,node):
        scriptText = node.InlineScriptInfo
        
        core = shared_data.core
        #Go over each line of scriptText, broken by a \n:
        lineData = scriptText.split(&#39;\n&#39;)
        errored=False
        for line in lineData:
            if errored:
                break
            try:
                eval(line)
                logging.debug(f&#39;Ran commdand succesfully: {line}&#39;)
            except Exception as e:
                logging.error(f&#39;Error with line {line}: {e}. Script broken off&#39;)
                errored=True
        
        if errored==False:
            logging.debug(&#39;Fully ran custom script!&#39;)
        
        self.finishedEmits(node)
    
    def runCaseSwitchCallAction(self,node):
        &#34;&#34;&#34; 
        Call action to runa  case/switch statement.
        &#34;&#34;&#34;
        CurrentValueWantedVariable = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.caseSwitchInfo,node.flowChart)[&#39;Var&#39;][0]
        
        
        #Alright so emitting the signals doesn&#39;t work because they&#39;re all connected.
        #So, idea is to evaluate the graph, find the correct linked node, and start that one from here.
        correctPlugFound = False
        graph = node.flowChart.evaluateGraph()
        for graphConnection in graph:
            if correctPlugFound == False and graphConnection[0] == node.name+&#39;.&#39;+str(CurrentValueWantedVariable):
                foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                logging.debug(f&#34;Node {node.name} found a case/switch with value {CurrentValueWantedVariable} connected to node {foundNodeName}&#34;)
                foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                foundNode.oneConnectionAtStartIsFinished()
                correctPlugFound = True
                node.status=&#39;finished&#39;
                break
            
        #If none are found:
        if correctPlugFound == False:
            logging.warning(&#39;Case/Switch not found, using the Error&#39;)
            for graphConnection in graph:
                if graphConnection[0] == node.name+&#39;.Error&#39;:
                    foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                    foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                    foundNode.oneConnectionAtStartIsFinished()
                    node.status=&#39;finished&#39;
    
    def runslackReportCallAction(self,node):
        &#34;&#34;&#34;
        Call action to send a message to Slack
        &#34;&#34;&#34;
        node.status=&#39;finished&#39;
        try:
            readableText = utils.nodz_evaluateAdv(node.slackReportInfo,node.flowChart,skipEval=True)
            if readableText == None:
                readableText = node.slackReportInfo
            if &#39;SLACK-CLIENT&#39; in self.shared_data.globalData: #type:ignore
                if self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;] is not None and not len(self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;]) == 0: #type:ignore
                    slackReadableText = readableText
                    if not (&#34;&lt;img&gt;&#34; in node.slackReportInfo and &#34;&lt;/img&gt;&#34; in node.slackReportInfo):
                        slackReadableText = slackReadableText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                        slackReadableText = slackReadableText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                        self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].chat_postMessage(channel=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],text=slackReadableText) 
                    else: #we have an image!
                        import re
                        #Extract the text between img tags:
                        imgInfo = re.findall(&#39;&lt;img&gt;(.*?)&lt;/img&gt;&#39;,node.slackReportInfo)[0]
                        restText = re.sub(&#39;&lt;img&gt;(.*?)&lt;/img&gt;&#39;,&#39;&#39;,node.slackReportInfo)
                        restText = restText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                        restText = restText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                        restText = restText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                        restText = restText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                        restText = restText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                        
                        #remove the curly brackets in imgInfo:
                        imgInfo = imgInfo.replace(&#39;{&#39;,&#39;&#39;)
                        imgInfo = imgInfo.replace(&#39;}&#39;,&#39;&#39;)
                        
                        #Get the image
                        im = utils.nodz_evaluateVar(imgInfo,node.flowChart)
                        # Convert the ndarray to a PIL Image
                        from PIL import Image
                        image = Image.fromarray(im/65535*255)# Or convert to RGB
                        image = image.convert(&#34;RGB&#34;)
                        
                        #Store the im as a PNG in a temporary folder:
                        import tempfile
                        tempDir = tempfile.TemporaryDirectory()
                        tempFile = os.path.join(tempDir.name,&#39;slackImage.png&#39;)
                        
                        # Save the image as a PNG file
                        image.save(tempFile, &#34;PNG&#34;)
                        #Send the message with the read-tempFile
                        slack_image = self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].files_upload(
                            title=&#34;Glados Image&#34;,
                            channels=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],
                            content=open(tempFile, &#39;rb&#39;).read(),
                            initial_comment = restText,
                        )
        except Exception as e:
            logging.warning(f&#39;Slack gave an unexpected error: {e}&#39;)
                    
        self.finishedEmits(node)
    #endregion
    
    #region NodzFlowChart runs
    def fullAutonomousRunStart(self):
        &#34;&#34;&#34;
        Starts a full autonomous run - i.e. scoring and acquisition
        
        Args:
            self: The object instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.info(&#39;Starting a full run&#39;)
        self.preventAcq = False
        self.preventScoring = False
        
        #General idea: first check if there are no glaring errors (scoring, position)
        #then go to whatever start position based on the xy positions
        #then run scoring+acquisition there
        
            
        
        self.fullRunOngoing = True
        self.fullRunCurrentPos = 0
        self.fullRunPositions = self.scanningWidget.getPositionInfo()
        # self.startNewScoreAcqAtPos()
        
        #Find the init_start node:
        initStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;initStart_&#39; in node.name:
                    initStartNode = node
        
        #Run the init_start routine:
        if initStartNode is not None:
            self.initStart(initStartNode)
        else:
            logging.error(&#39;Could not find initStart node in flowchart&#39;)

    def startNewScoreAcqAtPos(self):
        &#34;&#34;&#34;
        Starts a new score acquisition at the current microscope position.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        
        import time
        positions = self.fullRunPositions
        pos = self.fullRunCurrentPos
        
        self.shared_data.warningErrorInfoInfo[&#39;Info&#39;][&#39;Other&#39;] = [f&#34;Autonomous run is ongoing! Currently at pos {str(pos+1)}/{str(positions[&#39;nrPositions&#39;])}  ({str(round(pos/positions[&#39;nrPositions&#39;]*100,2))}%)&#34;]
        
        logging.info(f&#39;Starting new score acq at position {pos} -------------------------------------------------------------------------------&#39;)
        
        #Set all stages correct
        for stage in positions[pos][&#39;STAGES&#39;]:
            if stage != &#39;&#39;:
                stagepos = positions[pos][stage]
                #Check if this stage is an XY stage device...
                #Since then we need to do something 2-dimensional
                if stage in self.getDevicesOfDeviceType(&#39;XYStageDevice&#39;):
                    logging.debug(f&#39;Moving stage {stage} to position {stagepos}&#39;)
                    self.shared_data.core.set_xy_position(stage,stagepos[0],stagepos[1]) #type:ignore
                    self.shared_data.core.wait_for_system() #type:ignore
                else:#else we can move a 1d stage:
                    logging.debug(f&#39;Moving stage {stage} to position {stagepos}&#39;)
                    self.shared_data.core.set_position(stage,stagepos[0]) #type:ignore
                    self.shared_data.core.wait_for_system() #type:ignore
        
        self.runScoring()
    
    def runInitOnly(self):
        &#34;&#34;&#34;
        Run ONLY the init process at the current position. Actively prevents scoring
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.preventScoring = True
        self.preventAcq = False
        
        #Find the scoring_start node:
        initStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;initStart_&#39; in node.name:
                    initStartNode = node
        
        #Run the scoring_start routine:
        if initStartNode is not None:
            self.initStart(initStartNode)
        else:
            logging.error(&#39;Could not find initStart node in flowchart&#39;)
            
    
    def runScoringOnly(self):
        &#34;&#34;&#34;
        Run ONLY the scoring process at the current position. Actively prevents acquisition
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.preventAcq = True
        self.preventScoring = False
        
        #Find the scoring_start node:
        scoreStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringStart_&#39; in node.name:
                    scoreStartNode = node
        
        #Run the scoring_start routine:
        if scoreStartNode is not None:
            self.scoringStart(scoreStartNode)
        else:
            logging.error(&#39;Could not find scoringStart node in flowchart&#39;)
    
    def runScoring(self):
        &#34;&#34;&#34;
        Runs the scoring process starting from the scoring_start node, without inhibiting acquisition later - i.e. the scoring before a possible acquisition
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.preventAcq = False
        self.preventScoring = False
        #Find the scoring_start node:
        scoreStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringStart_&#39; in node.name:
                    scoreStartNode = node
        
        
        
        #Run the scoring_start routine:
        if scoreStartNode is not None:
            self.scoringStart(scoreStartNode)
        else:
            logging.error(&#39;Could not find scoringStart node in flowchart&#39;)
    
    def runAcquiring(self):
        &#34;&#34;&#34;
        Run the acquiring process at this microscopy XY position
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.info(&#34;Run Acquiring&#34;)
        
        #Find the acqStart node:
        acqStartNode = None
        flowChart = self
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;acqStart_&#39; in node.name:
                    acqStartNode = node
        
        #Run the scoring_start routine:
        if acqStartNode is not None:
            self.acquiringStart(acqStartNode)
        else:
            logging.error(&#39;Could not find acqStart node in flowchart&#39;)
    
    def interruptRun(self):
        &#34;&#34;&#34; 
        Interrupt the run - stop the scoring/init/acq and stop ongoing acquisitions.
        &#34;&#34;&#34;
        
        #Trying this for now:
        self.shared_data._mdaModeAcqData.abort()
        
        return
    
    def debugScoring(self):
        &#34;&#34;&#34;
        Function to get some debug information from the scoring function(s)
        &#34;&#34;&#34;
        logging.debug(&#34;Debug Scoring&#34;)
        scoreGraph = self.prepareGraph(methodName = &#34;Score&#34;)
        
        
        logging.debug(self)
        logging.debug(self.evaluateGraph())
    #endregion
    
    #region NodzFlowChart GraphArea functions
    def contextMenuEvent(self, QMouseevent):
        &#34;&#34;&#34;
        Function to create a context menu when right-clicking on the nodz canvas

        This function creates a context menu with all available node types that the user can select from, and adds the node to the nodz canvas at the position of the mouse click.

        Args:
            QMouseevent (PyQt5.QtGui.QMouseEvent): The mouse event that triggered this context menu
        &#34;&#34;&#34;
        #Check if we are right-clicking on a node:
        item_at_mouse = self.scene().itemAt(self.mapToScene(QMouseevent.pos()), QtGui.QTransform())
        
        if item_at_mouse == None:
            context_menu = QMenu(self)
            
            def addToContextMenu(context_menu,node_type,node_data):
                &#34;&#34;&#34;  
                Add a node type with node data to the right-click context menu
                &#34;&#34;&#34;
                new_subAction = QAction(node_data[&#39;displayName&#39;], self)
                context_menu.addAction(new_subAction)
                # Define a closure to capture the current value of node_type
                def create_lambda(node_type):
                    &#34;&#34;&#34;
                    Create a lambda function that calls the createNodeFromRightClick method with the specified node type.
                    
                    Args:
                        node_type: The type of node to be created.
                    
                    Returns:
                        A lambda function that takes an event and calls createNodeFromRightClick with the specified node type.
                    &#34;&#34;&#34;
                    return lambda _, event=QMouseevent: self.createNodeFromRightClick(event, nodeType=node_type)
                # Connect each action to its own lambda function
                new_subAction.triggered.connect(create_lambda(node_type))
            
            
            #Every type of node should be in here:
            allEntries = self.nodeInfo[&#39;__RightClickMenuNodeOrder__&#39;]
            
            addedMissedNodeType = False
            #But, we also loop over all entries in self.nodeInfo, and see if we missed any. If we did, we add them to the context menu.
            for nodeType in self.nodeInfo:
                if nodeType != &#39;__RightClickMenuNodeOrder__&#39; and nodeType not in allEntries:
                    if not addedMissedNodeType:
                        allEntries.append(&#39;|&#39;)
                        addedMissedNodeType = True
                    allEntries.append(nodeType)
            
            #We loop over all entries in here:
            for nodeType in allEntries:
                if nodeType == &#39;|&#39;:
                    context_menu.addSeparator()
                else:
                    if nodeType in self.nodeInfo:
                        node_type = nodeType
                        node_data = self.nodeInfo[nodeType]
                        addToContextMenu(context_menu,node_type,node_data)
            
            # Show the context menu at the event&#39;s position
            context_menu.exec_(QMouseevent.globalPos())
        elif item_at_mouse in self.nodes:
            
            context_menu = QMenu(self)
            
            #Add a change-name option
            changeName_subAction = QAction(&#39;Change name&#39;, self)
            context_menu.addAction(changeName_subAction)
            def create_lambda_changeName(item_at_mouse):
                &#34;&#34;&#34;
                Creates a lambda function to change the name of a node.
                
                Args:
                    item_at_mouse: The item at the mouse position.
                
                Returns:
                    A lambda function that calls the changeNodeName method with the item_at_mouse and event as arguments.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.changeNodeName(item_at_mouse, event)
            changeName_subAction.triggered.connect(create_lambda_changeName(item_at_mouse))
            
            #Add a change-color option
            changeColor_subAction = QAction(&#39;Change color&#39;, self)
            context_menu.addAction(changeColor_subAction)
            def create_lambda_changeColor(item_at_mouse):
                &#34;&#34;&#34;
                Creates a lambda function that changes the color of a node.
                
                Args:
                    item_at_mouse: The item at the mouse position.
                
                Returns:
                    A lambda function that calls the &#39;changeNodeColor&#39; method with the specified item and event.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.changeNodeColor(item_at_mouse, event)
            changeColor_subAction.triggered.connect(create_lambda_changeColor(item_at_mouse))
            
            #Add a advanced-info option
            advNodeInfo_subAction = QAction(&#39;Advanced Node info&#39;, self)
            context_menu.addAction(advNodeInfo_subAction)
            def create_lambda_advNodeInfo(item_at_mouse):
                &#34;&#34;&#34;
                Create a lambda function to call the advNodeInfo method with the given item at mouse position.
                
                Args:
                    item_at_mouse: The item at the mouse position to be passed to the advNodeInfo method.
                
                Returns:
                    A lambda function that calls the advNodeInfo method with the item_at_mouse and event parameters.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.advNodeInfo(item_at_mouse, event)
            advNodeInfo_subAction.triggered.connect(create_lambda_advNodeInfo(item_at_mouse))
            
            context_menu.exec_(QMouseevent.globalPos())

    def createNewNode(self, nodeType, event):
        &#34;&#34;&#34;
        Creates a new node on the nodz canvas, with name and preset specified.

        This function creates a new node on the nodz canvas at the position of the mouse event.
        The name of the node is specified by appending a number to the nodeType parameter.
        The preset of the node is set to &#39;node_preset_1&#39;.

        Args:
            nodeType (str): The type of node to create.
            event (PyQt5.QtGui.QMouseEvent): The mouse event that triggered this node creation.
        Returns:
            nodz.Node: The created nodz node.
        &#34;&#34;&#34;
        if self.nodeInfo[nodeType][&#39;NodeCounter&#39;] &gt;= self.nodeInfo[nodeType][&#39;MaxNodeCounter&#39;]:
            logging.error(&#39;Not allowed! Maximum number of nodes of this type reached&#39;)
            return
        
        #Create the new node with correct name and preset
        newNode = self.createNode(name=nodeType+&#34;_&#34;, preset = &#39;node_preset_1&#39;, position=self.mapToScene(event.pos()),displayName = self.nodeInfo[nodeType][&#39;displayName&#39;],nodeInfo=self.nodeInfo[nodeType])
        
        #Do post-node-creation functions - does this via the pyqtsignal!
        return newNode
    
    def createNodeFromRightClick(self,event,nodeType=None):
        &#34;&#34;&#34;
        This function creates a new node in the flowchart when the user right-clicks in the flowchart area. Mostly a wrapper function

        Args:
            event (QMouseEvent): The mouse event that triggered this function.
            nodeType (str): The type of node to create. Defaults to None.

        Returns:
            None
        &#34;&#34;&#34;
        self.createNewNode(nodeType,event)
    
    def focus(self):
        &#34;&#34;&#34;
        Focuses on the entire canvas
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self._focus()
    #endregion</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>nodz_main.Nodz</li>
<li>PyQt5.QtWidgets.QGraphicsView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.AnalysisNode_DEBUG_started"><code class="name flex">
<span>def <span class="ident">AnalysisNode_DEBUG_started</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the Analysis set in a node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node for which calls the analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AnalysisNode_DEBUG_started(self,node):
    &#34;&#34;&#34;
    Perform the Analysis set in a node
    
    Args:
        node: The node for which calls the analysis
    
    Returns:
        None
    &#34;&#34;&#34;
    #Find the node that is connected (i.e. downstream) to this
    connectedNode = None
    for connection in self.evaluateGraph():
        if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == &#39;Analysis start&#39;:
            if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                connectedNode = self.findNodeByName(connectedNodeName)
    if connectedNode is None:
        logging.error(&#39;Error! No connected node found for scoring analysis&#39;)
        return
    
    #Dictionary of nodes to pass around variables.
    nodeDict = utils.createNodeDictFromNodes(self.nodes)
    nodzInfo = node.flowChart
    
    #Figure out which function is selected in the scoring_analysis node
    selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
    #Figure out the belonging evaluation-text
    evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
    
    #And evaluate the custom function with custom parameters
    output = eval(evalText) #type:ignore
    
    #Display final output to the user for now
    logging.info(f&#34;Final output from node {node.name}: {output}&#34;)
    
    #Set the status of the nodz-coupled vis and real-time to finished:
    #Look at the &#39;Visual&#39; bottom attribute and visualise if needed
    visualAttr = node.bottomAttrs[&#39;Visual&#39;]
    if len(visualAttr.connections) &gt; 0:
        visual_connected_node_name = visualAttr.connections[0].socketNode
        for nodeV in self.nodes:
            if nodeV.name == visual_connected_node_name:
                visual_connected_node = nodeV
                
                selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
                visualEvalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;(output,napariLayer)&#39;,&#39;self.shared_data.core&#39;,nodzInfo=self)
                visualEvalText = visualEvalText.replace(selectedFunction,f&#39;{selectedFunction}_visualise&#39;) #type:ignore
                
                chosenLayerType = &#39;points&#39;
                
                layerTypeInfo = [
                    [&#39;Analysis_Measurements&#39;,&#39;points&#39;],
                    [&#39;Analysis_Shapes&#39;,&#39;shapes&#39;],
                    [&#39;Analysis_Images&#39;,&#39;image&#39;],
                ]
                
                folderName = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))+os.sep+&#39;AutonomousMicroscopy&#39;+os.sep
                
                for layerType in layerTypeInfo:
                    for root, dirs, files in os.walk(folderName+layerType[0]):
                        for file in files:
                            if selectedFunction.split(&#39;.&#39;)[0] in file: #type:ignore
                                if file.endswith(&#34;.py&#34;):
                                    with open(os.path.join(root, file), &#39;r&#39;) as f:
                                        filecontent = f.read()
                                    if selectedFunction.split(&#39;.&#39;)[1]+&#39;(&#39; in filecontent: #type:ignore
                                        chosenLayerType = layerType[1]
                                        break #to avoid searching in other files for this function
                
                
                layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                
                #If a layer with this name already exists, simply remove it:
                for layer in self.shared_data.napariViewer.layers: #type:ignore
                    if layer.name == layerName:
                        self.shared_data.napariViewer.layers.remove(layer) #type:ignore
                        
                cmap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                if chosenLayerType == &#39;points&#39;:
                    viewer = self.shared_data.napariViewer #type:ignore
                    napariLayer = viewer.add_points(
                        data=None,
                        text=None,
                        name=layerName,
                        colormap = cmap
                    )
                elif chosenLayerType == &#39;shapes&#39;:
                    viewer = self.shared_data.napariViewer #type:ignore
                    napariLayer = viewer.add_shapes(
                        data=None,
                        name=layerName,
                        colormap = cmap
                    )
                elif chosenLayerType == &#39;image&#39;:
                    logging.debug(&#39;creating new image layer&#39;)
                    viewer = self.shared_data.napariViewer #type:ignore
                    im = np.random.random((30, 30))
                    napariLayer = viewer.add_image(
                        data=im,
                        name=layerName,
                        colormap = cmap
                    )
                
                visualOutput = eval(visualEvalText)
                
                visual_connected_node.status = &#39;finished&#39;
        
        
    node.scoring_analysis_currentData[&#39;__output__&#39;] = output
    
    #Store the output as NodzVariables
    utils.analysis_outputs_store_as_variableNodz(node)
    
    
    #Finish up
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.AnalysisNode_started"><code class="name flex">
<span>def <span class="ident">AnalysisNode_started</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the Analysis set in a node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node for which calls the analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AnalysisNode_started(self,node):
    &#34;&#34;&#34;
    Perform the Analysis set in a node
    
    Args:
        node: The node for which calls the analysis
    
    Returns:
        None
    &#34;&#34;&#34;
    #Find the node that is connected (i.e. downstream) to this
    connectedNode = None
    for connection in self.evaluateGraph():
        if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == &#39;Analysis start&#39;:
            if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                connectedNode = self.findNodeByName(connectedNodeName)
    if connectedNode is None:
        logging.error(&#39;Error! No connected node found for scoring analysis&#39;)
        return
    
    #Dictionary of nodes to pass around variables.
    nodeDict = utils.createNodeDictFromNodes(self.nodes)
    nodzInfo = node.flowChart
    
    #Figure out which function is selected in the scoring_analysis node
    selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
    #Figure out the belonging evaluation-text
    evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
    
    
    worker = generalNodzCallActionWorker(nodzType=&#39;AnalysisNode&#39;,args={&#34;evalText&#34;:evalText, &#34;nodeDict&#34;:nodeDict, &#34;node&#34;:node, &#34;core&#34;: self.core, &#34;shared_data&#34;: self.shared_data})
    #Add the finished emit
    worker.signals.finished.connect(lambda: self.analysisNode_finished(node))
    #Star the worker
    self.thread_pool.start(worker)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.CustomFunctionNode_finished"><code class="name flex">
<span>def <span class="ident">CustomFunctionNode_finished</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CustomFunctionNode_finished(self,node):
    
    output = node.output
    node.customFunction_currentData[&#39;__output__&#39;] = node.output
    
    #Store the output as NodzVariables #TODO
    utils.customFunction_outputs_store_as_variableNodz(node)
    
    #Finish up
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.CustomFunctionNode_started"><code class="name flex">
<span>def <span class="ident">CustomFunctionNode_started</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform the Custom Function set in a node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node for which calls the analysis</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CustomFunctionNode_started(self,node):
    &#34;&#34;&#34;
    Perform the Custom Function set in a node
    
    Args:
        node: The node for which calls the analysis
    
    Returns:
        None
    &#34;&#34;&#34;
    #Dictionary of nodes to pass around variables.
    nodeDict = utils.createNodeDictFromNodes(self.nodes)
    nodzInfo = node.flowChart
    
    #Figure out which function is selected in the customFunction node
    selectedFunction = utils.functionNameFromDisplayName(node.customFunction_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.customFunction_currentData[&#39;__displayNameFunctionNameMap__&#39;])
    #Figure out the belonging evaluation-text
    evalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.customFunction_currentData,&#39;self.shared_data.core&#39;,&#39;&#39;,nodzInfo=self,skipp2=True)
    
    worker = generalNodzCallActionWorker(nodzType=&#39;CustomFunctionNode&#39;,args={&#34;evalText&#34;:evalText, &#34;nodeDict&#34;:nodeDict, &#34;node&#34;:node, &#34;core&#34;: self.core, &#34;shared_data&#34;: self.shared_data})
    #Add the finished emit
    worker.signals.finished.connect(lambda: self.CustomFunctionNode_finished(node))
    #Star the worker
    self.thread_pool.start(worker)
    
    # #And evaluate the custom function with custom parameters
    # output = eval(evalText) #type:ignore
    
    # node.customFunction_currentData[&#39;__output__&#39;] = output
    
    # #Store the output as NodzVariables
    # # utils.analysis_outputs_store_as_variableNodz(node)
    
    # #Finish up
    # self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.GraphToSignals"><code class="name flex">
<span>def <span class="ident">GraphToSignals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Idea: we evaluate the graph at this time point, connect all signals/emits:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GraphToSignals(self):
    &#34;&#34;&#34;Idea: we evaluate the graph at this time point, connect all signals/emits:
    
    &#34;&#34;&#34;
    logging.debug(&#39;graphicing to signals&#39;)
    #Loop over all nodes:
    for node in self.nodes:
        node.n_connect_at_start = 0
        node.n_connect_at_start_finished = 0
        #Disconnect all signals, but only if there are any
        if node.customFinishedEmits is not None and len(node.customFinishedEmits.signals)&gt;0:
            signal = node.customFinishedEmits.signals[0] #type: ignore
            try:
                #This disconnects all signals
                signal.disconnect()
            except:
                #Otherwise we FULLY reset the signal?
                logging.debug(&#39;attempted to disconnect a disconnected signal&#39;)
                # nodeType = self.nodeLookupName_withoutCounter(node.name)
                # if len(self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]) &gt; 0:
                #     node.customFinishedEmits = NodeSignalManager()
                #     for attr in self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]:
                #         node.customFinishedEmits.add_signal(attr) #type: ignore
                # else:
                #     node.customFinishedEmits = None
        
        if node.customDataEmits is not None and len(node.customDataEmits.signals)&gt;0:
            signal = node.customDataEmits.signals[0] #type: ignore
            try:
                #This disconnects all signals
                signal.disconnect()
            except:
                logging.warning(&#39;attempted to disconnect a disconnected signal&#39;)
                # nodeType = self.nodeLookupName_withoutCounter(node.name)
                # if len(self.nodeInfo[nodeType][&#39;dataAttributes&#39;]) &gt; 0:
                #     node.customDataEmits = NodeSignalManager()
                #     for attr in self.nodeInfo[nodeType][&#39;dataAttributes&#39;]:
                #         node.customDataEmits.add_signal(attr) #type: ignore
                # else:
                #     node.customDataEmits = None
        
    #Create all required signal connections
    currentgraph = self.evaluateGraph()
    for connection in currentgraph:
        plugAttribute = connection[0][connection[0].rfind(&#39;.&#39;)+1:]
        socketAttribute = connection[1][connection[1].rfind(&#39;.&#39;)+1:]
        srcNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
        dstNodeName = connection[1][:connection[1].rfind(&#39;.&#39;)]
        
        if self.nodeLookupName_withoutCounter(srcNodeName) is not None and self.nodeLookupName_withoutCounter(dstNodeName) is not None:
            typeOfFinishedAttributes_of_srcNode = self.nodeInfo[self.nodeLookupName_withoutCounter(srcNodeName)][&#39;finishedAttributes&#39;]
            typeOfDataAttributes_of_srcNode = self.nodeInfo[self.nodeLookupName_withoutCounter(srcNodeName)][&#39;dataAttributes&#39;]
            typeOfStartAttributes_of_dstNode = self.nodeInfo[self.nodeLookupName_withoutCounter(dstNodeName)][&#39;startAttributes&#39;]
        
            #Connect the finished event of the source node to the &#39;we finished one of the prerequisites&#39; at the destination node
            if plugAttribute in typeOfFinishedAttributes_of_srcNode and socketAttribute in typeOfStartAttributes_of_dstNode:
                srcNode = self.findNodeByName(srcNodeName)
                dstNode = self.findNodeByName(dstNodeName)
                #The destination node needs one extra to be started...
                dstNode.n_connect_at_start += 1 #type: ignore
                
                #And the finished event of the source node is connected to the &#39;we finished one of the prerequisites&#39; at the destination node
                srcNode.customFinishedEmits.signals[0].connect(dstNode.oneConnectionAtStartIsFinished) #type: ignore
                
                logging.debug(f&#34;connected Finish {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
            #Same for data
            elif plugAttribute in typeOfDataAttributes_of_srcNode and socketAttribute in typeOfStartAttributes_of_dstNode:
                srcNode = self.findNodeByName(srcNodeName)
                dstNode = self.findNodeByName(dstNodeName)
                #The destination node needs one extra to be started...
                dstNode.n_connect_at_start += 1 #type: ignore
                
                #And the finished event of the source node is connected to the &#39;we gave data&#39; at the destination node
                srcNode.customDataEmits.signals[0].connect(dstNode.oneConnectionAtStartProvidesData) #type: ignore
                logging.debug(f&#34;connected Data {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)
            else:
                logging.warning(f&#34;not connected {srcNodeName} to {dstNodeName} via {plugAttribute} to {socketAttribute}&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.MMconfigChangeRan"><code class="name flex">
<span>def <span class="ident">MMconfigChangeRan</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the configuration change event for a node.</p>
<p>This function handles the configuration change event for a node, by
changing the desired configs in the Core.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MMconfigChangeRan(self,node):
    &#34;&#34;&#34;
    Handle the configuration change event for a node.

    This function handles the configuration change event for a node, by
    changing the desired configs in the Core.

    Args:
        node (nodz.Node): The node that has triggered the event.
    &#34;&#34;&#34;
    logging.debug(&#39;MMconfigChangeRan&#39;)
    
    
    #Create the worker
    worker = generalNodzCallActionWorker(nodzType=&#39;MMconfigChangeRan&#39;,args={&#34;config_string_storage&#34;:node.MMconfigInfo.config_string_storage, &#34;MMconfig&#34;:node.MMconfigInfo, &#34;core&#34;: self.core})
    #Add the finished emit
    worker.signals.finished.connect(lambda: self.finishedEmits(node))
    #Star the worker
    self.thread_pool.start(worker)
    
    # self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.MMstageChangeRan"><code class="name flex">
<span>def <span class="ident">MMstageChangeRan</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the stage of the microscope based on the node info</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The MM node to change the stage for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MMstageChangeRan(self,node):
    #TODO: Implement this :)
    &#34;&#34;&#34;
    Change the stage of the microscope based on the node info
    
    Args:
        node: The MM node to change the stage for.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    for stor in node.MMconfigInfo.relstage_string_storage:
        if stor[0] == &#39;__chosenRelStage__&#39;:
            stageToMove = stor[1]
    
    for stor in node.MMconfigInfo.relstage_string_storage:
        if stor[0] == stageToMove:
            distToMove = float(stor[1])
    
    self.core.set_relative_position(stageToMove,distToMove)
    
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeAdded"><code class="name flex">
<span>def <span class="ident">NodeAdded</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when one or more nodes are created in the flowchart.</p>
<p>When one or more nodes are created in the flowchart, this function is called.
It does some pre-processing of the node and then calls performPostNodeCreation_Start.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NodeAdded(self,node):
    &#34;&#34;&#34;
    Handle when one or more nodes are created in the flowchart.

    When one or more nodes are created in the flowchart, this function is called.
    It does some pre-processing of the node and then calls performPostNodeCreation_Start.
    &#34;&#34;&#34;
    logging.debug(&#39;one or more nodes are created!&#39;)
    nodeType = self.nodeLookupName_withoutCounter(node.name)
    self.performPostNodeCreation_Start(node,nodeType)
    self.checkNodesOnErrors()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeDoubleClicked"><code class="name flex">
<span>def <span class="ident">NodeDoubleClicked</span></span>(<span>self, nodeName)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle double-clicking on a node in the flowchart.</p>
<p>When a node is double-clicked, this function is called. Depending on the node, this
function will open a dialog to modify the node's data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NodeDoubleClicked(self,nodeName):
    &#34;&#34;&#34;
    Handle double-clicking on a node in the flowchart.

    When a node is double-clicked, this function is called. Depending on the node, this 
    function will open a dialog to modify the node&#39;s data.
    &#34;&#34;&#34;
    currentNode = self.findNodeByName(nodeName)
    if &#39;acquisition&#39; in nodeName:
        dialog = nodz_openMDADialog(parentData=self,currentNode = currentNode)
        if dialog.exec_() == QDialog.Accepted:
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;acquisition&#39;)
            currentNode.dialogInfo = dialog #type:ignore
            logging.debug(f&#34;MDA dialog input: {dialog.getInputs()}&#34;)
        
        # currentNode.mdaData.exposure_ms = dialog.getExposureTime()
        # currentNode.mdaData.mda = dialog.getInputs()#type:ignore
        dialogmdaData = dialog.getmdaData()
        attrs_to_not_copy = [&#39;gui&#39;,&#39;core&#39;,&#39;shared_data&#39;,&#39;has_GUI&#39;,&#39;data&#39;,&#39;staticMetaObject&#39;,&#39;MDA_completed&#39;,&#39;MM_JSON&#39;]
        #Loop over all attributes in dialogmdaData:
        for attrs in vars(dialogmdaData):
            if attrs not in attrs_to_not_copy:
                setattr(currentNode.mdaData,attrs,getattr(dialogmdaData,attrs)) #type:ignore
        
        currentNode.update() #type:ignore
    elif &#39;changeProperties&#39; in nodeName:
        currentNode = self.findNodeByName(nodeName)
        #Show dialog:
        if &#39;MMconfigInfo&#39; in vars(currentNode):
            storedConfigsStrings = currentNode.MMconfigInfo.config_string_storage #type: ignore
        else:
            currentNode.MMconfigInfo = [] #type: ignore
            storedConfigsStrings = None
        dialog = nodz_openMMConfigDialog(parentNode=currentNode,storedConfigsStrings = storedConfigsStrings) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeProperties&#39;)
            #Update the results of this dialog into the nodz node   
            self.changeConfigStorageInNodz(currentNode,dialog.ConfigsToBeChanged())
    elif &#39;visualisation_&#39; in nodeName:
        currentNode = self.findNodeByName(nodeName)
        #Show dialog:
        dialog = nodz_visualisationDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;visualisation&#39;)
            currentNode.visualisation_currentData[&#39;layerName&#39;] = dialog.layerNameEdit.text() #type:ignore
            currentNode.visualisation_currentData[&#39;colormap&#39;] = dialog.colormapComboBox.currentText() #type:ignore
    elif &#39;changeStagePos&#39; in nodeName:
        currentNode = self.findNodeByName(nodeName)
        #Show dialog:
        if &#39;MMconfigInfo&#39; in vars(currentNode):
            storedRelStagesString = currentNode.MMconfigInfo.relstage_string_storage #type: ignore
        else:
            currentNode.MMconfigInfo = [] #type: ignore
            storedRelStagesString = None
        dialog = nodz_openMMConfigDialog(parentNode=currentNode,storedrelStagesString = storedRelStagesString) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            #Update the results of this dialog into the nodz node
            self.changeRelStageStorageInNodz(currentNode,dialog.RelStageInfo())
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeStagePos&#39;)
            
    elif &#39;analysisMeasurement&#39; in nodeName or &#39;analysisMeasurementDEBUG&#39; in nodeName:
        currentNode = self.findNodeByName(nodeName)
        dialog = nodz_analysisDialog(currentNode = currentNode, parent = self)
        if dialog.exec_() == QDialog.Accepted:
            
            #Update the results of this dialog into the nodz node
            currentNode.scoring_analysis_currentData = dialog.currentData #type:ignore
            utils.analysis_outputs_to_variableNodz(currentNode)
            try:
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;analysisMeasurement&#39;)
            except:
                logging.warning(&#39;Failed to set text in analysisMeasurementDialog&#39;)
            logging.debug(&#39;Pressed OK on analysisMeasurementDialog&#39;)
    elif &#39;customFunction&#39; in nodeName:
        currentNode = self.findNodeByName(nodeName)
        dialog = nodz_customFunctionDialog(currentNode = currentNode, parent = self)
        if dialog.exec_() == QDialog.Accepted:
            #Update the results of this dialog into the nodz node
            currentNode.customFunction_currentData = dialog.currentData #type:ignore
            utils.customFunction_outputs_to_variableNodz(currentNode)
            try:
                currentNode.dialogInfo = dialog #type:ignore
                self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;customFunction&#39;)
            except:
                logging.warning(&#39;Failed to set text in analysisMeasurementDialog&#39;)
            logging.debug(&#39;Pressed OK on customFunctionDialog&#39;)
        
        
    elif &#39;realTimeAnalysis&#39; in nodeName:
        currentNode = self.findNodeByName(nodeName)
        #TODO: pre-load dialog.currentData with currentNode.currentData if that exists (better naming i guess) to hold all pre-selected data 
        dialog = nodz_realTimeAnalysisDialog(currentNode = currentNode, parent = self)
        if dialog.exec_() == QDialog.Accepted:
            #Update the results of this dialog into the nodz node
            currentNode.real_time_analysis_currentData = dialog.currentData #type:ignore
            currentNode.real_time_analysis_currentData[&#39;__selectedDropdownEntryRTAnalysis__&#39;] = dialog.comboBox_RTanalysisFunctions.currentText() #type:ignore
            currentNode.real_time_analysis_currentData[&#39;__realTimeVisualisation__&#39;] = dialog.visualisationBox.isChecked() #type:ignore 
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;RTanalysisMeasurement&#39;)
            logging.debug(&#39;Pressed OK on RTanalysis&#39;)
            
    elif &#39;timer&#39; in nodeName:
        dialog = nodz_openTimerDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.timerInfo = dialog.timerInfo #type:ignore
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;timer&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;storeData&#39; in nodeName:
        dialog = nodz_openStoreDataDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.storeDataInfo = dialog.storeDataInfo #type:ignore
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;storeData&#39;)
    elif &#39;changeGlobalVar&#39; in nodeName:
        dialog = nodz_openChangeGlobalVarDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.changeGlobalVarInfo = dialog.changeGlobalVarInfo #type:ignore
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;changeGlobalVar&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;ifStatement&#39; in nodeName:
        dialog = nodz_openIfStatementDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.ifStatementInfo = dialog.ifStatementInfo #type:ignore
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;ifStatement&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;newGlobalVar&#39; in nodeName:
        dialog = nodz_openNewGlobalVarDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.newGlobalVarInfo = dialog.newGlobalVarInfo #type:ignore
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;newGlobalVar&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;runInlineScript&#39; in nodeName:
        dialog = nodz_openInlineScriptDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.InlineScriptInfo = dialog.InlineScriptInfo #type:ignore
            currentNode.dialogInfo = dialog #type:ignore
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;runInlineScript&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;caseSwitch&#39; in nodeName:
        dialog = nodz_caseSwitchDialog(parentNode=currentNode,currentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            dialogLineEdits = []
            for lineEdit in dialog.lineEdits:
                dialogLineEdits.append(lineEdit.text())
            self.update_plugs_fromDialog(currentNode,dialogLineEdits)
            
            currentNode.caseSwitchInfo = dialog.caseSwitchInfo
            currentNode.caseSwitchInfo[&#39;Plugs&#39;] = dialogLineEdits
            
            #Update the node itself
            self.update()
            nodeType = self.nodeLookupName_withoutCounter(nodeName)
            for _ in range(3):
                self.updateNumberStartFinishedDataAttributes(currentNode,nodeType)
                self.update()
            
            logging.debug(dialogLineEdits)
            logging.debug(&#39;Pressed OK on caseSwitch&#39;)
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;caseSwitch&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;slackReport&#39; in nodeName:
        dialog = nodz_slackReportDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.slackReportInfo = dialog.slackReportInfo
            logging.debug(&#39;Pressed OK on caseSwitch&#39;)
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;slackReport&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;stickyNote&#39; in nodeName:
        dialog = nodz_stickyNoteDialog(parentNode=currentNode) #type:ignore
        if dialog.exec_() == QDialog.Accepted:
            currentNode.stickyNoteInfo = dialog.stickyNoteInfo
            logging.debug(&#39;Pressed OK on stickyNote&#39;)
            self.set_readable_text_after_dialogChange(currentNode,dialog,&#39;stickyNote&#39;)
        # currentNode.callAction(self) #type:ignore
    elif &#39;scoringStart&#39; in nodeName:
        currentNode.callAction(self) #type:ignore
    elif &#39;scoringEndVar&#39; in nodeName:
        dialog = nodz_openScoringEndVarDialog(parent=self,currentNode=currentNode)
        if dialog.exec_() == QDialog.Accepted:
            #Update the decisionwidget:
            self.decisionWidget.updateAllDecisions()
            logging.debug(&#39;Pressed OK on scoringEndVar&#39;)
    elif &#39;scoringEnd&#39; in nodeName:
        dialog = nodz_openScoringEndDialog(parent=self,currentNode=currentNode)
        if dialog.exec_() == QDialog.Accepted:
            dialogLineEdits = []
            for lineEdit in dialog.lineEdits:
                dialogLineEdits.append(lineEdit.text())
            self.update_scoring_end(currentNode,dialogLineEdits)
            #Update the node itself
            self.update()
            nodeType = self.nodeLookupName_withoutCounter(nodeName)
            self.updateNumberStartFinishedDataAttributes(currentNode,nodeType)
            self.update()
            
            #Update the decisionwidget:
            self.decisionWidget.updateAllDecisions()
            logging.debug(dialogLineEdits)
            logging.debug(&#39;Pressed OK on scoringEnd&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeFullyInitialised"><code class="name flex">
<span>def <span class="ident">NodeFullyInitialised</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when a node is fully initialised.</p>
<p>Specifically, when all e.g. data['NODES_SCORING_SCORING'] from loading is added to the node, only after that, this will run.</p>
<p>This function is called when a node is fully initialised. It does some
post-initialisation processing for nodes based on their type.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>Node</code></dt>
<dd>The node that has been fully initialised.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NodeFullyInitialised(self,node):
    &#34;&#34;&#34;
    Handle when a node is fully initialised.
    
    Specifically, when all e.g. data[&#39;NODES_SCORING_SCORING&#39;] from loading is added to the node, only after that, this will run.

    This function is called when a node is fully initialised. It does some
    post-initialisation processing for nodes based on their type.

    Parameters
    ----------
    node : Node
        The node that has been fully initialised.
    &#34;&#34;&#34;
    nodeType = self.nodeLookupName_withoutCounter(node.name)
    if nodeType == &#39;scoringEnd&#39;:
        self.update_scoring_end(node,node.scoring_end_currentData[&#39;Variables&#39;])
    if nodeType == &#39;caseSwitch&#39;:
        if &#39;Plugs&#39; in node.caseSwitchInfo:
            self.update_plugs_fromDialog(node,node.caseSwitchInfo[&#39;Plugs&#39;])
            
    self.checkNodesOnErrors()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeRemoved"><code class="name flex">
<span>def <span class="ident">NodeRemoved</span></span>(<span>self, nodeNames)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when one or more nodes are removed from the flowchart.</p>
<p>When one or more nodes are removed from the flowchart, this function is called.
It will update the node counters of the corresponding node types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NodeRemoved(self,nodeNames):
    &#34;&#34;&#34;
    Handle when one or more nodes are removed from the flowchart.

    When one or more nodes are removed from the flowchart, this function is called.
    It will update the node counters of the corresponding node types.
    &#34;&#34;&#34;
    logging.debug(&#39;one or more nodes are removed!&#39;)
    for nodeName in nodeNames:
        for node_type, node_data in self.nodeInfo.items():
            if node_type != &#39;__RightClickMenuNodeOrder__&#39;:
                try:
                    if node_data[&#39;name&#39;] in nodeName:
                        # if self.nodeInfo[node_type][&#39;MaxNodeCounter&#39;] &lt; np.inf:
                        self.nodeInfo[node_type][&#39;NodeCounter&#39;] -= 1
                except:
                    pass
        #Also remove from self.nodes:
        node = self.findNodeByName(nodeName)
        try:
            self.nodes.remove(node)
        except:
            logging.warning(f&#34;failed to remove node: {nodeName}&#34;)
    self.checkNodesOnErrors()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugConnected"><code class="name flex">
<span>def <span class="ident">PlugConnected</span></span>(<span>self, srcNodeName, plugAttribute, dstNodeName, socketAttribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when a plug is connected.</p>
<p>When a plug is connected, this function is called. It will check if the destination
node should be marked as 'started' based on the attributes connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlugConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
    &#34;&#34;&#34;
    Handle when a plug is connected.

    When a plug is connected, this function is called. It will check if the destination
    node should be marked as &#39;started&#39; based on the attributes connected.
    &#34;&#34;&#34;
    #Check if all are non-Nones:
    logging.debug(&#39;plug connected&#39;)
    self.checkNodesOnErrors()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugOrSocketConnected"><code class="name flex">
<span>def <span class="ident">PlugOrSocketConnected</span></span>(<span>self, srcNodeName, plugAttribute, dstNodeName, socketAttribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when a plug or socket is connected.</p>
<p>When a plug or socket is connected, this function is called. It will check if the destination
node should be marked as 'started' or 'finished' based on the attributes connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlugOrSocketConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
    &#34;&#34;&#34;
    Handle when a plug or socket is connected.

    When a plug or socket is connected, this function is called. It will check if the destination
    node should be marked as &#39;started&#39; or &#39;finished&#39; based on the attributes connected.
    &#34;&#34;&#34;
    logging.debug(f&#34;plug/socket connected start: {srcNodeName}, {plugAttribute}, {dstNodeName}, {socketAttribute}&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugOrSocketDisconnected"><code class="name flex">
<span>def <span class="ident">PlugOrSocketDisconnected</span></span>(<span>self, srcNodeName, plugAttribute, dstNodeName, socketAttribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when a plug or socket is disconnected.</p>
<p>When a plug or socket is disconnected, this function is called. It will disconnect
the finished event of the source node from the 'we finished one of the prerequisites' at the destination node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlugOrSocketDisconnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
    &#34;&#34;&#34;
    Handle when a plug or socket is disconnected.

    When a plug or socket is disconnected, this function is called. It will disconnect
    the finished event of the source node from the &#39;we finished one of the prerequisites&#39; at the destination node.
    &#34;&#34;&#34;
    logging.debug(&#39;plugorsocketdisconnected&#39;)
    self.checkNodesOnErrors()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.SocketConnected"><code class="name flex">
<span>def <span class="ident">SocketConnected</span></span>(<span>self, srcNodeName, plugAttribute, dstNodeName, socketAttribute)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when a socket is connected.</p>
<p>When a socket is connected, this function is called. It does not do anything
special, it only exists to keep the Node class happy by having a method that
corresponds to the 'SocketConnected' signal from the FlowChart.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SocketConnected(self,srcNodeName, plugAttribute, dstNodeName, socketAttribute):
    &#34;&#34;&#34;
    Handle when a socket is connected.

    When a socket is connected, this function is called. It does not do anything
    special, it only exists to keep the Node class happy by having a method that
    corresponds to the &#39;SocketConnected&#39; signal from the FlowChart.
    &#34;&#34;&#34;
    #Only one specific use-case at the moment:
    #If a connection is made between any node N to an analysisMeasurement node, and if there is at least one acquisition node linked at or downstream of N, and if the input of the analysisMeasurement is not already defined, and if the input is actually an image, fill the input data of the analysisMeasurement node to be the data of this acquisition node.
    
    
    #Possibly later, for any other nodes, set the &#39;input&#39; of the right node to the &#39;default&#39; of the left node, if typing accomodates.
    
    #TODO
    #First, we need to create some function to look at the downstream-connected nodes of some node - this needs to be a rather proper function.
    
    if &#39;analysisMeasurement_&#39; in dstNodeName or &#39;analysisMeasurementDEBUG_&#39; in dstNodeName:
        srcNode = nodz_utils.findNodeByName(self,srcNodeName)
        dstNode = nodz_utils.findNodeByName(self,dstNodeName)
        
        downstreamConnections = nodz_utils.findConnectedToNode(self.evaluateGraph(),dstNodeName,[],upstream=False,downstream=True) 
        #Note: first entry is always closest to node.
        #So we check if there is at least one acquisition node downstream of the dstNode:
        shortestConnectedAcquisition = None
        for connection in downstreamConnections:
            if &#39;acquisition_&#39; in connection:
                shortestConnectedAcquisition = nodz_utils.findNodeByName(self,connection)
                break
        
        if shortestConnectedAcquisition is not None:
            for function in dstNode.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;]: #type:ignore
                inputOfFunction = utils.inputFromFunction(function[1])[0][0]
                
                lineEditName = &#39;LineEdit#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                lineEditVarName = &#39;LineEditVariable#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                lineEditAdvName = &#39;LineEditAdv#&#39;+function[1]+&#39;#&#39;+inputOfFunction[&#39;name&#39;] #type:ignore
                if lineEditVarName in dstNode.scoring_analysis_currentData: #type:ignore
                    if dstNode.scoring_analysis_currentData[lineEditVarName] == &#39;&#39;: #type:ignore
                        import ndtiff
                        if ndtiff.NDTiffDataset in inputOfFunction[&#39;type&#39;]: #type:ignore
                            if ndtiff.NDTiffDataset in shortestConnectedAcquisition.variablesNodz[&#39;data&#39;][&#39;type&#39;]:
                                dstNode.scoring_analysis_currentData[lineEditVarName] = &#39;data@&#39;+shortestConnectedAcquisition.name #type:ignore
                            
    
    
    #Check if all are non-Nones:
    logging.debug(&#39;socket connected&#39;)
    self.checkNodesOnErrors()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.acquiringEnd"><code class="name flex">
<span>def <span class="ident">acquiringEnd</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the Acquiring End node in the Flowchart.</p>
<p>This function signals to the rest of the flowchart that the Acquiring routine is ended</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquiringEnd(self,node):
    &#34;&#34;&#34;
    This function is the action function for the Acquiring End node in the Flowchart.

    This function signals to the rest of the flowchart that the Acquiring routine is ended

    Args:
        node (nodz.Node): The node that has triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    #This finishedEmit needs to be at the start of this function :) 
    self.finishedEmits(node)
    logging.debug(&#34;End Acquiring----------------------------------------------------------&#34;)
    if self.fullRunOngoing:
        #if there are more positions to look at...
        if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
            logging.info(f&#39;Just did position {self.fullRunCurrentPos+1}/{self.fullRunPositions[&#34;nrPositions&#34;]}, continuing!--------------------------------------------------------&#39;)
            self.fullRunCurrentPos +=1
            #And start a new score/acq at a new pos:
            self.startNewScoreAcqAtPos()
        else:
            logging.info(f&#39;ALLDONE Just did position {self.fullRunCurrentPos+1}/{self.fullRunPositions[&#34;nrPositions&#34;]}, continuing!----------------------------------------------------------&#39;)
            self.singleRunOngoing = False
    else:
        logging.info(&#34;ACQUIRING FULL RUN IS NOT ONGOING--------------------------------------------&#34;)
    logging.debug(&#34;End Acquiring2------------------------------------------------------------&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.acquiringStart"><code class="name flex">
<span>def <span class="ident">acquiringStart</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the Acquiring Start node in the Flowchart.</p>
<p>This function signals to the rest of the flowchart that it's time to start
the Acquiring routine.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquiringStart(self,node):
    &#34;&#34;&#34;
    This function is the action function for the Acquiring Start node in the Flowchart.

    This function signals to the rest of the flowchart that it&#39;s time to start
    the Acquiring routine.

    Args:
        node (nodz.Node): The node that has triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    if self.preventAcq == False:
        logging.debug(&#39;Starting the acquiring routine!&#39;)
        
        #Set all connected nodes to idle
        connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
        for connectedNode in connectedNodes:
            for nodeC in self.nodes:
                if nodeC.name == connectedNode:
                    nodeC.status=&#39;idle&#39;
        self.update()
                    
        self.GraphToSignals()
        
        self.finishedEmits(node)
    else:
        logging.warning(&#39;Would have started acquiring, but was prevented!&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.advNodeInfo"><code class="name flex">
<span>def <span class="ident">advNodeInfo</span></span>(<span>self, node, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Show advanced information about a node in a popup window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node object for which advanced information is to be displayed.</dd>
<dt><strong><code>event</code></strong></dt>
<dd>The event triggering the display of advanced information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advNodeInfo(self,node,event):
    &#34;&#34;&#34;
    Show advanced information about a node in a popup window.
    
    Args:
        node: The node object for which advanced information is to be displayed.
        event: The event triggering the display of advanced information.
    
    Returns:
        None
    &#34;&#34;&#34;
    #Create a quick popup window with a line edit and an ok/cancel:
    dialog = QDialog()
    dialog.setWindowTitle(&#39;Node info&#39;)
    dialog.setModal(True)
    layout = QVBoxLayout(dialog)

    
    textEdit = QTextEdit()
    
    attrs_to_show = [&#39;name&#39;,&#39;displayName&#39;,&#39;nodePreset&#39;,&#39;plugs&#39;,&#39;sockets&#39;,&#39;scoring_analysis_currentData&#39;,&#39;scoring_end_currentData&#39;,&#39;scoring_scoring_currentData&#39;,&#39;scoring_visualisation_currentData&#39;,&#39;visualisation_currentData&#39;,&#39;real_time_analysis_currentData&#39;]
    
    text_to_show = &#39;&#39;
    for attr in attrs_to_show:
        if hasattr(node,attr):
            text_to_show += f&#39;{attr}: {str(getattr(node,attr))}\n&#39;
    
    #Custom add these ones:
    if hasattr(node,&#39;mdaData&#39;):
        if hasattr(node.mdaData,&#39;mda&#39;):
            text_to_show += f&#39;mda: {str(node.mdaData.mda)}\n&#39;
    if hasattr(node,&#39;MMconfigInfo&#39;):
        if hasattr(node.MMconfigInfo,&#39;config_string_storage&#39;):
            text_to_show += f&#39;config_string_storage: {str(node.MMconfigInfo.config_string_storage)}\n&#39;
    
    textEdit.setText(text_to_show)
    layout.addWidget(textEdit)

    buttonBox = QDialogButtonBox(QDialogButtonBox.Ok, dialog)
    layout.addWidget(buttonBox)

    buttonBox.accepted.connect(dialog.accept)
    
    if dialog.exec_() == QDialog.Accepted:
        logging.debug(&#39;advanced node info closed&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.analysisNode_finished"><code class="name flex">
<span>def <span class="ident">analysisNode_finished</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analysisNode_finished(self,node):
    #Set the status of the nodz-coupled vis and real-time to finished:
    #Look at the &#39;Visual&#39; bottom attribute and visualise if needed
    output = node.output
    #Dictionary of nodes to pass around variables.
    nodeDict = utils.createNodeDictFromNodes(self.nodes)
    nodzInfo = node.flowChart
    
    visualAttr = node.bottomAttrs[&#39;Visual&#39;]
    if len(visualAttr.connections) &gt; 0:
        visual_connected_node_name = visualAttr.connections[0].socketNode
        for nodeV in self.nodes:
            if nodeV.name == visual_connected_node_name:
                visual_connected_node = nodeV
                
                selectedFunction = utils.functionNameFromDisplayName(node.scoring_analysis_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;],node.scoring_analysis_currentData[&#39;__displayNameFunctionNameMap__&#39;])
                visualEvalText = utils.getFunctionEvalTextFromCurrentData(selectedFunction,node.scoring_analysis_currentData,&#39;(output,napariLayer)&#39;,&#39;self.shared_data.core&#39;,nodzInfo=self)
                visualEvalText = visualEvalText.replace(selectedFunction,f&#39;{selectedFunction}_visualise&#39;) #type:ignore
                
                chosenLayerType = &#39;points&#39;
                
                layerTypeInfo = [
                    [&#39;Analysis_Measurements&#39;,&#39;points&#39;],
                    [&#39;Analysis_Shapes&#39;,&#39;shapes&#39;],
                    [&#39;Analysis_Images&#39;,&#39;image&#39;],
                ]
                
                folderName = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))+os.sep+&#39;AutonomousMicroscopy&#39;+os.sep
                
                for layerType in layerTypeInfo:
                    for root, dirs, files in os.walk(folderName+layerType[0]):
                        for file in files:
                            if selectedFunction.split(&#39;.&#39;)[0] in file: #type:ignore
                                if file.endswith(&#34;.py&#34;):
                                    with open(os.path.join(root, file), &#39;r&#39;) as f:
                                        filecontent = f.read()
                                    if selectedFunction.split(&#39;.&#39;)[1]+&#39;(&#39; in filecontent: #type:ignore
                                        chosenLayerType = layerType[1]
                                        break #to avoid searching in other files for this function
                
                
                layerName = visual_connected_node.visualisation_currentData[&#39;layerName&#39;]
                
                #If a layer with this name already exists, simply remove it:
                for layer in self.shared_data.napariViewer.layers: #type:ignore
                    if layer.name == layerName:
                        self.shared_data.napariViewer.layers.remove(layer) #type:ignore
                        
                cmap = visual_connected_node.visualisation_currentData[&#39;colormap&#39;]
                if chosenLayerType == &#39;points&#39;:
                    viewer = self.shared_data.napariViewer #type:ignore
                    napariLayer = viewer.add_points(
                        data=None,
                        text=None,
                        name=layerName,
                        colormap = cmap
                    )
                elif chosenLayerType == &#39;shapes&#39;:
                    viewer = self.shared_data.napariViewer #type:ignore
                    napariLayer = viewer.add_shapes(
                        data=None,
                        name=layerName,
                        colormap = cmap
                    )
                elif chosenLayerType == &#39;image&#39;:
                    logging.debug(&#39;creating new image layer&#39;)
                    viewer = self.shared_data.napariViewer #type:ignore
                    im = np.random.random((30, 30))
                    napariLayer = viewer.add_image(
                        data=im,
                        name=layerName,
                        colormap = cmap
                    )
                
                visualOutput = eval(visualEvalText)
                
                visual_connected_node.status = &#39;finished&#39;
    
    
    node.scoring_analysis_currentData[&#39;__output__&#39;] = node.output
    
    #Store the output as NodzVariables
    utils.analysis_outputs_store_as_variableNodz(node)
    
    
    #Finish up
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.and_logicCallAction"><code class="name flex">
<span>def <span class="ident">and_logicCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs when the and_logic gate is fully completed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def and_logicCallAction(self,node):
    &#34;&#34;&#34; 
    Runs when the and_logic gate is fully completed
    &#34;&#34;&#34;
    #Honestly just needs to run the next nodes
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeConfigStorageInNodz"><code class="name flex">
<span>def <span class="ident">changeConfigStorageInNodz</span></span>(<span>self, currentNode, configNameSet)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to change the config storage of a nodz node from the double-click popup to the MMconfigInfo class stored inside the node.</p>
<p>This is useful when storing and loading configurations for a node, as the MMconfigInfo class can be serialized and deserialized.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>currentNode</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node to change the config storage of.</dd>
<dt><strong><code>configNameSet</code></strong> :&ensp;<code>set</code> of <code>tuples</code></dt>
<dd>A set of tuples in the form (configName, selectedValue)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeConfigStorageInNodz(self,currentNode,configNameSet):
    &#34;&#34;&#34;
    Function to change the config storage of a nodz node from the double-click popup to the MMconfigInfo class stored inside the node.

    This is useful when storing and loading configurations for a node, as the MMconfigInfo class can be serialized and deserialized.

    Args:
        currentNode (nodz.Node): The node to change the config storage of.
        configNameSet (set of tuples): A set of tuples in the form (configName, selectedValue)
    &#34;&#34;&#34;
    #Changes a config from a double-click config popup to the MMconfig stored inside the nodz node itself (i.e. storing/loading of configs)
    
    #Add all of them to the MMconfigInfo.config_string_storage:
    currentNode.MMconfigInfo.config_string_storage=[]
    for singleConfig in configNameSet:
        currentNode.MMconfigInfo.config_string_storage.append([singleConfig[0],singleConfig[1]])
    return</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeGlobalVarCallAction"><code class="name flex">
<span>def <span class="ident">changeGlobalVarCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>Refer to the class itself</dd>
<dt><strong><code>node</code></strong></dt>
<dd>Identify which node triggered the event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeGlobalVarCallAction(self,node):
    &#34;&#34;&#34;
    The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.
    
    Args:
        self: Refer to the class itself
        node: Identify which node triggered the event
    &#34;&#34;&#34;
    varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.changeGlobalVarInfo,node.flowChart)
    
    variable = varInfo[&#39;globalVarName&#39;][1]
    value = varInfo[&#39;globalVarValue&#39;][0]
    
    utils.nodz_setVariableToValue(variable,value,node.flowChart)
    
    
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeNodeColor"><code class="name flex">
<span>def <span class="ident">changeNodeColor</span></span>(<span>self, node, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the color of a node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node object whose color will be changed.</dd>
<dt><strong><code>event</code></strong></dt>
<dd>The event that triggers the color change.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeNodeColor(self, node, event):
    &#34;&#34;&#34;
    Change the color of a node.
    
    Args:
        node: The node object whose color will be changed.
        event: The event that triggers the color change.
    
    Returns:
        None
    &#34;&#34;&#34;
    color = QColorDialog.getColor()
    node.alternateFillColor = color.getRgb()
    #Force the change in the node:
    node.BGcolChanged()
    node.update()
    logging.debug(f&#34;Node color changed to {node.alternateFillColor}&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeNodeName"><code class="name flex">
<span>def <span class="ident">changeNodeName</span></span>(<span>self, node, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the name of a node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>The node whose name will be changed.</dd>
<dt><strong><code>event</code></strong></dt>
<dd>The event triggering the name change.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeNodeName(self, node, event):
    &#34;&#34;&#34;
    Change the name of a node.
    
    Args:
        node: The node whose name will be changed.
        event: The event triggering the name change.
    
    Returns:
        None
    &#34;&#34;&#34;
    #Create a quick popup window with a line edit and an ok/cancel:
    dialog = QDialog()
    dialog.setWindowTitle(&#39;Change node name&#39;)
    dialog.setModal(True)
    layout = QVBoxLayout(dialog)

    lineEdit = QLineEdit()
    lineEdit.setText(node.displayName)
    layout.addWidget(lineEdit)

    buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, Qt.Horizontal, dialog) #type:ignore
    buttonBox.accepted.connect(dialog.accept)
    buttonBox.rejected.connect(dialog.reject)
    layout.addWidget(buttonBox)

    if dialog.exec_() == QDialog.Accepted:
        node.displayName = lineEdit.text()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeRelStageStorageInNodz"><code class="name flex">
<span>def <span class="ident">changeRelStageStorageInNodz</span></span>(<span>self, currentNode, relstageinfo)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeRelStageStorageInNodz(self,currentNode,relstageinfo):
    
    currentNode.MMconfigInfo.relstage_string_storage=relstageinfo</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.checkNodesOnErrors"><code class="name flex">
<span>def <span class="ident">checkNodesOnErrors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkNodesOnErrors(self):
    #Idea: check all nodes for errors, alongside unconnected nodes. If so, update the warning. If not, reset the warning to none.
    
    if not self.shared_data.loadingOngoing:
        #Check that all nodes have connections where required.
        #Effectively, this means that all nodes should have a downstream connector
        self.cleanupNodeList()
        
        for node in self.nodes:
            #Init all nodes with no error:
            node.errorInfo = &#39;&#39;
            
            #check fo downstream connections
            downstreamNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[],upstream=False,downstream=True)
            if len(downstreamNodes) == 0:
                #Check if it requires one...
                if len(node.sockets) &gt; 0:
                    node.errorInfo = &#39;No downstream connections found.&#39;
        
        utils.updateAutonousErrorWarningInfo(self.shared_data)
    
    # self.shared_data.warningErrorInfoInfo[&#39;Errors&#39;] = totalNodeErrorMessage</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.cleanupNodeList"><code class="name flex">
<span>def <span class="ident">cleanupNodeList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanupNodeList(self):
    #Ensure that self.nodes accurately reflects the nodes on the screen.
    nodeNamesOnScreen = []
    for node in self.scene().nodes:
        nodeNamesOnScreen = nodeNamesOnScreen +[node]
    
    for node in self.nodes:
        if node.name not in nodeNamesOnScreen:
            self.nodes.remove(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.contextMenuEvent"><code class="name flex">
<span>def <span class="ident">contextMenuEvent</span></span>(<span>self, QMouseevent)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create a context menu when right-clicking on the nodz canvas</p>
<p>This function creates a context menu with all available node types that the user can select from, and adds the node to the nodz canvas at the position of the mouse click.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>QMouseevent</code></strong> :&ensp;<code>PyQt5.QtGui.QMouseEvent</code></dt>
<dd>The mouse event that triggered this context menu</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contextMenuEvent(self, QMouseevent):
    &#34;&#34;&#34;
    Function to create a context menu when right-clicking on the nodz canvas

    This function creates a context menu with all available node types that the user can select from, and adds the node to the nodz canvas at the position of the mouse click.

    Args:
        QMouseevent (PyQt5.QtGui.QMouseEvent): The mouse event that triggered this context menu
    &#34;&#34;&#34;
    #Check if we are right-clicking on a node:
    item_at_mouse = self.scene().itemAt(self.mapToScene(QMouseevent.pos()), QtGui.QTransform())
    
    if item_at_mouse == None:
        context_menu = QMenu(self)
        
        def addToContextMenu(context_menu,node_type,node_data):
            &#34;&#34;&#34;  
            Add a node type with node data to the right-click context menu
            &#34;&#34;&#34;
            new_subAction = QAction(node_data[&#39;displayName&#39;], self)
            context_menu.addAction(new_subAction)
            # Define a closure to capture the current value of node_type
            def create_lambda(node_type):
                &#34;&#34;&#34;
                Create a lambda function that calls the createNodeFromRightClick method with the specified node type.
                
                Args:
                    node_type: The type of node to be created.
                
                Returns:
                    A lambda function that takes an event and calls createNodeFromRightClick with the specified node type.
                &#34;&#34;&#34;
                return lambda _, event=QMouseevent: self.createNodeFromRightClick(event, nodeType=node_type)
            # Connect each action to its own lambda function
            new_subAction.triggered.connect(create_lambda(node_type))
        
        
        #Every type of node should be in here:
        allEntries = self.nodeInfo[&#39;__RightClickMenuNodeOrder__&#39;]
        
        addedMissedNodeType = False
        #But, we also loop over all entries in self.nodeInfo, and see if we missed any. If we did, we add them to the context menu.
        for nodeType in self.nodeInfo:
            if nodeType != &#39;__RightClickMenuNodeOrder__&#39; and nodeType not in allEntries:
                if not addedMissedNodeType:
                    allEntries.append(&#39;|&#39;)
                    addedMissedNodeType = True
                allEntries.append(nodeType)
        
        #We loop over all entries in here:
        for nodeType in allEntries:
            if nodeType == &#39;|&#39;:
                context_menu.addSeparator()
            else:
                if nodeType in self.nodeInfo:
                    node_type = nodeType
                    node_data = self.nodeInfo[nodeType]
                    addToContextMenu(context_menu,node_type,node_data)
        
        # Show the context menu at the event&#39;s position
        context_menu.exec_(QMouseevent.globalPos())
    elif item_at_mouse in self.nodes:
        
        context_menu = QMenu(self)
        
        #Add a change-name option
        changeName_subAction = QAction(&#39;Change name&#39;, self)
        context_menu.addAction(changeName_subAction)
        def create_lambda_changeName(item_at_mouse):
            &#34;&#34;&#34;
            Creates a lambda function to change the name of a node.
            
            Args:
                item_at_mouse: The item at the mouse position.
            
            Returns:
                A lambda function that calls the changeNodeName method with the item_at_mouse and event as arguments.
            &#34;&#34;&#34;
            return lambda _, event=QMouseevent: self.changeNodeName(item_at_mouse, event)
        changeName_subAction.triggered.connect(create_lambda_changeName(item_at_mouse))
        
        #Add a change-color option
        changeColor_subAction = QAction(&#39;Change color&#39;, self)
        context_menu.addAction(changeColor_subAction)
        def create_lambda_changeColor(item_at_mouse):
            &#34;&#34;&#34;
            Creates a lambda function that changes the color of a node.
            
            Args:
                item_at_mouse: The item at the mouse position.
            
            Returns:
                A lambda function that calls the &#39;changeNodeColor&#39; method with the specified item and event.
            &#34;&#34;&#34;
            return lambda _, event=QMouseevent: self.changeNodeColor(item_at_mouse, event)
        changeColor_subAction.triggered.connect(create_lambda_changeColor(item_at_mouse))
        
        #Add a advanced-info option
        advNodeInfo_subAction = QAction(&#39;Advanced Node info&#39;, self)
        context_menu.addAction(advNodeInfo_subAction)
        def create_lambda_advNodeInfo(item_at_mouse):
            &#34;&#34;&#34;
            Create a lambda function to call the advNodeInfo method with the given item at mouse position.
            
            Args:
                item_at_mouse: The item at the mouse position to be passed to the advNodeInfo method.
            
            Returns:
                A lambda function that calls the advNodeInfo method with the item_at_mouse and event parameters.
            &#34;&#34;&#34;
            return lambda _, event=QMouseevent: self.advNodeInfo(item_at_mouse, event)
        advNodeInfo_subAction.triggered.connect(create_lambda_advNodeInfo(item_at_mouse))
        
        context_menu.exec_(QMouseevent.globalPos())</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createNewNode"><code class="name flex">
<span>def <span class="ident">createNewNode</span></span>(<span>self, nodeType, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new node on the nodz canvas, with name and preset specified.</p>
<p>This function creates a new node on the nodz canvas at the position of the mouse event.
The name of the node is specified by appending a number to the nodeType parameter.
The preset of the node is set to 'node_preset_1'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodeType</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of node to create.</dd>
<dt><strong><code>event</code></strong> :&ensp;<code>PyQt5.QtGui.QMouseEvent</code></dt>
<dd>The mouse event that triggered this node creation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nodz.Node</code></dt>
<dd>The created nodz node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNewNode(self, nodeType, event):
    &#34;&#34;&#34;
    Creates a new node on the nodz canvas, with name and preset specified.

    This function creates a new node on the nodz canvas at the position of the mouse event.
    The name of the node is specified by appending a number to the nodeType parameter.
    The preset of the node is set to &#39;node_preset_1&#39;.

    Args:
        nodeType (str): The type of node to create.
        event (PyQt5.QtGui.QMouseEvent): The mouse event that triggered this node creation.
    Returns:
        nodz.Node: The created nodz node.
    &#34;&#34;&#34;
    if self.nodeInfo[nodeType][&#39;NodeCounter&#39;] &gt;= self.nodeInfo[nodeType][&#39;MaxNodeCounter&#39;]:
        logging.error(&#39;Not allowed! Maximum number of nodes of this type reached&#39;)
        return
    
    #Create the new node with correct name and preset
    newNode = self.createNode(name=nodeType+&#34;_&#34;, preset = &#39;node_preset_1&#39;, position=self.mapToScene(event.pos()),displayName = self.nodeInfo[nodeType][&#39;displayName&#39;],nodeInfo=self.nodeInfo[nodeType])
    
    #Do post-node-creation functions - does this via the pyqtsignal!
    return newNode</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createNodeFromRightClick"><code class="name flex">
<span>def <span class="ident">createNodeFromRightClick</span></span>(<span>self, event, nodeType=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function creates a new node in the flowchart when the user right-clicks in the flowchart area. Mostly a wrapper function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>QMouseEvent</code></dt>
<dd>The mouse event that triggered this function.</dd>
<dt><strong><code>nodeType</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of node to create. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNodeFromRightClick(self,event,nodeType=None):
    &#34;&#34;&#34;
    This function creates a new node in the flowchart when the user right-clicks in the flowchart area. Mostly a wrapper function

    Args:
        event (QMouseEvent): The mouse event that triggered this function.
        nodeType (str): The type of node to create. Defaults to None.

    Returns:
        None
    &#34;&#34;&#34;
    self.createNewNode(nodeType,event)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createSingleCoreVar"><code class="name flex">
<span>def <span class="ident">createSingleCoreVar</span></span>(<span>self, name, data, type, importance='Informative')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createSingleCoreVar(self,name,data,type,importance=&#39;Informative&#39;):
    self.coreVariables[name] = {} 
    self.coreVariables[name][&#39;type&#39;] = type 
    self.coreVariables[name][&#39;data&#39;] = data 
    self.coreVariables[name][&#39;importance&#39;] = importance </code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.debugScoring"><code class="name flex">
<span>def <span class="ident">debugScoring</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get some debug information from the scoring function(s)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debugScoring(self):
    &#34;&#34;&#34;
    Function to get some debug information from the scoring function(s)
    &#34;&#34;&#34;
    logging.debug(&#34;Debug Scoring&#34;)
    scoreGraph = self.prepareGraph(methodName = &#34;Score&#34;)
    
    
    logging.debug(self)
    logging.debug(self.evaluateGraph())</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.defineNodeInfo"><code class="name flex">
<span>def <span class="ident">defineNodeInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the node information for all nodes in the flowchart.</p>
<p>This function is called once at the initialization of the flowchart.
It returns a dictionary containing all nodes and their info.
The info is used by the flowchart to create the nodes and their connections.</p>
<p>It also contains layout information (colors and such)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def defineNodeInfo(self):
    &#34;&#34;&#34;
    Define the node information for all nodes in the flowchart.

    This function is called once at the initialization of the flowchart.
    It returns a dictionary containing all nodes and their info.
    The info is used by the flowchart to create the nodes and their connections.
    
    It also contains layout information (colors and such)
    &#34;&#34;&#34;
    self.nodeInfo = {}
    
    #Order: ChangeMicroscope|AnalysisMethods|RealTimeThings|Logics|Reports|StartStops|Advanceds
    self.nodeInfo[&#39;__RightClickMenuNodeOrder__&#39;] = [
        &#39;acquisition&#39;,&#39;changeProperties&#39;,&#39;changeStagePos&#39;,&#39;|&#39;,
        &#39;analysisMeasurement&#39;,&#39;customFunction&#39;,&#39;storeData&#39;,&#39;timer&#39;,&#39;|&#39;,
        &#39;realTimeAnalysis&#39;,&#39;visualisation&#39;,&#39;|&#39;,
        &#39;newGlobalVar&#39;,&#39;changeGlobalVar&#39;,&#39;caseSwitch&#39;,&#39;ifStatement&#39;,&#39;ANDlogic&#39;,&#39;|&#39;,
        &#39;slackReport&#39;,&#39;stickyNote&#39;,&#39;|&#39;,
        &#39;initStart&#39;,&#39;initEnd&#39;,&#39;scoringStart&#39;,&#39;scoringEndVar&#39;,&#39;earlyScoreFail&#39;,&#39;acqStart&#39;,&#39;acqEnd&#39;,&#39;|&#39;,
        &#39;runInlineScript&#39;,&#39;analysisMeasurementDEBUG&#39;]
    #If we miss any in here, they&#39;ll be added at the bottom in later logic
    #  
    
    #We define the node info for each type of node like this: (might be expanded in the future)
    self.nodeInfo[&#39;acquisition&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;acquisition&#39;][&#39;name&#39;] = &#39;acquisition&#39;
    self.nodeInfo[&#39;acquisition&#39;][&#39;displayName&#39;] = &#39;Acquisition&#39;
    self.nodeInfo[&#39;acquisition&#39;][&#39;startAttributes&#39;] = [&#39;Acquisition start&#39;]
    self.nodeInfo[&#39;acquisition&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    self.nodeInfo[&#39;acquisition&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;,&#39;Real-time&#39;]
    
    self.nodeInfo[&#39;changeProperties&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;changeProperties&#39;][&#39;name&#39;] = &#39;changeProperties&#39;
    self.nodeInfo[&#39;changeProperties&#39;][&#39;displayName&#39;] = &#39;Change Properties&#39;
    self.nodeInfo[&#39;changeProperties&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;changeProperties&#39;][&#39;finishedAttributes&#39;] = [&#39;Done&#39;]
    
    self.nodeInfo[&#39;visualisation&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;visualisation&#39;][&#39;name&#39;] = &#39;visualisation&#39;
    self.nodeInfo[&#39;visualisation&#39;][&#39;displayName&#39;] = &#39;Visualisation&#39;
    self.nodeInfo[&#39;visualisation&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;visualisation&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;stickyNote&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;stickyNote&#39;][&#39;name&#39;] = &#39;stickyNote&#39;
    self.nodeInfo[&#39;stickyNote&#39;][&#39;displayName&#39;] = &#39;Sticky Note&#39;
    self.nodeInfo[&#39;stickyNote&#39;][&#39;NodeSize&#39;] = 70
    
    self.nodeInfo[&#39;realTimeAnalysis&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;name&#39;] = &#39;realTimeAnalysis&#39;
    self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;displayName&#39;] = &#39;Real-Time analysis&#39;
    self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;realTimeAnalysis&#39;][&#39;NodeSize&#39;] = 60
    
    # self.nodeInfo[&#39;reporting&#39;] = self.singleNodeTypeInit()
    # self.nodeInfo[&#39;reporting&#39;][&#39;name&#39;] = &#39;reporting&#39;
    # self.nodeInfo[&#39;reporting&#39;][&#39;displayName&#39;] = &#39;Report&#39;
    # self.nodeInfo[&#39;reporting&#39;][&#39;topAttributes&#39;] = [&#39;Start&#39;]
    # self.nodeInfo[&#39;reporting&#39;][&#39;NodeSize&#39;] = 40
    
    self.nodeInfo[&#39;changeStagePos&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;changeStagePos&#39;][&#39;name&#39;] = &#39;changeStagePos&#39;
    self.nodeInfo[&#39;changeStagePos&#39;][&#39;displayName&#39;] = &#39;Change Stage Position&#39;
    self.nodeInfo[&#39;changeStagePos&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;changeStagePos&#39;][&#39;finishedAttributes&#39;] = [&#39;Done&#39;]
    self.nodeInfo[&#39;changeStagePos&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;analysisMeasurement&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;name&#39;] = &#39;analysisMeasurement&#39;
    self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;displayName&#39;] = &#39;Analysis [Measurement]&#39;
    self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
    self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    # self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
    self.nodeInfo[&#39;analysisMeasurement&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;]
    
    self.nodeInfo[&#39;customFunction&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;customFunction&#39;][&#39;name&#39;] = &#39;customFunction&#39;
    self.nodeInfo[&#39;customFunction&#39;][&#39;displayName&#39;] = &#39;Custom Function&#39;
    self.nodeInfo[&#39;customFunction&#39;][&#39;startAttributes&#39;] = [&#39;Function start&#39;]
    self.nodeInfo[&#39;customFunction&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    
    # self.nodeInfo[&#39;analysisShapes&#39;] = self.singleNodeTypeInit()
    # self.nodeInfo[&#39;analysisShapes&#39;][&#39;name&#39;] = &#39;analysisShapes&#39;
    # self.nodeInfo[&#39;analysisShapes&#39;][&#39;displayName&#39;] = &#39;Analysis [Shapes]&#39;
    # self.nodeInfo[&#39;analysisShapes&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
    # self.nodeInfo[&#39;analysisShapes&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    # self.nodeInfo[&#39;analysisShapes&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
    
    # self.nodeInfo[&#39;analysisImages&#39;] = self.singleNodeTypeInit()
    # self.nodeInfo[&#39;analysisImages&#39;][&#39;name&#39;] = &#39;analysisImages&#39;
    # self.nodeInfo[&#39;analysisImages&#39;][&#39;displayName&#39;] = &#39;Analysis [Images]&#39;
    # self.nodeInfo[&#39;analysisImages&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
    # self.nodeInfo[&#39;analysisImages&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    # self.nodeInfo[&#39;analysisImages&#39;][&#39;dataAttributes&#39;] = [&#39;Output&#39;]
    
    self.nodeInfo[&#39;scoringStart&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;scoringStart&#39;][&#39;name&#39;] = &#39;scoringStart&#39;
    self.nodeInfo[&#39;scoringStart&#39;][&#39;displayName&#39;] = &#39;Scoring start&#39;
    self.nodeInfo[&#39;scoringStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;scoringStart&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;scoringStart&#39;][&#39;NodeSize&#39;] = 60
    
    # self.nodeInfo[&#39;scoringEnd&#39;] = self.singleNodeTypeInit()
    # self.nodeInfo[&#39;scoringEnd&#39;][&#39;name&#39;] = &#39;scoringEnd&#39;
    # self.nodeInfo[&#39;scoringEnd&#39;][&#39;displayName&#39;] = &#39;Scoring end&#39;
    # self.nodeInfo[&#39;scoringEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
    # self.nodeInfo[&#39;scoringEnd&#39;][&#39;bottomAttributes&#39;] = [&#39;Report&#39;]
    # self.nodeInfo[&#39;scoringEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
    # self.nodeInfo[&#39;scoringEnd&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;scoringEndVar&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;scoringEndVar&#39;][&#39;name&#39;] = &#39;scoringEndVar&#39;
    self.nodeInfo[&#39;scoringEndVar&#39;][&#39;displayName&#39;] = &#39;Scoring end&#39;
    self.nodeInfo[&#39;scoringEndVar&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
    self.nodeInfo[&#39;scoringEndVar&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;scoringEndVar&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;earlyScoreFail&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;name&#39;] = &#39;earlyScoreFail&#39;
    self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;displayName&#39;] = &#39;Early score end&#39;
    self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
    self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;earlyScoreFail&#39;][&#39;NodeSize&#39;] = 40
    
    self.nodeInfo[&#39;acqStart&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;acqStart&#39;][&#39;name&#39;] = &#39;acqStart&#39;
    self.nodeInfo[&#39;acqStart&#39;][&#39;displayName&#39;] = &#39;Acquiring start&#39;
    self.nodeInfo[&#39;acqStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;acqStart&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;acqStart&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;acqEnd&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;acqEnd&#39;][&#39;name&#39;] = &#39;acqEnd&#39;
    self.nodeInfo[&#39;acqEnd&#39;][&#39;displayName&#39;] = &#39;Acquiring end&#39;
    self.nodeInfo[&#39;acqEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
    self.nodeInfo[&#39;acqEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;acqEnd&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;initStart&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;initStart&#39;][&#39;name&#39;] = &#39;initStart&#39;
    self.nodeInfo[&#39;initStart&#39;][&#39;displayName&#39;] = &#39;Initialisation start&#39;
    self.nodeInfo[&#39;initStart&#39;][&#39;finishedAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;initStart&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;initStart&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;initEnd&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;initEnd&#39;][&#39;name&#39;] = &#39;initEnd&#39;
    self.nodeInfo[&#39;initEnd&#39;][&#39;displayName&#39;] = &#39;Initialisation end&#39;
    self.nodeInfo[&#39;initEnd&#39;][&#39;startAttributes&#39;] = [&#39;End&#39;]
    self.nodeInfo[&#39;initEnd&#39;][&#39;MaxNodeCounter&#39;] = 1
    self.nodeInfo[&#39;initEnd&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;timer&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;timer&#39;][&#39;name&#39;] = &#39;timer&#39;
    self.nodeInfo[&#39;timer&#39;][&#39;displayName&#39;] = &#39;Timer&#39;
    self.nodeInfo[&#39;timer&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;timer&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    self.nodeInfo[&#39;timer&#39;][&#39;NodeSize&#39;] = 40
    
    self.nodeInfo[&#39;storeData&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;storeData&#39;][&#39;name&#39;] = &#39;storeData&#39;
    self.nodeInfo[&#39;storeData&#39;][&#39;displayName&#39;] = &#39;Store Data&#39;
    self.nodeInfo[&#39;storeData&#39;][&#39;startAttributes&#39;] = [&#39;Store&#39;]
    self.nodeInfo[&#39;storeData&#39;][&#39;finishedAttributes&#39;] = [&#39;Stored&#39;]
    self.nodeInfo[&#39;storeData&#39;][&#39;NodeSize&#39;] = 40
    
    self.nodeInfo[&#39;newGlobalVar&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;newGlobalVar&#39;][&#39;name&#39;] = &#39;newGlobalVar&#39;
    self.nodeInfo[&#39;newGlobalVar&#39;][&#39;displayName&#39;] = &#39;New Global Variable&#39;
    self.nodeInfo[&#39;newGlobalVar&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;newGlobalVar&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    self.nodeInfo[&#39;newGlobalVar&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;changeGlobalVar&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;name&#39;] = &#39;changeGlobalVar&#39;
    self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;displayName&#39;] = &#39;Change Global Variable&#39;
    self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    self.nodeInfo[&#39;changeGlobalVar&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;ifStatement&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;ifStatement&#39;][&#39;name&#39;] = &#39;ifStatement&#39;
    self.nodeInfo[&#39;ifStatement&#39;][&#39;displayName&#39;] = &#39;If-statement&#39;
    self.nodeInfo[&#39;ifStatement&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;ifStatement&#39;][&#39;finishedAttributes&#39;] = [&#39;Succeed&#39;,&#39;Fail&#39;]
    self.nodeInfo[&#39;ifStatement&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;runInlineScript&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;runInlineScript&#39;][&#39;name&#39;] = &#39;runInlineScript&#39;
    self.nodeInfo[&#39;runInlineScript&#39;][&#39;displayName&#39;] = &#39;Run advanced script&#39;
    self.nodeInfo[&#39;runInlineScript&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;runInlineScript&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    
    self.nodeInfo[&#39;caseSwitch&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;caseSwitch&#39;][&#39;name&#39;] = &#39;caseSwitch&#39;
    self.nodeInfo[&#39;caseSwitch&#39;][&#39;displayName&#39;] = &#39;Case/Switch&#39;
    self.nodeInfo[&#39;caseSwitch&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;caseSwitch&#39;][&#39;finishedAttributes&#39;] = [&#39;Error&#39;]
    self.nodeInfo[&#39;caseSwitch&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;slackReport&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;slackReport&#39;][&#39;name&#39;] = &#39;slackReport&#39;
    self.nodeInfo[&#39;slackReport&#39;][&#39;displayName&#39;] = &#39;Slack Report&#39;
    self.nodeInfo[&#39;slackReport&#39;][&#39;startAttributes&#39;] = [&#39;Start&#39;]
    self.nodeInfo[&#39;slackReport&#39;][&#39;finishedAttributes&#39;] = [&#39;Send&#39;]
    self.nodeInfo[&#39;slackReport&#39;][&#39;NodeSize&#39;] = 60
    
    self.nodeInfo[&#39;ANDlogic&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;ANDlogic&#39;][&#39;name&#39;] = &#39;ANDlogic&#39;
    self.nodeInfo[&#39;ANDlogic&#39;][&#39;displayName&#39;] = &#39;AND-Logic&#39;
    self.nodeInfo[&#39;ANDlogic&#39;][&#39;startAttributes&#39;] = [&#39;In&#39;]
    self.nodeInfo[&#39;ANDlogic&#39;][&#39;finishedAttributes&#39;] = [&#39;Out&#39;]
    self.nodeInfo[&#39;ANDlogic&#39;][&#39;NodeSize&#39;] = 30
    
    self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;] = self.singleNodeTypeInit()
    self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;name&#39;] = &#39;analysisMeasurementDEBUG&#39;
    self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;displayName&#39;] = &#39;DEBUG Analysis [Measurement]&#39;
    self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;startAttributes&#39;] = [&#39;Analysis start&#39;]
    self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;finishedAttributes&#39;] = [&#39;Finished&#39;]
    self.nodeInfo[&#39;analysisMeasurementDEBUG&#39;][&#39;bottomAttributes&#39;] = [&#39;Visual&#39;]
    
    #We also add some custom JSON info about the node layout (colors and such)
    import json
    #NOTE: taking a lot of these by grouping-colors. I.e. I create one color (acquisition), then for others in the same &#39;group&#39;, I use analogous scheme of colorffy.com
    self.nodeLayout = json.loads(&#39;&#39;&#39;{
        
        &#34;scoringStart&#34;: {
            &#34;bg&#34;: [80, 180, 80, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;scoringEnd&#34;: {
            &#34;bg&#34;: [120, 180, 120, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;scoringEndVar&#34;: {
            &#34;bg&#34;: [120, 180, 120, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;earlyScoreFail&#34;: {
            &#34;bg&#34;: [220, 180, 120, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        &#34;acqStart&#34;: {
            &#34;bg&#34;: [224, 195, 69, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;acqEnd&#34;: {
            &#34;bg&#34;: [234, 205, 109, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;initStart&#34;: {
            &#34;bg&#34;: [180, 80, 180, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;initEnd&#34;: {
            &#34;bg&#34;: [180, 120, 180, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        
        
        &#34;acquisition&#34;: {
            &#34;bg&#34;: [79, 79, 183, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;changeProperties&#34;: {
            &#34;bg&#34;: [121, 79, 183, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;changeStagePos&#34;: {
            &#34;bg&#34;: [79, 100, 183, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        
        &#34;analysisMeasurement&#34;: {
            &#34;bg&#34;: [240, 113, 103, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;customFunction&#34;: {
            &#34;bg&#34;: [240, 168, 103, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;storeData&#34;: {
            &#34;bg&#34;: [240, 140, 103, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;timer&#34;: {
            &#34;bg&#34;: [197, 93, 85, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        
        &#34;realTimeAnalysis&#34;: {
            &#34;bg&#34;: [63, 99, 129, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;visualisation&#34;: {
            &#34;bg&#34;: [63, 125, 129, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;reporting&#34;: {
            &#34;bg&#34;: [63, 129, 107, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        
        &#34;newGlobalVar&#34;: {
            &#34;bg&#34;: [123, 194, 112, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;changeGlobalVar&#34;: {
            &#34;bg&#34;: [134, 203, 151, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;caseSwitch&#34;: {
            &#34;bg&#34;: [112, 194, 134, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;ifStatement&#34;: {
            &#34;bg&#34;: [143, 184, 155, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;ANDlogic&#34;: {
            &#34;bg&#34;: [112, 194, 118, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        
        &#34;slackReport&#34;: {
            &#34;bg&#34;: [68, 129, 168, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;stickyNote&#34;: {
            &#34;bg&#34;: [230, 185, 5, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        
        
        &#34;runInlineScript&#34;: {
            &#34;bg&#34;: [179, 98, 122, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        },
        &#34;analysisMeasurementDEBUG&#34;: {
            &#34;bg&#34;: [162, 65, 98, 255],
            &#34;border&#34;: [50, 50, 50, 255],
            &#34;border_sel&#34;: [170, 80, 80, 255],
            &#34;text&#34;: [180, 180, 240, 255]
        }
        
        
        
    }&#39;&#39;&#39;)
    self.addConfig(self.nodeLayout)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.earlyScoringFail"><code class="name flex">
<span>def <span class="ident">earlyScoringFail</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def earlyScoringFail(self,node):
    #Sob asically it&#39;s the Scoring node, but hard-coded to fail.
    logging.info(&#34;Scoring early abandoned!&#34;)
    self.finishedEmits(node)
    node.status=&#39;finished&#39;
    #Go to next XY position
    if self.fullRunOngoing:
        if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
            self.fullRunCurrentPos +=1
            #And start a new score/acq at a new pos:
            self.startNewScoreAcqAtPos()
        else:
            self.singleRunOngoing = False
            logging.info(&#39;All done!&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.explore_attributes"><code class="name flex">
<span>def <span class="ident">explore_attributes</span></span>(<span>self, obj, indent=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively print the attributes of an object.</p>
<p>This function is used for debugging purposes to explore the attributes of an object.
It will print the attributes of <code>obj</code> and all of its sub-attributes, up to a maximum
depth of 20.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>The object to explore</dd>
<dt><strong><code>indent</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The indentation level, by default 0</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explore_attributes(self, obj, indent=0):
    &#34;&#34;&#34;
    Recursively print the attributes of an object.

    This function is used for debugging purposes to explore the attributes of an object.
    It will print the attributes of `obj` and all of its sub-attributes, up to a maximum
    depth of 20.

    Parameters
    ----------
    obj : object
        The object to explore
    indent : int, optional
        The indentation level, by default 0
    &#34;&#34;&#34;
    if indent &lt; 20:
        attributes = vars(obj)
        for attr_name in attributes:
            if not attr_name.startswith(&#39;_&#39;):
                attr = getattr(obj, attr_name)
                if not callable(attr):
                    logging.debug(&#34; &#34; * indent + attr_name)
                else:
                    logging.debug(&#34; &#34; * indent + attr_name + &#39;()&#39;)
                if hasattr(attr, &#39;__dict__&#39;):
                    self.explore_attributes(attr, indent + 2)
            # except:
            #     pass</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.findNodeByName"><code class="name flex">
<span>def <span class="ident">findNodeByName</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to find a node based on its name attribute</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the node to find</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nodz.node</code></dt>
<dd>The node with the given name or None if not found</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findNodeByName(self, name):
    &#34;&#34;&#34;
    Function to find a node based on its name attribute

    Args:
        name (str): The name of the node to find

    Returns:
        nodz.node: The node with the given name or None if not found
    &#34;&#34;&#34;
    for node in self.nodes:
        #check if the attribute &#39;name&#39; is found:
        if hasattr(node, &#39;name&#39;):
            if node.name == name:
                return node
    return None</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.finishedEmits"><code class="name flex">
<span>def <span class="ident">finishedEmits</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function emits the customFinishedEmits signal of a node, and allt he customDataEmits</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that needs to finish.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finishedEmits(self,node):
    &#34;&#34;&#34;
    This function emits the customFinishedEmits signal of a node, and allt he customDataEmits

    Args:
        node (nodz.Node): The node that needs to finish.

    Returns:
        None
    &#34;&#34;&#34;
    self.updateCoreVariables()
    node.status=&#39;finished&#39;
    self.shared_data.warningErrorInfoInfo[&#39;Info&#39;][&#39;LastNodeRan&#39;] = node.name
    
    self.update()
    if node.customFinishedEmits is not None and len(node.customFinishedEmits.signals)&gt;0:
        node.customFinishedEmits.emit_all_signals()
    if node.customDataEmits is not None and len(node.customDataEmits.signals)&gt;0:
        node.customDataEmits.emit_all_signals()

    if &#39;dialogInfo&#39; in vars(node):
        self.set_readable_text_after_dialogChange(node,node.dialogInfo)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.focus"><code class="name flex">
<span>def <span class="ident">focus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Focuses on the entire canvas</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus(self):
    &#34;&#34;&#34;
    Focuses on the entire canvas
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    self._focus()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.fullAutonomousRunStart"><code class="name flex">
<span>def <span class="ident">fullAutonomousRunStart</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a full autonomous run - i.e. scoring and acquisition</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The object instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullAutonomousRunStart(self):
    &#34;&#34;&#34;
    Starts a full autonomous run - i.e. scoring and acquisition
    
    Args:
        self: The object instance.
    
    Returns:
        None
    &#34;&#34;&#34;
    logging.info(&#39;Starting a full run&#39;)
    self.preventAcq = False
    self.preventScoring = False
    
    #General idea: first check if there are no glaring errors (scoring, position)
    #then go to whatever start position based on the xy positions
    #then run scoring+acquisition there
    
        
    
    self.fullRunOngoing = True
    self.fullRunCurrentPos = 0
    self.fullRunPositions = self.scanningWidget.getPositionInfo()
    # self.startNewScoreAcqAtPos()
    
    #Find the init_start node:
    initStartNode = None
    flowChart = self
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;initStart_&#39; in node.name:
                initStartNode = node
    
    #Run the init_start routine:
    if initStartNode is not None:
        self.initStart(initStartNode)
    else:
        logging.error(&#39;Could not find initStart node in flowchart&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.getDevicesOfDeviceType"><code class="name flex">
<span>def <span class="ident">getDevicesOfDeviceType</span></span>(<span>self, devicetype)</span>
</code></dt>
<dd>
<div class="desc"><p>Find all devices that have a specific devicetype.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>devicetype</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of device to search for. Refer to <a href="https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html">https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html</a> for all devicetypes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of devices that match the specified devicetype.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDevicesOfDeviceType(self,devicetype):
    &#34;&#34;&#34;
    Find all devices that have a specific devicetype.
    
    Args:
        devicetype (str): The type of device to search for. Refer to https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html for all devicetypes.
    
    Returns:
        list: A list of devices that match the specified devicetype.
    &#34;&#34;&#34;
    
    #Find all devices that have a specific devicetype
    #Look at https://javadoc.scijava.org/Micro-Manager-Core/mmcorej/DeviceType.html 
    #for all devicetypes
    #Get devices
    devices = self.shared_data.core.get_loaded_devices() #type:ignore
    devices = [devices.get(i) for i in range(devices.size())]
    devicesOfType = []
    #Loop over devices
    for device in devices:
        if self.shared_data.core.get_device_type(device).to_string() == devicetype: #type:ignore
            logging.debug(&#34;found &#34; + device + &#34; of type &#34; + devicetype)
            devicesOfType.append(device)
    return devicesOfType</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.getNodz"><code class="name flex">
<span>def <span class="ident">getNodz</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current instance of the class.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The current instance of the class.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNodz(self):
    &#34;&#34;&#34;
    Return the current instance of the class.
    
    Returns:
        object: The current instance of the class.
    &#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.giveInfoOnNode"><code class="name flex">
<span>def <span class="ident">giveInfoOnNode</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints information about a node in the flowchart</p>
<p>This function prints some basic information about a node in the flowchart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node to get information about.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def giveInfoOnNode(self,node):
    &#34;&#34;&#34;
    Prints information about a node in the flowchart

    This function prints some basic information about a node in the flowchart.

    Args:
        node (nodz.Node): The node to get information about.

    Returns:
        None
    &#34;&#34;&#34;
    logging.info(&#39;--------&#39;)
    logging.info(node)
    logging.info(f&#34;node name: {node.name}&#34;)
    logging.info(f&#34;incoming connections: {node.n_connect_at_start}&#34; )</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.ifStatementCallAction"><code class="name flex">
<span>def <span class="ident">ifStatementCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>Refer to the class itself</dd>
<dt><strong><code>node</code></strong></dt>
<dd>Identify which node triggered the event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ifStatementCallAction(self,node):
    &#34;&#34;&#34;
    The changeGlobalVarCallAction function is the action function for the change global var Call node in the Flowchart.
    
    Args:
        self: Refer to the class itself
        node: Identify which node triggered the event
    &#34;&#34;&#34;
    
    varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.ifStatementInfo,node.flowChart)
    
    result = eval(str(varInfo[&#39;valueToCheck&#39;][0])+varInfo[&#39;comparator&#39;][0]+str(varInfo[&#39;valueCheckAgainst&#39;][0]))
    
    if result == True:
        graph = node.flowChart.evaluateGraph()
        for graphConnection in graph:
            if graphConnection[0] == node.name+&#39;.Succeed&#39;:
                foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                node.status=&#39;finished&#39;
                foundNode.oneConnectionAtStartIsFinished()
                break    
    elif result == False:
        graph = node.flowChart.evaluateGraph()
        for graphConnection in graph:
            if graphConnection[0] == node.name+&#39;.Fail&#39;:
                foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                node.status=&#39;finished&#39;
                foundNode.oneConnectionAtStartIsFinished()
                break    </code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.initEnd"><code class="name flex">
<span>def <span class="ident">initEnd</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initEnd(self,node):

    logging.debug(&#39;Initialisation finished fully!&#39;)
    node.status = &#39;finished&#39;
    #Find the acqStart node:
    scoringStartNode = None
    flowChart = self
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for nodeF in flowChart.nodes:
            if &#39;scoringStart_&#39; in nodeF.name:
                scoringStartNode = nodeF
    
    #Run the scoring_start routine:
    if scoringStartNode is not None:
        if self.fullRunOngoing:
            logging.info(&#39;Starting full run routine!&#39;)
            self.startNewScoreAcqAtPos()
        else:
            logging.info(&#39;Starting single scoring only!&#39;)
            self.scoringStart(scoringStartNode)
    else:
        logging.error(&#39;Could not find scoringStartNode node in flowchart&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.initStart"><code class="name flex">
<span>def <span class="ident">initStart</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the Initialisation Start node in the Flowchart.</p>
<p>This function signals to the rest of the flowchart that it's time to start
the init routine.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initStart(self,node):
    &#34;&#34;&#34;
    This function is the action function for the Initialisation Start node in the Flowchart.

    This function signals to the rest of the flowchart that it&#39;s time to start
    the init routine.

    Args:
        node (nodz.Node): The node that has triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    logging.debug(&#39;Starting the initialisation routine!&#39;)
    
    #Set all connected nodes to idle
    connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
    for connectedNode in connectedNodes:
        for nodeC in self.nodes:
            if nodeC.name == connectedNode:
                nodeC.status=&#39;idle&#39;
    
    self.set_readable_text_after_dialogChange(node,&#39;&#39;,&#39;initStart&#39;)
    
    self.GraphToSignals()
    #Effectively, only finishes the initStart node
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.interruptRun"><code class="name flex">
<span>def <span class="ident">interruptRun</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Interrupt the run - stop the scoring/init/acq and stop ongoing acquisitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interruptRun(self):
    &#34;&#34;&#34; 
    Interrupt the run - stop the scoring/init/acq and stop ongoing acquisitions.
    &#34;&#34;&#34;
    
    #Trying this for now:
    self.shared_data._mdaModeAcqData.abort()
    
    return</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.limitTextLength"><code class="name flex">
<span>def <span class="ident">limitTextLength</span></span>(<span>self, text, textLength:Â intÂ =Â 40)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a string (text) and return a "abc&hellip;def" string if it's too long.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limitTextLength(self,text,textLength:int=40):
    &#34;&#34;&#34; 
    Get a string (text) and return a &#34;abc...def&#34; string if it&#39;s too long.
    &#34;&#34;&#34;
    if type(text) != str:
        text = str(text)
    textLength = int(textLength)
    if textLength % 1 == 0: #if odd length, make it even
        textLength = int(textLength+1)
    if len(text) &gt; textLength:
        displayVal = text[:20] + &#39;...&#39; + text[-20:]
    else:
        displayVal = text
    return displayVal</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.loadGraphJSON"><code class="name flex">
<span>def <span class="ident">loadGraphJSON</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the graph from a JSON file.</p>
<p>This function loads the graph from a JSON file created using <code>storeGraphJSON()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadGraphJSON(self):
    &#34;&#34;&#34;
    Load the graph from a JSON file.

    This function loads the graph from a JSON file created using `storeGraphJSON()`.
    &#34;&#34;&#34;        
    filename, _ = QFileDialog.getOpenFileName(self, &#39;Open file&#39;, &#39;&#39;, &#39;JSON files (*.json)&#39;)
    if filename:
        try:
            #Fully clear graph and delete all nodes from memory:
            self.clearGraph()
            self.nodes = []
            #Set all counters to 0:
            for nodeType in self.nodeInfo:
                if nodeType[:2] != &#39;__&#39;: #Ignore internal/special node info (&#39;__init__&#39; etc)
                    self.nodeInfo[nodeType][&#39;NodeCounter&#39;] = 0
                    self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] = 0
            #Load the graph
            with open(filename, &#39;rb&#39;) as f:
                self.loadGraph_KM(filename)
            
            #Update warnings/info/errors:
            self.shared_data.warningErrorInfoInfo[&#34;Info&#34;][&#39;Other&#39;] = [&#34;Loaded &#34;+filename]
            # utils.updateAutonousErrorWarningInfo(self.shared_data)
        except:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Warning)
            msg.setText(&#34;Could not load file: &#34; + filename)
            msg.setWindowTitle(&#34;Warning&#34;)
            msg.setStandardButtons(QMessageBox.Ok)
            msg.exec_()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.newGlobalVarCallAction"><code class="name flex">
<span>def <span class="ident">newGlobalVarCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>The newGlobalVarCallAction function is the action function for the new global var Call node in the Flowchart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>Refer to the class itself</dd>
<dt><strong><code>node</code></strong></dt>
<dd>Identify which node triggered the event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newGlobalVarCallAction(self,node):
    &#34;&#34;&#34;
    The newGlobalVarCallAction function is the action function for the new global var Call node in the Flowchart.
    
    Args:
        self: Refer to the class itself
        node: Identify which node triggered the event
    &#34;&#34;&#34;
    varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.newGlobalVarInfo,node.flowChart)
    
    variable = varInfo[&#39;globalVarName&#39;][1]
    value = varInfo[&#39;globalVarValue&#39;][0]
    
    #Create the new global Variable
    if variable  in node.flowChart.globalVariables:
        #If it&#39;s already present, give a warning for now, but still set it.
        logging.warning(f&#39;New global variable {variable} defined with same name as already existing - overwriting it!&#39;)
        
    node.flowChart.globalVariables[variable] = {}
    node.flowChart.globalVariables[variable][&#39;data&#39;] = value
    #Try to find the type of the variable automatically, else just set it as str
    try:
        node.flowChart.globalVariables[variable][&#39;type&#39;] = [(type(eval(value)))]
    except: #This will effectively set it as a string.
        node.flowChart.globalVariables[variable][&#39;type&#39;] = [(type((value)))]
    node.flowChart.globalVariables[variable][&#39;importance&#39;] = &#39;informative&#39;
    import time
    node.flowChart.globalVariables[variable][&#39;lastUpdateTime&#39;] = time.time()
    
    
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.nodeLookupName_withoutCounter"><code class="name flex">
<span>def <span class="ident">nodeLookupName_withoutCounter</span></span>(<span>self, nodeName)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the node name without the counter suffix.</p>
<p>Given a node name like "MyNode_0" this function returns "MyNode".</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodeName</code></strong> :&ensp;<code>str</code></dt>
<dd>The node name to strip the counter from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The node name without the counter suffix.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodeLookupName_withoutCounter(self,nodeName):
    &#34;&#34;&#34;
    Returns the node name without the counter suffix.

    Given a node name like &#34;MyNode_0&#34; this function returns &#34;MyNode&#34;.

    Parameters
    ----------
    nodeName : str
        The node name to strip the counter from.

    Returns
    -------
    str
        The node name without the counter suffix.
    &#34;&#34;&#34;
    #Find the last underscore (&#39;_0, _1, etc&#39;)
    index_last_underscore = nodeName.rfind(&#39;_&#39;)
    nodeNameNC = nodeName[:index_last_underscore]
    finalNodeName=None
    #Now get the correct lookup name by looking through all nodeInfo items
    for node_name, node_data in self.nodeInfo.items():
        # Check if the name matches the specific value
        if &#39;name&#39; in node_data and node_data[&#39;name&#39;] == nodeNameNC:
            finalNodeName = node_name
    
    return finalNodeName</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.nodeRan"><code class="name flex">
<span>def <span class="ident">nodeRan</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that's called at the start of every node
Updates the core variables and the variables in the UI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodeRan(self,node):
    &#34;&#34;&#34; 
    Function that&#39;s called at the start of every node
    Updates the core variables and the variables in the UI.
    &#34;&#34;&#34;
    try:
        self.update()
        # self.updateCoreVariables()
        self.variablesWidget.updateVariables()
    except:
        pass
    logging.debug(f&#39;Node with name {node.name} ran&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.obtainAllNodes"><code class="name flex">
<span>def <span class="ident">obtainAllNodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain all nodes, return them</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obtainAllNodes(self):
    &#34;&#34;&#34; 
    Obtain all nodes, return them
    &#34;&#34;&#34;
    return self.nodes</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.performPostNodeCreation_Start"><code class="name flex">
<span>def <span class="ident">performPostNodeCreation_Start</span></span>(<span>self, newNode, nodeType)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles post-node-creation functions for nodes.</p>
<p>This function handles post-node-creation functions for nodes, such as
setting the node name and preset, and adding custom attributes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>newNode</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The newly created node.</dd>
<dt><strong><code>nodeType</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of node that was created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performPostNodeCreation_Start(self,newNode,nodeType):
    &#34;&#34;&#34;
    Handles post-node-creation functions for nodes.

    This function handles post-node-creation functions for nodes, such as
    setting the node name and preset, and adding custom attributes.

    Args:
        newNode (nodz.Node): The newly created node.
        nodeType (str): The type of node that was created.
    &#34;&#34;&#34;
    if not newNode.createdFromLoading: #Normal case when it&#39;s simply created from the nodz canvas
        newNodeName = self.nodeInfo[nodeType][&#39;name&#39;]+&#34;_&#34;+str(self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;])
        #Increase the nodeCounter - use the neverReset one to completely eliminate options of same-named nodes ever
        self.nodeInfo[nodeType][&#39;NodeCounter&#39;]+=1
        self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;]+=1
    elif newNode.createdFromLoading: #Special case in case it&#39;s created from loading the whole graph
        newNodeName = newNode.name #Don&#39;t change the name
        self.nodeInfo[nodeType][&#39;NodeCounter&#39;]+=1
        #Get the node name:
        lastUnderscore = newNode.name.rfind(&#39;_&#39;)
        newNodeNumber = int(newNode.name[lastUnderscore+1:])
        #And set the nodecounterneverreset to be this value +1 or higher
        if self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] &lt; newNodeNumber+1:
            self.nodeInfo[nodeType][&#39;NodeCounterNeverReset&#39;] = newNodeNumber+1
    newNode.flowChart = self
    if nodeType in self.config:
        configtype = nodeType
    else:
        configtype = &#39;node_preset_1&#39;
        
    
    #Change name, change sdisplayName, change preset:
    newNode.changeName(newNodeName)
    newNode.changeDisplayName(self.nodeInfo[nodeType][&#39;displayName&#39;])
    newNode.changePreset(configtype)
    
    self.nodes.append(newNode)
    
    self.updateNumberStartFinishedDataAttributes(newNode,nodeType)
    
    #Custom functions that should be done
    if nodeType == &#39;acquisition&#39;:
        #Attach a MDA data to this node
        parentV = None
        if self.parent is not None:
            parentV = self.parent
            
        
        #Set the variableNodz info, maybe later do this in seperate function?
        newNode.variablesNodz[&#39;data&#39;] = {}
        from ndtiff import NDTiffDataset
        newNode.variablesNodz[&#39;data&#39;][&#39;type&#39;] = [NDTiffDataset, np.ndarray]
        newNode.variablesNodz[&#39;data&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;data&#39;][&#39;importance&#39;] = &#39;Default&#39;
        newNode.variablesNodz[&#39;order&#39;] = {}
        newNode.variablesNodz[&#39;order&#39;][&#39;type&#39;] = [str]
        newNode.variablesNodz[&#39;order&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;order&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;exposure_ms&#39;] = {}
        newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;type&#39;] = [float]
        newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;exposure_ms&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;n_timepoints&#39;] = {}
        newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;type&#39;] = [int]
        newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;n_timepoints&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;time_interval_ms&#39;] = {}
        newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;type&#39;] = [float]
        newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;time_interval_ms&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;xy_positions&#39;] = {}
        newNode.variablesNodz[&#39;xy_positions&#39;][&#39;type&#39;] = [np.ndarray]
        newNode.variablesNodz[&#39;xy_positions&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;xy_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;n_xy_positions&#39;] = {}
        newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;type&#39;] = [int]
        newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;n_xy_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;z_positions&#39;] = {}
        newNode.variablesNodz[&#39;z_positions&#39;][&#39;type&#39;] = [np.ndarray]
        newNode.variablesNodz[&#39;z_positions&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;z_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;n_z_positions&#39;] = {}
        newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;type&#39;] = [int]
        newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;n_z_positions&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;channel_group&#39;] = {}
        newNode.variablesNodz[&#39;channel_group&#39;][&#39;type&#39;] = [str]
        newNode.variablesNodz[&#39;channel_group&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;channel_group&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;channels&#39;] = {}
        newNode.variablesNodz[&#39;channels&#39;][&#39;type&#39;] = [np.ndarray]
        newNode.variablesNodz[&#39;channels&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;channels&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;n_channels&#39;] = {}
        newNode.variablesNodz[&#39;n_channels&#39;][&#39;type&#39;] = [int]
        newNode.variablesNodz[&#39;n_channels&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;n_channels&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        newNode.variablesNodz[&#39;storage_path&#39;] = {}
        newNode.variablesNodz[&#39;storage_path&#39;][&#39;type&#39;] = [str]
        newNode.variablesNodz[&#39;storage_path&#39;][&#39;data&#39;] = None
        newNode.variablesNodz[&#39;storage_path&#39;][&#39;importance&#39;] = &#39;Informative&#39;
        
        #Attach a MDA data to this node
        newNode.mdaData = MDAGlados(self.core,self.MM_JSON,None,self.shared_data,hasGUI=True,parent=parentV,node=newNode) # type: ignore
        
        #Initialise with showing only time.
        newNode.mdaData.GUI_show_channel = False
        newNode.mdaData.GUI_show_exposure = True
        newNode.mdaData.GUI_show_order = True
        newNode.mdaData.GUI_show_storage = False
        newNode.mdaData.GUI_show_time = True
        newNode.mdaData.GUI_show_xy = False
        newNode.mdaData.GUI_show_z = False
        
        #Do the acquisition upon callAction
        newNode.callAction = lambda self, node=newNode: node.mdaData.MDA_acq_from_Node(node)
        
        #Add the node emits of &#39;finishing&#39; upon MDA completion.
        #Also connect the node&#39;s finishedMDA
        #This order is important!
        newNode.mdaData.MDA_completed.connect(newNode.finishedmda)
        newNode.mdaData.MDA_completed.connect(lambda self, node = newNode: node.customFinishedEmits.emit_all_signals())
        #Note: the recorded MDA data is stored in node.mdaData.data - any analysis method should find/read this.
        #The core is at node.mdaData.core
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;realTimeAnalysis&#39;:
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;visualisation&#39;:
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;changeProperties&#39;:
        #attach MMconfigUI to this:
        # Get all config groups
        allConfigGroups={}
        nrconfiggroups = self.core.get_available_config_groups().size() #type:ignore
        for config_group_id in range(nrconfiggroups):
            allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
    
    
        newNode.MMconfigInfo = MMConfigUI(allConfigGroups,showConfigs = True,showStages=False,showROIoptions=False,showShutterOptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False,showCheckboxes = True,autoSaveLoad=False) # type: ignore
        
        #Add the callaction
        newNode.callAction = lambda self, node=newNode: self.MMconfigChangeRan(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;changeStagePos&#39;:
        # Get all config group s
        allConfigGroups={}
        nrconfiggroups = self.core.get_available_config_groups().size() #type:ignore
        for config_group_id in range(nrconfiggroups):
            allConfigGroups[config_group_id] = ConfigInfo(self.core,config_group_id)
    
        newNode.MMconfigInfo = MMConfigUI(allConfigGroups,showConfigs = False,showStages=False,showROIoptions=False,showShutterOptions=False,showLiveSnapExposureButtons=False,number_config_columns=5,changes_update_MM = False,showCheckboxes = False,showRelativeStages = True, autoSaveLoad=False) # type: ignore
        
        #Add the callaction
        newNode.callAction = lambda self, node=newNode: self.MMstageChangeRan(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within 
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;customFunction&#39;:
        newNode.callAction = lambda self, node=newNode: self.CustomFunctionNode_started(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #initialise the scoring_analysis_currentData values:
        #Rather stupidly, but I create the double-click-dialog, but just never show it.
        dialog = nodz_customFunctionDialog(currentNode = newNode, parent = self)
        newNode.customFunction_currentData=dialog.currentData
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;analysisMeasurement&#39;:
        newNode.callAction = lambda self, node=newNode: self.AnalysisNode_started(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #initialise the scoring_analysis_currentData values:
        #Rather stupidly, but I create the double-click-dialog, but just never show it.
        dialog = nodz_analysisDialog(currentNode = newNode, parent = self)
        newNode.scoring_analysis_currentData=dialog.currentData
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;analysisMeasurementDEBUG&#39;:
        #This is a DEBUG type of analysis measurement which blocks the main thread, but allows for easier debugging.
        newNode.callAction = lambda self, node=newNode: self.AnalysisNode_DEBUG_started(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #initialise the scoring_analysis_currentData values:
        #Rather stupidly, but I create the double-click-dialog, but just never show it.
        dialog = nodz_analysisDialog(currentNode = newNode, parent = self)
        newNode.scoring_analysis_currentData=dialog.currentData
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;timer&#39;:
        newNode.callAction = lambda self, node=newNode: self.timerCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;storeData&#39;:
        newNode.callAction = lambda self, node=newNode: self.storeDataCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;changeGlobalVar&#39;:
        newNode.callAction = lambda self, node=newNode: self.changeGlobalVarCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;ifStatement&#39;:
        newNode.callAction = lambda self, node=newNode: self.ifStatementCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;newGlobalVar&#39;:
        newNode.callAction = lambda self, node=newNode: self.newGlobalVarCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;runInlineScript&#39;:
        newNode.callAction = lambda self, node=newNode: self.runInlineScriptCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;caseSwitch&#39;:
        newNode.callAction = lambda self, node=newNode: self.runCaseSwitchCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;slackReport&#39;:
        newNode.callAction = lambda self, node=newNode: self.runslackReportCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    elif nodeType == &#39;scoringStart&#39;:
        newNode.callAction = lambda self, node=newNode: self.scoringStart(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
    elif nodeType == &#39;scoringEnd&#39;:
        newNode.callAction = lambda self, node=newNode: self.scoringEnd(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        #Update the decisionwidget after loading the scoringEnd node:
        self.decisionWidget.updateAllDecisions()
    elif nodeType == &#39;scoringEndVar&#39;:
        newNode.callAction = lambda self, node=newNode: self.scoringEnd(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        #Update the decisionwidget after loading the scoringEnd node:
        self.decisionWidget.updateAllDecisions()
    elif nodeType == &#39;earlyScoreFail&#39;:
        newNode.callAction = lambda self, node=newNode: self.earlyScoringFail(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
        self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;earlyScoringFail&#39;)
    elif nodeType == &#39;acqEnd&#39;:
        newNode.callAction = lambda self, node=newNode: self.acquiringEnd(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
    elif nodeType == &#39;initStart&#39;:
        newNode.callAction = lambda self, node=newNode: self.initStart(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
    elif nodeType == &#39;initEnd&#39;:
        newNode.callAction = lambda self, node=newNode: self.initEnd(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
    elif nodeType == &#39;ANDlogic&#39;:
        newNode.callAction = lambda self, node=newNode: self.and_logicCallAction(node)
        newNode.callActionRelatedObject = self #this line is required to run a function from within this class
    elif nodeType == &#39;caseSwitch&#39;:
        #Initialise text on the node with a &#39;double-click this to set the settings!&#39; text:
        if not newNode.createdFromLoading:
            self.set_readable_text_after_dialogChange(newNode,&#39;&#39;,&#39;__InitRequireUserDoubleClick__&#39;)
    else:
        newNode.callAction = None

    newNode.update()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.prepareGraph"><code class="name flex">
<span>def <span class="ident">prepareGraph</span></span>(<span>self, methodName='Score')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to prepare a graph based on the flowchart's connections.
The resulting graph will have all nodes connected by edges based on the connections
in the flowchart</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepareGraph(self, methodName=&#39;Score&#39;):
    &#34;&#34;&#34;
    Function to prepare a graph based on the flowchart&#39;s connections.
    The resulting graph will have all nodes connected by edges based on the connections
    in the flowchart
    &#34;&#34;&#34;
    graphEval = self.evaluateGraph()
    if methodName == &#39;Score&#39;:
        scoreGraph = GladosGraph(self)
        scoreGraph.addRawGraphEval(graphEval)
        for node in scoreGraph.nodes:
            self.giveInfoOnNode(node)
        return scoreGraph</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runAcquiring"><code class="name flex">
<span>def <span class="ident">runAcquiring</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the acquiring process at this microscopy XY position</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runAcquiring(self):
    &#34;&#34;&#34;
    Run the acquiring process at this microscopy XY position
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    logging.info(&#34;Run Acquiring&#34;)
    
    #Find the acqStart node:
    acqStartNode = None
    flowChart = self
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;acqStart_&#39; in node.name:
                acqStartNode = node
    
    #Run the scoring_start routine:
    if acqStartNode is not None:
        self.acquiringStart(acqStartNode)
    else:
        logging.error(&#39;Could not find acqStart node in flowchart&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runCaseSwitchCallAction"><code class="name flex">
<span>def <span class="ident">runCaseSwitchCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Call action to runa
case/switch statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runCaseSwitchCallAction(self,node):
    &#34;&#34;&#34; 
    Call action to runa  case/switch statement.
    &#34;&#34;&#34;
    CurrentValueWantedVariable = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.caseSwitchInfo,node.flowChart)[&#39;Var&#39;][0]
    
    
    #Alright so emitting the signals doesn&#39;t work because they&#39;re all connected.
    #So, idea is to evaluate the graph, find the correct linked node, and start that one from here.
    correctPlugFound = False
    graph = node.flowChart.evaluateGraph()
    for graphConnection in graph:
        if correctPlugFound == False and graphConnection[0] == node.name+&#39;.&#39;+str(CurrentValueWantedVariable):
            foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
            logging.debug(f&#34;Node {node.name} found a case/switch with value {CurrentValueWantedVariable} connected to node {foundNodeName}&#34;)
            foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
            foundNode.oneConnectionAtStartIsFinished()
            correctPlugFound = True
            node.status=&#39;finished&#39;
            break
        
    #If none are found:
    if correctPlugFound == False:
        logging.warning(&#39;Case/Switch not found, using the Error&#39;)
        for graphConnection in graph:
            if graphConnection[0] == node.name+&#39;.Error&#39;:
                foundNodeName = graphConnection[1].split(&#39;.&#39;)[0]
                foundNode = nodz_utils.findNodeByName(node.flowChart,foundNodeName)
                foundNode.oneConnectionAtStartIsFinished()
                node.status=&#39;finished&#39;</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runInitOnly"><code class="name flex">
<span>def <span class="ident">runInitOnly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run ONLY the init process at the current position. Actively prevents scoring</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runInitOnly(self):
    &#34;&#34;&#34;
    Run ONLY the init process at the current position. Actively prevents scoring
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    self.preventScoring = True
    self.preventAcq = False
    
    #Find the scoring_start node:
    initStartNode = None
    flowChart = self
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;initStart_&#39; in node.name:
                initStartNode = node
    
    #Run the scoring_start routine:
    if initStartNode is not None:
        self.initStart(initStartNode)
    else:
        logging.error(&#39;Could not find initStart node in flowchart&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runInlineScriptCallAction"><code class="name flex">
<span>def <span class="ident">runInlineScriptCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runInlineScriptCallAction(self,node):
    scriptText = node.InlineScriptInfo
    
    core = shared_data.core
    #Go over each line of scriptText, broken by a \n:
    lineData = scriptText.split(&#39;\n&#39;)
    errored=False
    for line in lineData:
        if errored:
            break
        try:
            eval(line)
            logging.debug(f&#39;Ran commdand succesfully: {line}&#39;)
        except Exception as e:
            logging.error(f&#39;Error with line {line}: {e}. Script broken off&#39;)
            errored=True
    
    if errored==False:
        logging.debug(&#39;Fully ran custom script!&#39;)
    
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runScoring"><code class="name flex">
<span>def <span class="ident">runScoring</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the scoring process starting from the scoring_start node, without inhibiting acquisition later - i.e. the scoring before a possible acquisition</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runScoring(self):
    &#34;&#34;&#34;
    Runs the scoring process starting from the scoring_start node, without inhibiting acquisition later - i.e. the scoring before a possible acquisition
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    self.preventAcq = False
    self.preventScoring = False
    #Find the scoring_start node:
    scoreStartNode = None
    flowChart = self
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;scoringStart_&#39; in node.name:
                scoreStartNode = node
    
    
    
    #Run the scoring_start routine:
    if scoreStartNode is not None:
        self.scoringStart(scoreStartNode)
    else:
        logging.error(&#39;Could not find scoringStart node in flowchart&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runScoringOnly"><code class="name flex">
<span>def <span class="ident">runScoringOnly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run ONLY the scoring process at the current position. Actively prevents acquisition</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runScoringOnly(self):
    &#34;&#34;&#34;
    Run ONLY the scoring process at the current position. Actively prevents acquisition
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    self.preventAcq = True
    self.preventScoring = False
    
    #Find the scoring_start node:
    scoreStartNode = None
    flowChart = self
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;scoringStart_&#39; in node.name:
                scoreStartNode = node
    
    #Run the scoring_start routine:
    if scoreStartNode is not None:
        self.scoringStart(scoreStartNode)
    else:
        logging.error(&#39;Could not find scoringStart node in flowchart&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runslackReportCallAction"><code class="name flex">
<span>def <span class="ident">runslackReportCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Call action to send a message to Slack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runslackReportCallAction(self,node):
    &#34;&#34;&#34;
    Call action to send a message to Slack
    &#34;&#34;&#34;
    node.status=&#39;finished&#39;
    try:
        readableText = utils.nodz_evaluateAdv(node.slackReportInfo,node.flowChart,skipEval=True)
        if readableText == None:
            readableText = node.slackReportInfo
        if &#39;SLACK-CLIENT&#39; in self.shared_data.globalData: #type:ignore
            if self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;] is not None and not len(self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;]) == 0: #type:ignore
                slackReadableText = readableText
                if not (&#34;&lt;img&gt;&#34; in node.slackReportInfo and &#34;&lt;/img&gt;&#34; in node.slackReportInfo):
                    slackReadableText = slackReadableText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                    self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].chat_postMessage(channel=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],text=slackReadableText) 
                else: #we have an image!
                    import re
                    #Extract the text between img tags:
                    imgInfo = re.findall(&#39;&lt;img&gt;(.*?)&lt;/img&gt;&#39;,node.slackReportInfo)[0]
                    restText = re.sub(&#39;&lt;img&gt;(.*?)&lt;/img&gt;&#39;,&#39;&#39;,node.slackReportInfo)
                    restText = restText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                    restText = restText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                    restText = restText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                    restText = restText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                    restText = restText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                    
                    #remove the curly brackets in imgInfo:
                    imgInfo = imgInfo.replace(&#39;{&#39;,&#39;&#39;)
                    imgInfo = imgInfo.replace(&#39;}&#39;,&#39;&#39;)
                    
                    #Get the image
                    im = utils.nodz_evaluateVar(imgInfo,node.flowChart)
                    # Convert the ndarray to a PIL Image
                    from PIL import Image
                    image = Image.fromarray(im/65535*255)# Or convert to RGB
                    image = image.convert(&#34;RGB&#34;)
                    
                    #Store the im as a PNG in a temporary folder:
                    import tempfile
                    tempDir = tempfile.TemporaryDirectory()
                    tempFile = os.path.join(tempDir.name,&#39;slackImage.png&#39;)
                    
                    # Save the image as a PNG file
                    image.save(tempFile, &#34;PNG&#34;)
                    #Send the message with the read-tempFile
                    slack_image = self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].files_upload(
                        title=&#34;Glados Image&#34;,
                        channels=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],
                        content=open(tempFile, &#39;rb&#39;).read(),
                        initial_comment = restText,
                    )
    except Exception as e:
        logging.warning(f&#39;Slack gave an unexpected error: {e}&#39;)
                
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.scoringEnd"><code class="name flex">
<span>def <span class="ident">scoringEnd</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the Scoring End node in the Flowchart.</p>
<p>This function signals to the rest of the flowchart that the scoring routine is finished.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scoringEnd(self,node):
    &#34;&#34;&#34;
    This function is the action function for the Scoring End node in the Flowchart.

    This function signals to the rest of the flowchart that the scoring routine is finished.

    Args:
        node (nodz.Node): The node that has triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    self.finishedEmits(node)
    #Find the nodes that are connected downstream of this:
    try:
        data = {}
        attrs = []
        for attr in node.attrs:
            connectedNode = None
            for connection in self.evaluateGraph():
                if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == attr:
                    if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                        connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                        connectedNode = self.findNodeByName(connectedNodeName)
        
                    data[attr] = connectedNode.scoring_analysis_currentData[&#39;__output__&#39;] #type:ignore
                    attrs.append(attr)
                    logging.debug(f&#34;Data found for {attr}: {data[attr]}&#34;)
    except:
        pass
    
    try:
        testPassed = self.decisionWidget.testCurrentDecision()
        testPassedText = &#39;Test is Passed&#39; if testPassed else &#39;Test is Not Passed&#39;
        # readableText = self.set_readable_text_after_dialogChange(node,[attrs,data,testPassedText],&#39;scoreEnd&#39;)
        
        logging.info(&#39;Scoring finished fully!&#39;)
        if testPassed:
            logging.info(&#34;Test is... Passed!&#34;)
            
            #Find the acqStart node:
            acqStartNode = None
            flowChart = self
            if len(flowChart.nodes) &gt; 0:
                #Find the scoringEnd node in flowChart:
                for nodeF in flowChart.nodes:
                    if &#39;acqStart_&#39; in nodeF.name:
                        acqStartNode = nodeF
            
            #Run the scoring_start routine:
            if acqStartNode is not None:
                logging.info(&#39;Starting acquisition routine!&#39;)
                self.acquiringStart(acqStartNode)
            else:
                logging.error(&#39;Could not find acqStart node in flowchart&#39;)
            
        elif not testPassed:
            logging.info(&#34;Test is... Not Passed!&#34;)
            #Go to next XY position
            if self.fullRunOngoing:
                if self.fullRunCurrentPos+1 &lt; self.fullRunPositions[&#39;nrPositions&#39;]:
                    self.fullRunCurrentPos +=1
                    #And start a new score/acq at a new pos:
                    self.startNewScoreAcqAtPos()
                else:
                    self.singleRunOngoing = False
                    logging.info(&#39;All done!&#39;)
        logging.info(&#39;----------------------&#39;)

    except:
        testPassed = False
        node.status = &#39;error&#39;
        testPassedText = &#39;Error when assessing test&#39;
        readableText = self.set_readable_text_after_dialogChange(node,[attrs,data,testPassedText],&#39;scoreEnd&#39;)
    
    
    #Find the reporting node(s)
    connectedNodes = nodz_utils.getConnectedNodes(node, &#39;bottomAttr&#39;)
    for node in connectedNodes:
        logging.debug(node.name)
        if &#39;reporting_&#39; in node.name:
            node.status = &#39;running&#39;
            if &#39;SLACK&#39; in self.shared_data.globalData: #type:ignore
                if self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;] is not None and not len(self.shared_data.globalData[&#39;SLACK-TOKEN&#39;][&#39;value&#39;]) == 0: #type:ignore
                    slackReadableText = readableText
                    slackReadableText = slackReadableText.replace(&#39;&lt;br&gt;&#39;,&#39;\r\n&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;i&gt;&#39;,&#39;_&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;/i&gt;&#39;,&#39;_&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;b&gt;&#39;,&#39;*&#39;)
                    slackReadableText = slackReadableText.replace(&#39;&lt;/b&gt;&#39;,&#39;*&#39;)
                    slackReadableText = &#34;New Score: \n&#34; + slackReadableText
                    self.shared_data.globalData[&#39;SLACK-CLIENT&#39;][&#39;value&#39;].chat_postMessage(channel=self.shared_data.globalData[&#39;SLACK-CHANNEL&#39;][&#39;value&#39;],text=slackReadableText) #type:ignore
                    node.status = &#39;finished&#39;
                else:
                    node.status = &#39;error&#39;
            else:
                node.status = &#39;error&#39;
    
    self.preventAcq = False</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.scoringStart"><code class="name flex">
<span>def <span class="ident">scoringStart</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the Scoring Start node in the Flowchart.</p>
<p>This function signals to the rest of the flowchart that it's time to start
the scoring routine.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scoringStart(self,node):
    &#34;&#34;&#34;
    This function is the action function for the Scoring Start node in the Flowchart.

    This function signals to the rest of the flowchart that it&#39;s time to start
    the scoring routine.

    Args:
        node (nodz.Node): The node that has triggered the event.

    Returns:
        None
    &#34;&#34;&#34;
    
    if self.preventScoring == False:
        logging.debug(&#39;Starting the score routine!&#39;)
        
        #Set all connected nodes to idle
        connectedNodes = nodz_utils.findConnectedToNode(self.evaluateGraph(),node.name,[])
        for connectedNode in connectedNodes:
            for nodeC in self.nodes:
                if nodeC.name == connectedNode:
                    nodeC.status=&#39;idle&#39;
        
        #Get all connections:
        allConnections = []
        for connectedNode in connectedNodes:
            for nodeC in self.nodes:
                if nodeC.name == connectedNode:
                    for attr in nodeC.sockets:
                        connections = nodeC.sockets[attr].connections
                        for connection in connections:
                            if connection not in allConnections:
                                allConnections.append(connection)
                    for attr in nodeC.plugs:
                        connections = nodeC.plugs[attr].connections
                        for connection in connections:
                            if connection not in allConnections:
                                allConnections.append(connection)
                    for attr in nodeC.topAttrs:
                        connections = nodeC.topAttrs[attr].connections
                        for connection in connections:
                            if connection not in allConnections:
                                allConnections.append(connection)
                    for attr in nodeC.bottomAttrs:
                        connections = nodeC.bottomAttrs[attr].connections
                        for connection in connections:
                            if connection not in allConnections:
                                allConnections.append(connection)
        
        for connection in allConnections:
            connection._pen.setColor(QColor(*self.config[&#39;connection_color&#39;]))
            connection.updatePath()
        
        self.set_readable_text_after_dialogChange(node,&#39;&#39;,&#39;scoreStart&#39;)
        
        self.GraphToSignals()
        
        self.finishedEmits(node)
    else:
        logging.warning(&#39;Actively blocked scoring due to self.preventScoring!&#39;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.set_readable_text_after_dialogChange"><code class="name flex">
<span>def <span class="ident">set_readable_text_after_dialogChange</span></span>(<span>self, currentNode, dialog, nodeType=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Script which sets a readable text inside the textfield of the currentNode after a dialog is closed (i.e. a popup window is closed).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>currentNode</code></strong> :&ensp;<code>Nodz Node</code></dt>
<dd>Current Nodz Node</dd>
<dt><strong><code>dialog</code></strong> :&ensp;<code>QDialog</code></dt>
<dd>Dialog output</dd>
<dt><strong><code>nodeType</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_readable_text_after_dialogChange(self,currentNode,dialog,nodeType=None):
    &#34;&#34;&#34;Script which sets a readable text inside the textfield of the currentNode after a dialog is closed (i.e. a popup window is closed).

    Args:
        currentNode (Nodz Node): Current Nodz Node
        dialog (QDialog): Dialog output
        nodeType (str): Type of node
    &#34;&#34;&#34;
    displayHTMLtext = &#39;&#39;
    if nodeType == None:
        nodeType = currentNode.name.split(&#39;_&#39;)[0]
    if nodeType == &#39;analysisMeasurement&#39; or nodeType == &#39;analysisMeasurementDEBUG&#39;:
        methodName = dialog.currentData[&#39;__selectedDropdownEntryAnalysis__&#39;]
        methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
        reqKwValues = []
        optKwValues = []
        
        reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
        optKwargs = utils.optKwargsFromFunction(methodFunctionName)
        
        displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&lt;br&gt;Input:&#34;
        
        relativeData = {}
        for key in dialog.currentData:
            if &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                relativeData[key] = dialog.currentData[key]
        
        allValues = utils.nodz_dataFromGeneralAdvancedLineEditDialog(relativeData,currentNode.flowChart)
        
        for rkw in reqKwargs:
            displayVal = self.limitTextLength(str(allValues[rkw][1]))
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{rkw}&lt;/b&gt;: {displayVal}&#34;

        for okw in optKwargs:
            displayVal = self.limitTextLength(str(allValues[okw][1]))
            displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{okw}&lt;/i&gt;: {displayVal}&#34;
        
        displayHTMLtext += &#34;&lt;br&gt;&lt;br&gt;Output:&#34;
        htmloutputadded=False
        for varName in currentNode.variablesNodz:
            currData = str(currentNode.variablesNodz[varName][&#39;data&#39;])
            typing = currentNode.variablesNodz[varName][&#39;type&#39;]
            importance = currentNode.variablesNodz[varName][&#39;importance&#39;]
            
            if currData is not None:
                currData = self.limitTextLength(currData)
            else:
                currData = &#39;None&#39;
            
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{varName}&lt;/b&gt;: {str(currData)}&#34;
            htmloutputadded=True
        
        if not htmloutputadded:
            displayHTMLtext += f&#34;&lt;br&gt;None&#34;
    elif nodeType == &#39;RTanalysisMeasurement&#39;:
        methodName = dialog.currentData[&#39;__selectedDropdownEntryRTAnalysis__&#39;]
        methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
        reqKwValues = []
        optKwValues = []
        
        reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
        optKwargs = utils.optKwargsFromFunction(methodFunctionName)
        
        for key in dialog.currentData:
            for rkw in reqKwargs:
                if rkw in key and &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                    reqKwValues.append(dialog.currentData[key])
            for okw in optKwargs:
                if okw in key and &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                    optKwValues.append(dialog.currentData[key])
        
        displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&#34;
        for i in range(len(reqKwargs)):
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{reqKwargs[i]}&lt;/b&gt;: {reqKwValues[i]}&#34;
        for i in range(len(optKwargs)):
            displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{optKwargs[i]}&lt;/i&gt;: {optKwValues[i]}&#34;
            
    elif nodeType == &#39;visualisation&#39;:
        displayHTMLtext = f&#34;&lt;b&gt;Layer name: {dialog.layerNameEdit.text()}&lt;/b&gt;&#34;
        if dialog.colormapComboBox.currentText() != &#39;None&#39;:
            displayHTMLtext += f&#34;&lt;br&gt;Colormap: {dialog.colormapComboBox.currentText()}&#34;
    elif nodeType == &#39;acquisition&#39;:
        displayHTMLtext = f&#34;&lt;b&gt;{len(dialog.getInputs())} frames with order {dialog.mdaconfig.order}&lt;/b&gt;&#34;
        if dialog.mdaconfig.GUI_exposure_enabled:
            displayHTMLtext += f&#34;&lt;br&gt;{dialog.getExposureTime()} ms exposure time&#34;
        if dialog.mdaconfig.GUI_show_time:
            displayHTMLtext += f&#34;&lt;br&gt;{dialog.mdaconfig.num_time_points} time points&#34;
        if dialog.mdaconfig.GUI_show_channel:
            displayHTMLtext += f&#34;&lt;br&gt;{len(dialog.mdaconfig.channel_exposures_ms)} channels in group {dialog.mdaconfig.channel_group}&#34;
        if dialog.mdaconfig.GUI_show_xy:
            displayHTMLtext += f&#34;&lt;br&gt;{len(dialog.mdaconfig.xy_positions)} XY positions&#34;
        if dialog.mdaconfig.GUI_show_z:
            if dialog.mdaconfig.z_nr_steps is not None:
                displayHTMLtext += f&#34;&lt;br&gt;{dialog.mdaconfig.z_nr_steps} Z positions&#34;
            else:
                nrZsteps = (dialog.mdaconfig.z_end-dialog.mdaconfig.z_start)//dialog.mdaconfig.z_step_distance
                displayHTMLtext += f&#34;&lt;br&gt;{nrZsteps} Z positions&#34;
    elif nodeType == &#39;changeProperties&#39;:
        displayHTMLtext = f&#34;Changing {len(dialog.ConfigsToBeChanged())} config(s):&#34;
        for config in dialog.ConfigsToBeChanged():
            try:
                displayRounded = str(round(float(config[1]),3))
            except:
                displayRounded = config[1]
            displayHTMLtext += f&#34;&lt;br&gt;{config[0]} to {displayRounded}&#34;
    elif nodeType == &#39;scoreEnd&#39;:
        import time
        from datetime import datetime
        displayHTMLtext = f&#34;&lt;i&gt; {datetime.fromtimestamp(time.time()).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&lt;/i&gt;&#34;
        for score_entry in dialog[0]:
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{score_entry}:&lt;/b&gt; {format(dialog[1][score_entry],&#39;.2f&#39;)}&#34;
        if len(dialog) &gt; 2:
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{dialog[2]}&lt;/b&gt;&#34;
    elif nodeType == &#39;scoreStart&#39;:
        import time
        from datetime import datetime
        displayHTMLtext = &#34;&lt;b&gt;Scoring started at:&lt;/b&gt;&#34;
        displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt; {datetime.fromtimestamp(time.time()).strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)}&lt;/i&gt;&#34;
    
    elif nodeType == &#39;earlyScoringFail&#39;:
        displayHTMLtext = f&#34;This node will fail this score and go to the next position!&#34;
    elif nodeType == &#39;timer&#39;:
        values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(dialog.timerInfo,currentNode.flowChart)
        try:
            displayHTMLtext = f&#34;&lt;b&gt;Timer:&lt;/b&gt; wait {str(values[&#39;wait_time&#39;][1])} s&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
    elif nodeType == &#39;storeData&#39;:
        values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.storeDataInfo,currentNode.flowChart,dontEvaluate=True)
        try:
            displayHTMLtext = f&#34;Store data &lt;b&gt;{self.limitTextLength(values[&#39;item_to_store&#39;][1])}&lt;/b&gt; at location &lt;b&gt;{self.limitTextLength(values[&#39;store_location&#39;][1])}&lt;/b&gt;&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
    elif nodeType == &#39;changeGlobalVar&#39;:
        values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.changeGlobalVarInfo,currentNode.flowChart,dontEvaluate=True)
        try:
            displayHTMLtext = f&#34;Change global variable &lt;b&gt;{self.limitTextLength(values[&#39;globalVarName&#39;][1])}&lt;/b&gt; to &lt;b&gt;{self.limitTextLength(values[&#39;globalVarValue&#39;][1],textLength = 60)}&lt;/b&gt;&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
    
    elif nodeType == &#39;ifStatement&#39;:
        values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.ifStatementInfo,currentNode.flowChart,dontEvaluate=True)
        try:
            comparatorValue = values[&#39;comparator&#39;][1]
            #Replace &lt; inside the value:
            comparatorValue = comparatorValue.replace(&#39;&lt;&#39;,&#39;&amp;lt;&#39;)
            
            displayHTMLtext = f&#34;Assess the statement &lt;b&gt;{values[&#39;valueToCheck&#39;][1]} {comparatorValue} {values[&#39;valueCheckAgainst&#39;][1]}&lt;/b&gt;&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
        
    elif nodeType == &#39;runInlineScript&#39;:
        scriptInfo = currentNode.InlineScriptInfo
        n_lines = len(scriptInfo.split(&#39;\n&#39;))
        if n_lines == 1:
            displayHTMLtext = f&#34;Run a pycromanager script with &lt;b&gt;{n_lines} line&lt;/b&gt;&#34;
        else:
            displayHTMLtext = f&#34;Run a pycromanager script with &lt;b&gt;{n_lines} lines&lt;/b&gt;&#34;
    elif nodeType == &#39;newGlobalVar&#39;:
        values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.newGlobalVarInfo,currentNode.flowChart,dontEvaluate=True)
        try:
            displayHTMLtext = f&#34;Create new global variable &lt;b&gt;{self.limitTextLength(values[&#39;globalVarName&#39;][1])}&lt;/b&gt; with value &lt;b&gt;{self.limitTextLength(values[&#39;globalVarValue&#39;][1])}&lt;/b&gt;&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
    elif nodeType == &#39;customFunction&#39;:
        methodName = dialog.currentData[&#39;__selectedDropdownEntryAnalysis__&#39;]
        methodFunctionName = [i for i in dialog.currentData[&#39;__displayNameFunctionNameMap__&#39;] if i[0] == methodName][0][1]
        reqKwValues = []
        optKwValues = []
        
        reqKwargs = utils.reqKwargsFromFunction(methodFunctionName)
        optKwargs = utils.optKwargsFromFunction(methodFunctionName)
        
        displayHTMLtext = f&#34;&lt;b&gt;{methodName}&lt;/b&gt;&lt;br&gt;Input:&#34;
        
        relativeData = {}
        for key in dialog.currentData:
            if &#39;#&#39;+methodFunctionName+&#39;#&#39; in key:
                relativeData[key] = dialog.currentData[key]
        
        allValues = utils.nodz_dataFromGeneralAdvancedLineEditDialog(relativeData,currentNode.flowChart,dontEvaluate=True)
        
        for rkw in reqKwargs:
            displayVal = str(allValues[rkw][1])
            if len(displayVal) &gt; 40:
                displayVal = displayVal[:20] + &#39;...&#39; + displayVal[-20:]
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{rkw}&lt;/b&gt;: {displayVal}&#34;

        for okw in optKwargs:
            displayVal = str(allValues[okw][1])
            if len(displayVal) &gt; 40:
                displayVal = displayVal[:20] + &#39;...&#39; + displayVal[-20:]
            displayHTMLtext += f&#34;&lt;br&gt;&lt;i&gt;{okw}&lt;/i&gt;: {displayVal}&#34;
        
        
        displayHTMLtext += &#34;&lt;br&gt;&lt;br&gt;Output:&#34;
        
        htmloutputadded=False
        
        for varName in currentNode.variablesNodz:
            currData = str(currentNode.variablesNodz[varName][&#39;data&#39;])
            if currData is not None:
                currData = self.limitTextLength(currData)
            else:
                currData = &#39;None&#39;
            typing = currentNode.variablesNodz[varName][&#39;type&#39;]
            importance = currentNode.variablesNodz[varName][&#39;importance&#39;]
            displayHTMLtext += f&#34;&lt;br&gt;&lt;b&gt;{varName}&lt;/b&gt;: {str(currData)}&#34;
            htmloutputadded=True
        
        if not htmloutputadded:
            displayHTMLtext += f&#34;&lt;br&gt;None&#34;
    elif nodeType == &#34;changeStagePos&#34;:
        #Find the chosen stage and corresponding set movement (relative only for now)
        for key in dialog.RelStageInfo():
            if key[0] == &#39;__chosenRelStage__&#39;:
                chosenStage = key[1]
        for key in dialog.RelStageInfo():
            if key[0] == chosenStage:
                setMovement = key[1]
        #Set the displayHTML text:
        try:
            displayHTMLtext = &#34;&lt;b&gt;Relative&lt;/b&gt; movement of stage &lt;b&gt;&#34;+chosenStage+&#34;&lt;/b&gt; by &lt;b&gt;&#34;+str(setMovement)+&#34;&lt;/b&gt; units&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
    elif nodeType == &#34;caseSwitch&#34;:
        values = utils.nodz_dataFromGeneralAdvancedLineEditDialog(currentNode.caseSwitchInfo,currentNode.flowChart,dontEvaluate=True)
        try:
            displayHTMLtext = &#34;Perform a case/switch logic based on variable &lt;b&gt;&#34;+self.limitTextLength(values[&#39;Var&#39;][1])+&#34;&lt;/b&gt;&#34;
        except:
            displayHTMLtext = &#34;&lt;font color=&#39;#c00000&#39;&gt;Likely error with this node info!&lt;/font&gt;&#34;
    elif nodeType == &#39;stickyNote&#39;:
        displayHTMLtext = f&#34;{currentNode.stickyNoteInfo}&#34;
    elif nodeType == &#39;slackReport&#39;:
        displayHTMLtext = f&#34;{currentNode.slackReportInfo}&#34;
    elif nodeType == &#34;__InitRequireUserDoubleClick__&#34;:
        displayHTMLtext = &#34;&lt;font color=&#39;#a00000&#39;&gt;Double-click this node to initialize it correctly.&lt;/font&gt;&#34;
    #And update the display
    currentNode.updateDisplayText(displayHTMLtext)
    return displayHTMLtext</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.singleNodeTypeInit"><code class="name flex">
<span>def <span class="ident">singleNodeTypeInit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the info for a single node type. Hand-in-hand with defineNodeInfo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def singleNodeTypeInit(self):
    &#34;&#34;&#34; 
    Initialise the info for a single node type. Hand-in-hand with defineNodeInfo.
    &#34;&#34;&#34;
    init = {}
    init[&#39;name&#39;] = &#39;name&#39;
    init[&#39;displayName&#39;] = &#39;DisplayName&#39;
    init[&#39;startAttributes&#39;] = []
    init[&#39;finishedAttributes&#39;] = []
    init[&#39;dataAttributes&#39;] = []
    init[&#39;bottomAttributes&#39;] = []
    init[&#39;topAttributes&#39;] = []
    init[&#39;NodeCounter&#39;] = 0
    init[&#39;NodeCounterNeverReset&#39;] = 0
    init[&#39;MaxNodeCounter&#39;] = np.inf
    init[&#39;NodeSize&#39;] = 100
    return init</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.startNewScoreAcqAtPos"><code class="name flex">
<span>def <span class="ident">startNewScoreAcqAtPos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a new score acquisition at the current microscope position.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startNewScoreAcqAtPos(self):
    &#34;&#34;&#34;
    Starts a new score acquisition at the current microscope position.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    
    import time
    positions = self.fullRunPositions
    pos = self.fullRunCurrentPos
    
    self.shared_data.warningErrorInfoInfo[&#39;Info&#39;][&#39;Other&#39;] = [f&#34;Autonomous run is ongoing! Currently at pos {str(pos+1)}/{str(positions[&#39;nrPositions&#39;])}  ({str(round(pos/positions[&#39;nrPositions&#39;]*100,2))}%)&#34;]
    
    logging.info(f&#39;Starting new score acq at position {pos} -------------------------------------------------------------------------------&#39;)
    
    #Set all stages correct
    for stage in positions[pos][&#39;STAGES&#39;]:
        if stage != &#39;&#39;:
            stagepos = positions[pos][stage]
            #Check if this stage is an XY stage device...
            #Since then we need to do something 2-dimensional
            if stage in self.getDevicesOfDeviceType(&#39;XYStageDevice&#39;):
                logging.debug(f&#39;Moving stage {stage} to position {stagepos}&#39;)
                self.shared_data.core.set_xy_position(stage,stagepos[0],stagepos[1]) #type:ignore
                self.shared_data.core.wait_for_system() #type:ignore
            else:#else we can move a 1d stage:
                logging.debug(f&#39;Moving stage {stage} to position {stagepos}&#39;)
                self.shared_data.core.set_position(stage,stagepos[0]) #type:ignore
                self.shared_data.core.wait_for_system() #type:ignore
    
    self.runScoring()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.storeDataCallAction"><code class="name flex">
<span>def <span class="ident">storeDataCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the storeData Call node in the Flowchart.</p>
<p>This function stores data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storeDataCallAction(self,node):
    
    &#34;&#34;&#34;
    This function is the action function for the storeData Call node in the Flowchart.

    This function stores data.

    Args:
        node (nodz.Node): The node that has triggered the event.
    &#34;&#34;&#34;
    
    #Extract Data
    varInfo = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.storeDataInfo,node.flowChart)
    
    #Get the store-data from a variable
    storeInfo = varInfo[&#39;item_to_store&#39;][0]
    storeLoc = varInfo[&#39;store_location&#39;][0]
    
    #Check if storeInfo is image-like:
    if isinstance(storeInfo, np.ndarray) and storeInfo.ndim &gt; 1:
        #Check if we want to store a tiff
        if storeLoc[-4:] == &#39;.tif&#39; or storeLoc[-5:] == &#39;.tiff&#39;:
            import tifffile
            tifffile.imsave(storeLoc,storeInfo)
            logging.debug(f&#39;Stored TIF image at {storeLoc}&#39;)
    
    self.finishedEmits(node)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.storeGraphJSON"><code class="name flex">
<span>def <span class="ident">storeGraphJSON</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the current graph to a JSON file.</p>
<p>This function saves the current graph to a JSON file, which can be loaded later using <code>loadPickle()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def storeGraphJSON(self):
    &#34;&#34;&#34;
    Save the current graph to a JSON file.

    This function saves the current graph to a JSON file, which can be loaded later using `loadPickle()`.
    &#34;&#34;&#34;
    filename, _ = QFileDialog.getSaveFileName(self, &#39;Save file&#39;, &#39;&#39;, &#39;JSON files (*.json)&#39;)
    if filename:
        if not filename.endswith(&#39;.json&#39;):
            filename += &#39;.json&#39;
        with open(filename, &#39;wb&#39;) as f:
            self.saveGraph(filename)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.timerCallAction"><code class="name flex">
<span>def <span class="ident">timerCallAction</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is the action function for the Timer Call node in the Flowchart.</p>
<p>This function waits for a specified amount of time before triggering the next node in the flowchart.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>nodz.Node</code></dt>
<dd>The node that has triggered the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timerCallAction(self,node):
    &#34;&#34;&#34;
    This function is the action function for the Timer Call node in the Flowchart.

    This function waits for a specified amount of time before triggering the next node in the flowchart.

    Args:
        node (nodz.Node): The node that has triggered the event.
    Returns:
        None
    &#34;&#34;&#34;        
    #Get info
    vardata = utils.nodz_dataFromGeneralAdvancedLineEditDialog(node.timerInfo, node.flowChart)
    wait_time = float(vardata[&#39;wait_time&#39;][0])

    #Create the worker
    worker = generalNodzCallActionWorker(nodzType=&#39;Timer&#39;,args={&#34;wait_time&#34;:wait_time})
    #Add the finished emit
    worker.signals.finished.connect(lambda: self.finishedEmits(node))
    #Star the worker
    self.thread_pool.start(worker)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.updateCoreVariables"><code class="name flex">
<span>def <span class="ident">updateCoreVariables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Idea, get information like this:
self.coreVariables is initialised like {}</p>
<p>self.coreVariables['TrialGlobalVariable']={}
self.coreVariables['TrialGlobalVariable']['type'] = str
self.coreVariables['TrialGlobalVariable']['data'] = 'test'
self.coreVariables['TrialGlobalVariable']['importance'] = 'Informative'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateCoreVariables(self):
    &#34;&#34;&#34;
    
    Idea, get information like this:
    self.coreVariables is initialised like {}
    
    self.coreVariables[&#39;TrialGlobalVariable&#39;]={}
    self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;type&#39;] = str
    self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;data&#39;] = &#39;test&#39;
    self.coreVariables[&#39;TrialGlobalVariable&#39;][&#39;importance&#39;] = &#39;Informative&#39;
    
    &#34;&#34;&#34;
    allXYstages = utils.getCoreDevicesOfDeviceType(self.core,&#39;XYStageDevice&#39;)
    all1Dstages = utils.getCoreDevicesOfDeviceType(self.core,&#39;StageDevice&#39;)
    
    #Core variables to store:
    #Stage positions, all stages
    for stage in allXYstages:
        xypos = self.core.get_xy_stage_position(stage) #type:ignore
        self.createSingleCoreVar(stage+&#39;_current_pos&#39;,[xypos.x,xypos.y],[list,np.ndarray]) #type:ignore
    
    for stage in all1Dstages:
        pos = self.core.get_position(stage) #type:ignore
        self.createSingleCoreVar(stage+&#39;_current_pos&#39;,[pos],[list,np.ndarray]) #type:ignore
    
    #Config values, all configs
    allConfigs = self.core.get_available_config_groups()
    if allConfigs != None:
        nrconfiggroups = allConfigs.size()
        for config_id in range(nrconfiggroups):
            configInfo = ConfigInfo(self.core,config_id)
            configName = configInfo.configGroupName()
            configValue = configInfo.getStorableValue()
            try:
                typev = [type(configValue)]
            except:
                typev = [str]
            self.createSingleCoreVar(&#39;config_&#39;+configName,configValue,typev) #type:ignore
        
    #Pixel size, ROI size
    self.createSingleCoreVar(&#39;Pixel_size_um&#39;,self.core.get_pixel_size_um(),[float]) #type:ignore
    self.createSingleCoreVar(&#39;ROI_size&#39;,[self.core.get_roi().width,self.core.get_roi().height],[list,np.ndarray]) #type:ignore</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.updateNumberStartFinishedDataAttributes"><code class="name flex">
<span>def <span class="ident">updateNumberStartFinishedDataAttributes</span></span>(<span>self, newNode, nodeType)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates custom attributes for a new node based on the specified node type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>newNode</code></strong></dt>
<dd>The new node to update custom attributes for.</dd>
<dt><strong><code>nodeType</code></strong></dt>
<dd>The type of the node to determine which custom attributes to update.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateNumberStartFinishedDataAttributes(self,newNode,nodeType):
    &#34;&#34;&#34;
    Updates custom attributes for a new node based on the specified node type.
    
    Args:
        newNode: The new node to update custom attributes for.
        nodeType: The type of the node to determine which custom attributes to update.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    if len(self.nodeInfo[nodeType][&#39;startAttributes&#39;]) &gt; 0:
        newNode.customStartEmits = NodeSignalManager()
    else:
        newNode.customStartEmits = None
    if len(self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]) &gt; 0:
        newNode.customFinishedEmits = NodeSignalManager()
    else:
        newNode.customFinishedEmits = None
    if len(self.nodeInfo[nodeType][&#39;dataAttributes&#39;]) &gt; 0:
        newNode.customDataEmits = NodeSignalManager()
    else:
        newNode.customDataEmits = None
    if len(self.nodeInfo[nodeType][&#39;bottomAttributes&#39;]) &gt; 0:
        newNode.customBottomEmits = NodeSignalManager()
    else:
        newNode.customBottomEmits = None
    if len(self.nodeInfo[nodeType][&#39;topAttributes&#39;]) &gt; 0:
        newNode.customTopEmits = NodeSignalManager()
    else:
        newNode.customTopEmits = None
        
    #Add custom attributes where necessary
    for attr in self.nodeInfo[nodeType][&#39;startAttributes&#39;]:
        self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=True)
        newNode.customStartEmits.add_signal(attr) #type: ignore
    for attr in self.nodeInfo[nodeType][&#39;finishedAttributes&#39;]:
        self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=True, socket=False)
        newNode.customFinishedEmits.add_signal(attr) #type: ignore
    for attr in self.nodeInfo[nodeType][&#39;dataAttributes&#39;]:
        self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=True, socket=False)
        newNode.customDataEmits.add_signal(attr) #type: ignore
    for attr in self.nodeInfo[nodeType][&#39;bottomAttributes&#39;]:
        self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=False, bottomAttr=True)
        newNode.customBottomEmits.add_signal(attr) #type: ignore
    for attr in self.nodeInfo[nodeType][&#39;topAttributes&#39;]:
        self.createAttribute(node=newNode, name=attr, index=-1, preset=&#39;attr_preset_1&#39;, plug=False, socket=False, topAttr=True)
        newNode.customTopEmits.add_signal(attr) #type: ignore
    
    logging.debug(&#34;updated custom attributes&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.update_plugs_fromDialog"><code class="name flex">
<span>def <span class="ident">update_plugs_fromDialog</span></span>(<span>self, currentNode, dialogLineEdits)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the "scoring end" current node with new dialog line edits.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>currentNode</code></strong></dt>
<dd>The current node to update.</dd>
<dt><strong><code>dialogLineEdits</code></strong></dt>
<dd>The new sockets of the current node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_plugs_fromDialog(self,currentNode,dialogLineEdits):
    &#34;&#34;&#34;
    Update the &#34;scoring end&#34; current node with new dialog line edits.
    
    Args:
        currentNode: The current node to update.
        dialogLineEdits: The new sockets of the current node.
    
    Returns:
        None
    &#34;&#34;&#34;
            
    #the dialogLineEdits should be the new plugs of the current node. However, if a plug with the name already exists, it shouldn&#39;t be changed.
    import time
    sleepTime = 0.02
    for _ in range(3): #Just repeat everything 3 times and hope it solves itself
        self.update()
        time.sleep(sleepTime)
        current_plugs = [item[0] for item in list(currentNode.plugs.items())]
        if dialogLineEdits != current_plugs:
            
            for plug_id in reversed(range(len(currentNode.attrs))):
                plug = currentNode.attrs[plug_id]
                #We check if the plug is in dialogLineEdits:
                if plug not in dialogLineEdits and plug in current_plugs:
                    logging.debug(plug_id)
                    #If it isn&#39;t, we just delete it:
                    self.deleteAttribute(currentNode,plug_id)
                    time.sleep(sleepTime)
                    self.update()
                    time.sleep(sleepTime)
            
            #Check which are different (index-wise) between dialogLineEdits and current_plugs:
            diff_indexes = []
            same_indexes = []
            for i in range(min(len(dialogLineEdits),len(current_plugs))):
                if dialogLineEdits[i] != current_plugs[i]:
                    diff_indexes.append(i)
                else:
                    same_indexes.append(i)
            #Also append indexes if dialogLineEdits is longer than current_plugs:
            if len(dialogLineEdits) &gt; len(current_plugs):
                for i in range(len(current_plugs),len(dialogLineEdits)):
                    diff_indexes.append(i)
            
            offset = 100
            #Then we create new plugs or move existing plugs, only for those that have a different pos
            for plug_new in ([dialogLineEdits[i] for i in diff_indexes]):
                pos_in_dialogLineEdits = dialogLineEdits.index(plug_new)
                if plug_new not in currentNode.plugs:
                    self.createAttribute(currentNode, name=plug_new, index=pos_in_dialogLineEdits+offset, preset=&#39;attr_default&#39;, plug=True, socket=False, dataType=None)
                    time.sleep(sleepTime)
                    self.update()
                    time.sleep(sleepTime)
                else: #Else we move it from some other location to where we want it
                    #Find this plug in currentNode.plugs.items():
                    plugFull = list(currentNode.plugs.items())
                    pos_in_node_info = [plug_id for plug_id in range(len(plugFull)) if plugFull[plug_id][0] == plug_new][0]
                    old_pos = plugFull[pos_in_node_info][1].index
                    #Physically move it
                    self.editAttribute(currentNode,old_pos,newName = None, newIndex=pos_in_dialogLineEdits+offset)
                    time.sleep(sleepTime)
                    self.update()
                    time.sleep(sleepTime)
    
    #We also need to add these attributes to the nodes startAttributes in self.nodeInfo:
    self.nodeInfo[self.nodeLookupName_withoutCounter(currentNode.name)][&#39;finishedAttributes&#39;] = dialogLineEdits</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.update_scoring_end"><code class="name flex">
<span>def <span class="ident">update_scoring_end</span></span>(<span>self, currentNode, dialogLineEdits)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the "scoring end" current node with new dialog line edits.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>currentNode</code></strong></dt>
<dd>The current node to update.</dd>
<dt><strong><code>dialogLineEdits</code></strong></dt>
<dd>The new sockets of the current node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_scoring_end(self,currentNode,dialogLineEdits):
    &#34;&#34;&#34;
    Update the &#34;scoring end&#34; current node with new dialog line edits.
    
    Args:
        currentNode: The current node to update.
        dialogLineEdits: The new sockets of the current node.
    
    Returns:
        None
    &#34;&#34;&#34;
    
    currentNode.scoring_end_currentData[&#39;Variables&#39;] = dialogLineEdits #type: ignore
    
    #the dialogLineEdits should be the new sockets of the current node. However, if a plug with the name already exists, it shouldn&#39;t be changed.
    import time
    sleepTime = 0.02
    for _ in range(3): #Just repeat everything 3 times and hope it solves itself
        self.update()
        time.sleep(sleepTime)
        current_sockets = [item[0] for item in list(currentNode.sockets.items())]
        if dialogLineEdits != current_sockets:
            
            for socket_id in reversed(range(len(currentNode.attrs))):
                socket = currentNode.attrs[socket_id]
                #We check if the socket is in dialogLineEdits:
                if socket not in dialogLineEdits and socket in current_sockets:
                    #If it isn&#39;t, we just delete it:
                    self.deleteAttribute(currentNode,socket_id)
                    time.sleep(sleepTime)
                    self.update()
                    time.sleep(sleepTime)
            
            #Check which are different (index-wise) between dialogLineEdits and current_sockets:
            diff_indexes = []
            same_indexes = []
            for i in range(min(len(dialogLineEdits),len(current_sockets))):
                if dialogLineEdits[i] != current_sockets[i]:
                    diff_indexes.append(i)
                else:
                    same_indexes.append(i)
            #Also append indexes if dialogLineEdits is longer than current_sockets:
            if len(dialogLineEdits) &gt; len(current_sockets):
                for i in range(len(current_sockets),len(dialogLineEdits)):
                    diff_indexes.append(i)
            
            offset = 100
            #Then we create new sockets or move existing sockets, only for those that have a different pos
            for socket_new in ([dialogLineEdits[i] for i in diff_indexes]):
                pos_in_dialogLineEdits = dialogLineEdits.index(socket_new)
                if socket_new not in currentNode.sockets:
                    self.createAttribute(currentNode, name=socket_new, index=pos_in_dialogLineEdits+offset, preset=&#39;attr_default&#39;, plug=False, socket=True, dataType=None, socketMaxConnections=1)
                    time.sleep(sleepTime)
                    self.update()
                    time.sleep(sleepTime)
                else: #Else we move it from some other location to where we want it
                    #Find this socket in currentNode.sockets.items():
                    socketFull = list(currentNode.sockets.items())
                    pos_in_node_info = [socket_id for socket_id in range(len(socketFull)) if socketFull[socket_id][0] == socket_new][0]
                    old_pos = socketFull[pos_in_node_info][1].index
                    #Physically move it
                    self.editAttribute(currentNode,old_pos,newName = None, newIndex=pos_in_dialogLineEdits+offset)
                    time.sleep(sleepTime)
                    self.update()
                    time.sleep(sleepTime)
    
    #We also need to add these attributes to the nodes startAttributes in self.nodeInfo:
    self.nodeInfo[self.nodeLookupName_withoutCounter(currentNode.name)][&#39;startAttributes&#39;] = dialogLineEdits</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.HoverTableWidget"><code class="flex name class">
<span>class <span class="ident">HoverTableWidget</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QTableWidget(parent: typing.Optional[QWidget] = None)
QTableWidget(rows: int, columns: int, parent: typing.Optional[QWidget] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HoverTableWidget(QTableWidget):
    cellHovered = pyqtSignal(int, int)

    def __init__(self,parent=None):
        super().__init__(parent)
        self.setMouseTracking(True)  # Enable mouse tracking without pressing a button
        self.setSortingEnabled(True) #Enable sorting the columns
        self.verticalHeader().hide() #Hide the row numbering

    def mouseMoveEvent(self, event):
        index = self.indexAt(event.pos())
        if index.isValid():
            self.cellHovered.emit(index.row(), index.column())
        super().mouseMoveEvent(event)

    def leaveEvent(self, event):
        # Emit cellHovered signal with invalid index when mouse leaves
        self.cellHovered.emit(-1, -1)
        super().leaveEvent(event)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QTableWidget</li>
<li>PyQt5.QtWidgets.QTableView</li>
<li>PyQt5.QtWidgets.QAbstractItemView</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.HoverTableWidget.cellHovered"><code class="name flex">
<span>def <span class="ident">cellHovered</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="FlowChart_dockWidgets.HoverTableWidget.leaveEvent"><code class="name flex">
<span>def <span class="ident">leaveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>leaveEvent(self, a0: QEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leaveEvent(self, event):
    # Emit cellHovered signal with invalid index when mouse leaves
    self.cellHovered.emit(-1, -1)
    super().leaveEvent(event)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.HoverTableWidget.mouseMoveEvent"><code class="name flex">
<span>def <span class="ident">mouseMoveEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>mouseMoveEvent(self, e: QMouseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouseMoveEvent(self, event):
    index = self.indexAt(event.pos())
    if index.isValid():
        self.cellHovered.emit(index.row(), index.column())
    super().mouseMoveEvent(event)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.LoggerWidget"><code class="flex name class">
<span>class <span class="ident">LoggerWidget</span></span>
<span>(</span><span>logLevel='INFO')</span>
</code></dt>
<dd>
<div class="desc"><p>QPlainTextEdit(parent: typing.Optional[QWidget] = None)
QPlainTextEdit(text: str, parent: typing.Optional[QWidget] = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoggerWidget(QPlainTextEdit):
    def __init__(self, logLevel=&#39;INFO&#39;):
        super().__init__()
        
        # Set the widget to read-only
        self.setReadOnly(True)
        
        # Get the appdata folder
        appdata_folder = os.getenv(&#39;APPDATA&#39;)
        if appdata_folder is None:
            raise EnvironmentError(&#34;APPDATA environment variable not found&#34;)
        self.app_specific_folder = os.path.join(appdata_folder, &#39;Glados-PycroManager&#39;)
    
        #Find all log files
        log_files = [f for f in os.listdir(self.app_specific_folder) if f.endswith(&#34;.log&#34;)]
        if not log_files:
            return None
    
        if logLevel == &#39;DEBUG&#39;:
            correct_level_log_files = [f for f in log_files if &#39;DEBUG&#39; in f]
            self.most_recent_file = max(correct_level_log_files, key=lambda f: os.path.getmtime(os.path.join(self.app_specific_folder, f)))
        else:
            correct_level_log_files = [f for f in log_files if &#39;INFO&#39; in f]
            self.most_recent_file = max(correct_level_log_files, key=lambda f: os.path.getmtime(os.path.join(self.app_specific_folder, f)))
        
        self.update_log_content()
        
        #random value between around 500: (desyncs multiple logger widgets)
        import random
        if not logLevel == &#39;DEBUG&#39;:
            # Set up a timer to periodically update the log content
            self.timer = QTimer(self)
            self.timer.timeout.connect(self.update_log_content)
            self.timer.start(random.randint(400, 600))
            
    def update_log_content(self):
        &#34;&#34;&#34; 
        Update the contents of the logger view by re-reading the log_file
        &#34;&#34;&#34;
        if not self.most_recent_file:
            return

        with open(os.path.join(self.app_specific_folder,self.most_recent_file), &#39;r&#39;) as log_file:
            self.setPlainText(log_file.read())
            self.moveCursor(QTextCursor.End)  # Scroll to the bottom</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QPlainTextEdit</li>
<li>PyQt5.QtWidgets.QAbstractScrollArea</li>
<li>PyQt5.QtWidgets.QFrame</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.LoggerWidget.update_log_content"><code class="name flex">
<span>def <span class="ident">update_log_content</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the contents of the logger view by re-reading the log_file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_log_content(self):
    &#34;&#34;&#34; 
    Update the contents of the logger view by re-reading the log_file
    &#34;&#34;&#34;
    if not self.most_recent_file:
        return

    with open(os.path.join(self.app_specific_folder,self.most_recent_file), &#39;r&#39;) as log_file:
        self.setPlainText(log_file.read())
        self.moveCursor(QTextCursor.End)  # Scroll to the bottom</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.NodeSignalManager"><code class="flex name class">
<span>class <span class="ident">NodeSignalManager</span></span>
</code></dt>
<dd>
<div class="desc"><p>The NodeSignalManager class is used to manage the signals emitted and received by nodes in the graph (i.e. those created by connections).
This is a generic class to handle the signals of any number of nodes.</p>
<p>Constructor for the NodeSignalManager class.</p>
<p>This class is used to manage the signals emitted by nodes in the graph.
This is a generic class to handle the signals of any number of nodes.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeSignalManager(QObject):
    &#34;&#34;&#34;
    The NodeSignalManager class is used to manage the signals emitted and received by nodes in the graph (i.e. those created by connections).
    This is a generic class to handle the signals of any number of nodes.
    &#34;&#34;&#34;
    
    #pyqtSignals need to be outside init def
    new_signal = pyqtSignal()
    
    def __init__(self):
        &#34;&#34;&#34;
        Constructor for the NodeSignalManager class.

        This class is used to manage the signals emitted by nodes in the graph.
        This is a generic class to handle the signals of any number of nodes.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        QObject.__init__(self)
        super().__init__()
        self.signals = []

    def add_signal(self, signal_name):
        &#34;&#34;&#34;
        Adds a new signal to the NodeSignalManager class.

        This function is used to dynamically add a new signal to the object.

        Args:
            signal_name (str): The name of the signal to be added.

        Returns:
            None
        &#34;&#34;&#34;
        # Dynamically add a new signal to the object
        setattr(self, signal_name, eval(&#39;self.new_signal&#39;))
        self.signals.append(eval(&#39;self.new_signal&#39;))
        

    def print_signals(self):
        &#34;&#34;&#34;
        Prints all the signals managed by this class.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        for signal in self.signals:
            logging.info(signal)

    def emit_all_signals(self):
        &#34;&#34;&#34;
        Emits all the signals managed by this class.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        for signal in self.signals:
            signal.emit()
            logging.debug(f&#34;emitting signal {signal}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.NodeSignalManager.add_signal"><code class="name flex">
<span>def <span class="ident">add_signal</span></span>(<span>self, signal_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new signal to the NodeSignalManager class.</p>
<p>This function is used to dynamically add a new signal to the object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signal_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the signal to be added.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_signal(self, signal_name):
    &#34;&#34;&#34;
    Adds a new signal to the NodeSignalManager class.

    This function is used to dynamically add a new signal to the object.

    Args:
        signal_name (str): The name of the signal to be added.

    Returns:
        None
    &#34;&#34;&#34;
    # Dynamically add a new signal to the object
    setattr(self, signal_name, eval(&#39;self.new_signal&#39;))
    self.signals.append(eval(&#39;self.new_signal&#39;))</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.NodeSignalManager.emit_all_signals"><code class="name flex">
<span>def <span class="ident">emit_all_signals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Emits all the signals managed by this class.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emit_all_signals(self):
    &#34;&#34;&#34;
    Emits all the signals managed by this class.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    for signal in self.signals:
        signal.emit()
        logging.debug(f&#34;emitting signal {signal}&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.NodeSignalManager.new_signal"><code class="name flex">
<span>def <span class="ident">new_signal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="FlowChart_dockWidgets.NodeSignalManager.print_signals"><code class="name flex">
<span>def <span class="ident">print_signals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints all the signals managed by this class.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_signals(self):
    &#34;&#34;&#34;
    Prints all the signals managed by this class.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    for signal in self.signals:
        logging.info(signal)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.ScanningWidget"><code class="flex name class">
<span>class <span class="ident">ScanningWidget</span></span>
<span>(</span><span>nodzinstance=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The scanning widget which handles the xy(z) scanning in a full autonomous runs. Mainly contains multiple advScanGridLayouts() which each individually handle a single method of xy(z) scanning.</p>
<p>Initializes the scanning widget class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodzinstance</code></strong></dt>
<dd>The nodz instance to be associated with.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ScanningWidget(QWidget):
    &#34;&#34;&#34; 
    The scanning widget which handles the xy(z) scanning in a full autonomous runs. Mainly contains multiple advScanGridLayouts() which each individually handle a single method of xy(z) scanning.
    &#34;&#34;&#34;
    def __init__(self, nodzinstance=None,parent=None):
        &#34;&#34;&#34;
        Initializes the scanning widget class.
        
        Args:
            nodzinstance: The nodz instance to be associated with.
            parent: The parent widget.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        # super().__init__()
        self.nodzinstance=nodzinstance
        self.scanMode = &#39;LoadPos&#39;
        self.scanArray_modes = [
                            [&#39;LoadPos&#39;,&#39;Load a POS list&#39;]]
                
        self.scanLayouts = {}
        self.currentMode = None
        
        self.create_GUI()
    
    def create_GUI(self):
        &#34;&#34;&#34;
        Create scanning widget GUI with mode dropdown and corresponding advScanGridLayout layouts.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.mode_dropdown = QComboBox()
        self.mode_dropdown.addItems([option[1] for option in self.scanArray_modes])
        self.mode_layout = QGridLayout()
        self.mode_layout.addWidget(QLabel(&#39;Mode: &#39;),0,0)
        self.mode_layout.addWidget(self.mode_dropdown,0,1)

        from PyQt5.QtWidgets import QHBoxLayout
        for mode_option in self.scanArray_modes:
            self.scanLayouts[mode_option[0]] = advScanGridLayout(mode=mode_option[0],parent=self)
            
            self.scanLayouts[mode_option[0]].setVisible(True) #False
        
        self.layoutV = QVBoxLayout()
        self.layoutV.addLayout(self.mode_layout)
        counter = 2
        for mode_option in self.scanArray_modes:
            self.mode_layout.addWidget(self.scanLayouts[mode_option[0]],counter,0,1,2)
            counter+=1
        self.setLayout(self.layoutV)
        
        self.mode_dropdown.currentIndexChanged.connect(self.changeScanMode)
        self.changeScanMode()

    def changeScanMode(self):
        &#34;&#34;&#34;
        Change the scan mode based on the selected index. - i.e. hide all non-chosen advScanGridLayouts and show the chosen one.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for groupbox in self.scanLayouts.values():
            groupbox.setVisible(False) #False
            
        try:
            self.scanLayouts[self.scanArray_modes[self.mode_dropdown.currentIndex()][0]].setVisible(True)
            
            self.currentMode = self.scanArray_modes[self.mode_dropdown.currentIndex()][0]
        except:
            pass

    def getPositionInfo(self):
        &#34;&#34;&#34;
        Get the position information of the chosen advScanGridLayout. (i.e. list of XY(Z) positions)
        
        Returns:
            The position information.
        &#34;&#34;&#34;
        return self.scanLayouts[self.scanArray_modes[self.mode_dropdown.currentIndex()][0]].getPositionInfo()
    
    
    def updateAllScans(self):
        &#34;&#34;&#34;
        Update all scannings in the scan layouts based on the internal stored data.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        for scanMode in self.scanLayouts:
            if scanMode == &#34;LoadPos&#34;:
                try:
                    self.scanLayouts[scanMode].lineEdit_posFilename.setText(self.scanLayouts[scanMode].scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;])
                except:
                    logging.debug(&#39;No fileName specified in scanMode loading&#39;)
        logging.debug(&#39;Updated all scan layouts&#39;)

    def assessScan(self):
        &#34;&#34;&#34;
        Return true or false whether or not the current scan will run normally or not
        &#34;&#34;&#34;
        assessment=False
        
        if self.scanMode == &#39;LoadPos&#39;:
            if self.scanLayouts[&#39;LoadPos&#39;].lineEdit_posFilename.text()[-4:] == &#39;.pos&#39;:
                assessment = True
        return assessment</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.ScanningWidget.assessScan"><code class="name flex">
<span>def <span class="ident">assessScan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true or false whether or not the current scan will run normally or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assessScan(self):
    &#34;&#34;&#34;
    Return true or false whether or not the current scan will run normally or not
    &#34;&#34;&#34;
    assessment=False
    
    if self.scanMode == &#39;LoadPos&#39;:
        if self.scanLayouts[&#39;LoadPos&#39;].lineEdit_posFilename.text()[-4:] == &#39;.pos&#39;:
            assessment = True
    return assessment</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.ScanningWidget.changeScanMode"><code class="name flex">
<span>def <span class="ident">changeScanMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the scan mode based on the selected index. - i.e. hide all non-chosen advScanGridLayouts and show the chosen one.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeScanMode(self):
    &#34;&#34;&#34;
    Change the scan mode based on the selected index. - i.e. hide all non-chosen advScanGridLayouts and show the chosen one.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    for groupbox in self.scanLayouts.values():
        groupbox.setVisible(False) #False
        
    try:
        self.scanLayouts[self.scanArray_modes[self.mode_dropdown.currentIndex()][0]].setVisible(True)
        
        self.currentMode = self.scanArray_modes[self.mode_dropdown.currentIndex()][0]
    except:
        pass</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.ScanningWidget.create_GUI"><code class="name flex">
<span>def <span class="ident">create_GUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create scanning widget GUI with mode dropdown and corresponding advScanGridLayout layouts.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_GUI(self):
    &#34;&#34;&#34;
    Create scanning widget GUI with mode dropdown and corresponding advScanGridLayout layouts.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    self.mode_dropdown = QComboBox()
    self.mode_dropdown.addItems([option[1] for option in self.scanArray_modes])
    self.mode_layout = QGridLayout()
    self.mode_layout.addWidget(QLabel(&#39;Mode: &#39;),0,0)
    self.mode_layout.addWidget(self.mode_dropdown,0,1)

    from PyQt5.QtWidgets import QHBoxLayout
    for mode_option in self.scanArray_modes:
        self.scanLayouts[mode_option[0]] = advScanGridLayout(mode=mode_option[0],parent=self)
        
        self.scanLayouts[mode_option[0]].setVisible(True) #False
    
    self.layoutV = QVBoxLayout()
    self.layoutV.addLayout(self.mode_layout)
    counter = 2
    for mode_option in self.scanArray_modes:
        self.mode_layout.addWidget(self.scanLayouts[mode_option[0]],counter,0,1,2)
        counter+=1
    self.setLayout(self.layoutV)
    
    self.mode_dropdown.currentIndexChanged.connect(self.changeScanMode)
    self.changeScanMode()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.ScanningWidget.getPositionInfo"><code class="name flex">
<span>def <span class="ident">getPositionInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the position information of the chosen advScanGridLayout. (i.e. list of XY(Z) positions)</p>
<h2 id="returns">Returns</h2>
<p>The position information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPositionInfo(self):
    &#34;&#34;&#34;
    Get the position information of the chosen advScanGridLayout. (i.e. list of XY(Z) positions)
    
    Returns:
        The position information.
    &#34;&#34;&#34;
    return self.scanLayouts[self.scanArray_modes[self.mode_dropdown.currentIndex()][0]].getPositionInfo()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.ScanningWidget.updateAllScans"><code class="name flex">
<span>def <span class="ident">updateAllScans</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update all scannings in the scan layouts based on the internal stored data.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateAllScans(self):
    &#34;&#34;&#34;
    Update all scannings in the scan layouts based on the internal stored data.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    for scanMode in self.scanLayouts:
        if scanMode == &#34;LoadPos&#34;:
            try:
                self.scanLayouts[scanMode].lineEdit_posFilename.setText(self.scanLayouts[scanMode].scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;])
            except:
                logging.debug(&#39;No fileName specified in scanMode loading&#39;)
    logging.debug(&#39;Updated all scan layouts&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.VariablesBase"><code class="flex name class">
<span>class <span class="ident">VariablesBase</span></span>
<span>(</span><span>nodzinstance:Â <a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget">GladosNodzFlowChart_dockWidget</a>, parent=None, doubleClickEffect=None, doubleClickLineEditChange=None, connectedNode_showOnlyDownstream=None, typeInfo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the variables of all nodz-instances, possibly filtered on connectedNodz only.</p>
<p>Initializes the scanning widget class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodzinstance</code></strong></dt>
<dd>The nodz instance to be associated with.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget.</dd>
<dt><strong><code>doubleClickEffect</code></strong></dt>
<dd>what you want to do if double-clicked. Options: None, 'updateLineEdit'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariablesBase(QWidget):
    &#34;&#34;&#34; 
    Show the variables of all nodz-instances, possibly filtered on connectedNodz only.
    &#34;&#34;&#34;
    def __init__(self, 
                nodzinstance:GladosNodzFlowChart_dockWidget,
                parent=None,
                doubleClickEffect=None,
                doubleClickLineEditChange=None,
                connectedNode_showOnlyDownstream=None,
                typeInfo=None):
        &#34;&#34;&#34;
        Initializes the scanning widget class.
        
        Args:
            nodzinstance: The nodz instance to be associated with.
            parent: The parent widget.
            doubleClickEffect: what you want to do if double-clicked. Options: None, &#39;updateLineEdit&#39;
            
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        # super().__init__()
        self.nodzinstance=nodzinstance
        
        if typeInfo is not None:
            #if typeInfo is not in an array, put it inside one
            if isinstance(typeInfo,type):
                typeInfo = [typeInfo]
            
            #Specifically check if there is a FLOAT type, but no INT type. If so, add the INT type as well
            hasFloatInt = [0,0]
            for typev in typeInfo:
                if typev == int:
                    hasFloatInt[1] = 1
                elif typev == float:
                    hasFloatInt[0] = 1
            if hasFloatInt == [1,0]:
                typeInfo.append(int)
                
        self.typeInfo = typeInfo
        
        self.create_GUI()
        
        return self
    
    def create_GUI(self):
        &#34;&#34;&#34;
        Create a QTableWidget GUI
        &#34;&#34;&#34;
        logging.debug(&#39;Inside variableswidget-createGUi&#39;)
        self.buttonTest = QPushButton(&#34;Update&#34;)
        self.buttonTest.clicked.connect(self.updateVariables)
        
        self.lineEditHover = QLabel(&#34;Hover over a Cell&#34;,self)
        self.lineEditHover.setEnabled(False)
        
        headers = [&#34;CellValue&#34;, &#34;Origin&#34;, &#34;Name&#34;, &#34;Value&#34;, &#34;Importance&#34;, &#34;Type&#34;, &#34;LastChanged&#34;]
        self.variablesTableWidget = HoverTableWidget()
        self.variablesTableWidget.setColumnCount(len(headers))
        self.variablesTableWidget.setHorizontalHeaderLabels(headers)
        
        # Connect the cellDoubleClicked signal to a custom slot
        self.variablesTableWidget.cellClicked.connect(self.on_cell_clicked)
        self.variablesTableWidget.cellDoubleClicked.connect(self.on_cell_double_clicked)
        self.variablesTableWidget.cellHovered.connect(self.on_cell_hovered)
        
        self.layoutV = QVBoxLayout()
        self.layoutV.addWidget(self.buttonTest)
        self.layoutV.addWidget(self.lineEditHover)
        self.layoutV.addWidget(self.variablesTableWidget)
        self.setLayout(self.layoutV)
        
    def on_cell_hovered(self, row, column):
        # Get the hovered entry
        try:
            #Specifically, get the origin Nodz
            hovered_entry = self.variablesTableWidget.item(row,1).text()# self.variablesTableWidget.item(row, column).text()
        except:
            hovered_entry = None
            
        #Loop over the nods in the nodzinstance:
        for node in self.nodzinstance.nodes:
            from PyQt5.QtWidgets import QGraphicsColorizeEffect, QGraphicsEffect, QGraphicsDropShadowEffect, QGraphicsView, QApplication
            if node.name == hovered_entry:                
                #Add a green shadow effect if it&#39;s the one hovered over.
                effect = QGraphicsDropShadowEffect()
                effect.setBlurRadius(60)
                effect.setColor(QColor(0, 200, 100, 230))
                effect.setOffset(0,0)

                node.setGraphicsEffect(effect)
            else:
                node.setGraphicsEffect(None)
                
        self.lineEditHover.setText(f&#34;Hovered: {hovered_entry}&#34;)

    def on_cell_clicked(self, row, column):
        self.selected_entry = []
        for col in range(self.variablesTableWidget.columnCount()):
            textEntry = &#39;&#39;
            try:
                textEntry = self.variablesTableWidget.item(row, col).text()
            except AttributeError:
                textEntry = &#39;None&#39;
            self.selected_entry.append(textEntry)
        
        import pyperclip
        copystr = f&#39;{self.selected_entry[2]}@{self.selected_entry[1]}&#39;
        pyperclip.copy(copystr)
        
            
    def on_cell_double_clicked(self, row, column):
        #Figure out the selected row
        self.selected_entry = []
        for col in range(self.variablesTableWidget.columnCount()):
            textEntry = &#39;&#39;
            try:
                textEntry = self.variablesTableWidget.item(row, col).text()
            except AttributeError:
                textEntry = &#39;None&#39;
            self.selected_entry.append(textEntry)
    
    def get_selected_entry(self):
        return getattr(self, &#39;selected_entry&#39;, None)
    
    def updateVariables(self):
        &#34;&#34;&#34;
        Update the nodz-variables.
        &#34;&#34;&#34;
        
        self.nodzinstance.updateCoreVariables()
        
        allvariableData = {}
        #Add all global variables
        for var in self.nodzinstance.globalVariables:
            pos = len(allvariableData)
            correctTyping = False
            if self.typeInfo is not None:
                variableTypes = self.nodzinstance.globalVariables[var][&#39;type&#39;]
                if isinstance(variableTypes,type):
                    variableTypes = [variableTypes]
                if isinstance(self.typeInfo,type):
                    self.typeInfo = [self.typeInfo]
                
                for variableType in variableTypes:
                    for selftype in self.typeInfo:
                        if variableType == selftype:
                            correctTyping = True
            else: #if no typing specified, accept everything
                correctTyping = True
            
            if correctTyping:
                allvariableData[pos] = self.nodzinstance.globalVariables[var]
                allvariableData[pos][&#39;NodeOrigin&#39;] = &#39;Global&#39;
                allvariableData[pos][&#39;VariableName&#39;] = var
            
        #Add all core variables
        for var in self.nodzinstance.coreVariables:
            pos = len(allvariableData)
            correctTyping = False
            if self.typeInfo is not None:
                variableTypes = self.nodzinstance.coreVariables[var][&#39;type&#39;]
                if isinstance(variableTypes,type):
                    variableTypes = [variableTypes]
                if isinstance(self.typeInfo,type):
                    self.typeInfo = [self.typeInfo]
                
                for variableType in variableTypes:
                    for selftype in self.typeInfo:
                        if variableType == selftype:
                            correctTyping = True
            else: #if no typing specified, accept everything
                correctTyping = True
            
            if correctTyping:
                allvariableData[pos] = self.nodzinstance.coreVariables[var]
                allvariableData[pos][&#39;NodeOrigin&#39;] = &#39;Core&#39;
                allvariableData[pos][&#39;VariableName&#39;] = var
            
        #Add all variables of all nodes
        allNodes = self.nodzinstance.obtainAllNodes()
        
        for node in allNodes:
            for var in node.variablesNodz:
                pos = len(allvariableData)
                correctTyping = False
                if self.typeInfo is not None:
                    variableTypes = node.variablesNodz[var][&#39;type&#39;]
                    if isinstance(variableTypes,type):
                        variableTypes = [variableTypes]
                    if isinstance(self.typeInfo,type):
                        self.typeInfo = [self.typeInfo]
                    
                    for variableType in variableTypes:
                        for selftype in self.typeInfo:
                            if variableType == selftype:
                                correctTyping = True
                else: #if no typing specified, accept everything
                    correctTyping = True
                
                if correctTyping:
                    allvariableData[pos] = node.variablesNodz[var]
                    allvariableData[pos][&#39;NodeOrigin&#39;] = node.name
                    allvariableData[pos][&#39;VariableName&#39;] = var
            
        
        # Set the number of rows
        self.variablesTableWidget.setRowCount(len(allvariableData))

        from PyQt5.QtWidgets import QTableWidgetItem
        from datetime import datetime
        # Fill the table with data
        for row_id in range(len(allvariableData)):
            varData = allvariableData[row_id]
            # headers = [&#34;CellValue&#34;, &#34;Origin&#34;, &#34;Name&#34;, &#34;Value&#34;, &#34;Importance&#34;,&#34;Type&#34;, &#34;LastChanged&#34;]
            self.variablesTableWidget.setItem(row_id, 1, QTableWidgetItem(str(varData[&#39;NodeOrigin&#39;])))
            self.variablesTableWidget.setItem(row_id, 2, QTableWidgetItem(str(varData[&#39;VariableName&#39;])))
            self.variablesTableWidget.setItem(row_id, 3, QTableWidgetItem(str(varData[&#39;data&#39;])))
            self.variablesTableWidget.setItem(row_id, 4, QTableWidgetItem(str(varData[&#39;importance&#39;])))
            self.variablesTableWidget.setItem(row_id, 5, QTableWidgetItem(str(varData[&#39;type&#39;])))
            if &#39;lastUpdateTime&#39; in varData and varData[&#39;lastUpdateTime&#39;] is not None:
                self.variablesTableWidget.setItem(row_id, 6, QTableWidgetItem(str(datetime.fromtimestamp(varData[&#39;lastUpdateTime&#39;]).strftime(&#34;%H:%M:%S %d-%m-%Y&#34;))))
            else:
                self.variablesTableWidget.setItem(row_id, 6, QTableWidgetItem(&#39;None&#39;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.VariablesDialog" href="#FlowChart_dockWidgets.VariablesDialog">VariablesDialog</a></li>
<li><a title="FlowChart_dockWidgets.VariablesWidget" href="#FlowChart_dockWidgets.VariablesWidget">VariablesWidget</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.VariablesBase.create_GUI"><code class="name flex">
<span>def <span class="ident">create_GUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a QTableWidget GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_GUI(self):
    &#34;&#34;&#34;
    Create a QTableWidget GUI
    &#34;&#34;&#34;
    logging.debug(&#39;Inside variableswidget-createGUi&#39;)
    self.buttonTest = QPushButton(&#34;Update&#34;)
    self.buttonTest.clicked.connect(self.updateVariables)
    
    self.lineEditHover = QLabel(&#34;Hover over a Cell&#34;,self)
    self.lineEditHover.setEnabled(False)
    
    headers = [&#34;CellValue&#34;, &#34;Origin&#34;, &#34;Name&#34;, &#34;Value&#34;, &#34;Importance&#34;, &#34;Type&#34;, &#34;LastChanged&#34;]
    self.variablesTableWidget = HoverTableWidget()
    self.variablesTableWidget.setColumnCount(len(headers))
    self.variablesTableWidget.setHorizontalHeaderLabels(headers)
    
    # Connect the cellDoubleClicked signal to a custom slot
    self.variablesTableWidget.cellClicked.connect(self.on_cell_clicked)
    self.variablesTableWidget.cellDoubleClicked.connect(self.on_cell_double_clicked)
    self.variablesTableWidget.cellHovered.connect(self.on_cell_hovered)
    
    self.layoutV = QVBoxLayout()
    self.layoutV.addWidget(self.buttonTest)
    self.layoutV.addWidget(self.lineEditHover)
    self.layoutV.addWidget(self.variablesTableWidget)
    self.setLayout(self.layoutV)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.VariablesBase.get_selected_entry"><code class="name flex">
<span>def <span class="ident">get_selected_entry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selected_entry(self):
    return getattr(self, &#39;selected_entry&#39;, None)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.VariablesBase.on_cell_clicked"><code class="name flex">
<span>def <span class="ident">on_cell_clicked</span></span>(<span>self, row, column)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_cell_clicked(self, row, column):
    self.selected_entry = []
    for col in range(self.variablesTableWidget.columnCount()):
        textEntry = &#39;&#39;
        try:
            textEntry = self.variablesTableWidget.item(row, col).text()
        except AttributeError:
            textEntry = &#39;None&#39;
        self.selected_entry.append(textEntry)
    
    import pyperclip
    copystr = f&#39;{self.selected_entry[2]}@{self.selected_entry[1]}&#39;
    pyperclip.copy(copystr)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.VariablesBase.on_cell_double_clicked"><code class="name flex">
<span>def <span class="ident">on_cell_double_clicked</span></span>(<span>self, row, column)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_cell_double_clicked(self, row, column):
    #Figure out the selected row
    self.selected_entry = []
    for col in range(self.variablesTableWidget.columnCount()):
        textEntry = &#39;&#39;
        try:
            textEntry = self.variablesTableWidget.item(row, col).text()
        except AttributeError:
            textEntry = &#39;None&#39;
        self.selected_entry.append(textEntry)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.VariablesBase.on_cell_hovered"><code class="name flex">
<span>def <span class="ident">on_cell_hovered</span></span>(<span>self, row, column)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_cell_hovered(self, row, column):
    # Get the hovered entry
    try:
        #Specifically, get the origin Nodz
        hovered_entry = self.variablesTableWidget.item(row,1).text()# self.variablesTableWidget.item(row, column).text()
    except:
        hovered_entry = None
        
    #Loop over the nods in the nodzinstance:
    for node in self.nodzinstance.nodes:
        from PyQt5.QtWidgets import QGraphicsColorizeEffect, QGraphicsEffect, QGraphicsDropShadowEffect, QGraphicsView, QApplication
        if node.name == hovered_entry:                
            #Add a green shadow effect if it&#39;s the one hovered over.
            effect = QGraphicsDropShadowEffect()
            effect.setBlurRadius(60)
            effect.setColor(QColor(0, 200, 100, 230))
            effect.setOffset(0,0)

            node.setGraphicsEffect(effect)
        else:
            node.setGraphicsEffect(None)
            
    self.lineEditHover.setText(f&#34;Hovered: {hovered_entry}&#34;)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.VariablesBase.updateVariables"><code class="name flex">
<span>def <span class="ident">updateVariables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the nodz-variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateVariables(self):
    &#34;&#34;&#34;
    Update the nodz-variables.
    &#34;&#34;&#34;
    
    self.nodzinstance.updateCoreVariables()
    
    allvariableData = {}
    #Add all global variables
    for var in self.nodzinstance.globalVariables:
        pos = len(allvariableData)
        correctTyping = False
        if self.typeInfo is not None:
            variableTypes = self.nodzinstance.globalVariables[var][&#39;type&#39;]
            if isinstance(variableTypes,type):
                variableTypes = [variableTypes]
            if isinstance(self.typeInfo,type):
                self.typeInfo = [self.typeInfo]
            
            for variableType in variableTypes:
                for selftype in self.typeInfo:
                    if variableType == selftype:
                        correctTyping = True
        else: #if no typing specified, accept everything
            correctTyping = True
        
        if correctTyping:
            allvariableData[pos] = self.nodzinstance.globalVariables[var]
            allvariableData[pos][&#39;NodeOrigin&#39;] = &#39;Global&#39;
            allvariableData[pos][&#39;VariableName&#39;] = var
        
    #Add all core variables
    for var in self.nodzinstance.coreVariables:
        pos = len(allvariableData)
        correctTyping = False
        if self.typeInfo is not None:
            variableTypes = self.nodzinstance.coreVariables[var][&#39;type&#39;]
            if isinstance(variableTypes,type):
                variableTypes = [variableTypes]
            if isinstance(self.typeInfo,type):
                self.typeInfo = [self.typeInfo]
            
            for variableType in variableTypes:
                for selftype in self.typeInfo:
                    if variableType == selftype:
                        correctTyping = True
        else: #if no typing specified, accept everything
            correctTyping = True
        
        if correctTyping:
            allvariableData[pos] = self.nodzinstance.coreVariables[var]
            allvariableData[pos][&#39;NodeOrigin&#39;] = &#39;Core&#39;
            allvariableData[pos][&#39;VariableName&#39;] = var
        
    #Add all variables of all nodes
    allNodes = self.nodzinstance.obtainAllNodes()
    
    for node in allNodes:
        for var in node.variablesNodz:
            pos = len(allvariableData)
            correctTyping = False
            if self.typeInfo is not None:
                variableTypes = node.variablesNodz[var][&#39;type&#39;]
                if isinstance(variableTypes,type):
                    variableTypes = [variableTypes]
                if isinstance(self.typeInfo,type):
                    self.typeInfo = [self.typeInfo]
                
                for variableType in variableTypes:
                    for selftype in self.typeInfo:
                        if variableType == selftype:
                            correctTyping = True
            else: #if no typing specified, accept everything
                correctTyping = True
            
            if correctTyping:
                allvariableData[pos] = node.variablesNodz[var]
                allvariableData[pos][&#39;NodeOrigin&#39;] = node.name
                allvariableData[pos][&#39;VariableName&#39;] = var
        
    
    # Set the number of rows
    self.variablesTableWidget.setRowCount(len(allvariableData))

    from PyQt5.QtWidgets import QTableWidgetItem
    from datetime import datetime
    # Fill the table with data
    for row_id in range(len(allvariableData)):
        varData = allvariableData[row_id]
        # headers = [&#34;CellValue&#34;, &#34;Origin&#34;, &#34;Name&#34;, &#34;Value&#34;, &#34;Importance&#34;,&#34;Type&#34;, &#34;LastChanged&#34;]
        self.variablesTableWidget.setItem(row_id, 1, QTableWidgetItem(str(varData[&#39;NodeOrigin&#39;])))
        self.variablesTableWidget.setItem(row_id, 2, QTableWidgetItem(str(varData[&#39;VariableName&#39;])))
        self.variablesTableWidget.setItem(row_id, 3, QTableWidgetItem(str(varData[&#39;data&#39;])))
        self.variablesTableWidget.setItem(row_id, 4, QTableWidgetItem(str(varData[&#39;importance&#39;])))
        self.variablesTableWidget.setItem(row_id, 5, QTableWidgetItem(str(varData[&#39;type&#39;])))
        if &#39;lastUpdateTime&#39; in varData and varData[&#39;lastUpdateTime&#39;] is not None:
            self.variablesTableWidget.setItem(row_id, 6, QTableWidgetItem(str(datetime.fromtimestamp(varData[&#39;lastUpdateTime&#39;]).strftime(&#34;%H:%M:%S %d-%m-%Y&#34;))))
        else:
            self.variablesTableWidget.setItem(row_id, 6, QTableWidgetItem(&#39;None&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.VariablesDialog"><code class="flex name class">
<span>class <span class="ident">VariablesDialog</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>QDialog(parent: typing.Optional[QWidget] = None, flags: Union[Qt.WindowFlags, Qt.WindowType] = Qt.WindowFlags())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariablesDialog(QDialog, VariablesBase):
    def __init__(self, *args, **kwargs):
        QDialog.__init__(self)
        variablesWidget = VariablesBase.__init__(self, *args, **kwargs)
        self.setWindowTitle(&#34;Variables Dialog&#34;)
        #Create a container layout:
        # layout = QVBoxLayout()
        
        
        # Set font size for all items in the table
        font = QFont()
        font.setPointSize(7)  # Set the desired font size
        variablesWidget.variablesTableWidget.setFont(font)

        # Set font size for headers
        header_font = QFont()
        header_font.setPointSize(10)  # Set the desired font size for headers
        variablesWidget.variablesTableWidget.horizontalHeader().setFont(header_font)
        variablesWidget.variablesTableWidget.verticalHeader().setFont(header_font)
        
        from PyQt5.QtWidgets import QApplication, QTableWidget, QTableWidgetItem, QHeaderView

        # Make the table more compact
        variablesWidget.variablesTableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        variablesWidget.variablesTableWidget.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)
        variablesWidget.variablesTableWidget.verticalHeader().setDefaultSectionSize(25)  # Set the default height of each row

        
        #Update the variables
        variablesWidget.updateVariables()
        self.layout().addWidget(variablesWidget)
        
        
        
        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        
        # Add button box to the layout
        self.layout().addWidget(self.buttonBox)
        self.setMinimumSize(300,300)
        self.setBaseSize(300,300)
        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding)
        
    def on_cell_double_clicked(self, row, column):
        super().on_cell_double_clicked(row, column)
        #remove hover-effect
        self.variablesTableWidget.cellHovered.emit(-1, -1)
        self.accept()  # Close the dialog with the Accepted result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li><a title="FlowChart_dockWidgets.VariablesBase" href="#FlowChart_dockWidgets.VariablesBase">VariablesBase</a></li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.VariablesDialog.on_cell_double_clicked"><code class="name flex">
<span>def <span class="ident">on_cell_double_clicked</span></span>(<span>self, row, column)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_cell_double_clicked(self, row, column):
    super().on_cell_double_clicked(row, column)
    #remove hover-effect
    self.variablesTableWidget.cellHovered.emit(-1, -1)
    self.accept()  # Close the dialog with the Accepted result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="FlowChart_dockWidgets.VariablesBase" href="#FlowChart_dockWidgets.VariablesBase">VariablesBase</a></b></code>:
<ul class="hlist">
<li><code><a title="FlowChart_dockWidgets.VariablesBase.create_GUI" href="#FlowChart_dockWidgets.VariablesBase.create_GUI">create_GUI</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.updateVariables" href="#FlowChart_dockWidgets.VariablesBase.updateVariables">updateVariables</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.VariablesWidget"><code class="flex name class">
<span>class <span class="ident">VariablesWidget</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the variables of all nodz-instances, possibly filtered on connectedNodz only.</p>
<p>Initializes the scanning widget class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>nodzinstance</code></strong></dt>
<dd>The nodz instance to be associated with.</dd>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget.</dd>
<dt><strong><code>doubleClickEffect</code></strong></dt>
<dd>what you want to do if double-clicked. Options: None, 'updateLineEdit'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VariablesWidget(VariablesBase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.VariablesBase" href="#FlowChart_dockWidgets.VariablesBase">VariablesBase</a></li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="FlowChart_dockWidgets.VariablesBase" href="#FlowChart_dockWidgets.VariablesBase">VariablesBase</a></b></code>:
<ul class="hlist">
<li><code><a title="FlowChart_dockWidgets.VariablesBase.create_GUI" href="#FlowChart_dockWidgets.VariablesBase.create_GUI">create_GUI</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.updateVariables" href="#FlowChart_dockWidgets.VariablesBase.updateVariables">updateVariables</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.WorkerSignals"><code class="flex name class">
<span>class <span class="ident">WorkerSignals</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Signals belonging to generalNodzCallActionWorker</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WorkerSignals(QObject):
    &#34;&#34;&#34;  
    Signals belonging to generalNodzCallActionWorker
    &#34;&#34;&#34;
    finished = pyqtSignal()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.WorkerSignals.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout"><code class="flex name class">
<span>class <span class="ident">advDecisionGridLayout</span></span>
<span>(</span><span>mode=None, decision=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>advDecisionGridLayout each individually handle a single method of decision. Easiest example is DirectDecision mode with 'AND_SCORE' decision.
Each layout requires a MODE and a DECISION, where the MODE is one of four options (DirectDecision, fullscan, randomscan, stayonfov) &ndash;&gt; see ScanningWidget init, and the DECISION is more flexible (i.e. 'all scores are passed', or 'at least 1 score is passed' in the DirectDecision mode)
The advDecisionGridLayout are created in the DecisionWidget class
Currently implemented:
'DirectDecision' &ndash;&gt; 'AND_Score': Checks if all scores are passed.
'DirectDecision' &ndash;&gt; 'AND_Score_VAR': Checks if all scores, based on variables, are passed.</p>
<p>Initialize the class with the provided mode, decision, and parent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode to be set for the instance.</dd>
<dt><strong><code>decision</code></strong> :&ensp;<code>str</code></dt>
<dd>The decision to be set for the instance.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>object</code></dt>
<dd>The parent object associated with this instance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class advDecisionGridLayout(QGroupBox):
    &#34;&#34;&#34; 
    advDecisionGridLayout each individually handle a single method of decision. Easiest example is DirectDecision mode with &#39;AND_SCORE&#39; decision.
    Each layout requires a MODE and a DECISION, where the MODE is one of four options (DirectDecision, fullscan, randomscan, stayonfov) --&gt; see ScanningWidget init, and the DECISION is more flexible (i.e. &#39;all scores are passed&#39;, or &#39;at least 1 score is passed&#39; in the DirectDecision mode)
    The advDecisionGridLayout are created in the DecisionWidget class
    Currently implemented:
        &#39;DirectDecision&#39; --&gt; &#39;AND_Score&#39;: Checks if all scores are passed.
        &#39;DirectDecision&#39; --&gt; &#39;AND_Score_VAR&#39;: Checks if all scores, based on variables, are passed.
    &#34;&#34;&#34;
    def __init__(self, mode=None,decision=None,parent=None):
        &#34;&#34;&#34;
        Initialize the class with the provided mode, decision, and parent.
        
        Args:
            mode (str): The mode to be set for the instance.
            decision (str): The decision to be set for the instance.
            parent (object): The parent object associated with this instance.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.parent = parent #type:ignore
        super().__init__(parent)
        self.mode = mode
        self.decision = decision
        self.decisionInfoGUI = {} #Will finally contain all decision info in GUI form!
        self.decisionInfoGUIVAR = {} #Will finally contain all decision info in GUI form!
        #Create a QGridLayout to place in this groupbox:
        self.setLayout(QGridLayout())
        #Create a quick label that we place in 1,1:
        self.layout().addWidget(QLabel(f&#34;{mode} and {decision}&#34;,self),1,1) #type:ignore
        if mode == &#39;DirectDecision&#39;:
            if decision == &#39;AND_Score&#39;:
                self.directDecision_AND_Score_update()
            elif decision == &#39;AND_Score_VAR&#39;:
                self.directDecision_AND_Score_VAR_update()
    
    def update(self):
        &#34;&#34;&#34;
        Update the object based on the current mode and decision.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        if self.mode == &#39;DirectDecision&#39;:
            if self.decision == &#39;AND_Score&#39;:
                self.directDecision_AND_Score_update()
            elif self.decision == &#39;AND_Score_VAR&#39;:
                self.directDecision_AND_Score_VAR_update()
    
    def test_decision(self):
        &#34;&#34;&#34;
        Make a decision based on the mode and decision type. Should always output a boolean
        
        Args:
            mode (str): The mode of decision making.
            decision (str): The type of decision to be made.
        
        Returns:
            str: The result of the decision making process.
        &#34;&#34;&#34;
        if self.mode == &#39;DirectDecision&#39;:
            if self.decision == &#39;AND_Score&#39;:
                return self.directDecision_AND_Score_test()
            if self.decision == &#39;AND_Score_VAR&#39;:
                return self.directDecision_AND_Score_VAR_test()
    
    def getScoreMetrics(self):
        &#34;&#34;&#34;
        Get the score metrics from the scoringEnd node.
        
        Args:
            None
        
        Returns:
            list: A list of score metrics (i.e. sockets of score node).
        &#34;&#34;&#34;
        scoreMetrics = []
        #Get all score metrics (i.e. sockets of score node)
        flowChart = self.parent.nodzinstance
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringEnd_&#39; in node.name:
                    break
            
            #Now get the scores from here:
            for socket in node.sockets:
                scoreMetrics.append(socket)
        return scoreMetrics
    
    def remove_widgets_in_layout(self,layout):
        &#34;&#34;&#34;
        Removes all widgets in the given layout recursively.
        
        Args:
            layout: The layout from which widgets will be removed.
        
        Returns:
            None
        &#34;&#34;&#34;
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            if widget is not None:
                widget.deleteLater()
            elif item.layout() is not None:
                self.remove_widgets_in_layout(item.layout())
    
    def directDecision_AND_Score_test(self):
        &#34;&#34;&#34;
        Code to test whether the current score passes the decision matrix or not. Should always output a boolean
        &#34;&#34;&#34;
        finalTest = False
        scoreMetrics = self.getScoreMetrics()
        
        #Get all score metrics (i.e. sockets of score node)
        flowChart = self.parent.nodzinstance
        if len(flowChart.nodes) &gt; 0:
            #Find the scoringEnd node in flowChart:
            for node in flowChart.nodes:
                if &#39;scoringEnd_&#39; in node.name:
                    break
        
        #Find the nodes that are connected downstream of this:
        data = {}
        for attr in node.attrs:
            connectedNode = None
            for connection in flowChart.evaluateGraph():
                if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == attr:
                    if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                        connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                        connectedNode = flowChart.findNodeByName(connectedNodeName)
        
                    data[attr] = connectedNode.scoring_analysis_currentData[&#39;__output__&#39;] #type:ignore
        
        #Data now contains the values of the scores
        self.decisionInfoGUI
        scoreMetric = &#39;ScoreA&#39;
        indivBooleans = {}
        for scoreMetric in scoreMetrics:
            hbox = self.decisionInfoGUI[scoreMetric]
            operator = hbox[&#39;dropdown&#39;].currentText()
            value = hbox[&#39;lineedit&#39;].text()
            
            if eval(f&#34;{data[scoreMetric]} {operator} {value}&#34;):
                indivBooleans[scoreMetric] = True
            else:
                indivBooleans[scoreMetric] = False
        
        if all(indivBooleans.values()):
            finalTest = True
        
        return finalTest
    
    def directDecision_AND_Score_update(self):
        &#34;&#34;&#34;
        Code to update the GUI of the DirectDecision_AND_Score groupbox
        &#34;&#34;&#34;
        from PyQt5.QtWidgets import QComboBox, QHBoxLayout, QLabel, QLineEdit, QPushButton
        self.remove_widgets_in_layout(self.layout())
        
        self.outerLayout = QVBoxLayout()
        self.layout().addLayout(self.outerLayout,0,0) #type:ignore
        
        #Get out of this function if flowChart isn&#39;t initialised yet (i.e. first start-up):
        try:
            self.parent.nodzinstance.nodes
        except RuntimeError:
            return
        
        scoreMetrics = self.getScoreMetrics()
        
        for scoreMetric in scoreMetrics:
            hbox = QHBoxLayout()
            label = QLabel(scoreMetric)
            hbox.addWidget(label)
            dropdown = QComboBox()
            dropdown.addItems([&#39;&gt;&#39;,&#39;&gt;=&#39;,&#39;==&#39;,&#39;&lt;=&#39;,&#39;&lt;&#39;,&#39;!=&#39;])
            hbox.addWidget(dropdown)
            lineedit = QLineEdit()
            hbox.addWidget(lineedit)
            self.decisionInfoGUI[scoreMetric] = {}
            self.decisionInfoGUI[scoreMetric][&#39;dropdown&#39;] = dropdown
            self.decisionInfoGUI[scoreMetric][&#39;lineedit&#39;] = lineedit
            self.outerLayout.addLayout(hbox)
    
    def directDecision_AND_Score_VAR_test(self):
        &#34;&#34;&#34;
        Code to test whether the current score passes the decision matrix or not. Should always output a boolean
        &#34;&#34;&#34;
        finalTest = False
        #Data now contains the values of the scores
        self.decisionInfoGUIVAR
        
        totalTrueTests = 0
        requiredTrueTests = 0
        for decision in self.decisionInfoGUIVAR:
            if self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text() != &#39;&#39;:
                requiredTrueTests+=1
                logging.debug(self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text())
                
                #We get the value of the variable:
                varCurrentValue = utils.nodz_evaluateVar(self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text(),self.parent.nodzinstance)
                
                operator = self.decisionInfoGUIVAR[decision][&#39;dropdown&#39;].currentText()
                varTestValue = self.decisionInfoGUIVAR[decision][&#39;lineedit&#39;].text()
                
                varcurrentvalEvaluable = False
                try:
                    eval(f&#34;{varCurrentValue}&#34;)
                    varcurrentvalEvaluable = True
                except:
                    varcurrentvalEvaluable = False
                    
                vartestvalEvaluable = False
                try:
                    eval(f&#34;{varTestValue}&#34;)
                    vartestvalEvaluable = True
                except:
                    vartestvalEvaluable = False
                    
                if not varcurrentvalEvaluable and not vartestvalEvaluable:
                    evalText = f&#34;&#39;{varCurrentValue}&#39; {operator} &#39;{varTestValue}&#39;&#34;
                elif varcurrentvalEvaluable and not vartestvalEvaluable:
                    evalText = f&#34;{varCurrentValue} {operator} &#39;{varTestValue}&#39;&#34;
                elif not varcurrentvalEvaluable and vartestvalEvaluable:
                    evalText = f&#34;&#39;{varCurrentValue}&#39; {operator} {varTestValue}&#34;
                else:
                    evalText = f&#34;{varCurrentValue} {operator} {varTestValue}&#34;
                
                logging.debug(evalText)
                
                if eval(evalText):
                    totalTrueTests+=1
        
        if totalTrueTests == requiredTrueTests:
            finalTest = True
        
        return finalTest
    
    def directDecision_AND_Score_VAR_update(self):
        &#34;&#34;&#34;
        Code to update the GUI of the DirectDecision_AND_Score groupbox
        &#34;&#34;&#34;
        from PyQt5.QtWidgets import QComboBox, QHBoxLayout, QLabel, QLineEdit, QPushButton
        self.remove_widgets_in_layout(self.layout())
        
        self.outerLayout = QVBoxLayout()
        self.layout().addLayout(self.outerLayout,0,0) #type:ignore
        
        #Get out of this function if flowChart isn&#39;t initialised yet (i.e. first start-up):
        try:
            self.parent.nodzinstance.nodes
        except RuntimeError:
            return
        
        n_score_metrics = 5
        
        for n in range(n_score_metrics):
            hbox = QHBoxLayout()
            label = QLabel(str(n+1)+&#39;:&#39;)
            hbox.addWidget(label)
            
            varName = QLineEdit()
            varName.setObjectName(&#39;directDecision_AND_Score_VAR__varName_&#39;+str(n+1))
            hbox.addWidget(varName)
            
            dropdown = QComboBox()
            dropdown.addItems([&#39;&gt;&#39;,&#39;&gt;=&#39;,&#39;==&#39;,&#39;&lt;=&#39;,&#39;&lt;&#39;,&#39;!=&#39;])
            dropdown.setObjectName(&#39;directDecision_AND_Score_VAR__dropdown_&#39;+str(n+1))
            hbox.addWidget(dropdown)
            lineedit = QLineEdit()
            lineedit.setObjectName(&#39;directDecision_AND_Score_VAR__lineedit_&#39;+str(n+1))
            hbox.addWidget(lineedit)
            self.decisionInfoGUIVAR[n] = {}
            self.decisionInfoGUIVAR[n][&#39;varName&#39;] = varName
            self.decisionInfoGUIVAR[n][&#39;dropdown&#39;] = dropdown
            self.decisionInfoGUIVAR[n][&#39;lineedit&#39;] = lineedit
            self.outerLayout.addLayout(hbox)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_VAR_test"><code class="name flex">
<span>def <span class="ident">directDecision_AND_Score_VAR_test</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Code to test whether the current score passes the decision matrix or not. Should always output a boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def directDecision_AND_Score_VAR_test(self):
    &#34;&#34;&#34;
    Code to test whether the current score passes the decision matrix or not. Should always output a boolean
    &#34;&#34;&#34;
    finalTest = False
    #Data now contains the values of the scores
    self.decisionInfoGUIVAR
    
    totalTrueTests = 0
    requiredTrueTests = 0
    for decision in self.decisionInfoGUIVAR:
        if self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text() != &#39;&#39;:
            requiredTrueTests+=1
            logging.debug(self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text())
            
            #We get the value of the variable:
            varCurrentValue = utils.nodz_evaluateVar(self.decisionInfoGUIVAR[decision][&#39;varName&#39;].text(),self.parent.nodzinstance)
            
            operator = self.decisionInfoGUIVAR[decision][&#39;dropdown&#39;].currentText()
            varTestValue = self.decisionInfoGUIVAR[decision][&#39;lineedit&#39;].text()
            
            varcurrentvalEvaluable = False
            try:
                eval(f&#34;{varCurrentValue}&#34;)
                varcurrentvalEvaluable = True
            except:
                varcurrentvalEvaluable = False
                
            vartestvalEvaluable = False
            try:
                eval(f&#34;{varTestValue}&#34;)
                vartestvalEvaluable = True
            except:
                vartestvalEvaluable = False
                
            if not varcurrentvalEvaluable and not vartestvalEvaluable:
                evalText = f&#34;&#39;{varCurrentValue}&#39; {operator} &#39;{varTestValue}&#39;&#34;
            elif varcurrentvalEvaluable and not vartestvalEvaluable:
                evalText = f&#34;{varCurrentValue} {operator} &#39;{varTestValue}&#39;&#34;
            elif not varcurrentvalEvaluable and vartestvalEvaluable:
                evalText = f&#34;&#39;{varCurrentValue}&#39; {operator} {varTestValue}&#34;
            else:
                evalText = f&#34;{varCurrentValue} {operator} {varTestValue}&#34;
            
            logging.debug(evalText)
            
            if eval(evalText):
                totalTrueTests+=1
    
    if totalTrueTests == requiredTrueTests:
        finalTest = True
    
    return finalTest</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_VAR_update"><code class="name flex">
<span>def <span class="ident">directDecision_AND_Score_VAR_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Code to update the GUI of the DirectDecision_AND_Score groupbox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def directDecision_AND_Score_VAR_update(self):
    &#34;&#34;&#34;
    Code to update the GUI of the DirectDecision_AND_Score groupbox
    &#34;&#34;&#34;
    from PyQt5.QtWidgets import QComboBox, QHBoxLayout, QLabel, QLineEdit, QPushButton
    self.remove_widgets_in_layout(self.layout())
    
    self.outerLayout = QVBoxLayout()
    self.layout().addLayout(self.outerLayout,0,0) #type:ignore
    
    #Get out of this function if flowChart isn&#39;t initialised yet (i.e. first start-up):
    try:
        self.parent.nodzinstance.nodes
    except RuntimeError:
        return
    
    n_score_metrics = 5
    
    for n in range(n_score_metrics):
        hbox = QHBoxLayout()
        label = QLabel(str(n+1)+&#39;:&#39;)
        hbox.addWidget(label)
        
        varName = QLineEdit()
        varName.setObjectName(&#39;directDecision_AND_Score_VAR__varName_&#39;+str(n+1))
        hbox.addWidget(varName)
        
        dropdown = QComboBox()
        dropdown.addItems([&#39;&gt;&#39;,&#39;&gt;=&#39;,&#39;==&#39;,&#39;&lt;=&#39;,&#39;&lt;&#39;,&#39;!=&#39;])
        dropdown.setObjectName(&#39;directDecision_AND_Score_VAR__dropdown_&#39;+str(n+1))
        hbox.addWidget(dropdown)
        lineedit = QLineEdit()
        lineedit.setObjectName(&#39;directDecision_AND_Score_VAR__lineedit_&#39;+str(n+1))
        hbox.addWidget(lineedit)
        self.decisionInfoGUIVAR[n] = {}
        self.decisionInfoGUIVAR[n][&#39;varName&#39;] = varName
        self.decisionInfoGUIVAR[n][&#39;dropdown&#39;] = dropdown
        self.decisionInfoGUIVAR[n][&#39;lineedit&#39;] = lineedit
        self.outerLayout.addLayout(hbox)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_test"><code class="name flex">
<span>def <span class="ident">directDecision_AND_Score_test</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Code to test whether the current score passes the decision matrix or not. Should always output a boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def directDecision_AND_Score_test(self):
    &#34;&#34;&#34;
    Code to test whether the current score passes the decision matrix or not. Should always output a boolean
    &#34;&#34;&#34;
    finalTest = False
    scoreMetrics = self.getScoreMetrics()
    
    #Get all score metrics (i.e. sockets of score node)
    flowChart = self.parent.nodzinstance
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;scoringEnd_&#39; in node.name:
                break
    
    #Find the nodes that are connected downstream of this:
    data = {}
    for attr in node.attrs:
        connectedNode = None
        for connection in flowChart.evaluateGraph():
            if connection[1][connection[1].rfind(&#39;.&#39;)+1:] == attr:
                if connection[1][:connection[1].rfind(&#39;.&#39;)] == node.name:
                    connectedNodeName = connection[0][:connection[0].rfind(&#39;.&#39;)]
                    connectedNode = flowChart.findNodeByName(connectedNodeName)
    
                data[attr] = connectedNode.scoring_analysis_currentData[&#39;__output__&#39;] #type:ignore
    
    #Data now contains the values of the scores
    self.decisionInfoGUI
    scoreMetric = &#39;ScoreA&#39;
    indivBooleans = {}
    for scoreMetric in scoreMetrics:
        hbox = self.decisionInfoGUI[scoreMetric]
        operator = hbox[&#39;dropdown&#39;].currentText()
        value = hbox[&#39;lineedit&#39;].text()
        
        if eval(f&#34;{data[scoreMetric]} {operator} {value}&#34;):
            indivBooleans[scoreMetric] = True
        else:
            indivBooleans[scoreMetric] = False
    
    if all(indivBooleans.values()):
        finalTest = True
    
    return finalTest</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_update"><code class="name flex">
<span>def <span class="ident">directDecision_AND_Score_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Code to update the GUI of the DirectDecision_AND_Score groupbox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def directDecision_AND_Score_update(self):
    &#34;&#34;&#34;
    Code to update the GUI of the DirectDecision_AND_Score groupbox
    &#34;&#34;&#34;
    from PyQt5.QtWidgets import QComboBox, QHBoxLayout, QLabel, QLineEdit, QPushButton
    self.remove_widgets_in_layout(self.layout())
    
    self.outerLayout = QVBoxLayout()
    self.layout().addLayout(self.outerLayout,0,0) #type:ignore
    
    #Get out of this function if flowChart isn&#39;t initialised yet (i.e. first start-up):
    try:
        self.parent.nodzinstance.nodes
    except RuntimeError:
        return
    
    scoreMetrics = self.getScoreMetrics()
    
    for scoreMetric in scoreMetrics:
        hbox = QHBoxLayout()
        label = QLabel(scoreMetric)
        hbox.addWidget(label)
        dropdown = QComboBox()
        dropdown.addItems([&#39;&gt;&#39;,&#39;&gt;=&#39;,&#39;==&#39;,&#39;&lt;=&#39;,&#39;&lt;&#39;,&#39;!=&#39;])
        hbox.addWidget(dropdown)
        lineedit = QLineEdit()
        hbox.addWidget(lineedit)
        self.decisionInfoGUI[scoreMetric] = {}
        self.decisionInfoGUI[scoreMetric][&#39;dropdown&#39;] = dropdown
        self.decisionInfoGUI[scoreMetric][&#39;lineedit&#39;] = lineedit
        self.outerLayout.addLayout(hbox)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.getScoreMetrics"><code class="name flex">
<span>def <span class="ident">getScoreMetrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the score metrics from the scoringEnd node.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of score metrics (i.e. sockets of score node).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getScoreMetrics(self):
    &#34;&#34;&#34;
    Get the score metrics from the scoringEnd node.
    
    Args:
        None
    
    Returns:
        list: A list of score metrics (i.e. sockets of score node).
    &#34;&#34;&#34;
    scoreMetrics = []
    #Get all score metrics (i.e. sockets of score node)
    flowChart = self.parent.nodzinstance
    if len(flowChart.nodes) &gt; 0:
        #Find the scoringEnd node in flowChart:
        for node in flowChart.nodes:
            if &#39;scoringEnd_&#39; in node.name:
                break
        
        #Now get the scores from here:
        for socket in node.sockets:
            scoreMetrics.append(socket)
    return scoreMetrics</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.remove_widgets_in_layout"><code class="name flex">
<span>def <span class="ident">remove_widgets_in_layout</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all widgets in the given layout recursively.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>layout</code></strong></dt>
<dd>The layout from which widgets will be removed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_widgets_in_layout(self,layout):
    &#34;&#34;&#34;
    Removes all widgets in the given layout recursively.
    
    Args:
        layout: The layout from which widgets will be removed.
    
    Returns:
        None
    &#34;&#34;&#34;
    while layout.count():
        item = layout.takeAt(0)
        widget = item.widget()
        if widget is not None:
            widget.deleteLater()
        elif item.layout() is not None:
            self.remove_widgets_in_layout(item.layout())</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.test_decision"><code class="name flex">
<span>def <span class="ident">test_decision</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a decision based on the mode and decision type. Should always output a boolean</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode of decision making.</dd>
<dt><strong><code>decision</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of decision to be made.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The result of the decision making process.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_decision(self):
    &#34;&#34;&#34;
    Make a decision based on the mode and decision type. Should always output a boolean
    
    Args:
        mode (str): The mode of decision making.
        decision (str): The type of decision to be made.
    
    Returns:
        str: The result of the decision making process.
    &#34;&#34;&#34;
    if self.mode == &#39;DirectDecision&#39;:
        if self.decision == &#39;AND_Score&#39;:
            return self.directDecision_AND_Score_test()
        if self.decision == &#39;AND_Score_VAR&#39;:
            return self.directDecision_AND_Score_VAR_test()</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advDecisionGridLayout.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the object based on the current mode and decision.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    Update the object based on the current mode and decision.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    if self.mode == &#39;DirectDecision&#39;:
        if self.decision == &#39;AND_Score&#39;:
            self.directDecision_AND_Score_update()
        elif self.decision == &#39;AND_Score_VAR&#39;:
            self.directDecision_AND_Score_VAR_update()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.advScanGridLayout"><code class="flex name class">
<span>class <span class="ident">advScanGridLayout</span></span>
<span>(</span><span>mode=None, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>advScanGridLayouts each individually handle a single method of xy(z) scanning. Easiest example is 'loading a POS file'.
The advScanGridLayouts are created in the ScanningWidget class
The layouts should be based around the self.mode parameter, where the .mode is a string which defines the methodologies used. The modes are defined in the ScanningWidget class
Currently implemented:
'LoadPos': Load a POS list</p>
<p>Initializes the class with the given mode and parent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The mode to be set for the class.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>object</code></dt>
<dd>The parent object associated with this class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class advScanGridLayout(QGroupBox):
    &#34;&#34;&#34; 
    advScanGridLayouts each individually handle a single method of xy(z) scanning. Easiest example is &#39;loading a POS file&#39;.
    The advScanGridLayouts are created in the ScanningWidget class
    The layouts should be based around the self.mode parameter, where the .mode is a string which defines the methodologies used. The modes are defined in the ScanningWidget class
    Currently implemented:
        &#39;LoadPos&#39;: Load a POS list
    &#34;&#34;&#34;
    def __init__(self, mode=None,parent=None):
        &#34;&#34;&#34;
        Initializes the class with the given mode and parent.
        
        Args:
            mode (str): The mode to be set for the class.
            parent (object): The parent object associated with this class.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.parent = parent #type:ignore
        super().__init__(parent)
        self.mode = mode
        self.scanningInfoGUI = {}
        #Create a QGridLayout to place in this groupbox:
        try:
            self.setLayout(QGridLayout())
        except:
            pass
        #Create a quick label that we place in 1,1:
        self.layout().addWidget(QLabel(f&#34;{mode}&#34;,self))
        if mode == &#39;LoadPos&#39;:
            self.loadPos_update()
    
    def update(self):
        &#34;&#34;&#34;
        General Update class, can be called from the parent class
        
        Args:
            self: The object itself.
        
        Returns:
            None
        &#34;&#34;&#34;
        logging.debug(&#39;update&#39;)
    
    def getPositionInfo(self):
        &#34;&#34;&#34;
        General method to get the opsition info. Should basically return a well-formatted XY(Z) position list - see self.mode == LoadPos for an example.
        
        Args:
            None
        
        Returns:
            dict: A dictionary containing position information
        &#34;&#34;&#34;
        if self.mode == &#39;LoadPos&#39;:
            positions = {}
            #Read a JSON:
            import json
            with open(self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;], &#39;r&#39;) as f:
                xypositionsRaw = json.load(f)

            positions[&#39;nrPositions&#39;] = len(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;])
            for pos_id in range(positions[&#39;nrPositions&#39;]):
                positions[pos_id] = {}
                positions[pos_id][&#39;STAGES&#39;] = []
                if &#39;DefaultXYStage&#39; in xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id]:
                    positions[pos_id][&#39;STAGES&#39;].append(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DefaultXYStage&#39;][&#39;scalar&#39;])
                if &#39;DefaultZStage&#39; in xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id]:
                    positions[pos_id][&#39;STAGES&#39;].append(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DefaultZStage&#39;][&#39;scalar&#39;])
                
                for stage in positions[pos_id][&#39;STAGES&#39;]:
                    devicePositions = xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DevicePositions&#39;][&#39;array&#39;]
                    for devicePosition in devicePositions:
                        if stage == devicePosition[&#39;Device&#39;][&#39;scalar&#39;]:
                            positions[pos_id][stage] = devicePosition[&#39;Position_um&#39;][&#39;array&#39;]
                
            return positions
    
    def loadPos_update(self):
        &#34;&#34;&#34;
        Update function specific for the &#39;loadPos&#39; method - linked from the general update() method.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        self.scanningInfoGUI[&#39;LoadPos&#39;] = {}
        
        def load_pos_file():
            &#34;&#34;&#34;
            Load POS file using QFileDialog and set the filename in the line edit widget.
            
            Args:
                None
            
            Returns:
                None
            &#34;&#34;&#34;
            from qtpy.QtWidgets import QFileDialog
            filename, _ = QFileDialog.getOpenFileName(self,&#39;Open file&#39;, &#39;&#39;, &#39;*.POS Files (*.pos)&#39;)
            if filename:
                self.lineEdit_posFilename.setText(filename)
                self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;] = filename

        def update_file_name(new_file_name):
            &#34;&#34;&#34;
            Update the file name in the scanning information GUI.
            
            Args:
                new_file_name (str): The new file name to be set in the scanning information GUI.
            
            Returns:
                None
            &#34;&#34;&#34;
            self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;] = new_file_name
    
        self.lineEdit_posFilename = QLineEdit()
        self.layout().addWidget(self.lineEdit_posFilename,1,0) #type:ignore
        self.lineEdit_posFilename.textChanged.connect(lambda x: update_file_name(x))

        button_browsePosFile = QPushButton(&#39;...&#39;)
        self.layout().addWidget(button_browsePosFile,1,1) #type:ignore
        button_browsePosFile.clicked.connect(load_pos_file)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QGroupBox</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.advScanGridLayout.getPositionInfo"><code class="name flex">
<span>def <span class="ident">getPositionInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>General method to get the opsition info. Should basically return a well-formatted XY(Z) position list - see self.mode == LoadPos for an example.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing position information</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPositionInfo(self):
    &#34;&#34;&#34;
    General method to get the opsition info. Should basically return a well-formatted XY(Z) position list - see self.mode == LoadPos for an example.
    
    Args:
        None
    
    Returns:
        dict: A dictionary containing position information
    &#34;&#34;&#34;
    if self.mode == &#39;LoadPos&#39;:
        positions = {}
        #Read a JSON:
        import json
        with open(self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;], &#39;r&#39;) as f:
            xypositionsRaw = json.load(f)

        positions[&#39;nrPositions&#39;] = len(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;])
        for pos_id in range(positions[&#39;nrPositions&#39;]):
            positions[pos_id] = {}
            positions[pos_id][&#39;STAGES&#39;] = []
            if &#39;DefaultXYStage&#39; in xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id]:
                positions[pos_id][&#39;STAGES&#39;].append(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DefaultXYStage&#39;][&#39;scalar&#39;])
            if &#39;DefaultZStage&#39; in xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id]:
                positions[pos_id][&#39;STAGES&#39;].append(xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DefaultZStage&#39;][&#39;scalar&#39;])
            
            for stage in positions[pos_id][&#39;STAGES&#39;]:
                devicePositions = xypositionsRaw[&#39;map&#39;][&#39;StagePositions&#39;][&#39;array&#39;][pos_id][&#39;DevicePositions&#39;][&#39;array&#39;]
                for devicePosition in devicePositions:
                    if stage == devicePosition[&#39;Device&#39;][&#39;scalar&#39;]:
                        positions[pos_id][stage] = devicePosition[&#39;Position_um&#39;][&#39;array&#39;]
            
        return positions</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advScanGridLayout.loadPos_update"><code class="name flex">
<span>def <span class="ident">loadPos_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update function specific for the 'loadPos' method - linked from the general update() method.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadPos_update(self):
    &#34;&#34;&#34;
    Update function specific for the &#39;loadPos&#39; method - linked from the general update() method.
    
    Args:
        None
    
    Returns:
        None
    &#34;&#34;&#34;
    self.scanningInfoGUI[&#39;LoadPos&#39;] = {}
    
    def load_pos_file():
        &#34;&#34;&#34;
        Load POS file using QFileDialog and set the filename in the line edit widget.
        
        Args:
            None
        
        Returns:
            None
        &#34;&#34;&#34;
        from qtpy.QtWidgets import QFileDialog
        filename, _ = QFileDialog.getOpenFileName(self,&#39;Open file&#39;, &#39;&#39;, &#39;*.POS Files (*.pos)&#39;)
        if filename:
            self.lineEdit_posFilename.setText(filename)
            self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;] = filename

    def update_file_name(new_file_name):
        &#34;&#34;&#34;
        Update the file name in the scanning information GUI.
        
        Args:
            new_file_name (str): The new file name to be set in the scanning information GUI.
        
        Returns:
            None
        &#34;&#34;&#34;
        self.scanningInfoGUI[&#39;LoadPos&#39;][&#39;fileName&#39;] = new_file_name

    self.lineEdit_posFilename = QLineEdit()
    self.layout().addWidget(self.lineEdit_posFilename,1,0) #type:ignore
    self.lineEdit_posFilename.textChanged.connect(lambda x: update_file_name(x))

    button_browsePosFile = QPushButton(&#39;...&#39;)
    self.layout().addWidget(button_browsePosFile,1,1) #type:ignore
    button_browsePosFile.clicked.connect(load_pos_file)</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.advScanGridLayout.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>General Update class, can be called from the parent class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self</code></strong></dt>
<dd>The object itself.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    General Update class, can be called from the parent class
    
    Args:
        self: The object itself.
    
    Returns:
        None
    &#34;&#34;&#34;
    logging.debug(&#39;update&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.generalNodzCallActionWorker"><code class="flex name class">
<span>class <span class="ident">generalNodzCallActionWorker</span></span>
<span>(</span><span>nodzType, args)</span>
</code></dt>
<dd>
<div class="desc"><p>General worker that can do async running of callActions belonging to nodes.</p>
<p>Init only passes nodzType and args to the super class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class generalNodzCallActionWorker(QRunnable):
    
    &#34;&#34;&#34; 
    General worker that can do async running of callActions belonging to nodes.
    &#34;&#34;&#34;
    
    def __init__(self,nodzType,args):
        &#34;&#34;&#34; 
        Init only passes nodzType and args to the super class.
        &#34;&#34;&#34;
        super(generalNodzCallActionWorker,self).__init__()
        self.nodzType = nodzType
        self.args = args
        self.signals = WorkerSignals()
        logging.debug(f&#34;GeneralNodzCallActionworker INIT with nodzType: {self.nodzType} and args: {self.args}&#34;)
    
    def run(self):
        &#34;&#34;&#34; 
        Running of the different callActions belonging to all nodes.
        &#34;&#34;&#34;
        import logging
        logging.debug(f&#34;GeneralNodzCallActionworker RUN with nodzType: {self.nodzType} and args: {self.args}&#34;)
        #Timer
        if self.nodzType == &#39;Timer&#39;:
            import time
            time.sleep(self.args[&#39;wait_time&#39;])
        elif self.nodzType == &#39;MMconfigChangeRan&#39;:
            #We need to change some configs (probably):
            for config_to_change in self.args[&#39;config_string_storage&#39;]:
                
                #Find the correct config_group in MMconfig:
                for config_group_id_loop in self.args[&#39;MMconfig&#39;].config_groups:
                    config_group_name = self.args[&#39;MMconfig&#39;].config_groups[config_group_id_loop].configGroupName()
                    if config_group_name == config_to_change[0]:
                        config_group_id = config_group_id_loop
                        #Over-write the grouptype like this:
                        config_group_type = &#39;InputField&#39;
                        if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isInputField():
                            config_group_type = &#39;InputField&#39;
                        if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isDropDown():
                            config_group_type = &#39;DropDown&#39;
                        if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isSlider():
                            config_group_type = &#39;Slider&#39;
                
                if config_group_type == &#39;DropDown&#39;:
                    logging.debug(&#39;Changing dropDown value from MMconfig-Nodz!&#39;)
                    #Change the config, and wait for the config to be changed - this works for groups
                    self.args[&#39;core&#39;].set_config(config_to_change[0],config_to_change[1]) #type:ignore
                    self.args[&#39;core&#39;].wait_for_config(config_to_change[0],config_to_change[1])#type:ignore
                elif config_group_type == &#39;InputField&#39;:
                    logging.info(&#39;Changing inputField value from MMconfig-Nodz!&#39;)
                    CurrentText = config_to_change[1]
                    #Get the config group name:
                    configGroupName = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].configGroupName()

                    #An Editfield config by definition (?) only has a single property underneath, so get that:
                    underlyingProperty = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_available_configs(configGroupName).get(0)
                    configdata = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_config_data(configGroupName,underlyingProperty)
                    device_label = configdata.get_setting(0).get_device_label()
                    property_name = configdata.get_setting(0).get_property_name()

                    #Set this property:
                    self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.set_property(device_label,property_name,CurrentText)
                    logging.info(f&#34;Changed {device_label}.{property_name} to {CurrentText}&#34;)
                elif config_group_type == &#39;Slider&#39;:
                    logging.debug(&#39;Changing slider value from MMconfig-Nodz!&#39;)
                    newValue = config_to_change[1]
                    #Get the true value from the conversion - not required in MMconfig-nodz:
                    trueValue = newValue
                    
                    #Get the config group name:
                    configGroupName = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].configGroupName()
                    #Set in MM:
                    #A slider config by definition (?) only has a single property underneath, so get that:
                    underlyingProperty = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_available_configs(configGroupName).get(0)
                    configdata = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_config_data(configGroupName,underlyingProperty)
                    device_label = configdata.get_setting(0).get_device_label()
                    property_name = configdata.get_setting(0).get_property_name()

                    #Set this property:
                    self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.set_property(device_label,property_name,trueValue)
                    logging.info(f&#34;Changed {device_label}.{property_name} to {trueValue}&#34;)
                    
        elif self.nodzType == &#39;AnalysisNode&#39; or self.nodzType == &#39;CustomFunctionNode&#39;:
            #Get all the necessary info
            evalText = self.args[&#39;evalText&#39;]
            nodeDict = self.args[&#39;nodeDict&#39;]
            node = self.args[&#39;node&#39;]
            core = self.args[&#39;core&#39;]
            shared_data = self.args[&#39;shared_data&#39;]
            self.shared_data = shared_data
            logging.info(evalText)
            #Finally do the analysis
            node.output = eval(evalText)
        
        #Emit that the node is finished :) 
        self.signals.finished.emit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QRunnable</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.generalNodzCallActionWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Running of the different callActions belonging to all nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34; 
    Running of the different callActions belonging to all nodes.
    &#34;&#34;&#34;
    import logging
    logging.debug(f&#34;GeneralNodzCallActionworker RUN with nodzType: {self.nodzType} and args: {self.args}&#34;)
    #Timer
    if self.nodzType == &#39;Timer&#39;:
        import time
        time.sleep(self.args[&#39;wait_time&#39;])
    elif self.nodzType == &#39;MMconfigChangeRan&#39;:
        #We need to change some configs (probably):
        for config_to_change in self.args[&#39;config_string_storage&#39;]:
            
            #Find the correct config_group in MMconfig:
            for config_group_id_loop in self.args[&#39;MMconfig&#39;].config_groups:
                config_group_name = self.args[&#39;MMconfig&#39;].config_groups[config_group_id_loop].configGroupName()
                if config_group_name == config_to_change[0]:
                    config_group_id = config_group_id_loop
                    #Over-write the grouptype like this:
                    config_group_type = &#39;InputField&#39;
                    if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isInputField():
                        config_group_type = &#39;InputField&#39;
                    if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isDropDown():
                        config_group_type = &#39;DropDown&#39;
                    if self.args[&#39;MMconfig&#39;].config_groups[config_group_id].isSlider():
                        config_group_type = &#39;Slider&#39;
            
            if config_group_type == &#39;DropDown&#39;:
                logging.debug(&#39;Changing dropDown value from MMconfig-Nodz!&#39;)
                #Change the config, and wait for the config to be changed - this works for groups
                self.args[&#39;core&#39;].set_config(config_to_change[0],config_to_change[1]) #type:ignore
                self.args[&#39;core&#39;].wait_for_config(config_to_change[0],config_to_change[1])#type:ignore
            elif config_group_type == &#39;InputField&#39;:
                logging.info(&#39;Changing inputField value from MMconfig-Nodz!&#39;)
                CurrentText = config_to_change[1]
                #Get the config group name:
                configGroupName = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].configGroupName()

                #An Editfield config by definition (?) only has a single property underneath, so get that:
                underlyingProperty = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_available_configs(configGroupName).get(0)
                configdata = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_config_data(configGroupName,underlyingProperty)
                device_label = configdata.get_setting(0).get_device_label()
                property_name = configdata.get_setting(0).get_property_name()

                #Set this property:
                self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.set_property(device_label,property_name,CurrentText)
                logging.info(f&#34;Changed {device_label}.{property_name} to {CurrentText}&#34;)
            elif config_group_type == &#39;Slider&#39;:
                logging.debug(&#39;Changing slider value from MMconfig-Nodz!&#39;)
                newValue = config_to_change[1]
                #Get the true value from the conversion - not required in MMconfig-nodz:
                trueValue = newValue
                
                #Get the config group name:
                configGroupName = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].configGroupName()
                #Set in MM:
                #A slider config by definition (?) only has a single property underneath, so get that:
                underlyingProperty = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_available_configs(configGroupName).get(0)
                configdata = self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.get_config_data(configGroupName,underlyingProperty)
                device_label = configdata.get_setting(0).get_device_label()
                property_name = configdata.get_setting(0).get_property_name()

                #Set this property:
                self.args[&#39;MMconfig&#39;].config_groups[config_group_id].core.set_property(device_label,property_name,trueValue)
                logging.info(f&#34;Changed {device_label}.{property_name} to {trueValue}&#34;)
                
    elif self.nodzType == &#39;AnalysisNode&#39; or self.nodzType == &#39;CustomFunctionNode&#39;:
        #Get all the necessary info
        evalText = self.args[&#39;evalText&#39;]
        nodeDict = self.args[&#39;nodeDict&#39;]
        node = self.args[&#39;node&#39;]
        core = self.args[&#39;core&#39;]
        shared_data = self.args[&#39;shared_data&#39;]
        self.shared_data = shared_data
        logging.info(evalText)
        #Finally do the analysis
        node.output = eval(evalText)
    
    #Emit that the node is finished :) 
    self.signals.finished.emit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.nodz_analysisDialog"><code class="flex name class">
<span>class <span class="ident">nodz_analysisDialog</span></span>
<span>(</span><span>parent=None, currentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for analysis methods in the Nodz layout. Basically based on EVE's flexible file-finding function methodology.</p>
<p>Initializes the Analysis Options window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>Parent widget (default is None).</dd>
<dt><strong><code>currentNode</code></strong></dt>
<dd>Current node (default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_analysisDialog(AnalysisScoringVisualisationDialog):
    &#34;&#34;&#34;
    A Dialog that is created for analysis methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Initializes the Analysis Options window.
        
        Args:
            parent: Parent widget (default is None).
            currentNode: Current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent, currentNode)
        self.setWindowTitle(&#34;Analysis Options&#34;)
        self.setMinimumSize(400,100)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        #Let&#39;s try to get all possible analysis options
        analysisFunctions_Images = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Analysis_Images&#39;)
        analysisFunctions_Measurements = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Analysis_Measurements&#39;)
        analysisFunctions_Shapes = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Analysis_Shapes&#39;)
        #Also add them back to back
        all_analysisFunctions = analysisFunctions_Images + analysisFunctions_Measurements + analysisFunctions_Shapes
        
        allDisplayNames,displaynameMapping = utils.displayNamesFromFunctionNames(all_analysisFunctions,&#39;&#39;)
        #Store this mapping also in the node
        self.currentData[&#39;__displayNameFunctionNameMap__&#39;] = displaynameMapping
        
        #Add a dropbox with all the options
        self.comboBox_analysisFunctions = QComboBox(self)
        if len(analysisFunctions_Images) &gt; 0:
            for item in analysisFunctions_Images:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
            self.comboBox_analysisFunctions.insertSeparator(len(analysisFunctions_Images)-1)  
        if len(analysisFunctions_Measurements) &gt; 0:
            for item in analysisFunctions_Measurements:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
            self.comboBox_analysisFunctions.insertSeparator(len(analysisFunctions_Images)+len(analysisFunctions_Measurements)-1)
        if len(analysisFunctions_Shapes) &gt; 0:
            for item in analysisFunctions_Shapes:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
            self.comboBox_analysisFunctions.insertSeparator(len(analysisFunctions_Images)+len(analysisFunctions_Measurements)+len(analysisFunctions_Shapes)-1)          

        self.mainLayout.addWidget(self.comboBox_analysisFunctions, 0, 1)
        #give it an objectName:
        self.comboBox_analysisFunctions.setObjectName(&#39;comboBox_analysisFunctions_KEEP&#39;)
        #Give it a connect-callback if it&#39;s changed (then the layout should be changed)
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, layout=self.mainLayout, dropdown=self.comboBox_analysisFunctions,displaynameMapping=displaynameMapping: utils.layout_changedDropdown(layout,dropdown,displaynameMapping))
        #Also give it a connect-callback to store the currentinfo:
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, parentdata=self: utils.updateCurrentDataUponDropdownChange(parentdata))

        # pre-load all args/kwargs and their edit values - then hide all of them
        utils.layout_init(self.mainLayout,&#39;&#39;,displaynameMapping,current_dropdown = self.comboBox_analysisFunctions,nodzInfo=parent)
        
        # if currentNode.scoring_analysis_currentData == {}: #type:ignore
        #     utils.preLoadOptions_analysis(self.mainLayout,self.currentData)
        # else: 
            
        #Add an expanding spacer at the bottom:
        spacer_item = QSpacerItem(
            20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding
        )
        # Add the spacer item to the grid layout
        self.mainLayout.addItem(spacer_item, 99, 0)
        
        #Pre-load the options if they&#39;re in the current node info
        utils.preLoadOptions_analysis(self.mainLayout,currentNode.scoring_analysis_currentData) #type:ignore</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.AnalysisScoringVisualisationDialog" href="#FlowChart_dockWidgets.AnalysisScoringVisualisationDialog">AnalysisScoringVisualisationDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_analysisMeasurementDialog" href="#FlowChart_dockWidgets.nodz_analysisMeasurementDialog">nodz_analysisMeasurementDialog</a></li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_analysisMeasurementDialog"><code class="flex name class">
<span>class <span class="ident">nodz_analysisMeasurementDialog</span></span>
<span>(</span><span>parent=None, currentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for analysis methods in the Nodz layout. Basically based on EVE's flexible file-finding function methodology.</p>
<p>Dummy init function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_analysisMeasurementDialog(nodz_analysisDialog):
    &#34;&#34;&#34;
    A Dialog that is created for analysis methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Dummy init function.
        &#34;&#34;&#34;
        super().__init__(parent, currentNode)
        self.setWindowTitle(&#34;Analysis Measurement Options&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_analysisDialog" href="#FlowChart_dockWidgets.nodz_analysisDialog">nodz_analysisDialog</a></li>
<li><a title="FlowChart_dockWidgets.AnalysisScoringVisualisationDialog" href="#FlowChart_dockWidgets.AnalysisScoringVisualisationDialog">AnalysisScoringVisualisationDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_caseSwitchDialog"><code class="flex name class">
<span>class <span class="ident">nodz_caseSwitchDialog</span></span>
<span>(</span><span>parentNode=None, currentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The ScoringEnd (i.e. the end of the scoring) dialog window.</p>
<p>Initialize the ScoringEnd (i.e. the end of the scoring) dialog window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget (default is None).</dd>
<dt><strong><code>currentNode</code></strong></dt>
<dd>The current node (default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_caseSwitchDialog(QDialog):
    &#34;&#34;&#34;
    The ScoringEnd (i.e. the end of the scoring) dialog window.
    &#34;&#34;&#34;
    def __init__(self, parentNode=None, currentNode=None):
        &#34;&#34;&#34;
        Initialize the ScoringEnd (i.e. the end of the scoring) dialog window.
        
        Args:
            parent: The parent widget (default is None).
            currentNode: The current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__()
        if currentNode == None:
            logging.error(f&#34;Error in nodz_caseSwitchDialog: currentNode is None&#34;)
            return
        self.caseSwitchInfo = currentNode.caseSwitchInfo
        self.setWindowTitle(&#34;CaseSwitch&#34;)
        #Add an OK/Cancel box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Create the QVBoxLayout
        layout = QVBoxLayout()

        # Create a QWidget to contain the QGridLayout
        self.grid_widget = QGridLayout()
            
        self.varSwitchAdvLineEdit = utils.multiLineEdit_valueVarAdv(&#39;CaseSwitch&#39;,&#39;Var&#39;,self.grid_widget,currentNode.flowChart,True,self.textChanged,&#39;Variable&#39;)
        #Set the current variables:
        try:
            self.varSwitchAdvLineEdit.line_edit.textChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.line_edit.setText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit.objectName()])
            self.varSwitchAdvLineEdit.line_edit.textChanged.connect(self.textChanged)
            
            self.varSwitchAdvLineEdit.line_edit_variable.textChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.line_edit_variable.setText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_variable.objectName()])
            self.varSwitchAdvLineEdit.line_edit_variable.textChanged.connect(self.textChanged)
            
            self.varSwitchAdvLineEdit.line_edit_adv.textChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.line_edit_adv.setText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_adv.objectName()])
            self.varSwitchAdvLineEdit.line_edit_adv.textChanged.connect(self.textChanged)
            
            self.varSwitchAdvLineEdit.comboBox_switch.currentIndexChanged.disconnect(self.textChanged)
            self.varSwitchAdvLineEdit.comboBox_switch.setCurrentText(self.caseSwitchInfo[self.varSwitchAdvLineEdit.comboBox_switch.objectName()])
            self.varSwitchAdvLineEdit.comboBox_switch.currentIndexChanged.connect(self.textChanged)
        except:
            pass
        
        #Finally actually add it to layout
        self.grid_widget.addLayout(self.varSwitchAdvLineEdit,0,0)
        #update the hiding of value/adv/variable
        customParentChildren = [self.varSwitchAdvLineEdit.line_edit,self.varSwitchAdvLineEdit.line_edit_adv,self.varSwitchAdvLineEdit.line_edit_variable,self.varSwitchAdvLineEdit.line_edit_Button_adv,self.varSwitchAdvLineEdit.push_button_variable_adv]
        utils.hideAdvVariables(self.varSwitchAdvLineEdit.comboBox_switch,customParentChildren=customParentChildren)
            
        self.nrVarsSpinbox = QSpinBox()
        self.nrVarsSpinbox.setMinimum(1)
        self.nrVarsSpinbox.valueChanged.connect(self.updateLayout)
        self.grid_widget.addWidget(self.nrVarsSpinbox,1,0)

        self.variableContainer = QGridLayout()
        # self.grid_widget.addLayout(self.variableContainer,1,0)
        
        self.variableContainerscrollArea = QScrollArea(self)
        self.variableContainerscrollArea.setWidgetResizable(True)
        self.variableContainerscrollAreaWidgetContents = QWidget()
        self.variableContainerscrollAreaWidgetContents.setLayout(self.variableContainer)
        self.variableContainerscrollArea.setWidget(self.variableContainerscrollAreaWidgetContents)
        self.grid_widget.addWidget(self.variableContainerscrollArea,2,0)
        
        # Set a fixed size for the QScrollArea
        self.variableContainerscrollArea.setFixedSize(QSize(300, 300))  # Adjust the size as needed
        # Add the QMainWindow to the QVBoxLayout
        layout.addLayout(self.grid_widget)

        layout.addWidget(button_box)
        
        self.setLayout(layout)
        
        #Add a spacer item at the bottom of the variableContainer so it&#39;s pushing it down down down
        spacerItem = QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding)
        self.variableContainer.addItem(spacerItem, 999, 0)

        #Pre-load labels/line-Edits with the current plugs:
        self.labels = []
        self.lineEdits = []
        if currentNode is not None:
            currentPlugs = list(currentNode.plugs.items())
            for socket in currentPlugs:
                label = QLabel(f&#34;Option {len(self.labels)+1}:&#34;)
                lineEdit = QLineEdit()
                lineEdit.setText(socket[0])
                self.variableContainer.addWidget(label,len(self.labels),0)
                self.variableContainer.addWidget(lineEdit,len(self.labels),1)
                self.labels.append(label)
                self.lineEdits.append(lineEdit)
        
        self.nrVarsSpinbox.setValue(len(self.labels)) 
        
        #And update the layout at the start:
        # self.updateLayout()
    def textChanged(self):
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit.objectName()] = self.varSwitchAdvLineEdit.line_edit.text()
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_variable.objectName()] = self.varSwitchAdvLineEdit.line_edit_variable.text()
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_adv.objectName()] = self.varSwitchAdvLineEdit.line_edit_adv.text()
        self.caseSwitchInfo[self.varSwitchAdvLineEdit.comboBox_switch.objectName()] = self.varSwitchAdvLineEdit.comboBox_switch.currentText()
        self.caseSwitchInfo
    
    def updateLayout(self):
        &#34;&#34;&#34;
        Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.
        
            Args:
                None
        
            Returns:
                None
        &#34;&#34;&#34;
        nrVars = self.nrVarsSpinbox.value()
        if nrVars == len(self.labels)-1: #If we want to remove the last one
            tobeRemovedLabel = self.labels[-1]
            tobeRemovedLineEdit = self.lineEdits[-1]
            self.layout().removeWidget(tobeRemovedLabel)
            tobeRemovedLabel.deleteLater()
            self.layout().removeWidget(tobeRemovedLineEdit)
            tobeRemovedLineEdit.deleteLater()
            self.labels.pop()
            self.lineEdits.pop()
        elif nrVars == len(self.labels)+1: #if we want to add one...
            label = QLabel(f&#34;Option {len(self.labels)+1}:&#34;)
            lineEdit = QLineEdit()
            self.variableContainer.addWidget(label,len(self.labels),0)
            self.variableContainer.addWidget(lineEdit,len(self.labels),1)
            self.labels.append(label)
            self.lineEdits.append(lineEdit)
        elif nrVars == len(self.labels): 
            pass
        else: #Else, we added a fully new number, so we reset everything
            for label in self.labels:
                self.layout().removeWidget(label)
                label.deleteLater()
            for lineEdit in self.lineEdits:
                self.layout().removeWidget(lineEdit)
                lineEdit.deleteLater()

            self.labels = []
            self.lineEdits = []

            for i in range(nrVars):
                label = QLabel(f&#34;Option {i+1}:&#34;)
                lineEdit = QLineEdit()
                self.variableContainer.addWidget(label,i,0)
                self.labels.append(label)
                self.variableContainer.addWidget(lineEdit,i,1)
                self.lineEdits.append(lineEdit)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.nodz_caseSwitchDialog.textChanged"><code class="name flex">
<span>def <span class="ident">textChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textChanged(self):
    self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit.objectName()] = self.varSwitchAdvLineEdit.line_edit.text()
    self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_variable.objectName()] = self.varSwitchAdvLineEdit.line_edit_variable.text()
    self.caseSwitchInfo[self.varSwitchAdvLineEdit.line_edit_adv.objectName()] = self.varSwitchAdvLineEdit.line_edit_adv.text()
    self.caseSwitchInfo[self.varSwitchAdvLineEdit.comboBox_switch.objectName()] = self.varSwitchAdvLineEdit.comboBox_switch.currentText()
    self.caseSwitchInfo</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.nodz_caseSwitchDialog.updateLayout"><code class="name flex">
<span>def <span class="ident">updateLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.</p>
<pre><code>Args:
    None

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateLayout(self):
    &#34;&#34;&#34;
    Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.
    
        Args:
            None
    
        Returns:
            None
    &#34;&#34;&#34;
    nrVars = self.nrVarsSpinbox.value()
    if nrVars == len(self.labels)-1: #If we want to remove the last one
        tobeRemovedLabel = self.labels[-1]
        tobeRemovedLineEdit = self.lineEdits[-1]
        self.layout().removeWidget(tobeRemovedLabel)
        tobeRemovedLabel.deleteLater()
        self.layout().removeWidget(tobeRemovedLineEdit)
        tobeRemovedLineEdit.deleteLater()
        self.labels.pop()
        self.lineEdits.pop()
    elif nrVars == len(self.labels)+1: #if we want to add one...
        label = QLabel(f&#34;Option {len(self.labels)+1}:&#34;)
        lineEdit = QLineEdit()
        self.variableContainer.addWidget(label,len(self.labels),0)
        self.variableContainer.addWidget(lineEdit,len(self.labels),1)
        self.labels.append(label)
        self.lineEdits.append(lineEdit)
    elif nrVars == len(self.labels): 
        pass
    else: #Else, we added a fully new number, so we reset everything
        for label in self.labels:
            self.layout().removeWidget(label)
            label.deleteLater()
        for lineEdit in self.lineEdits:
            self.layout().removeWidget(lineEdit)
            lineEdit.deleteLater()

        self.labels = []
        self.lineEdits = []

        for i in range(nrVars):
            label = QLabel(f&#34;Option {i+1}:&#34;)
            lineEdit = QLineEdit()
            self.variableContainer.addWidget(label,i,0)
            self.labels.append(label)
            self.variableContainer.addWidget(lineEdit,i,1)
            self.lineEdits.append(lineEdit)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.nodz_customFunctionDialog"><code class="flex name class">
<span>class <span class="ident">nodz_customFunctionDialog</span></span>
<span>(</span><span>parent=None, currentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for analysis/scoring/visualisation methods in the Nodz layout. Basically based on EVE's flexible file-finding function methodology. Also used for real-time analysis dialog.</p>
<p>Initializes the Analysis Options window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>Parent widget (default is None).</dd>
<dt><strong><code>currentNode</code></strong></dt>
<dd>Current node (default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_customFunctionDialog(AnalysisScoringVisualisationDialog):
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Initializes the Analysis Options window.
        
        Args:
            parent: Parent widget (default is None).
            currentNode: Current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent, currentNode)
        self.setWindowTitle(&#34;Custom Function Options&#34;)
        self.setMinimumSize(400,100)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        #Let&#39;s try to get all possible analysis options
        customFunctions = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\CustomFunctions&#39;)
        #Also add them back to back
        all_analysisFunctions = customFunctions
        
        allDisplayNames,displaynameMapping = utils.displayNamesFromFunctionNames(all_analysisFunctions,&#39;&#39;)
        #Store this mapping also in the node
        self.currentData[&#39;__displayNameFunctionNameMap__&#39;] = displaynameMapping
        
        #Add a dropbox with all the options
        self.comboBox_analysisFunctions = QComboBox(self)
        if len(customFunctions) &gt; 0:
            for item in customFunctions:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_analysisFunctions.addItem(displayNameI[0])
                
        self.mainLayout.addWidget(self.comboBox_analysisFunctions, 0, 1)
        #give it an objectName:
        self.comboBox_analysisFunctions.setObjectName(&#39;comboBox_customFunctions_KEEP&#39;)
        #Give it a connect-callback if it&#39;s changed (then the layout should be changed)
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, layout=self.mainLayout, dropdown=self.comboBox_analysisFunctions,displaynameMapping=displaynameMapping: utils.layout_changedDropdown(layout,dropdown,displaynameMapping))
        #Also give it a connect-callback to store the currentinfo:
        self.comboBox_analysisFunctions.currentIndexChanged.connect(lambda index, parentdata=self: utils.updateCurrentDataUponDropdownChange(parentdata))

        # pre-load all args/kwargs and their edit values - then hide all of them
        utils.layout_init(self.mainLayout,&#39;&#39;,displaynameMapping,current_dropdown = self.comboBox_analysisFunctions,nodzInfo=parent,skipInput=True)
        
        #Add an expanding spacer at the bottom:
        spacer_item = QSpacerItem(
            20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding
        )
        # Add the spacer item to the grid layout
        self.mainLayout.addItem(spacer_item, 99, 0)
        
        #Pre-load the options if they&#39;re in the current node info
        utils.preLoadOptions_analysis(self.mainLayout,currentNode.customFunction_currentData,functionName = &#39;comboBox_customFunctions&#39;) #type:ignore
        
        try:
            #Set the current dropdown to be correct
            correctFunction = currentNode.customFunction_currentData[&#39;__selectedDropdownEntryAnalysis__&#39;] #type:ignore
            self.comboBox_analysisFunctions.setCurrentText(correctFunction)
        except KeyError:
            pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.AnalysisScoringVisualisationDialog" href="#FlowChart_dockWidgets.AnalysisScoringVisualisationDialog">AnalysisScoringVisualisationDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog"><code class="flex name class">
<span>class <span class="ident">nodz_generalAdvancedLineEditDialog</span></span>
<span>(</span><span>parentNode=None, title='Title', internalName='internalName', advLineEdits=[{'LineEdit1:': ['intLineEdit1', 'Value']}, {'LineEdit2:': ['intLineEdit2', 'Variable']}], storeVarName='storeVarName')</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for changeGlobalVar in the Nodz layout. </p>
<p>Initializes the changeGlobalVarDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_generalAdvancedLineEditDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for changeGlobalVar in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None,title=&#34;Title&#34;,internalName=&#39;internalName&#39;,advLineEdits=[{&#39;LineEdit1:&#39;:[&#39;intLineEdit1&#39;,&#39;Value&#39;]},{&#39;LineEdit2:&#39;: [&#39;intLineEdit2&#39;,&#39;Variable&#39;]}],storeVarName=&#39;storeVarName&#39;):
        &#34;&#34;&#34;
        Initializes the changeGlobalVarDialog.
        
        Args:
            parentNode: The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(title)
        self.storeVarName = storeVarName
        
        setattr(self,storeVarName,0)
        # selfvar = getattr(self,storeVarName)
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            setattr(self,storeVarName,getattr(parentNode,storeVarName))
            # self.changeGlobalVarInfo  = parentNode.changeGlobalVarInfo 

        # Create the QVBoxLayout
        layout = QGridLayout()

        self.advLineEditLayouts={}
        GridCounter = 0
        #Create a lineEditWidget for each requested
        for lineEditWidget in advLineEdits:
            labelName = list(lineEditWidget.keys())[0]
            varName = list(lineEditWidget.values())[0][0]
            standardChoice = list(lineEditWidget.values())[0][1]
        
            connection = self.updateFields
            self.advLineEditLayouts[varName] = utils.multiLineEdit_valueVarAdv(internalName,varName,layout,parentNode.flowChart,ShowVariablesOptions=True,textChangeCallback = connection,valueVarAdv=standardChoice) #type:ignore
            
            layout.addWidget(QLabel(labelName),GridCounter,0)
            layout.addLayout(self.advLineEditLayouts[varName],GridCounter,1)
            GridCounter+=1
            
            #Pre-load the values if they exist
            for lineEditVal in [&#39;line_edit&#39;,&#39;line_edit_adv&#39;,&#39;line_edit_variable&#39;]:
                this_line_edit = getattr(self.advLineEditLayouts[varName], lineEditVal)
                if this_line_edit.objectName() in getattr(self,storeVarName): #type:ignore
                    this_line_edit.textChanged.disconnect(connection)
                    this_line_edit.setText(getattr(self,storeVarName)[this_line_edit.objectName()]) #type:ignore
                    this_line_edit.textChanged.connect(connection)
            #Pre-load the value of the comboboxswitch:
            try:
                self.advLineEditLayouts[varName].comboBox_switch.setCurrentText(getattr(self,storeVarName)[self.advLineEditLayouts[varName].comboBox_switch.objectName()]) #type:ignore
            except:
                pass
            
            #When loading, hide the non-relevants:
            customParentChildren = [self.advLineEditLayouts[varName].line_edit,self.advLineEditLayouts[varName].line_edit_adv,self.advLineEditLayouts[varName].line_edit_variable,self.advLineEditLayouts[varName].line_edit_Button_adv,self.advLineEditLayouts[varName].push_button_variable_adv]
            utils.hideAdvVariables(self.advLineEditLayouts[varName].comboBox_switch,customParentChildren=customParentChildren)
        
        
        #OK/Cancel buttonBox.
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box,99,0,1,2)
        
        self.setLayout(layout)

    def updateFields(self):
        
        
        for entry in self.advLineEditLayouts:
            lineEditLayout = self.advLineEditLayouts[entry]
        
            try:
                #Set the value of the lineedits to storage
                getattr(self,self.storeVarName)[lineEditLayout.line_edit.objectName()] = lineEditLayout.line_edit.text()
                getattr(self,self.storeVarName)[lineEditLayout.line_edit_adv.objectName()] = lineEditLayout.line_edit_adv.text()
                getattr(self,self.storeVarName)[lineEditLayout.line_edit_variable.objectName()] = lineEditLayout.line_edit_variable.text()
                #Store the value of the combobox
                getattr(self,self.storeVarName)[lineEditLayout.comboBox_switch.objectName()] = lineEditLayout.comboBox_switch.currentText()
                
            except:
                pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_openChangeGlobalVarDialog" href="#FlowChart_dockWidgets.nodz_openChangeGlobalVarDialog">nodz_openChangeGlobalVarDialog</a></li>
<li><a title="FlowChart_dockWidgets.nodz_openIfStatementDialog" href="#FlowChart_dockWidgets.nodz_openIfStatementDialog">nodz_openIfStatementDialog</a></li>
<li><a title="FlowChart_dockWidgets.nodz_openNewGlobalVarDialog" href="#FlowChart_dockWidgets.nodz_openNewGlobalVarDialog">nodz_openNewGlobalVarDialog</a></li>
<li><a title="FlowChart_dockWidgets.nodz_openStoreDataDialog" href="#FlowChart_dockWidgets.nodz_openStoreDataDialog">nodz_openStoreDataDialog</a></li>
<li><a title="FlowChart_dockWidgets.nodz_openTimerDialog" href="#FlowChart_dockWidgets.nodz_openTimerDialog">nodz_openTimerDialog</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog.updateFields"><code class="name flex">
<span>def <span class="ident">updateFields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateFields(self):
    
    
    for entry in self.advLineEditLayouts:
        lineEditLayout = self.advLineEditLayouts[entry]
    
        try:
            #Set the value of the lineedits to storage
            getattr(self,self.storeVarName)[lineEditLayout.line_edit.objectName()] = lineEditLayout.line_edit.text()
            getattr(self,self.storeVarName)[lineEditLayout.line_edit_adv.objectName()] = lineEditLayout.line_edit_adv.text()
            getattr(self,self.storeVarName)[lineEditLayout.line_edit_variable.objectName()] = lineEditLayout.line_edit_variable.text()
            #Store the value of the combobox
            getattr(self,self.storeVarName)[lineEditLayout.comboBox_switch.objectName()] = lineEditLayout.comboBox_switch.currentText()
            
        except:
            pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openChangeGlobalVarDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openChangeGlobalVarDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for changeGlobalVar in the Nodz layout. </p>
<p>Initializes the changeGlobalVarDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openChangeGlobalVarDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for changeGlobalVar in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the changeGlobalVarDialog.
        
        Args:
            parentNode: The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;changeGlobalVarInfo  Dialog&#34;,
                        internalName=&#39;globalVarChange&#39;,
                        advLineEdits=[{&#39;Variable to change:&#39;:[&#39;globalVarName&#39;,&#39;Variable&#39;]},{&#39;Change to value:&#39;:[&#39;globalVarValue&#39;,&#39;Advanced&#39;]}],
                        storeVarName=&#39;changeGlobalVarInfo&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog">nodz_generalAdvancedLineEditDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openIfStatementDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openIfStatementDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for ifStatement in the Nodz layout. </p>
<p>Initializes the ifStatementDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the ifStatementDialog. If provided, the ifStatementDialog will be set to the ifStatementDialog of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openIfStatementDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for ifStatement in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the ifStatementDialog.
        
        Args:
            parentNode: The parent node of the ifStatementDialog. If provided, the ifStatementDialog will be set to the ifStatementDialog of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;ifStatement Dialog&#34;,
                        internalName=&#39;ifStatementDialog&#39;,
                        advLineEdits=[{&#39;Value to check:&#39;:[&#39;valueToCheck&#39;,&#39;Variable&#39;]},{&#39;Comparator:&#39;:[&#39;comparator&#39;,&#39;Value&#39;]},{&#39;Check against:&#39;:[&#39;valueCheckAgainst&#39;,&#39;Value&#39;]}],
                        storeVarName=&#39;ifStatementInfo&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog">nodz_generalAdvancedLineEditDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openInlineScriptDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openInlineScriptDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for timer in the Nodz layout. </p>
<p>Initializes the TimerDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the TimerDialog. If provided, the timerInfo will be set to the timerInfo of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openInlineScriptDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for timer in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the TimerDialog.
        
        Args:
            parentNode: The parent node of the TimerDialog. If provided, the timerInfo will be set to the timerInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(&#34;InlineScript Dialog&#34;)
        self.InlineScriptInfo  = &#39;&#39;
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            self.InlineScriptInfo  = parentNode.InlineScriptInfo

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Create the QVBoxLayout
        layout = QVBoxLayout()

        #add a big editable text box:
        scriptinfo = QTextEdit()
        scriptinfo.setPlainText(self.InlineScriptInfo)
        scriptinfo.textChanged.connect(lambda: setattr(self, &#39;InlineScriptInfo&#39;, scriptinfo.toPlainText()))

        # Add the QMainWindow to the QVBoxLayout
        layout.addWidget(scriptinfo)

        layout.addWidget(button_box)
        
        self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openMDADialog"><code class="flex name class">
<span>class <span class="ident">nodz_openMDADialog</span></span>
<span>(</span><span>parent=None, parentData=None, currentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Dialog for the MDA options within the Nodz environment.</p>
<p>Dialog for the MDA options.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>QtWidgets.QWidget</code></dt>
<dd>Parent widget of the dialog.</dd>
<dt><strong><code>parentData</code></strong> :&ensp;<code>FlowChartCore</code></dt>
<dd>Instance of the FlowChartCore class.</dd>
<dt><strong><code>currentNode</code></strong> :&ensp;<code>FlowChartNode</code></dt>
<dd>Instance of the FlowChartNode class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code></dt>
<dd>List of tuples, each containing the configuration name and its new value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openMDADialog(QDialog):
    &#34;&#34;&#34;
    Dialog for the MDA options within the Nodz environment.
    &#34;&#34;&#34;
    def __init__(self, parent=None, parentData=None, currentNode = None):
        &#34;&#34;&#34;
        Dialog for the MDA options.
        
        Args:
            parent (QtWidgets.QWidget): Parent widget of the dialog.
            parentData (FlowChartCore): Instance of the FlowChartCore class.
            currentNode (FlowChartNode): Instance of the FlowChartNode class.
            
        Returns:
            List: List of tuples, each containing the configuration name and its new value.
        &#34;&#34;&#34;
        super().__init__(parent)
        self.parent = parent #type:ignore
        self.parentData = parentData
        self.currentNode=  currentNode
        
        self.setWindowTitle(&#34;MDA Dialog&#34;)
        if parentData is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            testQWidget = QWidget()
            
            if currentNode is not None:
                #Create a new MDAGlados with all the same components as currentNode.mdaData:
                self.mdaconfig = MDAGlados(parentData.core,None,None,parentData.shared_data,
                    hasGUI=True,
                    GUI_show_channel=currentNode.mdaData.GUI_show_channel,
                    GUI_show_exposure=currentNode.mdaData.GUI_show_exposure,
                    GUI_show_order=currentNode.mdaData.GUI_show_order,
                    GUI_show_storage=currentNode.mdaData.GUI_show_storage,
                    GUI_show_time=currentNode.mdaData.GUI_show_time,
                    GUI_show_xy=currentNode.mdaData.GUI_show_xy,
                    GUI_show_z=currentNode.mdaData.GUI_show_z,
                    GUI_acquire_button=False,
                    order = currentNode.mdaData.order,
                    num_time_points=currentNode.mdaData.num_time_points,
                    time_interval_s=currentNode.mdaData.time_interval_s,
                    z_start=currentNode.mdaData.z_start,
                    z_end=currentNode.mdaData.z_end,
                    z_step=currentNode.mdaData.z_step,
                    z_stage_sel = currentNode.mdaData.z_stage_sel,
                    z_nr_steps = currentNode.mdaData.z_nr_steps,
                    z_step_distance = currentNode.mdaData.z_step_distance,
                    z_nrsteps_radio_sel = currentNode.mdaData.z_nrsteps_radio_sel,
                    z_stepdistance_radio_sel= currentNode.mdaData.z_stepdistance_radio_sel,
                    channel_group=currentNode.mdaData.channel_group,
                    channels=currentNode.mdaData.channels,
                    channel_exposures_ms=currentNode.mdaData.channel_exposures_ms,
                    xy_positions=currentNode.mdaData.xy_positions,
                    xyz_positions=currentNode.mdaData.xyz_positions,
                    position_labels=currentNode.mdaData.position_labels,
                    exposure_ms=currentNode.mdaData.exposure_ms,
                    storage_folder=currentNode.mdaData.storage_folder,
                    storage_file_name=currentNode.mdaData.storage_file_name,
                    GUI_xy_pos_fullInfo=currentNode.mdaData.xy_positions_saveInfo,
                    node = currentNode)
            else: #This should never happen, but otherwise just open a new mdaglados instance
                self.mdaconfig = MDAGlados(parentData.core,None,None,parentData.shared_data,hasGUI=True)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.mdaconfig.showOptionChanged)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
            

            # Create the QVBoxLayout
            layout = QVBoxLayout()

            # Create a QWidget to contain the QGridLayout
            grid_widget = QWidget()
            grid_widget.setLayout(self.mdaconfig.gui) #type:ignore
            # Add the QMainWindow to the QVBoxLayout
            layout.addWidget(grid_widget)

            layout.addWidget(button_box)
            
            self.setLayout(layout)
        
    def getInputs(self):
        &#34;&#34;&#34;
        Get the inputs from the MDA configuration.
        
        Returns:
            The inputs from the MDA configuration.
        &#34;&#34;&#34;
        
        return self.mdaconfig.mda

    def getExposureTime(self):
        &#34;&#34;&#34;
        Get the exposure time in milliseconds.
        
        Returns:
            int: The exposure time in milliseconds.
        &#34;&#34;&#34;
        return self.mdaconfig.exposure_ms

    def getmdaData(self):
        &#34;&#34;&#34;
        Get the MDA data.
        
        Returns:
            The MDA configuration data.
        &#34;&#34;&#34;
        return self.mdaconfig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.nodz_openMDADialog.getExposureTime"><code class="name flex">
<span>def <span class="ident">getExposureTime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the exposure time in milliseconds.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The exposure time in milliseconds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExposureTime(self):
    &#34;&#34;&#34;
    Get the exposure time in milliseconds.
    
    Returns:
        int: The exposure time in milliseconds.
    &#34;&#34;&#34;
    return self.mdaconfig.exposure_ms</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openMDADialog.getInputs"><code class="name flex">
<span>def <span class="ident">getInputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the inputs from the MDA configuration.</p>
<h2 id="returns">Returns</h2>
<p>The inputs from the MDA configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInputs(self):
    &#34;&#34;&#34;
    Get the inputs from the MDA configuration.
    
    Returns:
        The inputs from the MDA configuration.
    &#34;&#34;&#34;
    
    return self.mdaconfig.mda</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openMDADialog.getmdaData"><code class="name flex">
<span>def <span class="ident">getmdaData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the MDA data.</p>
<h2 id="returns">Returns</h2>
<p>The MDA configuration data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getmdaData(self):
    &#34;&#34;&#34;
    Get the MDA data.
    
    Returns:
        The MDA configuration data.
    &#34;&#34;&#34;
    return self.mdaconfig</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openMMConfigDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openMMConfigDialog</span></span>
<span>(</span><span>parentNode=None, storedConfigsStrings=None, storedrelStagesString=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a dialog to modify the MM configs of a node</p>
<p>Opens a dialog to modify the Micromanager configs of a node</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong> :&ensp;<code>Node</code></dt>
<dd>The node to modify the configs of.</dd>
<dt><strong><code>storedConfigsStrings</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>A list of tuples with the name of the config and the value of the config.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with the configs as a dictionary and the list of configs as strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openMMConfigDialog(QDialog):
    
    &#34;&#34;&#34;
    Opens a dialog to modify the MM configs of a node
    &#34;&#34;&#34;
    def __init__(self, parentNode=None, storedConfigsStrings=None, storedrelStagesString=None):
        &#34;&#34;&#34;
        Opens a dialog to modify the Micromanager configs of a node
        
        Args:
            parentNode (Node): The node to modify the configs of.
            storedConfigsStrings (list of tuples): A list of tuples with the name of the config and the value of the config.
            
        Returns:
            A tuple with the configs as a dictionary and the list of configs as strings.
        &#34;&#34;&#34;
        super().__init__(None)
        self.newConfigUI = type(MMConfigUI)
        
        self.setWindowTitle(&#34;MM config Dialog&#34;)
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
            
            self.MMlayout = parentNode.MMconfigInfo.mainLayout
            
            #Create a new MMconfigUI with the same components as parentNode.MMconfigInfo:
            self.newConfigUI = MMConfigUI(parentNode.MMconfigInfo.config_groups, showConfigs=parentNode.MMconfigInfo.showConfigs,showShutterOptions=parentNode.MMconfigInfo.showShutterOptions, showLiveSnapExposureButtons=parentNode.MMconfigInfo.showLiveSnapExposureButtons, showROIoptions =parentNode.MMconfigInfo.showROIoptions, showStages=parentNode.MMconfigInfo.showStages, showCheckboxes=parentNode.MMconfigInfo.showCheckboxes,changes_update_MM=parentNode.MMconfigInfo.changes_update_MM,showRelativeStages=parentNode.MMconfigInfo.showRelativeStages,autoSaveLoad=False)
            
            if parentNode.MMconfigInfo.changes_update_MM:
                logging.warning(&#39;WARNING! Nodz is actually changing the configs real-time rather than only when they are ran!&#39;)
            
            #Change some configs that are stored from last time this node was openend:
            if storedConfigsStrings is not None and len(storedConfigsStrings)&gt;0:
                for storedConfigString in storedConfigsStrings:
                    #Find the config that has this name:
                    for config_id in self.newConfigUI.config_groups:
                        thisConfig = self.newConfigUI.config_groups[config_id]
                        if thisConfig.configGroupName() == storedConfigString[0]:
                            foundConfigId = config_id
                            #Set the checkbox to true:
                            self.newConfigUI.configCheckboxes[foundConfigId].setChecked(True)
                            #Set the value correctly in the GUI:
                            self.newConfigUI.updateValueInGUI(foundConfigId,storedConfigString[1])
                            break
            
            if storedrelStagesString is not None:
                allRelStages = self.newConfigUI.oneDRelStackedWidget.children()
                #Set the values of all the stages
                for relstage in allRelStages:
                    objName = relstage.objectName()
                    if objName != &#39;&#39;:
                        for storedrelstage in storedrelStagesString:
                            if objName == storedrelstage[0]:
                                relstage.children()[2].setText(str(storedrelstage[1])) # type: ignore
                
                #Set the currently-selected stage:
                for storedrelstage in storedrelStagesString:
                    if storedrelstage[0] == &#39;__chosenRelStage__&#39;:
                        self.newConfigUI.oneDstageRelDropdown.setCurrentText(storedrelstage[1])
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
            
            # Create the QVBoxLayout
            layout = QVBoxLayout()

            # Create a QWidget to contain the QGridLayout
            grid_widget = QWidget()
            grid_widget.setLayout(self.newConfigUI.mainLayout) #type:ignore
            # Add the QMainWindow to the QVBoxLayout
            layout.addWidget(grid_widget)

            layout.addWidget(button_box)
            
            self.setLayout(layout)
        
    def ConfigsToBeChanged(self):
        &#34;&#34;&#34;
        Returns the configs that have been changed in the MM config Dialog.
        
        Returns:
            A list of tuples with the name of the config and the value of the config that has been changed.
        &#34;&#34;&#34;
        #Get the new value of all configs that are/should/want to be changed:
        ConfigsToBeChanged = []
        for config_id in range(len(self.newConfigUI.config_groups)): #type:ignore
            if self.newConfigUI.configCheckboxes[config_id].isChecked(): #type:ignore
                #Add config name and new value
                ConfigsToBeChanged.append([self.newConfigUI.config_groups[config_id].configGroupName(),self.newConfigUI.currentConfigUISingleValue(config_id)]) #type:ignore
        
        #Not adding ,self.newConfigUI.config_groups[config_id] (all info) for pickling reasons
        
        return ConfigsToBeChanged
        
        return self.newConfigUI
    
    def RelStageInfo(self):
        relStageInfo = []
        allRelStages = self.newConfigUI.oneDRelStackedWidget.children()
        for relstage in allRelStages:
            objName = relstage.objectName()
            if objName != &#39;&#39;:
                relStageInfo.append([objName,float(relstage.children()[2].text())]) # type: ignore
        relStageInfo.append([&#39;__chosenRelStage__&#39;,self.newConfigUI.oneDstageRelDropdown.currentText()])

        return relStageInfo
    # def getExposureTime(self):
    #     return self.mdaconfig.exposure_ms

    # def getmdaData(self):
    #     return self.mdaconfig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.nodz_openMMConfigDialog.ConfigsToBeChanged"><code class="name flex">
<span>def <span class="ident">ConfigsToBeChanged</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the configs that have been changed in the MM config Dialog.</p>
<h2 id="returns">Returns</h2>
<p>A list of tuples with the name of the config and the value of the config that has been changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConfigsToBeChanged(self):
    &#34;&#34;&#34;
    Returns the configs that have been changed in the MM config Dialog.
    
    Returns:
        A list of tuples with the name of the config and the value of the config that has been changed.
    &#34;&#34;&#34;
    #Get the new value of all configs that are/should/want to be changed:
    ConfigsToBeChanged = []
    for config_id in range(len(self.newConfigUI.config_groups)): #type:ignore
        if self.newConfigUI.configCheckboxes[config_id].isChecked(): #type:ignore
            #Add config name and new value
            ConfigsToBeChanged.append([self.newConfigUI.config_groups[config_id].configGroupName(),self.newConfigUI.currentConfigUISingleValue(config_id)]) #type:ignore
    
    #Not adding ,self.newConfigUI.config_groups[config_id] (all info) for pickling reasons
    
    return ConfigsToBeChanged
    
    return self.newConfigUI</code></pre>
</details>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openMMConfigDialog.RelStageInfo"><code class="name flex">
<span>def <span class="ident">RelStageInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RelStageInfo(self):
    relStageInfo = []
    allRelStages = self.newConfigUI.oneDRelStackedWidget.children()
    for relstage in allRelStages:
        objName = relstage.objectName()
        if objName != &#39;&#39;:
            relStageInfo.append([objName,float(relstage.children()[2].text())]) # type: ignore
    relStageInfo.append([&#39;__chosenRelStage__&#39;,self.newConfigUI.oneDstageRelDropdown.currentText()])

    return relStageInfo</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openNewGlobalVarDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openNewGlobalVarDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for newGlobalVar in the Nodz layout. </p>
<p>Initializes the newGlobalVarDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the newGlobalVarDialog. If provided, the newGlobalVarDialog will be set to the newGlobalVarDialog of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openNewGlobalVarDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for newGlobalVar in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the newGlobalVarDialog.
        
        Args:
            parentNode: The parent node of the newGlobalVarDialog. If provided, the newGlobalVarDialog will be set to the newGlobalVarDialog of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;newGlobalVarInfo Dialog&#34;,
                        internalName=&#39;newVarChange&#39;,
                        advLineEdits=[{&#39;Variable Name:&#39;:[&#39;globalVarName&#39;,&#39;Value&#39;]},{&#39;Initial Value:&#39;:[&#39;globalVarValue&#39;,&#39;Value&#39;]}],
                        storeVarName=&#39;newGlobalVarInfo&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog">nodz_generalAdvancedLineEditDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openScoringEndDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openScoringEndDialog</span></span>
<span>(</span><span>parent=None, currentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The ScoringEnd (i.e. the end of the scoring) dialog window.</p>
<p>Initialize the ScoringEnd (i.e. the end of the scoring) dialog window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget (default is None).</dd>
<dt><strong><code>currentNode</code></strong></dt>
<dd>The current node (default is None).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openScoringEndDialog(QDialog):
    &#34;&#34;&#34;
    The ScoringEnd (i.e. the end of the scoring) dialog window.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None):
        &#34;&#34;&#34;
        Initialize the ScoringEnd (i.e. the end of the scoring) dialog window.
        
        Args:
            parent: The parent widget (default is None).
            currentNode: The current node (default is None).
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parent)
        self.setWindowTitle(&#34;Scoring End&#34;)
        #Add an OK/Cancel box
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)

        # Create the QVBoxLayout
        layout = QVBoxLayout()

        # Create a QWidget to contain the QGridLayout
        self.grid_widget = QGridLayout()
            
        self.nrVarsSpinbox = QSpinBox()
        self.nrVarsSpinbox.setMinimum(1)
        self.nrVarsSpinbox.valueChanged.connect(self.updateLayout)
        self.grid_widget.addWidget(self.nrVarsSpinbox,0,0)

        self.variableContainer = QGridLayout()
        # self.grid_widget.addLayout(self.variableContainer,1,0)
        
        self.variableContainerscrollArea = QScrollArea(self)
        self.variableContainerscrollArea.setWidgetResizable(True)
        self.variableContainerscrollAreaWidgetContents = QWidget()
        self.variableContainerscrollAreaWidgetContents.setLayout(self.variableContainer)
        self.variableContainerscrollArea.setWidget(self.variableContainerscrollAreaWidgetContents)
        self.grid_widget.addWidget(self.variableContainerscrollArea,1,0)
        
        # Set a fixed size for the QScrollArea
        self.variableContainerscrollArea.setFixedSize(QSize(300, 300))  # Adjust the size as needed
        # Add the QMainWindow to the QVBoxLayout
        layout.addLayout(self.grid_widget)

        layout.addWidget(button_box)
        
        self.setLayout(layout)
        
        #Add a spacer item at the bottom of the variableContainer so it&#39;s pushing it down down down
        spacerItem = QSpacerItem(20, 40, QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Expanding)
        self.variableContainer.addItem(spacerItem, 999, 0)

        #Pre-load labels/line-Edits with the current sockets:
        self.labels = []
        self.lineEdits = []
        if currentNode is not None:
            currentSockets = list(currentNode.sockets.items())
            for socket in currentSockets:
                label = QLabel(f&#34;Score {len(self.labels)+1}:&#34;)
                lineEdit = QLineEdit()
                lineEdit.setText(socket[0])
                self.variableContainer.addWidget(label,len(self.labels),0)
                self.variableContainer.addWidget(lineEdit,len(self.labels),1)
                self.labels.append(label)
                self.lineEdits.append(lineEdit)
        
        self.nrVarsSpinbox.setValue(len(self.labels)) 
        #And update the layout at the start:
        # self.updateLayout()
        
    def updateLayout(self):
        &#34;&#34;&#34;
        Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.
        
            Args:
                None
        
            Returns:
                None
        &#34;&#34;&#34;
        nrVars = self.nrVarsSpinbox.value()
        if nrVars == len(self.labels)-1: #If we want to remove the last one
            tobeRemovedLabel = self.labels[-1]
            tobeRemovedLineEdit = self.lineEdits[-1]
            self.layout().removeWidget(tobeRemovedLabel)
            tobeRemovedLabel.deleteLater()
            self.layout().removeWidget(tobeRemovedLineEdit)
            tobeRemovedLineEdit.deleteLater()
            self.labels.pop()
            self.lineEdits.pop()
        elif nrVars == len(self.labels)+1: #if we want to add one...
            label = QLabel(f&#34;Score {len(self.labels)+1}:&#34;)
            lineEdit = QLineEdit()
            self.variableContainer.addWidget(label,len(self.labels),0)
            self.variableContainer.addWidget(lineEdit,len(self.labels),1)
            self.labels.append(label)
            self.lineEdits.append(lineEdit)
        elif nrVars == len(self.labels): 
            pass
        else: #Else, we added a fully new number, so we reset everything
            for label in self.labels:
                self.layout().removeWidget(label)
                label.deleteLater()
            for lineEdit in self.lineEdits:
                self.layout().removeWidget(lineEdit)
                lineEdit.deleteLater()

            self.labels = []
            self.lineEdits = []

            for i in range(nrVars):
                label = QLabel(f&#34;Score {i+1}:&#34;)
                lineEdit = QLineEdit()
                self.variableContainer.addWidget(label,i,0)
                self.labels.append(label)
                self.variableContainer.addWidget(lineEdit,i,1)
                self.lineEdits.append(lineEdit)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="FlowChart_dockWidgets.nodz_openScoringEndDialog.updateLayout"><code class="name flex">
<span>def <span class="ident">updateLayout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.</p>
<pre><code>Args:
    None

Returns:
    None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateLayout(self):
    &#34;&#34;&#34;
    Updates the scoreEnd layout based on the number of variables (i.e. number of connectable score parameters) specified.
    
        Args:
            None
    
        Returns:
            None
    &#34;&#34;&#34;
    nrVars = self.nrVarsSpinbox.value()
    if nrVars == len(self.labels)-1: #If we want to remove the last one
        tobeRemovedLabel = self.labels[-1]
        tobeRemovedLineEdit = self.lineEdits[-1]
        self.layout().removeWidget(tobeRemovedLabel)
        tobeRemovedLabel.deleteLater()
        self.layout().removeWidget(tobeRemovedLineEdit)
        tobeRemovedLineEdit.deleteLater()
        self.labels.pop()
        self.lineEdits.pop()
    elif nrVars == len(self.labels)+1: #if we want to add one...
        label = QLabel(f&#34;Score {len(self.labels)+1}:&#34;)
        lineEdit = QLineEdit()
        self.variableContainer.addWidget(label,len(self.labels),0)
        self.variableContainer.addWidget(lineEdit,len(self.labels),1)
        self.labels.append(label)
        self.lineEdits.append(lineEdit)
    elif nrVars == len(self.labels): 
        pass
    else: #Else, we added a fully new number, so we reset everything
        for label in self.labels:
            self.layout().removeWidget(label)
            label.deleteLater()
        for lineEdit in self.lineEdits:
            self.layout().removeWidget(lineEdit)
            lineEdit.deleteLater()

        self.labels = []
        self.lineEdits = []

        for i in range(nrVars):
            label = QLabel(f&#34;Score {i+1}:&#34;)
            lineEdit = QLineEdit()
            self.variableContainer.addWidget(label,i,0)
            self.labels.append(label)
            self.variableContainer.addWidget(lineEdit,i,1)
            self.lineEdits.append(lineEdit)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openStoreDataDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openStoreDataDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for changeGlobalVar in the Nodz layout. </p>
<p>Initializes the StoreDataDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the StoreDataDialog. If provided, the storeDataInfo will be set to the storeDataInfo of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openStoreDataDialog(nodz_generalAdvancedLineEditDialog):
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the StoreDataDialog.
        
        Args:
            parentNode: The parent node of the StoreDataDialog. If provided, the storeDataInfo will be set to the storeDataInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(parentNode=parentNode,
                        title=&#34;Store Data&#34;,
                        internalName=&#39;storeDataDialog&#39;,
                        advLineEdits=[{&#39;Data:&#39;:[&#39;item_to_store&#39;,&#39;Variable&#39;]},{&#39;Location:&#39;:[&#39;store_location&#39;,&#39;Advanced&#39;]}],
                        storeVarName=&#39;storeDataInfo&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog">nodz_generalAdvancedLineEditDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_openTimerDialog"><code class="flex name class">
<span>class <span class="ident">nodz_openTimerDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for timer in the Nodz layout. </p>
<p>Initializes the changeGlobalVarDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the changeGlobalVarDialog. If provided, the changeGlobalVarInfo will be set to the changeGlobalVarInfo of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_openTimerDialog(nodz_generalAdvancedLineEditDialog):
    &#34;&#34;&#34;
    A Dialog that is created for timer in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        super().__init__(parentNode=parentNode,
                        title=&#34;Timer&#34;,
                        internalName=&#39;timerDialog&#39;,
                        advLineEdits=[{&#39;Time to wait (s):&#39;:[&#39;wait_time&#39;,&#39;Value&#39;]}],
                        storeVarName=&#39;timerInfo&#39;)
    #     &#34;&#34;&#34;
    #     Initializes the TimerDialog.
        
    #     Args:
    #         parentNode: The parent node of the TimerDialog. If provided, the timerInfo will be set to the timerInfo of the parentNode.
        
    #     Returns:
    #         None
    #     &#34;&#34;&#34;
    #     super().__init__(None)
    #     self.setWindowTitle(&#34;Timer Dialog&#34;)
    #     self.timerInfo = 0
    #     if parentNode is not None:
    #         from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget
    #         self.timerInfo = parentNode.timerInfo

    #     button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    #     button_box.accepted.connect(self.accept)
    #     button_box.rejected.connect(self.reject)
        
    #     # Create the QVBoxLayout
    #     layout = QVBoxLayout()

    #     # Create a QWidget to contain the QGridLayout
    #     entryVal = QDoubleSpinBox()
    #     entryVal.setDecimals(2)
    #     entryVal.setSingleStep(0.1)
    #     entryVal.setValue(self.timerInfo)
    #     entryVal.valueChanged.connect(lambda value: setattr(self, &#39;timerInfo&#39;, value))
    #     # Add the QMainWindow to the QVBoxLayout
    #     layout.addWidget(entryVal)

    #     layout.addWidget(button_box)
        
    #     self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog">nodz_generalAdvancedLineEditDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_realTimeAnalysisDialog"><code class="flex name class">
<span>class <span class="ident">nodz_realTimeAnalysisDialog</span></span>
<span>(</span><span>parent=None, currentNode=None, addVisualisationBox=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for real-time analysis methods in the Nodz layout. Basically based on EVE's flexible file-finding function methodology.</p>
<p>Initializes the Real-Time Analysis Options window.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent</code></strong></dt>
<dd>The parent widget (default is None).</dd>
<dt><strong><code>currentNode</code></strong></dt>
<dd>The current node (default is None).</dd>
<dt><strong><code>addVisualisationBox</code></strong></dt>
<dd>A boolean indicating whether to add a visualization CheckBox (default is True). </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_realTimeAnalysisDialog(AnalysisScoringVisualisationDialog):
    &#34;&#34;&#34;
    A Dialog that is created for real-time analysis methods in the Nodz layout. Basically based on EVE&#39;s flexible file-finding function methodology.
    &#34;&#34;&#34;
    def __init__(self, parent=None, currentNode=None,addVisualisationBox=True):
        &#34;&#34;&#34;
        Initializes the Real-Time Analysis Options window.
        
        Args:
            parent: The parent widget (default is None).
            currentNode: The current node (default is None).
            addVisualisationBox: A boolean indicating whether to add a visualization CheckBox (default is True). 
        
        Returns:
            None
        &#34;&#34;&#34;
        
        super().__init__(parent, currentNode,addVisualisationBox)
        self.setWindowTitle(&#34;Real-Time Analysis Options&#34;)
        
        #Let&#39;s try to get all possible RT analysis options
        realTimeAnalysisFunctions = utils.functionNamesFromDir(&#39;AutonomousMicroscopy\\Real_Time_Analysis&#39;)
        
        allDisplayNames,displaynameMapping = utils.displayNamesFromFunctionNames(realTimeAnalysisFunctions,&#39;&#39;)
        #Store this mapping also in the node
        self.currentData[&#39;__displayNameFunctionNameMap__&#39;] = displaynameMapping
        
        #Add a dropbox with all the options
        self.comboBox_RTanalysisFunctions = QComboBox(self)
        if len(realTimeAnalysisFunctions) &gt; 0:
            for item in realTimeAnalysisFunctions:
                displayNameI, displaynameMappingI = utils.displayNamesFromFunctionNames([item],&#39;&#39;)
                self.comboBox_RTanalysisFunctions.addItem(displayNameI[0]) 
        
        self.mainLayout.addWidget(self.comboBox_RTanalysisFunctions, 0, 1)
        #give it an objectName:
        self.comboBox_RTanalysisFunctions.setObjectName(&#39;comboBox_RTanalysisFunctions_KEEP&#39;)
        #Give it a connect-callback if it&#39;s changed (then the layout should be changed)
        self.comboBox_RTanalysisFunctions.currentIndexChanged.connect(lambda index, layout=self.mainLayout, dropdown=self.comboBox_RTanalysisFunctions,displaynameMapping=displaynameMapping: utils.layout_changedDropdown(layout,dropdown,displaynameMapping))
        #Also give it a connect-callback to store the currentinfo:
        self.comboBox_RTanalysisFunctions.currentIndexChanged.connect(lambda index, parentdata=self: utils.updateCurrentDataUponDropdownChange(parentdata))

        # pre-load all args/kwargs and their edit values - then hide all of them
        utils.layout_init(self.mainLayout,&#39;&#39;,displaynameMapping,current_dropdown = self.comboBox_RTanalysisFunctions,nodzInfo=parent,skipInput=True)
        
        #Pre-load the options if they&#39;re in the current node info
        if &#39;real_time_analysis_currentData&#39; in vars(currentNode):
            if &#39;__realTimeVisualisation__&#39; in currentNode.real_time_analysis_currentData and currentNode.real_time_analysis_currentData[&#39;__realTimeVisualisation__&#39;]: #type:ignore
                self.visualisationBox.setChecked(True)
            
            utils.preLoadOptions_realtime(self.mainLayout,currentNode.real_time_analysis_currentData) #type:ignore</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="FlowChart_dockWidgets.AnalysisScoringVisualisationDialog" href="#FlowChart_dockWidgets.AnalysisScoringVisualisationDialog">AnalysisScoringVisualisationDialog</a></li>
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_slackReportDialog"><code class="flex name class">
<span>class <span class="ident">nodz_slackReportDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_slackReportDialog(QDialog):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(&#34;Slack Report Dialog&#34;)
        self.slackReportInfo  = &#39;&#39;
        if parentNode is not None:
            self.slackReportInfo   = parentNode.slackReportInfo

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Create the QVBoxLayout
        layout = QVBoxLayout()

        #add a big editable text box:
        slackReportInfo = QTextEdit()
        slackReportInfo.setPlainText(self.slackReportInfo)
        slackReportInfo.textChanged.connect(lambda: setattr(self, &#39;slackReportInfo&#39;, slackReportInfo.toPlainText()))

        # Add the QMainWindow to the QVBoxLayout
        layout.addWidget(slackReportInfo)

        layout.addWidget(button_box)
        
        self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_stickyNoteDialog"><code class="flex name class">
<span>class <span class="ident">nodz_stickyNoteDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A Dialog that is created for sticky notes in the Nodz layout. </p>
<p>Initializes the StickyNoteDialog.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong></dt>
<dd>The parent node of the StickyNoteDialog. If provided, the stickyNoteInfo will be set to the stickyNoteInfo of the parentNode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_stickyNoteDialog(QDialog):
    &#34;&#34;&#34;
    A Dialog that is created for sticky notes in the Nodz layout. 
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Initializes the StickyNoteDialog.
        
        Args:
            parentNode: The parent node of the StickyNoteDialog. If provided, the stickyNoteInfo will be set to the stickyNoteInfo of the parentNode.
        
        Returns:
            None
        &#34;&#34;&#34;
        super().__init__(None)
        self.setWindowTitle(&#34;Sticky Note Dialog&#34;)
        self.stickyNoteInfo  = &#39;&#39;
        if parentNode is not None:
            self.stickyNoteInfo = parentNode.stickyNoteInfo

        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        
        # Create the QVBoxLayout
        layout = QVBoxLayout()

        #add a big editable text box:
        stickyNoteInfoTE = QTextEdit()
        stickyNoteInfoTE.setPlainText(self.stickyNoteInfo)
        stickyNoteInfoTE.textChanged.connect(lambda: setattr(self, &#39;stickyNoteInfo&#39;, stickyNoteInfoTE.toPlainText()))

        # Add the QMainWindow to the QVBoxLayout
        layout.addWidget(stickyNoteInfoTE)

        layout.addWidget(button_box)
        
        self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="FlowChart_dockWidgets.nodz_visualisationDialog"><code class="flex name class">
<span>class <span class="ident">nodz_visualisationDialog</span></span>
<span>(</span><span>parentNode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a dialog to modify the visualisation settings</p>
<p>Opens a dialog to modify the visualisation settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parentNode</code></strong> :&ensp;<code>Node</code></dt>
<dd>The node to modify the configs of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with the configs as a dictionary and the list of configs as strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nodz_visualisationDialog(QDialog):
    &#34;&#34;&#34;
    Opens a dialog to modify the visualisation settings
    &#34;&#34;&#34;
    def __init__(self, parentNode=None):
        &#34;&#34;&#34;
        Opens a dialog to modify the visualisation settings
        
        Args:
            parentNode (Node): The node to modify the configs of.
            
        Returns:
            A tuple with the configs as a dictionary and the list of configs as strings.
        &#34;&#34;&#34;
        super().__init__(None)
        
        self.setWindowTitle(&#34;Visualisation Dialog&#34;)
        if parentNode is not None:
            from PyQt5.QtWidgets import QApplication, QVBoxLayout, QMainWindow, QWidget, QFormLayout
            layout_sub = QFormLayout()
            if &#39;layerName&#39; not in parentNode.visualisation_currentData or parentNode.visualisation_currentData[&#39;layerName&#39;] is not None:
                connectedNodes = nodz_utils.getConnectedNodes(parentNode, &#39;topAttr&#39;)
                if len(connectedNodes)&gt;0:
                    connectedNode = connectedNodes[0]
                    defaultText = connectedNode.name
                else:
                    defaultText = &#39;newLayer&#39;
            else:
                defaultText = parentNode.visualisation_currentData[&#39;layerName&#39;]
            self.layerNameEdit = QLineEdit()
            self.layerNameEdit.setText(defaultText)
            layout_sub.addRow(&#34;Layer name:&#34;, self.layerNameEdit)
            
            import napari
            
            self.colormapComboBox = QComboBox()
            colormaps = napari.utils.colormaps.AVAILABLE_COLORMAPS #type:ignore
            for colormap in colormaps:
                self.colormapComboBox.addItem(colormap)
            
            if &#39;colormap&#39; not in parentNode.visualisation_currentData or parentNode.visualisation_currentData[&#39;colormap&#39;] is None:
                self.colormapComboBox.setCurrentText(&#39;gray&#39;)
            else:
                self.colormapComboBox.setCurrentText(parentNode.visualisation_currentData[&#39;colormap&#39;])
            
            self.colormapComboBox.addItem(&#34;Use new config&#34;)
            layout_sub.addRow(&#34;Colormap:&#34;, self.colormapComboBox)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
            button_box.accepted.connect(self.accept)
            button_box.rejected.connect(self.reject)
            
            # Create the QVBoxLayout
            layout = QVBoxLayout()

            # Add the QMainWindow to the QVBoxLayout
            layout.addLayout(layout_sub)

            layout.addWidget(button_box)
            
            self.setLayout(layout)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QDialog</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.flowChart_dockWidgets" href="#FlowChart_dockWidgets.flowChart_dockWidgets">flowChart_dockWidgets</a></code></li>
<li><code><a title="FlowChart_dockWidgets.is_pip_installed" href="#FlowChart_dockWidgets.is_pip_installed">is_pip_installed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="FlowChart_dockWidgets.AnalysisScoringVisualisationDialog" href="#FlowChart_dockWidgets.AnalysisScoringVisualisationDialog">AnalysisScoringVisualisationDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.CustomGraphicsView" href="#FlowChart_dockWidgets.CustomGraphicsView">CustomGraphicsView</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.CustomGraphicsView.resizeEvent" href="#FlowChart_dockWidgets.CustomGraphicsView.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="FlowChart_dockWidgets.CustomGraphicsView.updateGraphicsViewSize" href="#FlowChart_dockWidgets.CustomGraphicsView.updateGraphicsViewSize">updateGraphicsViewSize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.DecisionWidget" href="#FlowChart_dockWidgets.DecisionWidget">DecisionWidget</a></code></h4>
<ul class="two-column">
<li><code><a title="FlowChart_dockWidgets.DecisionWidget.assessDecision" href="#FlowChart_dockWidgets.DecisionWidget.assessDecision">assessDecision</a></code></li>
<li><code><a title="FlowChart_dockWidgets.DecisionWidget.changeDecisionMode" href="#FlowChart_dockWidgets.DecisionWidget.changeDecisionMode">changeDecisionMode</a></code></li>
<li><code><a title="FlowChart_dockWidgets.DecisionWidget.changeMode" href="#FlowChart_dockWidgets.DecisionWidget.changeMode">changeMode</a></code></li>
<li><code><a title="FlowChart_dockWidgets.DecisionWidget.create_GUI" href="#FlowChart_dockWidgets.DecisionWidget.create_GUI">create_GUI</a></code></li>
<li><code><a title="FlowChart_dockWidgets.DecisionWidget.testCurrentDecision" href="#FlowChart_dockWidgets.DecisionWidget.testCurrentDecision">testCurrentDecision</a></code></li>
<li><code><a title="FlowChart_dockWidgets.DecisionWidget.updateAllDecisions" href="#FlowChart_dockWidgets.DecisionWidget.updateAllDecisions">updateAllDecisions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.FoVFindImaging_singleCh_configs" href="#FlowChart_dockWidgets.FoVFindImaging_singleCh_configs">FoVFindImaging_singleCh_configs</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.FoVFindImaging_singleCh_configs.getInputs" href="#FlowChart_dockWidgets.FoVFindImaging_singleCh_configs.getInputs">getInputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.GladosGraph" href="#FlowChart_dockWidgets.GladosGraph">GladosGraph</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.GladosGraph.addRawGraphEval" href="#FlowChart_dockWidgets.GladosGraph.addRawGraphEval">addRawGraphEval</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget">GladosNodzFlowChart_dockWidget</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.AnalysisNode_DEBUG_started" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.AnalysisNode_DEBUG_started">AnalysisNode_DEBUG_started</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.AnalysisNode_started" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.AnalysisNode_started">AnalysisNode_started</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.CustomFunctionNode_finished" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.CustomFunctionNode_finished">CustomFunctionNode_finished</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.CustomFunctionNode_started" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.CustomFunctionNode_started">CustomFunctionNode_started</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.GraphToSignals" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.GraphToSignals">GraphToSignals</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.MMconfigChangeRan" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.MMconfigChangeRan">MMconfigChangeRan</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.MMstageChangeRan" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.MMstageChangeRan">MMstageChangeRan</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeAdded" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeAdded">NodeAdded</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeDoubleClicked" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeDoubleClicked">NodeDoubleClicked</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeFullyInitialised" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeFullyInitialised">NodeFullyInitialised</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeRemoved" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.NodeRemoved">NodeRemoved</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugConnected" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugConnected">PlugConnected</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugOrSocketConnected" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugOrSocketConnected">PlugOrSocketConnected</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugOrSocketDisconnected" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.PlugOrSocketDisconnected">PlugOrSocketDisconnected</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.SocketConnected" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.SocketConnected">SocketConnected</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.acquiringEnd" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.acquiringEnd">acquiringEnd</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.acquiringStart" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.acquiringStart">acquiringStart</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.advNodeInfo" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.advNodeInfo">advNodeInfo</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.analysisNode_finished" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.analysisNode_finished">analysisNode_finished</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.and_logicCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.and_logicCallAction">and_logicCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeConfigStorageInNodz" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeConfigStorageInNodz">changeConfigStorageInNodz</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeGlobalVarCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeGlobalVarCallAction">changeGlobalVarCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeNodeColor" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeNodeColor">changeNodeColor</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeNodeName" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeNodeName">changeNodeName</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeRelStageStorageInNodz" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.changeRelStageStorageInNodz">changeRelStageStorageInNodz</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.checkNodesOnErrors" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.checkNodesOnErrors">checkNodesOnErrors</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.cleanupNodeList" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.cleanupNodeList">cleanupNodeList</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.contextMenuEvent" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.contextMenuEvent">contextMenuEvent</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createNewNode" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createNewNode">createNewNode</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createNodeFromRightClick" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createNodeFromRightClick">createNodeFromRightClick</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createSingleCoreVar" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.createSingleCoreVar">createSingleCoreVar</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.debugScoring" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.debugScoring">debugScoring</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.defineNodeInfo" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.defineNodeInfo">defineNodeInfo</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.earlyScoringFail" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.earlyScoringFail">earlyScoringFail</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.explore_attributes" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.explore_attributes">explore_attributes</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.findNodeByName" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.findNodeByName">findNodeByName</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.finishedEmits" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.finishedEmits">finishedEmits</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.focus" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.focus">focus</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.fullAutonomousRunStart" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.fullAutonomousRunStart">fullAutonomousRunStart</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.getDevicesOfDeviceType" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.getDevicesOfDeviceType">getDevicesOfDeviceType</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.getNodz" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.getNodz">getNodz</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.giveInfoOnNode" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.giveInfoOnNode">giveInfoOnNode</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.ifStatementCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.ifStatementCallAction">ifStatementCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.initEnd" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.initEnd">initEnd</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.initStart" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.initStart">initStart</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.interruptRun" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.interruptRun">interruptRun</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.limitTextLength" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.limitTextLength">limitTextLength</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.loadGraphJSON" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.loadGraphJSON">loadGraphJSON</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.newGlobalVarCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.newGlobalVarCallAction">newGlobalVarCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.nodeLookupName_withoutCounter" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.nodeLookupName_withoutCounter">nodeLookupName_withoutCounter</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.nodeRan" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.nodeRan">nodeRan</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.obtainAllNodes" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.obtainAllNodes">obtainAllNodes</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.performPostNodeCreation_Start" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.performPostNodeCreation_Start">performPostNodeCreation_Start</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.prepareGraph" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.prepareGraph">prepareGraph</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runAcquiring" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runAcquiring">runAcquiring</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runCaseSwitchCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runCaseSwitchCallAction">runCaseSwitchCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runInitOnly" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runInitOnly">runInitOnly</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runInlineScriptCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runInlineScriptCallAction">runInlineScriptCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runScoring" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runScoring">runScoring</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runScoringOnly" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runScoringOnly">runScoringOnly</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runslackReportCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.runslackReportCallAction">runslackReportCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.scoringEnd" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.scoringEnd">scoringEnd</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.scoringStart" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.scoringStart">scoringStart</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.set_readable_text_after_dialogChange" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.set_readable_text_after_dialogChange">set_readable_text_after_dialogChange</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.singleNodeTypeInit" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.singleNodeTypeInit">singleNodeTypeInit</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.startNewScoreAcqAtPos" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.startNewScoreAcqAtPos">startNewScoreAcqAtPos</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.storeDataCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.storeDataCallAction">storeDataCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.storeGraphJSON" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.storeGraphJSON">storeGraphJSON</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.timerCallAction" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.timerCallAction">timerCallAction</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.updateCoreVariables" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.updateCoreVariables">updateCoreVariables</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.updateNumberStartFinishedDataAttributes" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.updateNumberStartFinishedDataAttributes">updateNumberStartFinishedDataAttributes</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.update_plugs_fromDialog" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.update_plugs_fromDialog">update_plugs_fromDialog</a></code></li>
<li><code><a title="FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.update_scoring_end" href="#FlowChart_dockWidgets.GladosNodzFlowChart_dockWidget.update_scoring_end">update_scoring_end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.HoverTableWidget" href="#FlowChart_dockWidgets.HoverTableWidget">HoverTableWidget</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.HoverTableWidget.cellHovered" href="#FlowChart_dockWidgets.HoverTableWidget.cellHovered">cellHovered</a></code></li>
<li><code><a title="FlowChart_dockWidgets.HoverTableWidget.leaveEvent" href="#FlowChart_dockWidgets.HoverTableWidget.leaveEvent">leaveEvent</a></code></li>
<li><code><a title="FlowChart_dockWidgets.HoverTableWidget.mouseMoveEvent" href="#FlowChart_dockWidgets.HoverTableWidget.mouseMoveEvent">mouseMoveEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.LoggerWidget" href="#FlowChart_dockWidgets.LoggerWidget">LoggerWidget</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.LoggerWidget.update_log_content" href="#FlowChart_dockWidgets.LoggerWidget.update_log_content">update_log_content</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.NodeSignalManager" href="#FlowChart_dockWidgets.NodeSignalManager">NodeSignalManager</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.NodeSignalManager.add_signal" href="#FlowChart_dockWidgets.NodeSignalManager.add_signal">add_signal</a></code></li>
<li><code><a title="FlowChart_dockWidgets.NodeSignalManager.emit_all_signals" href="#FlowChart_dockWidgets.NodeSignalManager.emit_all_signals">emit_all_signals</a></code></li>
<li><code><a title="FlowChart_dockWidgets.NodeSignalManager.new_signal" href="#FlowChart_dockWidgets.NodeSignalManager.new_signal">new_signal</a></code></li>
<li><code><a title="FlowChart_dockWidgets.NodeSignalManager.print_signals" href="#FlowChart_dockWidgets.NodeSignalManager.print_signals">print_signals</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.ScanningWidget" href="#FlowChart_dockWidgets.ScanningWidget">ScanningWidget</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.ScanningWidget.assessScan" href="#FlowChart_dockWidgets.ScanningWidget.assessScan">assessScan</a></code></li>
<li><code><a title="FlowChart_dockWidgets.ScanningWidget.changeScanMode" href="#FlowChart_dockWidgets.ScanningWidget.changeScanMode">changeScanMode</a></code></li>
<li><code><a title="FlowChart_dockWidgets.ScanningWidget.create_GUI" href="#FlowChart_dockWidgets.ScanningWidget.create_GUI">create_GUI</a></code></li>
<li><code><a title="FlowChart_dockWidgets.ScanningWidget.getPositionInfo" href="#FlowChart_dockWidgets.ScanningWidget.getPositionInfo">getPositionInfo</a></code></li>
<li><code><a title="FlowChart_dockWidgets.ScanningWidget.updateAllScans" href="#FlowChart_dockWidgets.ScanningWidget.updateAllScans">updateAllScans</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.VariablesBase" href="#FlowChart_dockWidgets.VariablesBase">VariablesBase</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.VariablesBase.create_GUI" href="#FlowChart_dockWidgets.VariablesBase.create_GUI">create_GUI</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.get_selected_entry" href="#FlowChart_dockWidgets.VariablesBase.get_selected_entry">get_selected_entry</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.on_cell_clicked" href="#FlowChart_dockWidgets.VariablesBase.on_cell_clicked">on_cell_clicked</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.on_cell_double_clicked" href="#FlowChart_dockWidgets.VariablesBase.on_cell_double_clicked">on_cell_double_clicked</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.on_cell_hovered" href="#FlowChart_dockWidgets.VariablesBase.on_cell_hovered">on_cell_hovered</a></code></li>
<li><code><a title="FlowChart_dockWidgets.VariablesBase.updateVariables" href="#FlowChart_dockWidgets.VariablesBase.updateVariables">updateVariables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.VariablesDialog" href="#FlowChart_dockWidgets.VariablesDialog">VariablesDialog</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.VariablesDialog.on_cell_double_clicked" href="#FlowChart_dockWidgets.VariablesDialog.on_cell_double_clicked">on_cell_double_clicked</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.VariablesWidget" href="#FlowChart_dockWidgets.VariablesWidget">VariablesWidget</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.WorkerSignals" href="#FlowChart_dockWidgets.WorkerSignals">WorkerSignals</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.WorkerSignals.finished" href="#FlowChart_dockWidgets.WorkerSignals.finished">finished</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.advDecisionGridLayout" href="#FlowChart_dockWidgets.advDecisionGridLayout">advDecisionGridLayout</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_VAR_test" href="#FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_VAR_test">directDecision_AND_Score_VAR_test</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_VAR_update" href="#FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_VAR_update">directDecision_AND_Score_VAR_update</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_test" href="#FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_test">directDecision_AND_Score_test</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_update" href="#FlowChart_dockWidgets.advDecisionGridLayout.directDecision_AND_Score_update">directDecision_AND_Score_update</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.getScoreMetrics" href="#FlowChart_dockWidgets.advDecisionGridLayout.getScoreMetrics">getScoreMetrics</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.remove_widgets_in_layout" href="#FlowChart_dockWidgets.advDecisionGridLayout.remove_widgets_in_layout">remove_widgets_in_layout</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.test_decision" href="#FlowChart_dockWidgets.advDecisionGridLayout.test_decision">test_decision</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advDecisionGridLayout.update" href="#FlowChart_dockWidgets.advDecisionGridLayout.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.advScanGridLayout" href="#FlowChart_dockWidgets.advScanGridLayout">advScanGridLayout</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.advScanGridLayout.getPositionInfo" href="#FlowChart_dockWidgets.advScanGridLayout.getPositionInfo">getPositionInfo</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advScanGridLayout.loadPos_update" href="#FlowChart_dockWidgets.advScanGridLayout.loadPos_update">loadPos_update</a></code></li>
<li><code><a title="FlowChart_dockWidgets.advScanGridLayout.update" href="#FlowChart_dockWidgets.advScanGridLayout.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.generalNodzCallActionWorker" href="#FlowChart_dockWidgets.generalNodzCallActionWorker">generalNodzCallActionWorker</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.generalNodzCallActionWorker.run" href="#FlowChart_dockWidgets.generalNodzCallActionWorker.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_analysisDialog" href="#FlowChart_dockWidgets.nodz_analysisDialog">nodz_analysisDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_analysisMeasurementDialog" href="#FlowChart_dockWidgets.nodz_analysisMeasurementDialog">nodz_analysisMeasurementDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_caseSwitchDialog" href="#FlowChart_dockWidgets.nodz_caseSwitchDialog">nodz_caseSwitchDialog</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.nodz_caseSwitchDialog.textChanged" href="#FlowChart_dockWidgets.nodz_caseSwitchDialog.textChanged">textChanged</a></code></li>
<li><code><a title="FlowChart_dockWidgets.nodz_caseSwitchDialog.updateLayout" href="#FlowChart_dockWidgets.nodz_caseSwitchDialog.updateLayout">updateLayout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_customFunctionDialog" href="#FlowChart_dockWidgets.nodz_customFunctionDialog">nodz_customFunctionDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog">nodz_generalAdvancedLineEditDialog</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog.updateFields" href="#FlowChart_dockWidgets.nodz_generalAdvancedLineEditDialog.updateFields">updateFields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openChangeGlobalVarDialog" href="#FlowChart_dockWidgets.nodz_openChangeGlobalVarDialog">nodz_openChangeGlobalVarDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openIfStatementDialog" href="#FlowChart_dockWidgets.nodz_openIfStatementDialog">nodz_openIfStatementDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openInlineScriptDialog" href="#FlowChart_dockWidgets.nodz_openInlineScriptDialog">nodz_openInlineScriptDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openMDADialog" href="#FlowChart_dockWidgets.nodz_openMDADialog">nodz_openMDADialog</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.nodz_openMDADialog.getExposureTime" href="#FlowChart_dockWidgets.nodz_openMDADialog.getExposureTime">getExposureTime</a></code></li>
<li><code><a title="FlowChart_dockWidgets.nodz_openMDADialog.getInputs" href="#FlowChart_dockWidgets.nodz_openMDADialog.getInputs">getInputs</a></code></li>
<li><code><a title="FlowChart_dockWidgets.nodz_openMDADialog.getmdaData" href="#FlowChart_dockWidgets.nodz_openMDADialog.getmdaData">getmdaData</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openMMConfigDialog" href="#FlowChart_dockWidgets.nodz_openMMConfigDialog">nodz_openMMConfigDialog</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.nodz_openMMConfigDialog.ConfigsToBeChanged" href="#FlowChart_dockWidgets.nodz_openMMConfigDialog.ConfigsToBeChanged">ConfigsToBeChanged</a></code></li>
<li><code><a title="FlowChart_dockWidgets.nodz_openMMConfigDialog.RelStageInfo" href="#FlowChart_dockWidgets.nodz_openMMConfigDialog.RelStageInfo">RelStageInfo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openNewGlobalVarDialog" href="#FlowChart_dockWidgets.nodz_openNewGlobalVarDialog">nodz_openNewGlobalVarDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openScoringEndDialog" href="#FlowChart_dockWidgets.nodz_openScoringEndDialog">nodz_openScoringEndDialog</a></code></h4>
<ul class="">
<li><code><a title="FlowChart_dockWidgets.nodz_openScoringEndDialog.updateLayout" href="#FlowChart_dockWidgets.nodz_openScoringEndDialog.updateLayout">updateLayout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openStoreDataDialog" href="#FlowChart_dockWidgets.nodz_openStoreDataDialog">nodz_openStoreDataDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_openTimerDialog" href="#FlowChart_dockWidgets.nodz_openTimerDialog">nodz_openTimerDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_realTimeAnalysisDialog" href="#FlowChart_dockWidgets.nodz_realTimeAnalysisDialog">nodz_realTimeAnalysisDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_slackReportDialog" href="#FlowChart_dockWidgets.nodz_slackReportDialog">nodz_slackReportDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_stickyNoteDialog" href="#FlowChart_dockWidgets.nodz_stickyNoteDialog">nodz_stickyNoteDialog</a></code></h4>
</li>
<li>
<h4><code><a title="FlowChart_dockWidgets.nodz_visualisationDialog" href="#FlowChart_dockWidgets.nodz_visualisationDialog">nodz_visualisationDialog</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>